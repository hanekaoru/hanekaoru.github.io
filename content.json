{"pages":[{"title":"About","text":"博观而约取，厚积而薄发","link":"/about/index.html"}],"posts":[{"title":"为什么要使用依赖注入","text":"依赖注入是一种设计模式，先来看看为什么我们要使用这个模式 为什么要使用依赖注入一个简单的 Person 类，依赖与 Id 和 Address 两个类 123456789101112131415161718class Id { static getId(type: string): Id { return new Id(); }}class Address { constructor(city, street) { }}class Person { id: Id; address: Address; constructor() { this.id = Id.getId('123'); this.address = new Address('北京', '北京') }} 在这种情况下，Person 显性的依赖于 Id 和 Address 两个类，需要知道 Id 和 Address 两个类的具体构成 下面来重构一下 12345678910111213141516171819202122232425class Id { static getId(type: string): Id { return new Id(); }}class Address { constructor(city, street) { }}class Person { id: Id; address: Address; constructor(id: Id, address: Address) { this.id = id; this.address = address; }}// 在某个类当中调用的时候main() { const id = Id.getId('123'); const address = new Address('北京', '北京'); const person = new Person(id, address);} 这里存在一个小的问题，就是在 main() 方法中依然需要知道 Id 和 Address 两个类的具体构成 但是相对于之前的示例，依赖性不再是那么强烈 如果手动来进行解决的话，可以一级一级的往上推，直到入口函数当中统一处理 或者是依靠框架来帮助我们完成这样的任务 实现原理在 Angular 的依赖注入中主要有三个概念 Injector – 注入者，利用其提供的 API 去创建依赖的实例 Provider – 告诉 Injector 如何去创建一个实例（构造这个对象） Object – 创建好的对象，也就是当前所处的模块或者组件需要的依赖（某种类型的对象，依赖本身也是一种类型） 利用 Angular 来改写上面的例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import { Component, ReflectiveInjector, Inject } from '@angular/core';import { environment } from '../environments/environment';export class AppComponent { constructor() { // resolveAndCreate() 方法接收一个 provider 数组 // ReflectiveInjector 利用 resolveAndCreate() 方法会根据输入的一个 provider 数组来构建一个可以提供依赖性的池子 // 池子当中含有多个 provider 对象，该对象有两个属性 // 一个为 provide，可以简单的理解为 key/令牌 等，作用是唯一性的一个标识 // 另外一个为类型，类型有多种，比如 useClass, useFactory 等 // 简单来说，池子的作用就是把在这个类中所有想使用的依赖都存放到里面 const injector = ReflectiveInjector.resolveAndCreate([ // 针对于 { provide: Person, useClass: Person }, 这种 useClass 可以直接简写为 Person // 可以直接使用类来去代替，因为本质上就是提供了这个类的构造，key/令牌 也是这个类的本身 Person, { provide: Address, useFactory: () =&gt; { if (environment.production) { return new Address('北京', '北京') } else { return new Address('西藏', '拉萨') } } }, { provide: Id, useFactory: () =&gt; { return Id.getId('123') }} ]) // 注入之后就可以来进行使用了，利用 injector 的 get() 方法来获取 Person 对象 const person = injector.get(Person) console.log(JSON.stringify(person)) }}class Id { static getId(type: string): Id { return new Id(); }}class Address { city: string; street: string; constructor(city, street) { this.city = city; this.street = street; }}// 依赖 Id 和 Address 两个类class Person { id: Id; address: Address; // 需要两个依赖性，一个是 Id，一个是 Address // 这里执行的流程就是会去上面的池子当中进行寻找 constructor(@Inject(Id) id, @Inject(Address) address) { this.id = id; this.address = address; }} 但是在大部分的情况下，其实我们并不需要显性的去手写这么一个 provider 对象 Angular 提供给了我们一些便利，我们可以利用这些便利来完成上面这样复杂的操作 使用依赖注入来看看在项目当中真实状况下的 provider 123456789101112131415// 一个公共模块// 在 @NgModule 当中注入 BASE_CONFIG 这个静态变量@NgModule({ // ... providers: [ { provide: 'BASE_CONFIG', useValue: 'http://localhost:3000'} ]})// 使用import { Inject } from '@angular/core';constructor(@Inject('BASE_CONFIG') config) { console.log(config)} 我们在 Module 或者 Component 当中，只需要在 providers 数组当中提供这个 provide 对象 它便会自动的帮我们注册到 Inject 这个池子当中 所以在我们使用过程当中，只需要在 constructor 当中使用 @Inject() 注入进来即可 但是需要注意的一点就是，我们这样操作的话，在池子当中取的数据都是单例的 但是如果想要每次取的都是一个新的实例的话，比如之前的实例，只需在此基础上稍作调整，让其返回一个函数即可 12345678910111213141516171819202122232425export class AppComponent { constructor() { const injector = ReflectiveInjector.resolveAndCreate([ Person, { provide: Address, useFactory: () =&gt; { // 修改这里 return () =&gt; { if (environment.production) { return new Address('北京', '北京') } else { return new Address('西藏', '拉萨') } } } }, { provide: Id, useFactory: () =&gt; { return Id.getId('123') }} ]) const person = injector.get(Person) console.log(JSON.stringify(person)) }} 这是一种方式，另外一种方式就是利用父子传递的概念 12345678910111213141516171819202122232425262728constructor() { const injector = ReflectiveInjector.resolveAndCreate([ Person, { provide: Address, useFactory: () =&gt; { if (environment.production) { return new Address('北京', '北京') } else { return new Address('西藏', '拉萨') } } }, { provide: Id, useFactory: () =&gt; { return Id.getId('123') }} ]) // 创建一个子注入者，传入 Person // 这里有一点需要注意，在创建子注入者的时候，我们仅仅只传入了 Person，并没有传入 Id 和 Address // 这里的情况是 当在子池子中找不到的情况下就回去父池子当中进行查找 const childInjector = injector.resolveAndCreateChild([Person]) const personFromChild = childInjector.get(Person) const person = injector.get(Person) console.log(person === personFromChild) // false}","link":"/2018/12/14/Angular/02/"},{"title":"Angular 中的管道","text":"先来看看一些简单的使用场景 123456789&lt;p&gt;生日是 {{ birthday | data: 'yyyy-MM-dd' }}&lt;/p&gt;&lt;p&gt;圆周率为 {{ 3.14159265 | number: '1.2-2' }}&lt;/p&gt;&lt;p&gt;转为大写 {{ 'Angular' | uppercase }}&lt;/p&gt;&lt;p&gt;转为小写 {{ 'Angular' | lowercase }}&lt;/p&gt;&lt;p&gt;格式化 {{ { name: 'semlinker' } | json }}&lt;/p&gt; 管道参数管道可以接收任意数量的参数，使用方式是在管道名称后面添加 : 和参数值 如 number: '1.2-2' ，若需要传递多个参数则参数之间用冒号隔开 1&lt;p&gt;{{ 'semlinker' | slice:0:3 }}&lt;/p&gt; 管道链可以将多个管道连接在一起，组成管道链对数据进行处理 1&lt;p&gt;{{ 'semlinker' | slice:0:3 | uppercase }}&lt;/p&gt; 自定义管道管道是一个带有管道元数据装饰器的类，与组件和模块类似，就是一个简单的 TypeScript 类 通过 @pipe 装饰器来告诉 Angular 这是一个管道类，然后去实现 PipeTransform 接口即可 一个简单的管道，如果跟随参数，则返回和参数相乘的值，如果没有传递参数，则返回原值 12345678910111213141516import { Pipe, PipeTransform } from '@angular/core';@Pipe({ name: 'formatNumber'})// 只需实现 PipeTransform 接口即可// 内部仅有一个 transform 方法export class TestPipe implements PipeTransform { transform(value: number, args?: number): any { if (!args) { args = 1; } return value * args; }} 然后使用也很简单 1&lt;div&gt;{{num | formatNumber: '2'}}&lt;/div&gt; 在构造函数当中使用管道一个小技巧，但不是经常使用 12345678910import { DatePipe } from '@angular/common';class MyService { constructor(private datePipe: DatePipe) {} transformDate(date) { this.datePipe.transform(myDate, 'yyyy-MM-dd'); }} AsyncPipe（异步管道）使用 AsyncPipe 可以直接在模版当中使用 promise 和 Observable 对象 而不需要通过定义一个类的成员属性来存储返回的结果 两个例子，promise 和 Observable 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// Promiseimport { Component } from '@angular/core';@Component({ selector: 'exe-promise-pipe', template: ` &lt;h4&gt;Promise with AsyncPipeComponent&lt;/h4&gt; &lt;p&gt;{{ promise | async }}&lt;/p&gt; `})export class PromiseAsyncPipeComponent { promise: Promise&lt;string&gt;; constructor() { this.promise = this.getPromise(); } getPromise(): Promise&lt;string&gt; { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(`Promise with AsyncPipe complete!`); }, 2000); }); }}// Observablesimport { Component } from '@angular/core';import { Observable } from 'rxjs/Rx';@Component({ selector: 'exe-observable-pipe', template: ` &lt;h4&gt;Observable with AsyncPipe Component&lt;/h4&gt; &lt;p&gt;{{ observable | async }}&lt;/p&gt; `})export class ObservableAsyncPipeComponent { observable: Observable&lt;number&gt; constructor() { this.observable = this.getObservable(); } getObservable(): Observable&lt;number&gt; { return Observable .interval(1000) .take(10) .map(v =&gt; v * v); }} 两者的区别 promise - 返回单个值，不可取消的 Observable - 随着时间的推移发出多个值，可以取消的，支持 map、filter、reduce 等操作符，延迟执行，当订阅的时候才会开始执行 AsyncPipe 会发送多次请求比如如下情况 12345678910@Component({ selector: 'exe-app', template: ` &lt;div&gt; &lt;p&gt;{{ (person$ | async)?.id }}&lt;/p&gt; &lt;p&gt;{{ (person$ | async)?.title }}&lt;/p&gt; &lt;p&gt;{{ (person$ | async)?.body }}&lt;/p&gt; &lt;/div&gt; `}) 几种解决办法 使用 share()123// 使用 rxjs 中的共享操作符this.http.get(url) .map(res =&gt; res.json()).share() 使用 publishReplay()但是页面当中如果有按钮存在的情况，再次请求同样的地址还是会发送请求，这时可以使用 publishReplay() 1234567891011121314constructor(private http: Http) { this.preparePersonInfo();}ngOnInit() { // 调用 connect() 方法的时候，将主动执行订阅操作 this.person$.connect();}// 调用 publishReplay() 方法后将返回一个 ConnectableObservable 对象preparePersonInfo() { this.person$ = this.http.get(url) .map(res =&gt; res.json()).publishReplay()} 如果只需要从服务器获取数据并显示数据可以使用 promise 来修复 AsyncPipe 发送多次请求的问题 12this.person = this.http.get(url) .map(res =&gt; res.json()).toPromise() AsyncPipe 执行流程如下图","link":"/2018/01/11/Angular/04/"},{"title":":host 和 ::ng-deep","text":"这里会涉及到 Angular 的 ViewEncapsulation，即控制视图的封装模式，主要分为三种，原生（Native）、仿真（Emulated）和无（None）三种 Native 模式：完全隔离，外面的样式无法影响组件，组件里面的样式也无法影响外面 Emulated 模式（默认值）：全局样式可以影响组件，但组件样式无法影响外层 None 意味着完全消除隔离特性，全局样式可以影响组件，组件样式也可以影响外层 这种情况下 Angular 不使用视图封装，会把 CSS 添加到全局样式中，而不会应用之前那些作用域规则、隔离和保护等 从本质上来说，这跟把组件的样式直接放进 HTML 是一样的 术语上来说就是 ViewEncapsulation 允许设置三个可选的值： ViewEncapsulation.Emulated 没有 Shadow DOM，但是通过 Angular 提供的样式包装机制来封装组件，使得组件的样式不受外部影响，这是 Angular 的默认设置 虽然样式仍然是应用到整个 document，但 Angular 会为所在的类创建了一个 [_ngcontent-cmy-0] 选择器 ViewEncapsulation.Native 使用原生的 Shadow DOM 特性，Angular 会把组件按照浏览器支持的 Shadow DOM 形式渲染 ViewEncapsulation.None 即 没有 Shadow DOM，并且也无样式包装，即所有的样式都应用到整个 document，换句话说，组件的样式会受外界影响，可能被覆盖掉 唯一的区别在于 Shadow DOM，当然其作用是让组件的样式只进不出，换言之即组件内的样式不会影响到外部组件 三者的表现形成如下，假设基本模版为 12345@Component({ template: `&lt;h1&gt;test&lt;/h1&gt;`, styles: [`h1 { color: #f50; }`], encapsulation: ViewEncapsulation.Native}) 三种方式生成的分别为 Native1234#shadow-root (open) &lt;style&gt;h1 { color: #f50; }&lt;/style&gt; &lt;h1&gt;test&lt;/h1&gt; Emulated123&lt;style&gt;h1[_ngcontent-c0] { color: #f50; }&lt;/style&gt;&lt;h1 _ngcontent-c0&gt;test&lt;/h1&gt; None123&lt;style&gt;h1 { color: #f50; }&lt;/style&gt;&lt;h1&gt;test&lt;/h1&gt; 需要注意的是：Native 和 None 在内容是一样的，但其后者会影响至其他外部组件的 h1 元素 组件样式组件样式的封装模式取决于我们对 encapsulation 的配置，当然你可以了在 main.ts 时为所有组件统一设定一种行的模式，例如 1234// 使用 None 模式platformBrowserDynamic().bootstrapModule(AppModule, { defaultEncapsulation: ViewEncapsulation.None}) 虽然三种模式都有不同的风格，但对于一个组件而言，如果没有一很合理的使用风格在实际项目中会让我们很头疼，特别是当项目中同时在使用第三方组件库，情况会更为复杂 比如你在某一个组件当中添加了一个 class 样式 123.active-link { color: red;} 若组件设定为 None 模式，只要该组件出现过一次，并且在未来所有即使不再使用，那么这个样式也会得到保留，所有的添加了这个 class 的元素均会改变 反之，对于 Shadow 行为，它会为该组件创建一个额外的属性 _ngcontent-c1 来标识（不管是 Native、Emulated 本质是一样的）所设定的样式仅限于当前组件当中 而 Angular 中即采用 :host 来表示组件自身，所以前面的 CSS 样式可以调整为 123456789:host .active-link { color: red;}&lt;!-- 生成的样式为 --&gt;[_nghost-c1] .active-link[_ngcontent-c1] { color: red;} 然而我们会发现，对于第三方组件组件而言，.active-link 是其组件内部某个 HTML 元素的 class 而已，且它有自己的一套组件封装规则 但我们生成的 CSS 中包括了一个奇怪的字符 [_ngcontent-c1]，最终导致该组件样式无法改变内嵌的第三方组件内容的样式 在这种情况下，Angular 提供了一种对未来工具更好兼容性的命令 ::ng-deep 来强制样式允许侵入子组件 123456789:host ::ng-deep .active-link { color: red;}&lt;!-- 生成的样式为 --&gt;[_nghost-c1] .active-link { color: red;} 最终的结果就是这个样式只会在这个组件内部当中有效","link":"/2018/01/16/Angular/06/"},{"title":"Angular 中的动态加载","text":"本篇主要介绍如何在 Angular 中动态加载已经声明的组件 基本原理这里主要涉及到三个 API ViewChild 一个属性装饰器，用来从模版视图中获取对应的元素 可以通过模版变量获取，获取的时候可以通过 read 属性设置查询的条件 简单来说就是可以把视图转为不同的实例 ViewContainerRef 一个视图容器，可以在上面创建、插入、删除组件等 ComponentFactoryResolver 一个服务，动态加载组件的核心，这个服务可以将一个组件实例呈现到另一个组件视图上 所以总结起来简单来说就是 特定区域就是一个视图容器，可以通过 ViewChild 来实现获取和查询 然后使用 ComponentFactoryResolver 将已经声明但是未实例化的组件解析成可以动态加载的 Component 再将此 Component 呈现到之前的视图容器当中 动态加载已经声明的组件引用的是 Angular 组件基础内容 当中的示例 模版文件十分简洁，就是通过创建一个 #dyncomp 句柄，以便获得引用，详细可以参考上述链接 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// 注意引入的内容，上文提到的所需的三个都要引入import { Component, OnInit, ViewChild, ViewContainerRef, ComponentFactoryResolver, ComponentRef } from '@angular/core';import { Child11Component } from './child11/child11.component';import { state } from '@angular/animations';@Component({ selector: 'dynamic-comp', templateUrl: './dynamic-comp.component.html', styleUrls: ['./dynamic-comp.component.scss']})export class DynamicCompComponent implements OnInit { // 这里引用模板里面定义的 dyncomp 容器标签 // 通过模版变量名来获取引用，然后可以通过 read 选项设置一个 ViewContainerRef // 最终在生命周期 ngAfterViewInit 之后便会获取此区域的一个 ViewContainerRef 实例 @ViewChild('dyncomp', { read: ViewContainerRef }) dyncomp: ViewContainerRef; comp1: ComponentRef&lt;Child11Component&gt;; comp2: ComponentRef&lt;Child11Component&gt;; constructor( private resolver: ComponentFactoryResolver) { } ngOnInit() { } ngAfterContentInit() { console.log('动态创建组件的实例...'); // 这里是主要的加载组件函数 // 通过在 constructor 当中注入的 ComponentFactoryResolver 服务 // 调用其 resolveComponentFactory 来解析一个已经声明的组件并得到一个可动态加载的 componentFactory // 最后直接调用容器的 createComponent 函数将其解析出来的 componentFactory 动态的呈现到容器视图上 const childComp = this.resolver.resolveComponentFactory(Child11Component); this.comp1 = this.dyncomp.createComponent(childComp); // this.comp1.instance.title = '父层设置的新标题'; // this.comp1.instance.btnClick.subscribe((param) =&gt; { // console.log('---&gt;' + param); // }); // 可以创建多个组件实例出来 // let temp1 = this.dyncomp.createComponent(childComp); // temp1.instance.title = '第2个动态子组件'; // let temp2 = this.dyncomp.createComponent(childComp); // temp2.instance.title = '第3个动态子组件'; // let temp3 = this.dyncomp.createComponent(childComp); // temp3.instance.title = '第4个动态子组件'; // let temp4 = this.dyncomp.createComponent(childComp); // temp4.instance.title = '第5个动态子组件'; // let temp5 = this.dyncomp.createComponent(childComp); // temp5.instance.title = '第6个动态子组件'; /** * createComponent 方法可以调用很多次，会动态创建出多个组件实例 * 方法有第二个参数，表示组件渲染的顺序 */ this.comp2 = this.dyncomp.createComponent(childComp, 0); this.comp2.instance.title = '第二个子组件'; } public destoryChild(): void { this.comp1.destroy(); this.comp2.destroy(); }} 上面特别需要注意的一点就是，对于动态加载的组件必须要声明在特性模块的 entryComponents 中，如下所示 1234567891011121314151617// ...@NgModule({ declarations: [ AppComponent, DynamicCompComponent, Child11Component ], imports: [ BrowserModule ], providers: [], bootstrap: [AppComponent], entryComponents: [Child11Component]})export class AppModule { } 也就是说对于此处声明的组件，Angular 都会创建一个 ComponentFactory 并将其存储在 ComponentFactoryResolve 中，也就是动态加载必须的步骤 动态加载还未创建的组件简单来说这种情况就是动态创建不存在的组件而不是已经声明的组件，不过这种情况一般很少遇见 在这种情况下就需要用到 Compiler 作用就是用于在运行的时候运行 Angular 编译器来创建 ComponentFactory 的服务，然后可以使用它来创建和呈现组件实例 我们知道，容器创建和呈现组件的函数需要一个 ComponentFactory，而 Compiler 能够在运行的时候动态创建一个 ComponentFactory 一个简单的示例 1234567891011121314151617181920212223242526272829303132333435363738// 首先引入 Compilerimport { Compiler } from '@angular/core';// ...// 然后在构造函数当中进行注入constructor( private cp: Compiler) {}// ...// 在创建的时候就不再是指定组件了而是模块// 容器的呈现还是一样，直接 createComponentthis.comp1 = this.dyncomp.createComponent(this.createModule());// 新增一个 createModule 函数createModule() { // 通过 Component 和 NgModule 修饰器动态创建新的组件和模块 @Component({ template: '动态组件' }) class DynamicCom {} @NgModule({ declarations: [ DynamicCom ] }) class DynamicModule { } // 然后调用 Compiler 的 compileModuleAndAllComponentsSync 方法获取一个新的 ComponentFactory return this.cp.compileModuleAndAllComponentsSync(DynamicModule).componentFactories .find(comFac =&gt; comFac.componentType === DynamicCom)} 引申的问题有的时候会遇到，在创建动态组件后，调用 componentRef.instance 不能更新界面数据 比如说在动态组件创建了以后，使用动态组件的实例 componentRef.instance 去改变动态组件的属性，比如 1componentRef.instance.name = '123' 界面上绑定的 name 属性不会更新，但是控制台输出发现其中的 name 已经变更 如果是在动态组件当中使用函数，可以改变 name 属性的值，并且 name 属性也是可是实时更新 但是如果使用的是 componentRef，这样数据实时更新就不会起作用了 两种解决方法，一种是使用 setTimeout，可以解决问题，但是并不怎么优雅 12345678910111213141516171819202122232425262728293031323334@Component({ template: ` 我是测试模板 {{data}} `})export class CustomComponent implements OnInit { @Input() public data: string; public ngOnInit() { console.log(this.data); setTimeout(() =&gt; { console.log(this.data); }, 3000); }}// ----------------------------export class HomeComponent implements OnInit { constructor( private viewContainerRef: ViewContainerRef, private cfr: ComponentFactoryResolver ) { } public ngOnInit() { let factory = this.cfr.resolveComponentFactory(CustomComponent); let componentRef = this.viewContainerRef.createComponent(factory); componentRef.instance.data = 'hello'; setTimeout(() =&gt; { componentRef.instance.data = 'bye'; }, 2000); }} 第二种解决方式可以采用官方提供的 changeDetectorRef.markForCheck() 来解决这个问题 即手动去触发检测更新，详细见 ChangeDetectorRef 宿主对象上面介绍了 Angular 中动态加载的一些相关内容，下面来看一些宿主对象相关的知识点，主要包括： Angular 中利用指令来指定宿主对象 Angular 中如何动态添加宿主 如何与动态添加后的组件进行通信 使用指令来指定宿主对象在 Angular 中，我们通常需要一个宿主（Host）来给动态加载的组件提供一个容器，这个宿主在 Angular 中就是 ng-template 我们需要找到组件中的容器，并且将目标组件加载到这个宿主中，就需要通过创建一个指令（Directive）来对容器进行标记 先来看看模版文件 123456// app.component.ts&lt;h1&gt; {{title}}&lt;/h1&gt;&lt;ng-template dl-host&gt;&lt;ng-template&gt; 然后我们添加一个用于标记这个属性的指令 dl-host.directive 123456789101112// dl-host.directive.tsimport { Directive, ViewContainerRef } from '@angular/core';@Directive({ selector: '[dl-host]'})export class DlHostDirective { // 在这里注入了一个 ViewContainerRef 的服务 // 它的作用就是为组件提供容器，并且提供了一系列的管理这些组件的方法 constructor(public viewContainerRef: ViewContainerRef) { }} 这样一来，我们就可以在 app.component 中通过 @ViewChild 获取到 dl-host 的实例，因此进而获取到其中的 ViewContainerRef 另外，我们还需要为 ViewContainerRef 提供需要创建组件 A 的工厂 所以还需要在 app.component 中注入一个工厂生成器 ComponentFactoryResolver 并且在 app.module 中将需要生成的组件注册为一个 @NgModule.entryComponent 关于 @NgModule.entryComponent 可以参考之前的介绍 12345678910111213141516171819202122// app.comonent.tsimport { Component, ViewChild, ComponentFactoryResolver } from '@angular/core';import { DlHostDirective } from './dl-host.directive';import { AComponent } from './a/a.component';@Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css']})export class AppComponent { title = 'app works!'; @ViewChild(DlHostDirective) dlHost: DlHostDirective; constructor(private componentFactoryResolver: ComponentFactoryResolver) { } ngAfterViewInit() { this.dlHost.viewContainerRef.createComponent( this.componentFactoryResolver.resolveComponentFactory(AComponent) ); }} 下面是模块内容 1234567891011121314151617// app.module.tsimport { BrowserModule } from '@angular/platform-browser';import { NgModule } from '@angular/core';import { AppComponent } from './app.component';import { AComponent } from './a/a.component';import { DlHostDirective } from './dl-host.directive';@NgModule({ declarations: [AppComponent, AComponent, DlHostDirective], imports: [BrowserModule, FormsModule, HttpModule], entryComponents: [AComponent], providers: [], bootstrap: [AppComponent]})export class AppModule { } 如何动态添加宿主我们不可能在每一个需要动态添加组件的时候提供一个宿主组件，因为我们甚至都不会知道一个组件会在哪儿被创建出来并且被添加到页面中 就比如一个模态窗口，你希望在你需要使用的时候就能打开，而并非受限与宿主，在这种需求的前提下，我们就需要动态添加一个宿主到组件中 现在我们可以将 app.component 作为宿主的载体，但是并不提供宿主的显式声明，而是由我们动态去生成宿主 先将 app.component 还原 1234// app.component.ts&lt;h1&gt; {{title}}&lt;/h1&gt; 然后我们需要往 DOM 中注入一个节点，例如一个 div 节点作为页面上的宿主，再通过工厂生成一个 AComponent 并将这个组件的根节点添加到宿主上 在这种情况下我们需要通过工厂直接创建组件，而不是在使用 ComponentContanerRef 1234567891011121314151617181920212223242526272829303132333435363738// app.comonent.tsimport { Component, ComponentFactoryResolver, Injector, ElementRef, ComponentRef, AfterViewInit, OnDestroy} from '@angular/core';import { AComponent } from './a/a.component';@Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css']})export class AppComponent implements OnDestroy { title = 'app works!'; component: ComponentRef&lt;AComponent&gt;; constructor( private componentFactoryResolver: ComponentFactoryResolver, private elementRef: ElementRef, private injector: Injector ) { this.component = this.componentFactoryResolver .resolveComponentFactory(AComponent) .create(this.injector); } ngAfterViewInit() { let host = document.createElement(\"div\"); host.appendChild((this.component.hostView as any).rootNodes[0]); this.elementRef.nativeElement.appendChild(host); } ngOnDestroy() { this.component.destroy(); }} 这种手动添加 DOM 的方式会有一个问题，那就是无法对数据进行脏检查 如果修改了 a.component.ts 是不会触发更新的，所以我们需要手动的去通知应用处理这个组件的视图，对这个组件进行脏检查 1234567891011121314151617181920212223242526272829303132333435363738394041// app.comonent.tsimport { Component, ComponentFactoryResolver, Injector, ElementRef, ComponentRef, ApplicationRef, AfterViewInit, OnDestroy} from '@angular/core';import { AComponent } from './a/a.component';@Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css']})export class AppComponent implements OnDestroy { title = 'app works!'; component: ComponentRef&lt;AComponent&gt;; constructor( private componentFactoryResolver: ComponentFactoryResolver, private elementRef: ElementRef, private injector: Injector, private appRef: ApplicationRef ) { this.component = this.componentFactoryResolver .resolveComponentFactory(AComponent) .create(this.injector); appRef.attachView(this.component.hostView); } ngAfterViewInit() { let host = document.createElement(\"div\"); host.appendChild((this.component.hostView as any).rootNodes[0]); this.elementRef.nativeElement.appendChild(host); } ngOnDestroy() { this.appRef.detachView(this.component.hostView); this.component.destroy(); }} 如何与动态添加后的组件进行通信简单的方法是动态加载的组件通过 @Output() 向外 emit() 事件，外部组件通过监听事件（subscribe）得到通知 12345678910111213141516171819202122232425// 动态加载的组件 a.component// html 模版部分如下，简单的绑定一个点击事件// &lt;p (click)=\"onTitleClick()\"&gt;// {{title}}// &lt;/p&gt;// 组件部分如下import { Component, Output, Input, EventEmitter } from '@angular/core';@Component({ selector: 'app-a', templateUrl: './a.component.html', styleUrls: ['./a.component.css']})export class AComponent { @Input() title = 'a works!'; @Output() onTitleChange = new EventEmitter&lt;any&gt;(); onTitleClick() { this.onTitleChange.emit(); }} 下面来看看外部组件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 外部组件 app.component.tsimport { Component, ComponentFactoryResolver, Injector, ElementRef, ComponentRef, ApplicationRef, AfterViewInit, OnDestroy} from '@angular/core';import { AComponent } from './a/a.component';@Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css']})export class AppComponent implements OnDestroy { title = 'app works!'; component: ComponentRef&lt;AComponent&gt;; constructor( private componentFactoryResolver: ComponentFactoryResolver, private elementRef: ElementRef, private injector: Injector, private appRef: ApplicationRef ) { this.component = this.componentFactoryResolver .resolveComponentFactory(AComponent) .create(this.injector); appRef.attachView(this.component.hostView); (&lt;AComponent&gt;this.component.instance).onTitleChange .subscribe(() =&gt; { console.log('title clicked') }); (&lt;AComponent&gt;this.component.instance).title = 'a works again!'; } ngAfterViewInit() { let host = document.createElement('div'); host.appendChild((this.component.hostView as any).rootNodes[0]); this.elementRef.nativeElement.appendChild(host); } ngOnDestroy() { this.appRef.detachView(this.component.hostView); this.component.destroy(); }} 查看页面可以看到界面就显示了 a works again! 的文字，点击这行文字，就可以看到在 console 中输入了 title clicked","link":"/2019/05/12/Angular/08/"},{"title":"CSS 单行，多行溢出隐藏","text":"单行，多行溢出隐藏在 Web 开发过程中是一个十分常见的需求 在 WebKit 浏览器或移动端（绝大部分是 WebKit 内核的浏览器）的页面实现比较简单，可以直接使用 WebKit 的 CSS 扩展属性（WebKit 是私有属性） 1-webkit-line-clamp 但是需要注意的是，这是一个不规范的属性（unsupported WebKit property），它并没有出现在 CSS 规范草案中 -webkit-line-clamp 用来限制在一个块元素显示的文本的行数，为了实现该效果，它需要组合其他的 WebKit 属性 常见结合属性有以下几种 display: -webkit-box 必须结合的属性，将对象作为弹性伸缩盒子模型显示 -webkit-box-orient 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 text-overflow: ellipsis 可以用来多行文本的情况下，用省略号 '...' 隐藏超出范围的文本 一般多行溢出常用的代码如下： 1234567p { overflow : hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;} 修改一下就可以实现单行溢出隐藏 12345p { overflow: hidden; text-overflow: ellipsis; white-space: nowrap;} 或者使用 jQuery 来做限制： 1234567891011121314151617181920212223242526272829303132333435363738394041/* 自动获取 css 宽度进行处理，如果 css 中未对 .test1 给定宽度，则不起作用 $('.test1').wordLimit(); 截取字符数，值为大于 0 的整数，这里表示 class 为 test2 的标签内字符数最多 24 个 $('.test2').wordLimit(24);*/(function ($) { $.fn.wordLimit = function (num) { this.each(function () { if (!num) { var copyThis = $(this.cloneNode(true)).hide().css({ 'position': 'absolute', 'width': 'auto', 'overflow': 'visible' }); $(this).after(copyThis); if (copyThis.width() &gt; $(this).width()) { $(this).text($(this).text().substring(0, $(this).text().length - 4)); $(this).html($(this).html() + '...'); copyThis.remove(); $(this).wordLimit(); } else { // 清除复制 copyThis.remove(); return; } } else { var maxwidth = num; if ($(this).text().length &gt; maxwidth) { $(this).text($(this).text().substring(0, maxwidth)); $(this).html($(this).html() + '...'); } } }); }})(jQuery);","link":"/2016/12/02/CSS/02/"},{"title":"清除浮动之 clearfix 的原理和方法","text":"CSS 的 Float（浮动），会使元素向左或向右移动，其周围的元素也会重新排列 但是一般 Float 往往是用于图像的，但它在布局时一样非常有用 下面是一些需要注意的地方 元素的水平方向浮动，意味着元素只能左右移动而不能上下移动 一个浮动元素会尽量向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止 浮动元素之后的元素将围绕它 浮动元素之前的元素将不会受到影响 问题的由来有这样一种情形：在一个容器（container）中，有两个浮动的子元素 1234&lt;div&gt; &lt;div style=\"float:left;width:45%;\"&gt;&lt;/div&gt; &lt;div style=\"float:right;width:45%;\"&gt;&lt;/div&gt;&lt;/div&gt; 在浏览器中一运行，就会出现意想不到的结果，实际视图是子元素显示在父容器的外部 问题的原因与浮动定位有关在 CSS 规范中，浮动定位 不属于 正常的页面流（page flow），是 独立定位 的，所以，只含有浮动元素的父容器，在显示时不考虑子元素的位置，就当它们不存在一样 这就造成了显示出来，父容器好像空容器一样 解决方法一：添加空元素经典的解决方法，就是在浮动元素下方添加一个非浮动元素 12345&lt;div&gt; &lt;div style=\"float:left;width:45%;\"&gt;&lt;/div&gt; &lt;div style=\"float:right;width:45%;\"&gt;&lt;/div&gt; &lt;div style=\"clear:both;\"&gt;&lt;/div&gt;&lt;/div&gt; 原理是父容器现在必须考虑非浮动子元素的位置，而后者肯定出现在浮动元素下方，所以显示出来，父容器就把所有子元素都包括进去了，这种方法比较简单，但是要在页面中增加冗余标签，违背了语义的原则 解决方法二：浮动的父容器另一种思路是，索性将父容器也改成浮动定位，这样它就可以带着子元素一起浮动了 1234&lt;div style=\"float:left;\"&gt; &lt;div style=\"float:left;width:45%;\"&gt;&lt;/div&gt; &lt;div style=\"float:right;width:45%;\"&gt;&lt;/div&gt;&lt;/div&gt; 这种方法不用修改 html 代码，但是缺点在于父容器变成浮动以后，会影响到后面元素的定位，而且有时候，父容器是定位死的，无法变成浮动 解决方法三：浮动元素的自动 clearing让父容器变得可以自动”清理”（clearing）子元素的浮动，从而能够识别出浮动子元素的位置，不会出现显示上的差错 要做到这点，只要为父容器加上一条 'overflow: hidden' 的 CSS 语句就行了 至于为什么加上 'overflow: hidden' 就可以解决此类问题，可以参考 块格式化上下文| MDN 1234&lt;div style=\"overflow: hidden;\"&gt; &lt;div style=\"float:left;width:45%;\"&gt;&lt;/div&gt; &lt;div style=\"float:right;width:45%;\"&gt;&lt;/div&gt;&lt;/div&gt; 这种方法的缺点主要有二个，一个是 IE6 不支持，另一个是一旦子元素的大小超过父容器的大小，就会出显示问题 解决方法四：能不能通过 CSS 语句添加子元素呢，这样就不用修改 HTML 代码了答案是可以的，我们知道 CSS 语句中有一个 :after 伪选择符，就可以在父容器的尾部自动创建一个子元素，这正好符合我们的需要 下面的代码参照了 lifesinger 的写法 123456.clearfix:after { content: \"\"; display: block; height: 0; clear: both;} 'clearfix' 是父容器的 class 名称 content: ''; 是在父容器的结尾处放一个空白字符 &quot;height: 0;&quot; 是让这个这个空白字符不显示出来 &quot;display: block; clear: both;&quot; 是确保这个空白字符是非浮动的独立区块 需要注意：:after 选择符 IE6 不支持，也就是说上面的这段代码在 IE6 中无效，这怎么办？ 我们添加一条 IE6 的独有命令 'zoom: 1;' 就行了，这条命令的作用是激活父元素的 'hasLayout' 属性，让父元素拥有自己的布局，IE6 会读取这条命令，其他浏览器则会直接忽略它 最终代码12345678910.clearfix:after { content: ''; display: block; height: 0; clear: both;}.clearfix { zoom: 1;} 附录：什么是 hasLayoutIE 使用 Layout 概念来控制元素的尺寸和位置，如果一个元素有 Layout，它就有自身的尺寸和位置，如果没有，它的尺寸和位置由最近的拥有布局的祖先元素控制 123456789在默认情况下，拥有 Layout 的元素包括：&lt;html&gt;, &lt;body&gt;&lt;table&gt;, &lt;tr&gt;, &lt;th&gt;, &lt;td&gt;&lt;img&gt;&lt;hr&gt;&lt;input&gt;, &lt;button&gt;, &lt;select&gt;, &lt;textarea&gt;, &lt;fieldset&gt;, &lt;legend&gt;&lt;iframe&gt;, &lt;embed&gt;, &lt;object&gt;, &lt;applet&gt;&lt;marquee&gt; 注意，&lt;p&gt; 和 &lt;div&gt; 默认不拥有 Layout 凡是具有以下 CSS 属性的元素，也会拥有布局 12345678float: left|rightdisplay: inline-blockwidth: any value other than 'auto'height: any value other than 'auto'zoom: any value other than 'normal' （IE 专用属性）writing-mode: tb-rl（IE 专用属性）overflow: hidden|scroll|auto（只对 IE7 及以上版本有效）overflow-x|-y: hidden|scroll|auto（只对 IE7 及以上版本有效） hasLayout 是 IE 特有的属性，不是 CSS 属性，可以用 JavaScript 函数 hasLayout 查看一个元素是否拥有 Layout 如果有，这个函数就返回 true，否则返回 false，hasLayout 是一个只读属性，所以无法使用 JavaScript 进行设置 参考： 浮动原理","link":"/2016/11/09/CSS/01/"},{"title":"样式来源与层叠规则","text":"CSS 即所谓的层叠样式表，就是浏览器对多个样式来源进行叠加，最终确定结果的过程 样式来源之所有有层叠的概念，是因为有多个样式来源，具体为下面五种： &lt;div style=&quot;&quot;&gt;&lt;/div&gt; 属性样式 &lt;style&gt;&lt;/style&gt; 内部样式 &lt;link&gt; 引用样式 浏览器用户自定义样式 浏览器默认样式 上面三个可以利用程序来控制（比如 CSS 文件，行内样式等，就不所说了），后面两个则是浏览器的行为 浏览器用户自定义样式指的一些浏览器自带功能，比如字体的放大缩小，用户在这里设置了字体和字号以后，它们会覆盖掉浏览器默认的样式 层叠的规则由于样式的来源不同，浏览器在加载样式时，需要计算出最终的样式值，这里的规则就是：浏览器会让后面的样式覆盖前面的样式（行内的话同样适用） 例如下面这两种，即相同选择器在层叠时，后加载的覆盖前加载的 123456&lt;div style=\"color:red; color:blue;\"&gt;&lt;/div&gt;p { color: red; color: blue;} 这里就涉及到了一个选择器优先级的概念 特指度（I-C-E）特指度表示一个 CSS 选择器表达式的重要程度，通常称为 'I-C-E' 计算公式，其中的 I 对应着 id，C 对应着 class，E 对应着 element 在针对一个 CSS 选择器表达式的时候，遇到一个 id 就往特指度数值中加 100，遇到一个 class 就往特指度数值中加 10，遇到一个 element 就往特指度数值中加 1 下面是几个简单的例子： 12345div // 1div#box // 101div p#box // 102 优先级如下 !important 优先级是最高的，而 * 选择器最低，排除这两点以外 最高的优先级： 直接在标签中的设置样式，例如 &lt;div style=&quot;color:red;&quot;&gt;&lt;/div&gt; 次优先级： id 选择器，例如 #box { ... } 其次的是类选择器，例如 .box { ... } 最后的就是标签选择器，例如 div { ... } 简单总结的话，三句话： id 选择器高于 class 选择器 不同选择器的特指度比较时，不区分加载的顺序（而相同选择器在层叠时，后加载的覆盖前加载的） 设置的样式高于继承的样式，不用考虑特指度 浏览器默认样式浏览器自带一个默认的样式，如果 html 中没有为标签设置样式，则浏览器会按照自己的样式来显示，但是浏览器默认样式的级别是最低的，一旦有其他地方设置了标签样式，浏览器默认样式就会被冲掉 不过各个浏览器的默认样式有些地方不一样，所以我们在编写 CSS 的时候都会为了统一而指定相应的样式（例如 * {margin: 0; padding: 0}） block 元素1234html, address, blockquote, body, dd, div, dl, dt, fieldset, form, frame, frameset, h1, h2, h3, h4, h5, h6, noframes, ol, p, ul,center, dir, hr, menu, pre{ display: block} 浏览器默认样式天生规定了 div 等一些元素为 block，而不是 div 天生就是 block 简单来说，是默认样式规定的，而不是浏览器内核规定的 没有设置 block 的元素，默认显式为 inline 显式 display: list-item1li { display: list-item } display: list-item 会为元素内容生成一个块型盒，随后再生成一个列表型的行内盒 其效果就和 ul 中出现项目列表符号一样，通俗地说就是会在内容前面自动加上黑点，例如 1234&lt;span style=\"display:list-item; list-style:square; list-style-position:inside;\"&gt;1&lt;/span&gt;&lt;span style=\"display:list-item; list-style:square; list-style-position:inside;\"&gt;2&lt;/span&gt;&lt;span style=\"display:list-item; list-style:square; list-style-position:inside;\"&gt;3&lt;/span&gt;&lt;span style=\"display:list-item; list-style:square; list-style-position:inside;\"&gt;4&lt;/span&gt; list-style 和 list-style-type 属性list-style 列表中的列表项目标记设定为自定义的图片 而 list-style-type 可以来设置为不同的列表样式（自带），例如： 1234ul.a {list-style-type: circle}ul.b {list-style-type: square}ol.a {list-style-type: upper-roman}ol.b {list-style-type: lower-alpha} diplay: table1table { display: table } 设置该属性的元素会作为块级表格来显示（类似 &lt;table&gt;），表格前后带有换行符 与 diplay: block 最主要的区别就是，block 的元素会作为块级元素独占一行，而设置 table 的元素则会根据内容的宽度自适应的包含，即所谓的包裹性 display: table-cell1td, th { display: table-cell; } 这个属性主要用来多列布局，类似 bootstrap 中的栅格系统，比如： 123456789&lt;div style=\"display: table-cell; width: 20%\"&gt; 111111111111&lt;/div&gt;&lt;div style=\"display: table-cell;\"&gt; 2222222222222&lt;/div&gt;&lt;div style=\"display: table-cell; width: 30%\"&gt; 33333333333&lt;/div&gt; 其他剩余的一些都是比较常见的属性，或者几乎不会用到的属性，比如打印设置，字体的书写顺序（默认的就是从左到右） 通过其他一些设置可以看出，浏览器会默认的设置一些间距（margin，padding），字体大小，粗/斜体等 因为各个浏览器的解析效果可能不一致，所以在开发的时候，我们都会为其统一设置一个值，以来覆盖掉浏览器的默认样式","link":"/2017/09/22/CSS/03/"},{"title":"伪类与伪元素","text":"先来看看官方的定义，伪元素和伪类 CSS 引入伪类和伪元素概念是为了格式化文档树以外的信息，也就是说，伪类和伪元素是用来修饰不在文档树中的部分，两者的区别如下 伪类用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的 比如说，当用户悬停在指定的元素时，我们可以通过 :hover 来描述这个元素的状态 伪元素用于创建一些不在文档树中的元素，并为其添加样式 比如说，我们可以通过 :before 来在一个元素前增加一些文本，并为这些文本添加样式 虽然用户可以看到这些文本，但是这些文本实际上不在文档树中 简单的总结就是 伪类的操作对象是文档树中已有的元素 而伪元素则创建了一个文档数外的元素 两者的区别在于：有没有创建一个文档树之外的元素 伪元素是使用单冒号还是双冒号？CSS3 规范中的要求使用双冒号（::）表示伪元素，以此来区分伪元素和伪类 比如 ::before 和 ::after 等伪元素使用双冒号（::） :hover 和 :active 等伪类使用单冒号（:） 除了一些低于 IE8 版本的浏览器外，大部分浏览器都支持伪元素的双冒号（::）表示方法 然而，除了少部分伪元素，如 ::backdrop 必须使用双冒号，大部分伪元素都支持单冒号和双冒号的写法 比如 ::after，写成 :after 也可以正确运行 所以对于伪元素是使用单冒号还是双冒号的问题，可以参考 MDN 大概的意思就是：虽然 CSS3 标准要求伪元素使用双冒号的写法，但也依然支持单冒号的写法（为了向后兼容，建议你在目前还是使用单冒号的写法） 实际上，伪元素使用单冒号还是双冒号很难说得清谁对谁错，你可以按照个人的喜好来选择某一种写法 如何获取并修改伪元素的值这里主要涉及 ::before 和 ::after，其余几个伪元素（::first-letter、::first-line、::selection 等）由于没有 content 属性，所以一笔带过，本质上是一样的 获取伪元素的属性值由于 JavaScript 里没有可以直接操作伪元素的选择符，但是可以通过获取其 CSS 属性的方法来达到目的 这里可以利用 window.getComputedStyle 方法选择到伪元素，然后利用 getPropertyValue 方法获取对应的属性的值 1window.getComputedStyle(element[, pseudoElt]); 此方法包含两个参数，一个是元素本身另一个是元素的伪元素 1234var div = document.querySelector('div');// 获取 before 伪元素的字号大小（获取的时候使用 : 或者 :: 都是可以的）var fontSize = window.getComputedStyle(div, '::before').getPropertyValue('content'); 更改伪元素的属性值虽然上面的方法可以获取到伪元素的属性值，但是却无法更改，如果使用 JavaScript 来更改伪元素属性值的话，这里主要介绍下面两种方法 更改 data-* 属性值来更改伪元素的 content 值data-* 是 HTML5 新增的 DOM 元素属性，作用大致可以理解为标记，伪元素的 content 属性值除了常规赋值外，还有一种特殊的 attr() 方法来获取 1234567&lt;div class=\"test\" data-text=\"AAA\" data-color=\"red\"&gt;&lt;/div&gt;// CSS.test::before { content: attr(data-text); // AAA} 另外 content 其实可以多个 attr 连写，而且 attr() 内的可以是 DOM 元素的任意属性（比如 class 等，甚至非 W3C 标准属性也支持，不过不推荐这么做） 1234/* 注意用空格连接，不要用 + 号拼接 */.test::before { content: '类名是' attr(class) '颜色是' attr(data-color);} 需要注意，目前只有 content 属性支持这个方法 创建多个 class，通过切换 class 来达到改变样式的目的这个方法的优点是简单好用且无兼容性问题，缺点是多了一些其实用处不大的 class 参考： Attribute References: attr() Pseudo-elements and pseudo-classes 总结伪类与伪元素","link":"/2018/11/25/CSS/04/"},{"title":"BFC","text":"BFC 直译为块级格式化上下文，它是一个独立的渲染区域，只有 block-level-box 参与， 它规定了内部的 block-level-box 如何布局，并且与这个区域外部毫不相干 块级元素会自动生成一个块级盒 block-level-box，这是块级盒 block-level-box 的盒模型构成，它表明的是块级盒自身的结构构成 BFC 的原理简单来说其实也就是 BFC 的渲染规则，主要有下面几点： 普通流中的块元素（box）独占一行，然后从上往下一个接一个的排布（垂直方向），相邻元素间会有外边距折叠（垂直方向的距离由 margin 决定，属于同一个 BFC 的两个相邻 box 的 margin 会发生重叠） 每个元素的 margin box 的左边， 与包含块 border box 的左边相接触（对于从左往右的格式化，否则相反）（即使存在浮动也是如此） BFC 的区域不会与 float box 重叠 BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素（反之也如此） 计算 BFC 的高度时，浮动元素也参与计算 BFC 的生成既然 BFC 是一块渲染区域，那这块渲染区域到底在哪，它又是有多大，而这些则由生成 BFC 的元素决定（即哪些元素会生成 BFC） 这里只列举一些比较常见的，完整的列表可以参考 MDN - 块格式化上下文 float 属性不为 none，意思是，只要设置了浮动，当前元素就创建了 BFC overflow 的值不为 visible，可以让属性是 hidden、auto position 为 absolute 或 fixed display 为 inline-block, table-cell, table-caption, flex, inline-flex 关于 display：table，之所以可以生成 BFC，主要原因在于 table 会默认生成一个匿名的 table-cell 正是这个匿名的 table-cell 生成了 BFC display 值为 flow-root 的元素，新属性，简单来说给有浮动元素的父容器添加该属性可以清除浮动 弹性元素（display 为 flex 或 inline-flex 元素的直接子元素） 网格元素（display 为 grid 或 inline-grid 元素的直接子元素） BFC 的应用有了上面这些规则，我们就可以来解决平常遇到过的一些问题 两列布局先看下面代码 1234567891011121314151617181920212223&lt;style&gt;body { width: 300px; position: relative;}.aside { width: 100px; height: 150px; float: left; background: #f66;}.main { height: 200px; background: #fcc;}&lt;/style&gt;&lt;body&gt; &lt;div class=\"aside\"&gt;&lt;/div&gt; &lt;div class=\"main\"&gt;&lt;/div&gt;&lt;/body&gt; 效果如下： 根据规则可知，虽然存在浮动的元素 aslide，但 main 的左边依然会与包含块的左边相接触 BFC 不会与 float box 重叠，所以我们可以将 main 生成为 BFC 即可 123.main { overflow: hidden;} 当触发 main 生成 BFC 后，这个新的 BFC 不会与浮动的 aside 重叠，这样就可以生成一个简单的两列布局 效果如下： 高度坍塌这个也是一个比较常见的问题，即内部元素设置了浮动以后，外面包裹的容器，比如 div 的高度会发生坍塌，代码如下： 1234567891011121314151617181920&lt;style&gt;.par { border: 5px solid #fcc; width: 300px;}.child { border: 5px solid #f66; width:100px; height: 100px; float: left;}&lt;/style&gt;&lt;body&gt; &lt;div class=\"par\"&gt; &lt;div class=\"child\"&gt;&lt;/div&gt; &lt;div class=\"child\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 效果如下： 发生这种情况的原因是因为内部的 child 元素使用了 float，使其脱离了文档流，故父元素的高度自然就没有了 解决办法有很多，原理只需要将父元素触发为 BFC 即可 123.par { overflow: hidden;} 效果如下： margin 重叠代码如下： 123456789101112131415&lt;style&gt;p { color: #f55; background: #fcc; width: 200px; line-height: 100px; text-align:center; margin: 100px;}&lt;/style&gt;&lt;body&gt; &lt;p&gt;Haha&lt;/p&gt; &lt;p&gt;Hehe&lt;/p&gt;&lt;/body&gt; 效果如下： 在控制台中审查元素可知，两个 p 之间的距离为 100px，发生了 margin 重叠，根据规则可知，属于同一个 BFC 的两个相邻 box 的 margin 会发生重叠 解决办法也很简单，我们可以给其中任意一个元素包裹一层容器，并触发该容器生成 BFC，那么此时的两个子元素就不属于同一个 BFC，所以就不会发生 margin 重叠的现象了 123456789101112131415161718192021&lt;style&gt;.wrap { overflow: hidden;}p { color: #f55; background: #fcc; width: 200px; line-height: 100px; text-align:center; margin: 100px;}&lt;/style&gt;&lt;body&gt; &lt;p&gt;Haha&lt;/p&gt; &lt;div class=\"wrap\"&gt; &lt;p&gt;Hehe&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; 效果如下： 通过以上几个例子可以看出，同规则一样，BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素（反之也如此） 因为 BFC 内部的元素和外部的元素绝对不会互相影响，因此当 BFC 外部存在浮动时，它不应该影响 BFC 内部 box 的布局，BFC 会通过变窄，而不与浮动有重叠 同样的，当 BFC 内部有浮动时，为了不影响外部元素的布局，BFC 计算高度时会包括浮动的高度，同样，避免 margin 重叠也是这样的一个道理 参考： W3C CSS2.1 规范 什么是BFC BFC的理解 深入理解BFC","link":"/2018/12/03/CSS/06/"},{"title":"IFC","text":"IFC（Inline Formatting Context），直译为行内格式化上下文，与之相关的就是行盒模型 行盒模型是一个显示区域，根据块状容器内，每一行的多个内联元素（inline-level element）都会共同生成一个行盒模型 IFC 定义每个盒子都有一个 FC 特性，不同的 FC 值代表一组盒子不同的排列方式，有的 FC 值表示盒子从上到下垂直排列，有的 FC 值表示盒子从左到右水平排列等等 而 IFC 则是表示盒子从左到右的水平排列方式，仅此而已（注意：一个盒子仅且仅有一个 FC 值） 而 inline-level box 的 FC 特性值固定为 IFC 在 IFC 中，盒子水平放置，一个接着一个，从包含块的顶部开始，水平 margins，borders 和 padding 在这些盒子中被平分 这些盒子也许通过不同的方式进行对齐，他们的底部和顶部也许被对齐，或者通过文字的基线进行对齐，矩形区域包含着来自一行的盒子叫做 line box line box 的宽度由浮动情况和它的包含块决定，line box 的高度由 line-height 的计算结果决定 一个 line box 总是足够高对于包含在它内的所有盒子，它也许比包含在它内最高的盒子高（比如，盒子对齐导致基线提高了） 当盒子的高度比包含它的 line box 的高度低，在 line box 内的垂值对齐线通过 vertical align 属性决定 当几个行内级盒子在一个单独的 line box 内不能很好的水平放置，则他们被分配成了 2 个或者更多的垂直重叠的 line boxs 因此，一个段落是很多个 line boxs 的垂直叠加，line boxs 被叠加没有垂直方向上的分离（特殊情况除外），并且他们也不重叠 通常，line box 的左边缘挨着它的包含块的左边缘，右边缘挨着它的包含块的右边缘，然而浮动盒子也许会在包含块边缘和 line box 边缘之间 因此尽管 line boxs 在同样的行内格式上下文中通常都有相同的宽度（就是他的包含块的宽度），但是水平方向上的空间因为浮动被减少了，它的宽度也会变得复杂 line boxs 在同样的行内格式上下文中通常在高度上是多样的（比如，一行也许包含了一个最高的图片然后其他的也可以仅仅只包含文字） 注意事项注意以下几种情况： 当在一行中行内级盒子的总宽度比包含他们的 line box 的宽度小 他们的在 line box 中的水平放置位置由 text align 属性决定 如果属性是 justify，用户代理可能会拉伸空间和文字在 inline boxs 内 当一个行内盒子超过了 line box 的宽度 则它被分割成几个盒子并且这些盒子被分配成几个横穿过的 line boxs 如果一个行内盒子不能被分割，则行内盒子溢出 line box 当一个行内盒子被分割，分割发生则 margins，borders 和 padding 便没有了视觉效果 在同样的 line box 内的行内盒子也许会被分割成几个盒子因为 双向的文字 line boxs 在行内格式上下文中档需要包含行内级内容时被创造 line boxs 包含没有文字，没有空格，没有带着 margins，padding 和 borders 以及没有其他在流中的内容（比如图片，行内盒子和行内表格） 也不会以新起一行结尾，对于在他们内的任何盒子的位置都以他们决定并且必须将他们视作没有高度的 line boxs 影响效果影响 IFC 内布局的 CSS 主要有以下几个： font-size line-height height vertical-aligin font-size一般用于指定文本类型节点的大小，IFC 内的很多属性的值是基于这个的 line-height &amp;&amp; height在一个由多个内联元素组成的块状容器内，line-height 为内联元素的行盒模型指定了一个最低高度，这个最低高度是分别由基线上的最小高度和基线下的最小深度组成 从上到下四条线分别是顶线、中线、基线、底线，那么行高是指上下文本行的基线间的垂直距离，即如下图所示中的两条红线间垂直距离（实际在数值上，行高也等于其它相同颜色间的距离） vertical-align该属性影响由多个内联元素生成的盒模型组成的行内盒模型的垂直定位，vertical 有几个特定的值，或者指定一个值 12345678&lt;p class=\"a1\"&gt; &lt;span style=\"vertical-align:60px;\"&gt; English中文 &lt;/span&gt; &lt;span&gt; 中文English &lt;/span&gt;&lt;/p&gt; 显示如下： 其中，黄色线就是基线（baseline），绿线和黄线的间隔即为 60px，这里会发现，容器（蓝色）的高度被撑高了 需要注意的是：容器的高度 height = line-height + vertical-align 当然同理，如果容器的高度被指定了，那么高度则不变，而超出的部分则不影响布局，如果设置 overflow: hidden，则超过的部分则不可见 而 vertical-align 的其它特殊值，均可以看做一个根据容器高度而变化的相对值（比如可以设置百分比）","link":"/2018/12/05/CSS/07/"},{"title":"输入网址到页面显示经历的过程","text":"总的来说大概就三个流程 1）http 客户端发起请求，创建端口 2）http 服务器在端口监听客户端的请求 3）http 服务器向客户端返回状态和内容 我们下面就来看看，以 Chrome 浏览器搜索 baidu 为例，当在浏览器内输入一个 www.baidu.com 以后，到底发生了什么 第 1 步 搜索自身的 DNS 缓存浏览器会搜索自身的 DNS 缓存，看看自身的缓存中有没有 baidu.com 这个域名已经缓存的地址，这个缓存的时间大概只有一分钟，有没有失效可以通过 chrome://net-internals/#dns 来查看浏览过的网站的 DNS 缓存 第 2 步 搜索操作系统的 DNS 缓存如果浏览器没有找到缓存，或者说这个缓存已经失效，则会搜索操作系统自身的 DNS 缓存，如果找到，则它会停止搜索，然后解析也会到此结束 第 3 步 读取本地的 HOST 文件如果操作系统的 DNS 缓存也没有找到，那么就会去尝试读取本地的 host 文件 第 4 步 向主控 DNS 服务器发送请求如果在 host 文件内也没有找到对应的配置项，那么浏览器就会发起一个 DNS 的系统调用，就会想本地主控 DNS 服务器（一般来说是你的宽带运营商提供）发起的一个域名解析请求 第 4.1 步 主控 DNS 服务器查找自身缓存首先会查找自身的缓存，找到对应的条目，如果说也没用过期，那就解析成功了，那么如果没有找到这个条目 第 4.2 步 主控 DNS 服务器发起请求拿到 IP 地址那么运营商的 DNS 服务器就会代替我们的浏览器发起一个迭代的 DNS 服务请求 大体步骤如下： 根域（拿到 com 域） –&gt; com 域 DNS 服务器（拿到 baidu.com） –&gt; baidu.com 的 DNS 服务器（域名的注册商提供，万网，新网等） –&gt; 结果发送给运营商的 DNS 服务器（就拿到了 baidu.com 这个域名对应的 IP 地址） –&gt; 结果返回操作系统内核，同时缓存起来（当然，这个缓存可能会失效，有时间长短 ） –&gt; 内核从服务器上拿到这个 IP 地址，就把这个结果返回给浏览器 –&gt; 最终浏览器拿到了 www.baidu.com 对应的 IP 地址 第 5 步 TCP 三次握手建立连接域名解析完成以后，也就拿到了域名对应的 IP 地址，发起经典的 TCP 三次握手，浏览器就会以随机端口像服务器的外部程序发起一个 TCP 连接请求，这个连接请求通过层层路由设备，到达服务器端以后 进入到网卡，然后进入到内核的 TCP/IP 协议栈（还有可能经过防火墙的过滤），最终到了 web 服务端，然后就建立起了这个 TCP/IP 的连接 第 6 步 到这里就可以发送请求了（GET, POST 等）TCP/IP 连接建立起来以后，浏览器就可以向服务器发送 http 请求了，使用了比如说，用 http 的 GET 方法请求一个根域里的一个域名，协议可以采用 http 1.0 的一个协议 第 7 步 响应请求服务器端接受到了这个请求，根据路径参数，经过后端的一些处理之后，把处理后的一个结果的数据返回给浏览器，如果是百度的页面，就会把完整的 HTML 页面代码返回给浏览器 第 8 步 加载数据浏览器拿到了百度的完整的 HTML 页面代码，在解析和渲染这个页面的时候，里面的 JavaScript、CSS、图片等静态资源，他们同样也是一个个 http 请求都需要经过上面的主要的七个步骤 第9步 渲染页面浏览器根据拿到的资源对页面进行渲染，最终把一个完整的页面呈现给了用户","link":"/2017/11/07/HTTP/01/"},{"title":"IE 中的 haslayout","text":"特别注意：hasLayout 在 IE 8 及之后的 IE 版本中已经被抛弃，所以在实际开发中只需针对 IE 8 以下的浏览器为某些元素触发 hasLayout haslayout 定义Layout 是 IE 浏览器渲染引擎的一个内部组成部分，在 IE 浏览器中，一个元素要么自己对自身的内容进行组织和计算大小， 要么依赖于包含块来计算尺寸和组织内容 为了协调这两种方式的矛盾，渲染引擎采用了 hasLayout 属性，属性值可以为 true 或 false 当一个元素的 hasLayout 属性值为 true 时，我们说这个元素有一个布局（layout），或者说是拥有布局 可以通过 hasLayout 属性来判断一个元素是否拥有 layout，如 object.currentStyle.hasLayout hasLayout 与 BFC 有很多相似之处，但 hasLayout 的概念会更容易理解 在 Internet Explorer 中，元素使用布局概念来控制尺寸和定位，分为拥有布局和没有布局两种情况 拥有布局的元素由它控制本身及其子元素的尺寸和定位 而没有布局的元素则通过父元素（最近的拥有布局的祖先元素）来控制尺寸和定位 而一个元素是否拥有布局则由 hasLayout 属性告知浏览器，它是个布尔型变量，true 代表元素拥有布局，false 代表元素没有布局 简而言之，hasLayout 只是一个 IE 下专有的属性，hasLayout 为 true 的元素浏览器会赋予它一系列的效果 触发 layout一个元素触发 hasLayout 会影响一个元素的尺寸和定位，这样会消耗更多的系统资源 因此 IE 设计者默认只为一部分的元素触发 hasLayout （即默认有部分元素会触发 hasLayout，这与 BFC 基本完全由开发者通过特定 CSS 触发并不一样） 这部分元素如下： 1234567&lt;html&gt;, &lt;body&gt;&lt;table&gt;, &lt;tr&gt;, &lt;th&gt;, &lt;td&gt;&lt;img&gt;&lt;hr&gt;&lt;input&gt;, &lt;button&gt;, &lt;select&gt;, &lt;textarea&gt;, &lt;fieldset&gt;, &lt;legend&gt;&lt;iframe&gt;, &lt;embed&gt;, &lt;object&gt;, &lt;applet&gt;&lt;marquee&gt; 除了 IE 默认会触发 hasLayout 的元素外，Web 开发者还可以使用特定的 CSS 触发元素的 hasLayout 通过为元素设置以下任一 CSS ，可以触发 hasLayout （即把元素的 hasLayout 属性设置为 true） 属性名 取值 display inline-block height 除 auto 外任何值 width 除 auto 外任何值 float left 或 right position absolute writing-mode tb-rl zoom 除 normal 外任意值 min-height 任意值 min-width 任意值 max-height 除 none 外任意值 max-width 除 none 外任意值 overflow 除 visible 外任意值，仅用于块级元素 overflow-x 除 visible 外任意值，仅用于块级元素 overflow-y 除 visible 外任意值，仅用于块级元素 position fixed 对于内联元素（可以是默认被浏览器认为是内联元素的 span 元素，也可以是设置了 display: inline 的元素），width 和 height 只在 IE5.x 下和 IE6 或更新版本的 quirks 模式下能触发元素的 hasLayout 但是对于 IE6，如果浏览器运行于标准兼容模式下，内联元素会忽略 width 或 height 属性，所以设置 width 或 height 不能在此种情况下令该元素触发 hasLayout 但 zoom 除了在 IE 5.0 中外，总是能触发 hasLayout zoom 用于设置或检索元素的缩放比例，为元素设置 zoom: 1 既可以触发元素的 hasLayout，同时不会对元素造成多余的影响 因此综合考虑浏览器之间的兼容和对元素的影响， 建议使用 zoom: 1 来触发元素的 hasLayout 解决的问题hasLayout 表现出来的特性跟 BFC 很相似，所以可以认为是 IE 中的 BFC，规则几乎都遵循，所以在之前 BFC 当作遇到的问题在 IE 里都可以通过触发 hasLayout 来解决 虽然 hasLayout 也会像 BFC 那样影响着元素的尺寸和定位，但它却又不是一套完整的标准，并且由于它默认只为某些元素触发，这导致了 IE 下很多前端开发的 bugs 触发 hasLayout 更大的意义在于解决一些 IE 下的 bugs，而不是利用它的一些副作用来达到某些效果 另外由于触发 hasLayout 的元素会出现一些跟触发 BFC 的元素相似的效果，因此为了统一元素在 IE 与支持 BFC 的浏览器下的表现，建议为触发了 BFC 的元素同时触发 hasLayout 当然还需要考虑实际的情况，也有可能只需触发其中一个就可以达到表现统一","link":"/2018/12/12/CSS/08/"},{"title":"http 2.0","text":"先回顾一下 http 相关知识 http 协议的特点 支持客户和服务器模式 简单快速：客户向服务器请求服务时，只需要传送请求方法和路径，请求方法常用的有 GET，POST，HEAD 等，每种方法规定了客户与服务器联系的类型不同，由于 http 协议简单，使得 http 服务器的程序规模小，因而通讯速度很快 灵活：http 允许传输任意类型的数据对象，正在传输的类型由 Content-Type 加以标记 无连接：无连接的含义是限制每次连接只处理一个请求，服务器处理完客户的请求并收到客户的应答后，即断开连接，采用这种方式可以节省传输时间 无状态：http 协议是无状态协议，无状态是指协议对于事物处理没有记忆能力，缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大，另一方面，在服务器不需要先前信息的时候它的应答就较快 http/1.0 的缺点http/1.0 版本主要的缺点是，每个 tcp 连接只能发送一个请求，发送数据完毕，连接就关闭，如果还需要请求其他资源，就必须再新建一个连接 为了解决这个问题，有些浏览器在请求的时候，使用了一个非标准的 Connection 字段 1Connection: keep-alive 这个字段要求服务器不关闭 tcp 连接，以便其他请求复用，服务器同样回应这个字段 1Connection: keep-alive http/1.11.1 版本的最大的变化，就是引入了持久连接（persistent connection），即 tcp 连接默认不关闭，可以被多个请求复用，不用声明 Connection: keep-alive 客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接，不过，规范的做法是，客户端在最后一个请求的时候，发送 Connention: close，明确要求服务器关闭 tcp 连接 管道机制1.1 版本还引入了管道机制（pipelining），即在同一个 tcp 连接里面，客户端可以同时发送多个请求 例如客户端需要请求两个资源，以前的做法是，在同一个 tcp 连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求 管道机制则是允许浏览器同时发出 A 请求和 B 请求，但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求 http/1.1 缺点虽然 1.1 版允许复用 tcp 连接，但是同一个 tcp 连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个回应，才会进行下一个回应 要是前面的回应特别慢，后面就会有许多请求排队等着，这称为队头堵塞（Head-of-line blocking） 为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接 http/2主要涉及二进制帧，多路复用，请求优先级，流量控制，服务器端推送以及首部压缩等新改进 二进制协议http/1.1 版本的头信息肯定是文本（ASCII 编码），数据体可以是文本，也可以是二进制 http/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为帧（frame，头信息帧和数据帧） 在二进制分帧层中，http/2 会将所有传输的信息分割为更小的消息和帧（frame），并对它们采用二进制格式的编码 其中 http1.x 的首部信息会被封装到 HEADER frame，而相应的 Request Body 则封装到 DATA frame 里面 http/2 通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流 所以简单来说就是 单连接多资源的方式，减少服务端的链接压力，内存占用更少，连接吞吐量更大 由于 tcp 连接的减少而使网络拥塞状况得以改善，同时慢启动时间的减少，使拥塞和丢包恢复速度更快 多工http/2 复用 tcp 连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了队头堵塞 例如在一个 tcp 连接里面，服务器同时收到了 A 请求和 B 请求，于是先回应 A 请求，结果发现处理过程非常耗时 于是就发送 A 请求已经处理好的部分， 接着回应 B 请求，完成后，再发送 A 请求剩下的部分 这样双向的、实时的通信，就叫做多工（Multiplexing） 数据流（连接共享）因为 http/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应，因此必须要对数据包做标记，指出它属于哪个回应 http/2 将每个请求或回应的所有数据包，称为一个数据流（stream），每个数据流都有一个独一无二的编号，数据包发送的时候，都必须标记数据流 id，用来区分它属于哪个数据流 另外还规定，客户端发出的数据流，id 一律为奇数，服务器发出的，id 为偶数 数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM 帧），取消这个数据流 1.1 版取消数据流的唯一方法，就是关闭 tcp 连接 http/2 可以取消某一次请求，同时保证 tcp 连接还打开着，可以被其他请求使用 http/2 里的每个 stream 都可以设置又优先级（Priority）和依赖（Dependency） 优先级高的 stream 会被 server 优先处理和返回给客户端 stream 还可以依赖其它的 sub streams（优先级和依赖都是可以动态调整的） 客户端还可以指定数据流的优先级，优先级越高，服务器就会越早回应 头信息压缩http 协议不带有状态，每次请求都必须附上所有信息，所以请求的很多字段都是重复的 比如 Cookie 和 User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度 http/2 对这一点做了优化，使用了专门为首部压缩而设计的 HPACK 算法，引入了头信息压缩机制（header compression） 一方面，头信息使用 gzip 或 compress 压缩后再发送 另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了 服务器推送http/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push） 常见场景是客户端请求一个网页，这个网页里面包含很多静态资源，正常情况下客户端必须收到网页后，解析 html 源码，发现有静态资源，再发出静态资源请求 其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了 参考： http2 讲解 http/2 资料汇总 http2 explained Hypertext Transfer Protocol Version 2 (http/2) http/2.0 相比 1.0 有哪些重大改进？","link":"/2018/05/09/HTTP/06/"},{"title":"CommonJS、AMD 和 CMD","text":"CommonJs 是服务器端模块的规范，Node.js 采用了这个规范，根据 CommonJS 规范，一个单独的文件就是一个模块 加载模块使用 require 方法，该方法读取一个文件并执行，最后返回文件内部的 exports 对象 比如 123456789101112131415161718// foobar.js// 私有变量var test = 123;// 公有方法function foobar () { this.foo = function () { // do someing ... } this.bar = function () { //do someing ... }}// exports 对象上的方法和变量是公有的var foobar = new foobar();exports.foobar = foobar; 1234// require 方法默认读取 javaScript 文件，所以可以省略 javaScript 后缀var test = require('./foobar').foobar;test.bar(); CommonJS 加载模块是同步的，所以只有加载完成才能执行后面的操作，像 Node.js 主要用于服务器的编程，加载的模块文件一般都已经存在本地硬盘，所以加载起来比较快，不用考虑异步加载的方式 所以 CommonJS 规范比较适用，但如果是浏览器环境，要从服务器加载模块，这是就必须采用异步模式，所以就有了 AMD 和 CMD 解决方案 AMDAMD 用白话文讲就是 异步模块定义，所有的模块将被异步加载，模块加载不影响后面语句运行，所有依赖某些模块的语句均放置在回调函数中 适用 AMD 规范适用 define 方法定义模块 12345678// 通过数组引入依赖 ，回调函数通过形参传入依赖define(['someModule1', 'someModule2'], function (someModule1, someModule2) { function foo() { // someing someModule1.test(); } return { foo: foo }}); AMD 规范允许输出模块兼容 CommonJS 规范，这时 define 方法如下 1234567define(function (require, exports, module) { var reqModule = require(\"./someModule\"); requModule.test(); exports.asplode = function () { //someing }}); CMD123456789101112131415161718192021// AMDdefine(['./a', './b'], function (a, b) { // 依赖一开始就写好 a.test(); b.test();});// CMDdefine(function (requie, exports, module) { // 依赖可以就近书写 var a = require('./a'); a.test(); // ... // 软依赖 if (status) { var b = requie('./b'); b.test(); }}); 虽然 AMD 也支持 CMD 写法，但依赖前置是官方文档的默认模块定义写法 AMD 与 CMD 区别具体的区别可以参考两者的规范，这里只是简单的介绍 AMD规范 CMD规范 总的来说，区别有两点 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行，不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同） CMD 推崇依赖就近（as lazy as possible），AMD 推崇依赖前置 CMD 推崇依赖就近，可以把依赖写进你的代码中的任意一行，例 1234567define(function (require, exports, module) { var a = require('./a') a.doSomething() var b = require('./b') b.doSomething()}) 代码在运行时，首先是不知道依赖的，需要遍历所有的 require 关键字，找出后面的依赖，具体做法是将 function toString 后，用正则匹配出 require 关键字后面的依赖，显然，这是一种牺牲性能来换取更多开发便利的方法 而 AMD 是依赖前置的，换句话说，在解析和执行当前模块之前，模块作者必须指明当前模块所依赖的模块，表现在 require 函数的调用结构上为 1234define(['./a', './b'], function (a, b) { a.doSomething() b.doSomething()}) 代码在一旦运行到此处，能立即知晓依赖，而无需遍历整个函数体找到它的依赖，因此性能有所提升，缺点就是开发者必须显式得指明依赖——这会使得开发工作量变大 比如当你写到函数体内部几百上千行的时候，忽然发现需要增加一个依赖，你不得不回到函数顶端来将这个依赖添加进数组 但是这不是全部的情况，有的时候情况是这样的 1234// 函数体内：if (status) { a.doSomething()} 在这个函数体内，可能依赖 a，也可能不依赖 a，这种可能的依赖成为”软依赖”，对于软依赖当然可以直接当硬依赖处理，但是这样不经济，因为依赖是不一定的，有可能加载了此处的依赖而实际上没有用上 对于软依赖的处理，推荐 依赖前置 + 回调函数 的实现形式，上面的例子简单表述如下 123456// 函数体内：if (status) { async(['a'], function (a) { a.doSomething() })} 我们先把依赖分为两种，”强依赖” —— 肯定需要 和 “弱依赖” —— 可能需要 对于强依赖，如果要性能优先，则考虑参照依赖前置的思想设计你的模块加载器，也更推崇这个方案一些 如果考虑开发成本优先，则考虑按照依赖就近的思想设计你的模块加载器，对于弱依赖，只需要将弱依赖的部分改写到回调函数内即可 参考资料 CommonJS 到 Sea.js 以代码爱好者角度来看 AMD 与 CMD AMD 和 CMD 的区别有哪些？ JavaSript模块规范 - AMD规范与CMD规范介绍","link":"/2017/02/03/JavaScript/05/"},{"title":"JavaScript 中的单例模式","text":"所谓单例：就是 保证一个类仅有一个实例，并提供一个访问它的全局访问点 单例模式是一种常用的模式，有一些对象我们往往只需要一个，比如线程池、全局缓存、浏览器的 window 对象 单例模式的核心是 确保只有一个实例，并提供全局访问 全局变量不是单例，但在 JavaScript 中，我们经常会把全局变量当成单例来使用如 1var a = {}; 但是全局变量存在着许多问题，容易造成命名空间污染，做为普通开发者，有必要减少全局变量的使用，常见解决方法有如下两种 使用命名空间适当地使用命名空间，并不会杜绝全局变量，但可以减少全局变量的数量，最简单的方式依然是用对象字面量的方式 12345678namespace1 = { a: function () { alert(1); }, b: function () { alert(2); }} 把 a 和 b 都定义为 namespace1 的属性，这样可以减少变量和全局作用域打交道的机会，另外我们还可以动态地创建 命名空间（Object-Oriented javascript） 1234567891011121314151617var MyApp = {};MyApp.namespace = function (name) { var parts = name.split('.'); var current = MyApp; for (var i in parts) { if (!current[parts[i]]) { current[parts[i]] = {}; } current = current[parts[i]]; }}MyApp.namespace('event');MyApp.namespace('dom.style');console.dir(MyApp); 上述代码等价于 123456var MyApp = { event: {}, dom: { style: {} }}; 全用闭包封装私有变量这种方法把一些变量封装在闭包的内部，只暴露一些接口跟外界通信 12345678var user = (function () { var _name = 'zhangsan', _age = 18; return { getUserInfo: function () { return _name + '-' + _age; } }})(); 我们用下划线来约定私有变量 _name 和 _age，它们被封装在闭包产生的作用域中，外部是访问不到这两个变量的，这就避免了对全局的命令污染 单例模式的重点是惰性单例，所谓惰性单例指的是 在需要的时候才创建对象实例 逻辑始终是一样的：用一个变量来标志是否创建过对象，如果是，则在下次直接返回这个已经创建好的对象 1234var obj;if (!obj) { obj = xx;} 一个通用的惰性单例 123456var getSingle = function (fn) { var result; return function(){ return result || (result = fn.apply(this, arguments)) }} 两个示例创建唯一一个登录框12345678910111213var createLoginLayer = function () { var div = document.createElement('div'); div.innerHTML = '我是登录窗口'; div.style.display = 'none'; return div;}var createSingleLoginLayer = getSingle(createLoginLayer);document.getElementById('loginBtn').onclick = function () { var loginLayer = createSingleLoginLayer(); loginLayer.style.display = 'block';} 创建唯一一个 iframe 用于动态加载第三方页面12345678910var createSingleIframe = getSingle(function () { var iframe = document.createElement('iframe'); document.body.appendChild(iframe); return iframe;});document.getElementById('loginBtn').onclick = function () { var loginLayer = createSingleIframe(); loginLayer.src = 'xxxxx.com';} 单例模式的用途不止用于创建对象，比如我们通常渲染完页面中一个列表之后，接下来要给列表绑定 click 事件，如果是通过 Ajax 动态往列表里追回数据，在使用事件代理的前提下，click 事件实际上只需要在第一次渲染列表的时候被绑定一次 但是我们不想去判断当前是否是第一次渲染列表，如果我们是借助于 jQuery，我们通常选择给节点绑定 one 事件 1234567891011121314var bindEvent = function () { $('div').one('click', function () { alert('click'); });};var render = function () { console.log('开始渲染列表'); bindEvent();}render();render();render(); 如果利用 getSingle 函数，也能达到一样的效果： 123456789101112131415var bindEvent = getSingle(function () { document.getElementById('div1').onclick = function () { alert('click'); } return true;});var render = function () { console.log('开始渲染列表'); bindEvent();}render();render();render(); 可以看到，render 函数和 bindEvent 函数都分别执行了 3 次，但 div 实际上只被绑定了一个事件","link":"/2017/01/25/JavaScript/04/"},{"title":"JavaScript 中的值和引用","text":"ECMAScirpt 变量有两种不同的数据类型：基本类型，引用类型 引用就像一种特殊的指针，是来指向变量的指针（别名），如果参数不声明为引用的话，参数值总是通过值复制的方式传递，即便对复杂的对象值也是如此 JavaScript 中没有指针，引用的工作机制也不尽相同，在 JavaScript 中变量不可能成为指向另一个变量的引用 JavaScript 引用指向的是值，如果一个值有多个引用，这些引用指向的都是同一个值，它们是没有引用关系 JavaScript 对值和引用的 赋值/传递 在语法上没有区别，完全根据值的类型来决定 先来看一个例子 1234567891011121314151617var a = 2;var b = a; // b 是 a 的值的一个副本b++;a; // 2b; // 3// ===&gt;var c = [1, 2, 3];var d = c;d.push(4);c; // [1, 2, 3, 4]d; // [1, 2, 3, 4] 上例中的 2 是一个标量基本类型值，所以变量 a 持有该值的一个副本，b 持有它的另一个复本，所以，b 更改时，a 的值保持不变 而 c 和 d 则分别指向同一个复合值 [1, 2, 3] 的两个不同引用，请注意，c 和 d 仅仅是指向值 [1, 2, 3]，并非持有 所以它们更改的是同一个值（比如调用 push() 方法），随后它们都指向了更改后的新值 [1, 2, 3, 4] 简单值（即标量基本类型值，scalar primitive）总是通过值复制的方式来赋值（传递），包括 undefined，boolean，number，string，null 和 ES6 中的 Symbol 复合值（compound value）– 对象（包括数组和封装对象）和函数，则总是通过引用复制的方式来赋值（传递） 由上可知，由于引用指向的是值本身而非变量，所以一个引用无法更改另外一个引用的指向 1234567891011var a = [1, 2, 3];var b = a;a; // [1, 2, 3]b; // [1, 2, 3]// ===&gt;b = [4, 5, 6];a; // [1, 2, 3]b; // [4, 5, 6] 从上面例子可以看出 b = [4, 5, 6] 并不影响 a 指向 [1, 2, 3] 引用类型值的传递首先需要明确一点 在 Javascript 中没有引用传递，如果传递的参数是一个值，是按值传递，如果传递的是一个对象，则传递的是一个对象的引用 Javascript 不允许直接访问内存中的位置，不能直接操作对象的内存空间，实际上操作的是对象的引用，所以引用类型的值是按引用访问的 准确地说，引用类型的存储需要内存的栈区和堆区（堆区是指内存里的堆内存）共同完成，栈区内存保存变量标识符和指向堆内存中该对象的指针，也可以说是该对象在堆内存的地址 但是函数的参数就经常让人产生这样的疑惑 123456789101112131415function foo (x) { x.push(4); x; // [1, 2, 3, 4] // ===&gt; x = [4, 5, 6]; x.push(7); x; // [4, 5, 6, 7]}var a = [1, 2, 3];foo(a);a; // [1, 2, 3, 4] 我们向函数传递 a 的时候，实际是将引用 a 的一个复本赋值给 x，而 a 仍然指向 [1, 2, 3] 在函数中我们可以通过引用 x 来更改数组的值（如上，数组在 push(4) 后变为了 [1, 2, 3, 4]） 但 x = [4, 5, 6] 并不影响 a 的指向，所以 a 仍然指向 [1, 2, 3, 4] 我们不能通过引用 x 来更改引用 a 的指向，只能更改 a 和 x 共同指向的值 如果要将 a 的值变为 [4, 5, 6, 7]，那么就必须更改 x 指向的数组，而不是为 x 赋值一个新的数组 123456789101112131415function foo (x) { x.push(4); x; // [1, 2, 3, 4] // ===&gt; x.length = 0; x.push(4, 5, 6, 7); x; // [4, 5, 6, 7]}var a = [1, 2, 3];foo(a);a; // [4, 5, 6, 7] 这样一来，在不创建新数组，而只是更改了当前的数组的情况下，a 的指向就变成了 [4, 5, 6, 7] 我们无法自行决定使用值复制还是引用复制，一切由值的类型来决定 如果通过值复制的方式来传递复合值（数组），那么就需要为其创建一个复本，这样传递的就不再是原始值，比如 12// slice() 方法不传参数的情况会返回当前数组的一个浅副本（shallow copy）foo(a.slice()) 这样一来，由于传递给函数的是指向该副本的引用，所以 foo() 中的操作不会再影响 a 指向的数组 基本类型值的传递相反，如果要将标量基本类型值传递到函数内并进行更改，这时候就需要将该值封装到一个复合值（对象，数组等）中，然后通过引用复制的方式传递 1234567891011function foo (wrap) { wrap.a = 22;}var obj = { a: 2}foo(obj); obj.a; // 22 这里的 obj 是一个封装了标量基本类型值 a 的封装对象，obj 引用的一个复本作为参数 wrap 被传递到 foo() 中 这样我们就可以通过 wrap 来访问该对象并更改它的属性，函数执行结束后 obj.a 的值就变为了 22 与预期不同的是，虽然传递的是指向数字对象的引用复本，但我们并不能通过它来更改其中的基本类型值： 12345678910function foo (x) { x = x + 1; x; // 3}var a = 2;var b = new Number(a); // Objeact(a) 也是一样foo(b);b; // 2，而不是 3 这是因为标量基本类型的值是不可更改的（字符串和布尔也是如此），如果一个数字对象的标量基本类型值是 2，那么该值就不能更改，除非创建一个包含新值的数字对象 x = x + 1 中，x 中的标量基本类型值 2 从数字对象中拆封（提取）出来以后，x 就从引用变成了数字对象 它的值为 2 + 1 等于 3，然而函数外的 b 仍然指向原来那个值为 2 的数字对象 最后再来看两个小小的案例 12345678910111213141516171819// 第一个var o1 = new Object();var o2 = o1;o2.name = 'a';console.log(o1.name); // a// 第二个function changeObjectProperty (o) { o.name = 'a'; o = new Object(); o.name = 'b'; console.log(o.name);}var o = new Object();changeObjectProperty(o);console.log(o.name); 第一个就不用多说了，看了上面的内容以后应该会很清晰的得出 o1.name 也是为 a 的（引用的同一个地址） 至于第二个，如果传递的是 o 的引用，那么结果应该是 'b'，但实际结果却仍是 'a' 在函数内部修改了引用类型值的参数，该参数值的原始引用保持不变，我们可以把参数想象成局部变量 当参数被重写时，这个变量引用的就是一个局部变量，局部变量的生存期仅限于函数执行的过程中，函数执行完毕，局部变量即被销毁以释放内存 内部环境可以通过作用域链访问所有的外部环境中的变量对象，但外部环境无法访问内部环境 每个环境都可以向上搜索作用域链，以查询变量和函数名，反之向下则不能 如何引用一个对象，但是不改变原有对象的值（解决方法就是在一个函数中去引用），所以 对于保存基本类型值的变量，变量是按值访问的，因为我们操作的是变量实际保存的值 对于保存引用类型值的变量，变量是按引用访问的，我们操作的是变量值所引用（指向）的对象","link":"/2017/02/22/JavaScript/06/"},{"title":"Object.create( ... )","text":"Object.create() 是 E5 的一个新特性，其实可以理解为继承一个对象 官方的定义为 Object.create() 方法创建一个拥有指定原型和若干个指定属性的对象 基本语法为 1Object.create(proto, [ propertiesObject ]) 参数 proto 一个对象，作为新创建对象的原型 propertiesObject 可选，该参数对象是一组属性与值，该对象的属性名称将是新创建的对象的属性名称，值是属性描述符 需要注意的是，该参数对象不能是 undefined，另外只有该对象中自身拥有的可枚举的属性才有效，也就是说该对象的原型链上属性是无效的 使用 Object.create 的 propertyObject 参数 参数1234567891011121314151617181920212223var o;// 创建一个原型为 null 的空对象o = Object.create(null);o = {};// 以字面量方式创建的空对象就相当于o = Object.create(Object.prototype);o = Object.create(Object.prototype, { // foo 会成为所创建对象的数据属性 foo: { writable: true, configurable: true, value: 'hello' }, // bar 会成为所创建对象的访问器属性 bar: { configurable: false, get: function () { return 10 }, set: function (value) { console.log('Setting `o.bar` to', value) } }}) 另外一个示例 12345678910111213141516171819202122232425262728function Constructor() { }o = new Constructor();// 上面的一句就相当于:o = Object.create(Constructor.prototype);// 当然，如果在 Constructor 函数中有一些初始化代码，Object.create 不能执行那些代码// 创建一个以另一个空对象为原型，且拥有一个属性 p 的对象o = Object.create({}, { p: { value: 42 } })// 省略了的属性特性默认为 false，所以属性 p 是不可写，不可枚举，不可配置的o.p = 24o.p// 42o.q = 12for (var prop in o) { console.log(prop)}// 'q'delete o.p// false// 创建一个可写的，可枚举的，可配置的属性 po2 = Object.create({}, { p: { value: 42, writable: true, enumerable: true, configurable: true } }); 使用 Object.create 实现类式继承（单继承） 123456789101112131415161718192021222324252627// Shape - superclassfunction Shape() { this.x = 0; this.y = 0;}Shape.prototype.move = function (x, y) { this.x += x; this.y += y; console.info('Shape moved.');};// Rectangle - subclassfunction Rectangle() { Shape.call(this); // call super constructor.}Rectangle.prototype = Object.create(Shape.prototype);// 可以把 constructor 指回去Rectangle.prototype.constructor = Rectangle;var rect = new Rectangle();rect instanceof Rectangle // true.rect instanceof Shape // true.rect.move(1, 1); // Outputs, 'Shape moved.' 不过有几个需要注意的地方，第一种情况 12345var a = { x: 1 };var b = Object.create(a);console.log(b); // 输出 {}console.log(b.__proto__); // 输出 {x: 1} 第二种情况 1234567// 如果用的是 b = new object(a)connsole.log(b); // 输出 {x: 1}congsole.log(b.__proto__); // 输出 {}// 注意区分 __proto__ 和 prototype 实例下面这个实例跟上面那个类似，只是加深一下印象 12345678910111213141516171819202122232425262728function Foo(name) { this.name = name;}Foo.prototype.myName = function () { return this.name;};function Bar(name, label) { Foo.call(this, name); this.label = label;}// 我们创建了一个新的 Bar.prototype 对象并关联到 Foo.prototypeBar.prototype = Object.create(Foo.prototype);// 注意！现在没有 Bar.prototype.constructor 了// 如果你需要这个属性的话可能需要手动修复一下它// Bar.prototype.constructor = Bar;Bar.prototype.myLabel = function () { return this.label;};var a = new Bar('a', 'obj a');a.myName(); // 'a' a.myLabel(); // 'obj a' 这段代码的核心部分就是语句 Bar.prototype = Object.create( Foo.prototype ) 调用 Object.create() 会凭空创建一个新对象并把新对象内部的 [[Prototype]] 关联到你指定的对象（本例中是 Foo.prototype） 换句话说，这条语句的意思是，创建一个新的 Bar.prototype 对象并把它关联到 Foo.prototype 声明函数 Bar() 的时候，和其他函数一样，Bar 会有一个 .prototype 关联到默认的对象，但是这个对象并不是我们想要的 Foo.prototype 因此我们创建了一个新对象并把它关联到我们希望的对象上，直接把原始的关联对象抛弃掉 注意，下面这两种方式是常见的错误做法，实际上它们都存在一些问题 12345// 和你想要的机制不一样Bar.prototype = Foo.prototype;// 基本上满足你的需求，但是可能会产生一些副作用Bar.prototype = new Foo(); Bar.prototype = Foo.prototype 并不会创建一个关联到 Bar.prototype 的新对象，它只是让 Bar.prototype 直接引用 Foo.prototype 对象 因此当你执行类似 Bar.prototype.myLabel = ... 的赋值语句时会直接修改 Foo.prototype 对象本身 Bar.prototype = new Foo() 的确会创建一个关联到 Bar.prototype 的新对象，但是它使用了 new 操作符来进行调用 如果函数 Foo 有一些副作用（比如写日志、修改状态、注册到其他对象、给 this 添加数据属性，等等）的话，就会影响到 Bar() 的后代 因此，要创建一个合适的关联对象，我们必须使用 Object.create() 而不是使用具有副作用的 Foo() 这样做唯一的缺点就是需要创建一个新对象然后把旧对象抛弃掉，不能直接修改已有的默认对象 ES6 中的 Object.setPrototypeOf()如果能有一个标准并且可靠的方法来修改对象的 [[Prototype]] 关联就好了，在 ES6 之前，我们只能通过设置 .__proto__ 属性来实现 但是这个方法并不是标准并且无法兼容所有浏览器，ES6 添加了辅助函数 Object.setPrototypeOf()，可以用标准并且可靠的方法来修改关联 我们来对比一下两种把 Bar.prototype 关联到 Foo.prototype 的方法 12345// ES6 之前需要抛弃默认的 Bar.prototypeBar.ptototype = Object.create(Foo.prototype);// ES6 开始可以直接修改现有的 Bar.prototypeObject.setPrototypeOf(Bar.prototype, Foo.prototype); 如果忽略掉 Object.create() 方法带来的轻微性能损失（抛弃的对象需要进行垃圾回收），它实际上比 ES6 及其之后的方法更短而且可读性更高，不过无论如何，这是两种完全不同的语法 Object.create(null)通过 Object.create(null) 创建出来的对象，就没有 Object.prototype 上的一些方法，所以并不是所有的对象都继承有 Object.prototype 上的一些方法 看下面代码 12345var obj = Object.create(null);obj.__proto__; // undefinedobj.toString(); // obj.toString is not a function Object.create(null) 会创建一个拥有空（或者说 null）[[Prototype]] 链接的对象，这个对象无法进行委托 由于这个对象没有原型链，所以 instanceof 操作符无法进行判断，因此总是会返回 false 这些特殊的空 [[Prototype]] 对象通常被称作字典，它们完全不会受到原型链的干扰，因此非常适合用来存储数据 另外一个需要注意的地方，那就是并不是所有的函数对象都会有 prototype 属性，代码如下 12345678910function abc() {}abc.prototype // abc{}var binded = abc.bind(null);typeof binded // 'function'// 但是需要注意，binded 没有 prototype 属性binded.prototype // undefined","link":"/2017/03/03/JavaScript/07/"},{"title":"JavaScript 中的 == 和 ===","text":"两者的区别在于：== 允许在相等比较中进行强制类型转换，而 === 则不允许 JavaScript 拥有两套等性运算符： '===' 和 '!==' 以及 '==' 和 '!=' 类型转换如果两个操作数是相同的类型，具有相同的值，那么 '===' 将会产生 'true'，而 '!==' 则会产生 'false' == 操作符在做任意按需类型转换后将比较相等性，而 === 操作符并不会， === 运算符将不做转换，所以如果两值不一样类型 === 将返回 false 这种情况下，=== 将更快，并可能比 == 返回不同的结果，在所有其他情况下的性能都是一样的，这里有一些有趣的例子： 1234567891011121314151617181920212223242526272829303132[] == ![] // true'' == '0' // false2 == [2] // true'' == [null] // true0 == '\\n' // true0 == '' // true0 == '0' // true'0' == false // truefasle == 'false' // false'true' == true // false42 == '42' // true'foo' == ['foo'] // true// 七种比较少见的情况'0' == false; // truefalse == 0 // truefalse == '' // truefalse == [] // true'' == 0 // true'' == [] // true0 == [] // true 总之，始终建议使用 === 和 !== 1234567891011121314151617var a = [1, 2, 3];var b = [1, 2, 3];var c = { x: 1, y: 2 };var d = { x: 1, y: 2 };var e = 'text';var f = 'te' + 'xt';a == b // falsea === b // falsec == d // falsec === d // falsee == f // truee === f // true 特殊情况下，当你比较字面量和对象的时候，考虑到它的 toString 或者 valueOf 方法，例如，考虑比较由字符串构造函数创建的字符串对象和字符串字面量 12'abc' == new String('abc') // true'abc' === new String('abc') // false 这里的 == 操作符正在检查这两个对象的值并返回 true，但是鉴于它们不是相同类型并且 === 返回 false 再看一个综合的实例 [] == ![] 为什么是 true首先我们需要明确一下：相等运算符 '==' 的规则，有 boolean 的转为数字，有 Object 的转为原始值（类型转换与测试） 有了这个观点我们可以先看几个比较直白点的比较 [] == []当两个值都是对象 (引用值) 时, 比较的是两个引用值在内存中是否是同一个对象. 因为此 [] 非彼 [], 虽然同为空数组, 确是两个互不相关的空数组, 自然 == 为 false [] == false当 '==' 号两边其中一个是布尔值的话，先把它转换为数字（见规范），于是就变成了求 [] == 0 [] == 0当 '==' 的一边是字符串或数字，另一边是对象的时候（数组也是对象），先把对象值转换为原始值再判断相等，对象值到原始值是怎么转换的呢？对于所有非日期类对象来说，对象到原始值的转换基本上就是对象到数字的转换，也就是所谓的抽象操作 ToPrimitive 大致有以下 3 个步骤： 首先检查该值是否有 valueOf() 的方法，如果有并且返回基本类型值，就使用该值进行强制类型转换为这个原始值 如果没有，则调用 toString 方法，如果 toString 方法返回的是原始值（如果存在），则对象转换为这个原始值 如果 valueOf 和 toString 方法均没有返回原始值，则抛出 TypeError 异常 根据以上可以得知，首先调用 [].valueOf() 方法，返回值是对象自身，即 []，这不是一个原始值，所以继续调用 [].toString() 方法，返回的是空字符串 ''，这是一个原始值，所以此值就作为对象转换为原始值的输出，于是问题就变成了求 '' == 0 然后根据之前所知，会将 '' 转成数字为 0，所以最后的结果为 true [] == ![]那么现在在回到主题 [] == ![] 因为 ! 的优先级比 == 要高，所以会先执行 ![]，也就是先把 [] 转为布尔类型再取反，[] 转布尔值是 true 因为在 JavaScript 里除了 false 自身以外只有 5 个假值 分别是 ''，undefined，null，+0，-0，NaN，除了这 5 个假值以外，其他所有值转布尔类型都是 true 一切对象都是真值，包括 new Boolean(false)，于是问题就成了刚才我们讨论的 [] == false 了 参照标准, 该比较变成了 [] == ToNumber(false)（ToNumber(false)），即 [] == 0，这个时候又变成了 ToPrimitive([]) == 0（ToPrimitive([])），即 '' == 0 接下来就是比较 ToNumber('') == 0, 也就是 0 == 0, 最终结果为 true 直白点来说就是： 12345678910111213141516171819202122232425[] == ![] ===&gt; [] == false ([] 转布尔值是 true) ===&gt; [] == 0 (当 '==' 号两边其中一个是布尔值的话，先把它转换为数字)===&gt; [] == 0 ([].valueOf() 返回还是 对象自身)===&gt; [] == 0 ([].toString() 返回 '') ===&gt; '' == 0 ('' 会转成数字为 0) ===&gt; 0 == 0 查询规范后的总结字符串 和 数字 之间的比较（字符串 ==&gt; 数字） 如果 type(x) 是数字，type(y) 是字符串，则返回 x == ToNumber(y) 的结果 如果 type(x) 是字符串，type(y) 是数字，则返回 ToNumber(x) == y 的结果 其他类型 和 布尔类型 之间的比较（布尔 ==&gt; 数字） 如果 type(x) 是布尔类型，则返回 ToNumber(x) == y 的结果 如果 type(y) 是布尔类型，则返回 x == ToNumber(y) 的结果 null 和 undefined 之间的比较 如果 x 是 null，y 是 undefined，则结果为 true 如果 x 是 undefined，y 是 null，则结果为 true 对象 和 非对象 之间的比较（对象 ==&gt; ToPrimitive(对象)） 如果 type(x) 是字符串或数字，type(y) 是对象，则返回 x == ToPrimitive(y) 的结果 如果 type(x) 是对象，type(y) 是字符串或数字，则返回 ToPrimitive(x) == y 的结果","link":"/2017/03/17/JavaScript/09/"},{"title":"原型和原型对象","text":"所谓 JavaScript 中的原型，则大都是 prototype、__proto__ 和 constructor 的三者之间的关系，如下图所示 乍看上去感觉很复杂，其实说的就是两句代码之间的关系 12function Foo() { };var f1 = new Foo; 下面来分类介绍 构造函数用来初始化新创建的对象的函数是构造函数，在例子中，Foo() 函数是构造函数 实例对象通过构造函数的 new 操作创建的对象是实例对象，可以用一个构造函数，构造多个实例对象 123456function Foo() { };var f1 = new Foo;var f2 = new Foo;console.log(f1 === f2); // false 原型对象及 prototype构造函数有一个 prototype 属性，指向实例对象的原型对象，通过同一个构造函数实例化的多个对象具有相同的原型对象，经常使用原型对象来实现继承 1234567891011function Foo() { };Foo.prototype.a = 1;var f1 = new Foo;var f2 = new Foo;console.log(Foo.prototype.a); // 1console.log(f1.a); // 1console.log(f2.a); // 1 constructor原型对象有一个 constructor 属性，指向该原型对象对应的构造函数 123function Foo() { };console.log(Foo.prototype.constructor === Foo); // true 由于实例对象可以继承原型对象的属性，所以实例对象也拥有 constructor 属性，同样指向原型对象对应的构造函数 1234function Foo() { };var f1 = new Foo;console.log(f1.constructor === Foo); // true proto实例对象有一个 proto 属性，指向该实例对象对应的原型对象（需要注意，实例对象也是对象） 12345function Foo() { };var f1 = new Foo;console.log(f1.__proto__ === Foo.prototype); // true 不过需要注意是，如果实例对象 f1 是通过 Object.create() 创建的话，结果就不一样了 123456function Foo() { };var f1 = Object.create(Foo)console.log(f1.__proto__ === Foo.prototype); // falseconsole.log(f1.__proto__ === Foo); // true 下面来看图 第一部分， Foo如下图所示 实例对象 f1 是通过构造函数 Foo() 的 new 操作创建的 构造函数 Foo() 的原型对象是 Foo.prototype，实例对象 f1 通过 __proto__ 属性也指向原型对象 Foo.prototype 12345function Foo() { };var f1 = new Foo;console.log(f1.__proto__ === Foo.prototype); // true 实例对象 f1 本身并没有 constructor 属性，但它可以继承原型对象 Foo.prototype 的 constructor 属性 1234567function Foo() { };var f1 = new Foo;console.log(Foo.prototype.constructor === Foo); // trueconsole.log(f1.constructor === Foo); // trueconsole.log(f1.hasOwnProperty('constructor')); // false 第二部分， Object如下图所示 Foo.prototype 是 f1 的原型对象，同时它也是实例对象 实际上，任何对象都可以看做是通过 Object() 构造函数的 new 操作实例化的对象 所以，Foo.prototype 作为实例对象，它的构造函数是 Object()，原型对象是 Object.prototype 相应地，构造函数 Object() 的 prototype 属性指向原型对象 Object.prototype，实例对象 Foo.prototype 的 proto 属性同样指向原型对象 Object.prototype 12345function Foo() { };var f1 = new Foo;console.log(Foo.prototype.__proto__ === Object.prototype); // true 实例对象 Foo.prototype 本身具有 constructor 属性，所以它会覆盖继承自原型对象 Object.prototype 的 constructor 属性 1234567function Foo() { };var f1 = new Foo;console.log(Foo.prototype.constructor === Foo); // trueconsole.log(Object.prototype.constructor === Object); // trueconsole.log(Foo.prototype.hasOwnProperty('constructor')); // true 如果 Object.prototype 作为实例对象的话，其原型对象为 null 1console.log(Object.prototype.__proto__ === null); // true 第三部分， Function如下图所示 函数也是对象，只不过是具有特殊功能的对象而已，任何函数都可以看做是通过 Function() 构造函数的 new 操作实例化的结果 如果把函数 Foo 当成实例对象的话，其构造函数是 Function()，其原型对象是 Function.prototype 类似地，函数 Object 的构造函数也是 Function()，其原型对象是 Function.prototype 123456function Foo() { };var f1 = new Foo;console.log(Foo.__proto__ === Function.prototype); // trueconsole.log(Object.__proto__ === Function.prototype); // true 原型对象 Function.prototype 的 constructor 属性指向构造函数 Function() 实例对象 Object 和 Foo 本身没有 constructor 属性，需要继承原型对象 Function.prototype 的 constructor 属性 1234567891011function Foo() { };var f1 = new Foo;console.log(Function.prototype.constructor === Function); // trueconsole.log(Foo.constructor === Function); // trueconsole.log(Object.constructor === Function); // trueconsole.log(Foo.hasOwnProperty('constructor')); // falseconsole.log(Object.hasOwnProperty('constructor')); // false 所有的函数都可以看成是构造函数 Function() 的 new 操作的实例化对象 那么，Function 可以看成是调用其自身的 new 操作的实例化的结果 所以，如果 Function 作为实例对象，其构造函数是 Function，其原型对象是 Function.prototype 1234console.log(Function.__proto__ === Function.prototype); // trueconsole.log(Function.prototype.constructor === Function); // trueconsole.log(Function.prototype === Function); // true 如果 Function.prototype 作为实例对象的话，其原型对象是什么呢？ 和前面一样，所有的对象都可以看成是 Object() 构造函数的 new 操作的实例化结果 所以，Function.prototype 的原型对象是 Object.prototype，其原型函数是 Object() 1console.log(Function.prototype.__proto__ === Object.prototype); // true 而 Object.prototype 的原型对象是 null 1console.log(Object.prototype.__proto__ === null); // true 总结 函数（Function 也是函数）是 new Function 的结果，所以函数可以作为实例对象，其构造函数是 Function()，原型对象是 Function.prototype 对象（函数也是对象）是 new Object 的结果，所以对象可以作为实例对象，其构造函数是 Object()，原型对象是 Object.prototype Object.prototype 的原型对象是 null 参考 js 中 proto 和 prototype 的区别和关系？ Js 中 Prototype、proto、Constructor、Object、Function 关系介绍 一张图理解 prototype、proto 和 constructor 的三角关系 proto VS. prototype in JavaScript","link":"/2017/04/08/JavaScript/11/"},{"title":"parseInt() 与 parseFloat()","text":"在 JavaScript 中，parseInt() 函数和 parseFloat() 函数功能类型，都是将所谓的数字字符串转化为一个数值 下面就一个一个来看 parseFloat(string)parseFloat() 函数可解析一个字符串，并返回一个浮点数 指定字符串中的首个字符是否是数字，如果是，则对字符串进行解析，直到到达数字的末端为止，然后以数字返回该数字，而不是作为字符串 parseInt(string, radix)parseInt() 函数可解析一个字符串，并返回一个整数 radix 为进制，如果省略该参数或其值为 0，则数字将以 10 为基础来解析 差异parseInt 和 parseFloat 都是将字符串类型转换为 number 类型，两者区别在于 parseFloat 会将 . 号转换为浮点数，而 parseInt 直接忽略停止转换 比如当处理 '5.12asc' 时，parseInt 直接转换为 5，parseFloat 会转换为 5.12，parseInt 还可以指定第二位参数来指定转换结果的进制（2, 8, 16）（范围为 2 - 36） parseFloat 与 NANparseFloat 会将它的字符串参数解析成为浮点数并返回，如果在解析过程中遇到了正负号（+ 或 -）、数字（0 - 9）、小数点，或者科学记数法中的指数（e 或 E）以外的字符，则它会忽略该字符以及之后的所有字符，返回当前已经解析到的浮点数 同时参数字符串首位的空白符会被忽略，如果参数字符串的第一个字符不能被解析成为数字，则 parseFloat 返回 NaN 根据 #parseFloat 可知，当调用 parseFloat 函数，是先转成字符串，再转为数字，如果不能转为数字，则返回 NaN 大体意思就是 如果返回的是原始类型（即 Number，String，Boolean，Undefined，Null），则将此返回值转为字符串，再尝试将字符串转为数字，如果不能转成数字则返回 NaN 如果 toString 方法返回的不是原始类型，则继续调用 valueOf 方法，如果返回的是原始类型，则将其转为字符串，再将字符串转为数字返回 如果 valueOf 方法返回的也不是原始类型,则返回 NaN map(parseInt)一个经典的问题 12// 下面的语句返回什么['1', '2', '3'].map(parseInt); 你可能觉的会是 [1, 2, 3]，但实际的结果是 [1, NaN, NaN] 通常使用 parseInt 时，只需要传递一个参数，但实际上 parseInt 可以有两个参数，第二个参数是进制数，可以通过语句 'alert(parseInt.length) === 2' 来验证 map 方法在调用 callback 函数时，会给它传递三个参数，当前正在遍历的元素，元素索引，原数组本身 第三个参数 parseInt 会忽视，但第二个参数不会，也就是说 parseInt 把传过来的索引值当成进制数来使用，从而返回了 NaN 只需要稍微调整一下，正确的传递进制索引即可 12['1', '2', '3'].map(item =&gt; parseInt(item, 10))// 返回 [1, 2, 3] parseFloat() 精度的问题只有字符串中的第一个数字会被返回，开头和结尾的空格是允许的 提示，如果字符串的第一个字符不能被转换为数字，那么 parseFloat() 会返回 NaN，如果只想解析数字的整数部分，请使用 parseInt() 方法 12345678910111213parseFloat('10'); // 10parseFloat('10.00'); // 10parseFloat('10.33'); // 10.33parseFloat('34 45 66'); // 34parseFloat(' 60 '); // 60parseFloat('40 years'); // 40parseFloat('He was 40'); // NaN 通过以上一些实例，parseFloat 的用法大致应该了解一些了，下面来说一些遇到的问题 1234var num = parseFloat('233333.9') - parseFloat('0.2');// 233333.69999999998console.log(num); 造成这种情况的原因就在于能被计算机读懂的是二进制，而不是十进制，把 0.2 转换为二进制看一看 10.2 =&gt; 0.0011 0011 0011 0011…（无限循环） 这样一看问题就很明显了，我们需要做的就是尽量避免这样的情况发生 12345678910// 第一种，四舍五入Math.round(parseFloat('233333.9') - parseFloat(0.2));// 第二种，保留几位小数num.toFixed(2); // toFixed(n) 中的 n 代表保留几位 // 第三种，扩大一定的倍数，对结果在缩小这个倍数var num1 = parseFloat('233333.9') * 1000000000000;var num2 = parseFloat('0.2') * 1000000000000;var num3 = (num1 - num2) / 1000000000000; 另外还可以使用一些第三方库来进行解决，比如 bignumber 为什么 0.1 + 0.2 === 0.3 返回 false同上面的精度问题是一样的原因，但是为什么会造成这样的现象呢？在展开这个问题之前，我们需要先了解计算机内部是如何表示数的 在计算机当中使用位来处理数据，每一个二进制数（二进制串）都一一对应一个十进制数 看下面两个例子 十进制值 进制 按位格式 描述 13 10 13 1x10^1 + 3x10^0 = 10 + 3 13 2 1101 1x2^3 + 1x2^2 + 0x2^1 + 1x2^0 = 8 + 4 + 0 + 1 上面是整数，下面则是小数 0.625 10 0.625 6x10^-1 + 2x10^-2 + 5x10^-3 = 0.6 + 0.02 + 0.005 0.625 2 0.101 1x2^-1 + 0 x2^-2 + 1x2^-3 = 1/2 + 0 + 1/8 简单来说 十进制整数转二进制方法 – 除 2 取余 十进制小数转二进制方法 – 乘 2 除整 在这里就不得不提 0.1 这个比较特殊的小数了，0.1 的二进制格式是 0.0001100011 ... 这是一个二进制无限循环小数，但是计算机内存有限，不可能存储所有的小数位数 这里就会存在一个在某个精度点直接舍弃的操作，当然，代价就是，0.1 在计算机内部根本就不是精确的 0.1，而是一个有舍入误差的 0.1 当代码被编译或解释后，0.1 已经被四舍五入成一个与之很接近的计算机内部数字，以至于计算还没开始，一个很小的舍入错误就已经产生了，这也就是 0.1 + 0.2 不等于 0.3 的原因 这里就会引申出另外一个问题，如下 为什么 0.1 + 0.1 却等于 0.2结果是，两个有舍入误差的值在求和时，相互抵消了，类似于负负得正，相互抵消这样的效果 但这种结果不一定是可靠的，当这两个数字是用不同长度数位来表示的浮点数时，舍入误差可能不会相互抵消 另一个需要注意的是，二进制能精确地表示位数有限且分母是 2 的倍数的小数，比如 0.5，0.5 在计算机内部就没有舍入误差，所以 0.5 + 0.5 === 1 在现实中，不同行业，要求的精度不是线性的，我们允许（对结果无关紧要的）误差存在 虽然允许误差存在，但是永远不要直接比较两个浮点的大小 一般在进行计算的时候，尽量将浮点运算转换成整数计算，整数是完全精度的，不存在舍入误差 如果非要计算一些浮点数，可以采用第三方库，比如之前提到过的 bignumber 等库来计算，使得在一定精度内，让浮点数计算结果符合我们的期望 1234567891011121314151617{ let x = new BigNumber(0.1); let y = new BigNumber(0.2) let z = new BigNumber(0.3) console.log(z.equals(x.add(y))) // 0.3 === 0.1 + 0.2, true console.log(z.minus(x).equals(y)) // true console.log(z.minus(y).equals(x)) // true}{ let x = 0.2 console.log(x * x === 0.04) // false let y = new BigNumber(0.2) let r = y.mul(y) // 0.04 console.log(r.equals(new BigNumber(0.04))) // true} 总结 为什么 0.1 + 0.2 不等于 0.3，因为计算机不能精确表示 0.1， 0.2 这样的浮点数，计算时使用的是带有舍入误差的数 并不是所有的浮点数在计算机内部都存在舍入误差，比如 0.5 就没有舍入误差 具有舍入误差的运算结可能会符合我们的期望，原因可能是 “负负得正” 怎么办？一是使用整型代替浮点数计算，二是不要直接比较两个浮点数，而应该使用 bignumber 这样的浮点数运算库","link":"/2017/04/15/JavaScript/12/"},{"title":"JavaScript 中的遍历和枚举","text":"先来看下面这个实例 123456var myObject = { a: undefined};myObject.a; // undefined myObject.b; // undefined 两个返回值均返回 undefined，但是这个值有可能是属性中存储的 undefined，也可能是因为属性不存在所以返回 undefined，那么如何区分这两种情况呢？ 我们可以在不访问属性值的情况下判断对象中是否存在这个属性 123456789var myObject = { a: 2};('a' in myObject); // true ('b' in myObject); // false myObject.hasOwnProperty('a'); // true myObject.hasOwnProperty('b'); // false in 操作符会检查属性是否在对象及其 [[Prototype]] 原型链中，相比之下，hasOwnProperty(..) 只会检查属性是否在 myObject 对象中，不会检查 [[Prototype]] 链 所有的普通对象都可以通过对于 Object.prototype 的委托来访问 hasOwnProperty(..) 但是有的对象可能没有连接到 Object.prototype（比如通过Object.create(null) 来创建），在这种情况下，形如 myObejct.hasOwnProperty(..) 就会失败 这时可以使用一种更加强硬的方法来进行判断，Object.prototype.hasOwnProperty.call(myObject, 'a')，它借用基础的 hasOwnProperty(..) 方法并把它显式绑定到 myObject 上 不过需要注意，看起来 in 操作符可以检查容器内是否有某个值，但是它实际上检查的是某个属性名是否存在，对于数组来说这个区别非常重要，4 in [2, 4, 6] 的结果并不是你期待的 True，因为 [2, 4, 6] 这个数组中包含的属性名是 0、1、2，没有 4 枚举先来看一个实例 1234567891011121314151617181920212223var myObject = {};Object.defineProperty( myObject, 'a', { enumerable: true, value: 2 } // 让 a 像普通属性一样可以枚举 );Object.defineProperty( myObject, 'b', { enumerable: false, value: 3 } // 让 b 不可枚举 );myObject.b; // 3 ('b' in myObject); // true myObject.hasOwnProperty('b'); // true // myObject 中仅能枚举出 afor (var k in myObject) { console.log(k, myObject[k]); // 'a' 2} 可以看到，myObject.b 确实存在并且有访问值，但是却不会出现在 for..in 循环中（尽管可以通过 in 操作符来判断是否存在），原因是可枚举就相当于可以出现在对象属性的遍历中 注意，在数组上应用 for..in 循环有时会产生出人意料的结果，因为这种枚举不仅会包含所有数值索引，还会包含所有可枚举属性 建议是只在对象上应用 for..in 循环，在数组中就使用传统的 for 循环来遍历数值索引 也可以通过另一种方式来区分属性是否可枚举 12345678910111213141516171819var myObject = {};Object.defineProperty( myObject, 'a', { enumerable: true, value: 2 } // 让 a 像普通属性一样可以枚举 );Object.defineProperty( myObject, 'b', { enumerable: false, value: 3 } // 让 b 不可枚举 );myObject.propertyIsEnumerable('a'); // true myObject.propertyIsEnumerable('b'); // false Object.keys(myObject); // ['a'] Object.getOwnPropertyNames(myObject); // ['a', 'b'] propertyIsEnumerable(..) 会检查给定的属性名是否直接存在于对象中（而不是在原型链上）并且满足 enumerable: true Object.keys(..) 会返回一个数组，包含所有可枚举属性，Object.getOwnPropertyNames(..) 会返回一个数组，包含所有属性，无论它们是否可枚举 in 和 hasOwnProperty(..) 的区别在于是否查找 [[Prototype]] 链，然而，Object.keys(..) 和 Object.getOwnPropertyNames(..) 都只会查找对象直接包含的属性 遍历for..in 循环可以用来遍历对象的可枚举属性列表（包括 [[Prototype]] 链），但是如何遍历属性的值呢？ 对于数值索引的数组来说，可以使用标准的 for 循环来遍历值 123456var myArray = [1, 2, 3];for (var i = 0; i &lt; myArray.length; i++) { console.log(myArray[i]);}// 1 2 3 这实际上并不是在遍历值，而是遍历下标来指向值，如 myArray[i] 使用 for..in 遍历对象是无法直接获取属性值的，因为它实际上遍历的是对象中的所有可枚举属性，你需要手动获取属性值 在 ES6 中增加了一种用来遍历数组的 for..of 循环语法（如果对象本身定义了迭代器的话也可以遍历对象），利用它便可以直接遍历值而不是数组下标（或者对象属性） 123456789var myArray = [1, 2, 3];for (var v of myArray) { console.log(v);}// 1 // 2 // 3 for..of 循环首先会向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的 next() 方法来遍历所有返回值 数组有内置的 @@iterator，因此 for..of 可以直接应用在数组上，我们使用内置的 @@iterator 来手动遍历数组，看看它是怎么工作的 1234567var myArray = [1, 2, 3];var it = myArray[Symbol.iterator]();it.next(); // { value: 1, done: false } it.next(); // { value: 2, done: false } it.next(); // { value: 3, done: false } it.next(); // { done: true } 我们使用 ES6 中的符号 Symbol.iterator 来获取对象的 @@iterator 内部属性 虽然看起来很像一个对象，但是 @@iterator 本身并不是一个迭代器对象，而是一个返回迭代器对象的函数（这点很重要） 和数组不同，普通的对象没有内置的 @@iterator，所以无法自动完成 for..of 遍历 当然，你可以给任何想遍历的对象定义 @@iterator，举例来说， 123456789101112131415161718192021222324252627282930313233343536373839var myObject = { a: 2, b: 3};// 主要是为了让它不可枚举Object.defineProperty(myObject, Symbol.iterator, { enumerable: false, writable: false, configurable: true, value: function () { var o = this; var idx = 0; var ks = Object.keys(o); return { next: function () { return { value: o[ks[idx++]], done: (idx &gt; ks.length) }; } }; }});// 手动遍历 myObject var it = myObject[Symbol.iterator]();it.next(); // { value: 2, done: false } it.next(); // { value: 3, done: false } it.next(); // { value: undefined, done: true } // 用 for..of 遍历 myObject for (var v of myObject) { console.log(v);}// 2// 3 for..of 循环每次调用 myObject 迭代器对象的 next() 方法时，内部的指针都会向前移动并返回对象属性列表的下一个值（需要注意在遍历对象属性或者值的时候的顺序）","link":"/2017/04/22/JavaScript/13/"},{"title":"map/reduce","text":"map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果 reduce() 方法对累加器和数组中的每个元素（从左到右）应用一个函数，将其减少为单个值，这个函数必须接收两个参数 下面分别来看这两个方法 map由于 map() 方法定义在 JavaScript 的 Array 中 比如我们有一个函数 f(x) = x * x，要把这个函数作用在一个数组 [1, 2, 3, 4, 5, 6, 7, 8, 9] 上 我们调用 Array 的 map() 方法，传入我们自己的函数，就得到了一个新的 Array 作为结果 1234567function pow(x) { return x * x;}var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81] 再比如，把 Array 的所有数字转为字符串 123var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];arr.map(String); // ['1', '2', '3', '4', '5', '6', '7', '8', '9'] reduceArray 的 reduce() 把一个函数作用在这个 Array 的 [x1, x2, x3...] 上，这个函数必须接收两个参数，reduce() 把结果继续和序列的下一个元素做累积计算，其效果就是 1[x1, x2, x3, x4].reduce(f) = f( f( f(x1, x2), x3 ), x4 ) 比方说对一个 Array 求和，就可以用 reduce 实现 12345var arr = [1, 3, 5, 7, 9];arr.reduce(function (x, y) { return x + y;}); // 25 要把 [1, 3, 5, 7, 9] 变换成整数 13579，reduce() 也能派上用场 12345var arr = [1, 3, 5, 7, 9];arr.reduce(function (x, y) { return x * 10 + y;}); // 13579 利用 reduce() 求积 123function product(arr) { return arr.reduce(function(x, y){ return x * y})} 下面来看一个实例 寻找字符串中出现次数最少的、并且首次出现位置最前的字符要求实现一个算法，寻找字符串中出现次数最少的、并且首次出现位置最前的字符，如 cbaacfdeaebb 方法一利用 hash table，缺点是 Object.keys() 不能保证顺序，所以存在风险 12345678var o = [].reduce.call('cbaacfdeaebb', function (p, n) { return p[n] = (p[n] || 0) + 1, p;}, {}), s = Object.keys(o).reduce(function (p, n) { return o[p] &lt;= o[n] ? p : n; });console.log(s, o[s]); 方法二引入了 index 来解决顺序问题 1234567891011121314const all = 'cbaacfdeaebb'.split('') .reduce((all, ch, i) =&gt; { const m = all[ch] || (all[ch] = { ch: ch, index: i, count: 0 }); m.count++; return all; }, {});const theOne = Object.keys(all) .map(ch =&gt; all[ch]) .reduce((min, t) =&gt; min.count === t.count ? (min.index &gt; t.index ? t : min) : (min.count &gt; t.count ? t : min));console.log(`${theOne.ch}: ${theOne.count}`); 方法三利用数组代替 hash table，解决了顺序问题，但是 Array.sort() 并不一定是稳定的，风险可能更大 12345678910function findFirstChar(string) { const desc = []; [...string].forEach((char, index) =&gt; { const item = desc.find(item =&gt; item.char === char) item ? item.count++ : desc.push({ char, index, count: 1 }) }) return desc.sort((a, b) =&gt; a.count - b.count)[0]} 方法四使用 Object.values，但是目前还是草案 123456789101112const less = (x, y) =&gt; (x.count &lt;= y.count &amp;&amp; x.first &lt; y.first) ? x : y;function firstSingle(string) { let map = {} string.split('') .forEach((char, index) =&gt; { map[char] ? map[char].count++ : map[char] = { count: 1, first: index, char } }); return Object.values(map).reduce(less).char} 方法五代码简短，但是执行效率不是很高 123456var str = 'cbaacfdeaebb';var result = [...new Set(str)] .map(el =&gt; ({ el, len: str.split(el).length })) .reduce((a, e) =&gt; (a.len &gt; e.len ? e : a)) .el;","link":"/2017/06/01/JavaScript/20/"},{"title":"JavaScript 中的 || 和 &&","text":"逻辑运算符 ||（或） 和 &amp;&amp;（与）应该不陌生，但是称为逻辑运算符不太准确，称之为选择器运算符或者操作数选择器运算符更恰当一些 因为在 JavaScript 中，它们返回的并不是布尔值，它们的返回值是两个操作数中的一个（且仅一个），即选择两个操作数中的一个，然后返回它的值 二元逻辑运算符 &amp;&amp; 和 || 运算符的返回值不一定是布尔类型，而是两个操作数其中一个的值 123456789var a = '42';var b = 'abc';var c = null;a || b; // 42a &amp;&amp; b; // 'abc'c || b; // 'abc'c &amp;&amp; b; // null || 和 &amp;&amp; 首先会对 第一个操作数 执行条件判断，如果其值不是布尔，就先进行 ToBoolean 强制类型转换，然后在执行条件判断 对于 ||，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值 &amp;&amp; 则相反，如果条件判断结果为 true，就返回第二个操作数的值，如果为 false 就返回第一个操作数的值 ||下面是一个十分常见的 || 用法： 123456789function foo(a, b) { a = a || 'hello'; b = b || 'world'; console.log(a + ' ' + b)}foo(); // hello worldfoo('world', 'hello') // world hello a = a || 'hello' 检查变量 a，如果还未赋值（或者为假值），就赋予它一个默认值（'hello'） 但是需要注意，如果传入的是 foo('', '')，这时会同样的返回 hello world，因为传入的是一个假值，|| 判断不成立，会返回默认值 &amp;&amp;如果第一个操作数为真值，则 &amp;&amp; 运算符 ‘选择’ 第二个操作数作为返回值，这也叫做守护运算符，即前面的表达式为后面的表达式把关 1234567function foo() { console.log(a);}var a = 42;a &amp;&amp; foo(); // 42 foo() 只有在条件判断 a 通过时才会被调用，如果条件判断未通过，a &amp;&amp; foo() 就会悄然终止（也叫做短路），foo() 不会被调用 短路对于 &amp;&amp; 和 || 来说，如果从左边的操作数能够得出结果，就可以忽略右边的操作数，这种现象称之为短路（即执行最短路径） 以 a &amp;&amp; b 为例，如果 a 是一个假值，足以决定 &amp;&amp; 的结果，就没有必要再判断 b 的值 同样对于 a || b，如果 a 是一个真值，也足以决定 || 的结果，就没有必要再判断 b 的值 隐式强制类型转换既然返回的不是 true 和 false，那么为什么 a &amp;&amp; (b || c) 这样的表达式在 if 或者 for 中没有出现问题 这是因为这些条件判断表达式最后还会执行布尔值的隐式强制类型转换 1234567var a = 42;var b = null;var c = 'foo';if (a &amp;&amp; (b || c)) { console.log('hello') // hello} 这里的 a &amp;&amp; (b || c) 的结果实际上是 'foo' 而非 true，然后再由 if 将 foo 强制类型转换为布尔值，所以最后结果为 true 如果要避免隐式强制类型转换，可以采用下面的方式 1234567var a = 42;var b = null;var c = 'foo';if (!!a &amp;&amp; (!!b || !!c)) { console.log('hello') // hello} 运算符优先级JavaScript 中的 &amp;&amp; 和 || 运算符返回它们其中一个操作数的值，而非 true 或 false，但是两个运算符三个操作数呢： 123456var a = 42;var b = 'foo';var c = [1, 2, 3];a &amp;&amp; b || c;a || b &amp;&amp; c; 这里就涉及到了运算符优先级，这里只列举一部分，完整的列表可以参考 MDN - 运算符优先级 用 ',' 来连接一系列语句的时候，它的优先级最低，其他操作数的优先级都比它高 优先级 运算类型 运算符 20 圆括号 () 19 成员访问，成员访问，函数调用 . [] () 16 逻辑非，按位非，一元加法，一元减法，前置递增，前置递减 ! ~ + - ++ -- 14 乘法，除法，取模 * / % 13 加法，减法 + - 11 小于，小于等于，大于，大于等于 &lt; &lt;= &gt; &gt;= 10 等号，非等号，全等号，非全等号 == != === !== 6 逻辑与 &amp;&amp; 5 逻辑或 || 4 条件运算符 ? : 3 赋值 = += -= ... 0 逗号 , 下面是一个极端的例子，如果理清其中的逻辑之后，以后在遇到类似情况就都比较清晰了 1234567var a = 42;var b = 'foo';var c = false;var d = a &amp;&amp; b || c ? c || b ? a : c &amp;&amp; b : a;d; // 42 根据上面的运算符优先级，上例可以分解为 1234567var d = ((a &amp;&amp; b) || c) ? ((c || b) ? a : (c &amp;&amp; b)) : a;var d = ((a &amp;&amp; b) || c) ? ((c || b) ? a : (c &amp;&amp; b)) : a; 这样一来，就可以得出最后的结果为 42 总结逻辑运算符 '||' 和 '&amp;&amp;' 都是遵行短路原则，只要确定符号前面的真假，既可确定返回值 只要 '||' 前面为 false，无论 '||' 后面是 true 还是 false，结果都返回 '||' 后面的值 只要 '||' 前面为 true，无论 '||' 后面是 true 还是 false，结果都返回 '||' 前面的值 只要 '&amp;&amp;' 前面是 false，无论 '&amp;&amp;' 后面是 true 还是 false，结果都将返 '&amp;&amp;' 前面的值 只要 '&amp;&amp;' 前面是 true，无论 '&amp;&amp;' 后面是 true 还是 false，结果都将返 '&amp;&amp;' 后面的值","link":"/2017/05/19/JavaScript/19/"},{"title":"函数的 length 和 callee 属性","text":"需要注意的是，ES6 以后不再提倡使用函数的 callee 属性 函数的 length 是形参列表的长度，就是函数定义的时候写在 () 中的参数个数，无视实参的个数 也就是说，arguments.callee.length 就是形参列表的个数，而 arguments.length 则表示实参个数 即在调用函数的时候传入进来的实参个数 123456function fn(a, b, c, d, e, f) { console.log(arguments.callee.length); // 6 console.log(arguments.length); // 3}fn(1, 2, 3) callee在函数内部，如果想要得到函数本身，使用 this 是得不到的，这时一般会使用 arguments.callee 123456function fn() { // true，即 arguments.callee 就是函数本身 console.log(arguments.callee === fn);}fn(); 相关实例123456789function fun(m, n, o, p, q, r) { alert(this.length);}function f(a, b) { arguments[0](9, 10, 11, 12, 13);}f(fun, 5, 6, 7); // 4 函数的最终调用，是 arguments 对象进行的调用，而 arguments 对象则是一个类数组对象，所以函数 fun 中的 this 就是代表的 arguments 对象，所以 this.length 就是表示调用函数 f() 的实参个数 如果换成如下形式 123456789function fun(m, n, o, p, q, r) { alert(this.callee.length);}function f(a, b) { arguments[0](9, 10, 11, 12, 13);}f(fun, 5, 6, 7); // 2 因为函数 fun 里面的 this 是 arguments 对象，所以 arguments 对象的 callee 属性就是 f() 函数 它的长度就是它的形参列表个数，为 2 再来看一个相关示例 12345678910111213function fun(a, b, c, d) { // 决定了 fun2 当中的 this 指向的是 fun 当中的 arguments 对象 arguments[0](5, 6);}function fun2(q, w, e, r, t) { alert(this.length); // 6 alert(this.callee.length); // 4 alert(arguments.length); // 2 alert(arguments.callee.length); // 5}fun(fun2, 8, 9, 10, 11, 12); 一个大的综合案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354var number = 2;var obj = { number: 4, // fn1 是一个 IIFE fn1: (function () { // 此时 this 为 window，即把全局变量中的 number 修改为了 4 this.number *= 2; // 此时 number 为 undefined，所以 undefined * 2 为 NaN number = number * 2; // 变量提升，var number; var number = 3; // 然后返回一个函数（闭包） return function () { // 闭包特性，此时 this 为 window，所以此时全局变量中的 number 为 8 this.number *= 2; // 闭包特性，number 可以拿到 fn1() 作用域当中的 number 值，所以 3 * 3 = 9 number *= 3; // 9 alert(number); } })()}var fn1 = obj.fn1;// 此时全局中的 number 为 4// 因为 IIFE 肯定最先执行alert(number);// 调用的实际上是返回的那个函数// 把全局中的 number 变为了 8，闭包中的 number 变为了 9// 执行的 alert() 弹出的是闭包中的 number 为 9fn1();// 这样调用的话，this 指向的是 obj// 此时 this.number *= 2; 即把 obj.number 变为了 8// 此时的闭包还是老的闭包，因为没有重新赋值（因为没有执行过类似 var fn1 = obj.fn1 的操作）// 因为之前执行过 fn1，所以闭包中的 number 为 9，此时再次调用后变为 27obj.fn1();// 此时全局的 number 为 8alert(window.number);// 8alert(obj.number);","link":"/2017/07/04/JavaScript/22/"},{"title":"JavaScript 中节点（Node）相关属性","text":"一些常见的 nodeType 值 1 - 普通元素节点，比如 div，p 等 3 - 文本节点 8 - 注释节点 9 - document 节点 10 - 文档 DTD childNodes用来获取子节点，注意，返回的是一个类数组对象 1var childs = oDiv.childNodes; 这里存在一个坑，比如如下 123456&lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; 当 div 中没有文本节点的时候，此时应该为 4 个节点，但是 IE9，Chrome，FireFox 会认为存在 9 个节点，而 IE8 则认为只有 4 个节点 这时因为高级浏览器会把空文本节点也当作为一个节点，标签前后的空文本也会被算作一个节点 而且对于注释的前后算不算空文本节点，每个浏览器的解释也有不相同，所以我们在使用节点的时候，一定要过滤，比如判断节点的 nodeType 是不是 1（普通元素节点） 12345678910// 得到真正的标签子节点function getRealChild(elem) { var result = []; for (var i = 0; i &lt; elem.childNodes.length; i++) { if (elem.childNodes[i].nodeType == 1) { result.push(elem.childNodes[i]); } } return result;} 另外，如果要改变文本节点的内容（nodeType 为 3），需要改变其 nodeValue 属性 1oDiv.childNodes[0].nodeValue = '张三' parentNodeparentNode 属性表示父节点，任何节点的 parentNode 的 nodeType 一定为 1，也就是说父节点一定是标签节点 previousSibling 和 nextSibling表示一个兄弟节点，需要注意的是，其可能是文本或者注释节点，而原生 JavaScript 当中并没有提供 prevAll()，nextAll()，siblings() 等方法 如果不存在兄弟节点，则会返回 null，所以可以利用这个特性来写一个方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// prevfunction getRealPrev(elem) { // 原理就是遍历 elem 节点的前面，直到返回第一个 nodeType 为 1 的节点 var o = elem; // 循环遍历，将循环的结果再次赋予 o，依次向上查询 while (o = o.previousSibling) { if (o.nodeType == 1) { return o; } return null; }}// nextfunction getRealNext(elem) { // 原理就是遍历 elem 节点的后面，直到返回第一个 nodeType 为 1 的节点 var o = elem; // 循环遍历，将循环的结果再次赋予 o，依次向下查询 while (o = o.nextSibling) { if (o.nodeType == 1) { return o; } return null; }}// prevAllfunction getRealprevAll(elem) { // 原理就是遍历 elem 节点的前面，直到返回第一个 nodeType 为 1 的节点 var o = elem; var result = []; // 循环遍历，将循环的结果再次赋予 o，依次向上查询 // 如果不存在上一个节点，则会返回 null，便自动停止循环 while (o = o.previousSibling) { if (o.nodeType == 1) { result.unshift(o) } return result; }}// nextAllfunction getRealnextAll(elem) { // 原理就是遍历 elem 节点的后面，直到返回第一个 nodeType 为 1 的节点 var o = elem; var result = []; // 循环遍历，将循环的结果再次赋予 o，依次向下查询 // 如果不存在下一个节点，则会返回 null，便自动停止循环 while (o = o.nextSibling) { if (o.nodeType == 1) { result.push(o) } return result; }} 而 siblings() 方法则可以使用双重循环来实现，比如下面这个方法 123456789101112function toggleActive() { var span = document.querySelectorAll('.span') for (var i = 0; i &lt; span.length; i++) { span[i].addEventListener('click', function () { // 点击的时候清空所有，然后为当前选中的添加焦点 for (var j = 0; j &lt; span.length; j++) { span[j].classList.remove('active') } this.classList.add('active') }) }} 创建节点使用 document.createElement('标签名') 来创建一个节点，需要注意的是，创建出来的节点是不存在与 DOM 树上的，即孤儿节点，需要手动添加至 DOM 树中 1234var oBox = document.getElementById('div');var oDiv = document.createElement('div');oBox.appendChild(oDiv); 一个需要注意的地方，JavaScript 中存储 DOM 节点的变量是动态的，比如如下例子 12345678910var oBox = document.getElementById('box')var oDiv = oBox.getElementsByTagName('div')// 会造成死循环// 因为 oDiv.length 会动态增加for (var i = 0; i &lt; oDiv.length; i++) { var oP = document.createElement('p'); oP.innerHTML = '123'; oBox.appendChild(oP);} 解决方法很简单，用一个变量将 length 存储起来即可 123for (var i = 0; l = oDiv.length, i &lt; l; i++) { // ...} 插入节点appendChild()常用的方法是使用 appendChild() 来追加至元素的末尾，需要注意的地方就是 如果节点已经存在（比如 DOM 树中已经存在），而不是新创建的，这个时候则会移动该节点（不会克隆） insetBefore()接收两个参数，一个是新创建的元素，另一个为参照点 1oBox.insetBefore('新创建的元素', '参照元素') 这样插入的元素会以参照的元素依次往上添加（即添加的为 3，2，1参照），如果想让顺序变为正序，使用 oBox.childNodes[0] 为参照点即可 需要注意，如果使用 childNodes[0] 来做参照删除元素的话，会存在空白节点 删除节点节点不能自己删除，如果想要删除节点，必须使用父元素参照 1'父元素'.removeChild('删除的元素') 如果不知道父元素是谁，则可以使用 1'需要删除的元素'.parentNode.removeChild('需要删除的元素') 替换节点使用 replaceChild() 方法，一般使用的不是很多 1'父元素'.replaceChild('新节点', '旧节点') 比如 oBox.replaceChild(div1, div2) 结果是将 div1 节点处的内容替换至 div2 处（div1 处的节点内容就不存在了） 克隆节点比较常用的方式是使用 innerHTML 的方式来进行克隆（亦或是修改），但是执行效率没有 DOM 原生方法速度快 原生的方法是 cloneNode([true])，可以追加一个布尔值参数 true，表示深度克隆，克隆其所有的子节点","link":"/2017/06/26/JavaScript/21/"},{"title":"ES6 中的 Class","text":"首先需要明确的一些关于 ES6 当中 class 的特点 类的内部所有定义的方法，都是不可枚举的 类和模块的内部，默认就是严格模式，所以不需要使用 use strict 指定运行模式 一个类必须有 constructor 方法，如果没有显式定义，一个空的 constructor 方法会被默认添加 不存在变量提升（hoist） 类的方法内部如果含有 this，它默认指向类的实例 class 中的方法有三种类型：构造函数、静态方法、原型方法 class 内部只有静态方法，没有静态属性 私有方法ES6 不提供，只能通过变通方法模拟实现 一种做法是在命名上加以区别 12345678910111213class Widget { // 公有方法 foo(baz) { this._bar(baz); } // 私有方法 _bar(baz) { return this.snaf = baz; } // ...} 另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的 12345678910111213class Widget { // foo 是公有方法，内部调用了 bar.call(this, baz) // 使得 bar 实际上成为了当前模块的私有方法 foo(baz) { bar.call(this, baz); } // ...}function bar(baz) { return this.snaf = baz;} 有一种方法是利用 Symbol 值的唯一性，将私有方法的名字命名为一个 Symbol 值 12345678910111213141516const bar = Symbol('bar');const snaf = Symbol('snaf');export default class myClass { // 公有方法 foo(baz) { this[bar](baz); } // 私有方法 [bar](baz) { return this[snaf] = baz; } // ...}; 私有属性与私有方法一样，ES6 不支持私有属性，但是可以通过闭包来实现私有属性 12345678910111213141516171819202122232425262728var People = (function () { var p = new WeakMap(); class People { constructor(name) { var privateProperties = { name: name }; p.set(this, privateProperties); } sayName() { console.log(this.name); } get name() { return p.get(this).name; } } return People;})();var p = new People('zhangsan');console.log(p.name);p.sayName();var p2 = new People('lisi');console.log(p2.name);p2.sayName(); 静态方法静态方法一般用来提供一些工具方法，可以通过 static 关键字定义静态方法 123456789101112131415class People { constructor(name) { this.name = name; } sayName() { console.log(this.name); } static formatName(name) { return name.toUpperCase(); }}console.log(People.formatName('zhangsan')); 静态属性Class 内部只有静态方法，没有静态属性 静态属性指的是 Class 本身的属性，即 Class.propName，而不是定义在实例对象（this）上的属性 1234class Foo { }Foo.prop = 1;Foo.prop // 1 getters &amp; setters现在可以通过 get 和 set 关键字来定义 getters 和 setters 了 1234567891011121314151617181920212223class People { constructor(name) { this.name = name; } get name() { return this._name.toUpperCase(); } set name(name) { this._name = name; } sayName() { console.log(this.name); }}var p = new People('zhangsan');console.log(p.name); // ZHANGSANconsole.log(p._name); // zhangsanp.sayName(); // ZHANGSAN 因为定义了 name 的读写器，而没有定义 _name 的读写器，所以访问这两个属性的结果是不同的 继承通过关键字 extends 来继承一个类，并且可以通过 super 关键字来引用父类 1234567891011121314151617181920class People { constructor(name) { this.name = name; } sayName() { console.log(this.name); }}class Student extends People { constructor(name, grade) { super(name); this.grade = grade; } sayGrade() { console.log(this.grade); }} 几个注意事项： 子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错，这是因为子类没有自己的 this 对象，而是继承父类的 this 对象，然后对其进行加工，如果不调用 super 方法，子类就得不到 this 对象 如果子类没有定义 constructor 方法，这个方法会被默认添加，也就是说不管有没有显式定义，任何一个子类都有 constructor 方法 在子类的构造函数中，只有调用 super 之后，才可以使用 this 关键字，否则会报错（因为只有 super 方法才能返回父类实例） Object.getPrototypeOf 方法可以用来从子类上获取父类（判断一个类是否继承了另一个类） super 关键字 使用 super 的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错 super 作为函数调用时 super 作为函数调用时，代表父类的构造函数（子类的构造函数必须执行一次 super 函数） 虽然代表了父类的构造函数，但是 super 内部的 this 指的是子类的实例（相当于 Father.prototype.constructor.call(this)） 作为函数时，super() 只能用在子类的构造函数之中，用在其他地方就会报错 super 作为对象调用时 在普通方法中，指向父类的原型对象，在静态方法中，指向父类（与父类静态方法相呼应） 当 super 指向父类的原型对象时，定义在父类实例上的方法或属性，是无法通过 super 调用的（定义在 prototype 上的则可以取到） 通过 super 调用父类的方法时，super 会绑定子类的 this 通过 super 对某个属性赋值，这时 super 就是 this，赋值的属性会变成子类实例的属性，如下代码 123456789101112131415161718192021class A { constructor() { this.x = 1; }}class B extends A { constructor() { super(); this.x = 2; // 等同于对 this.x 赋值为 3 super.x = 3; // 而当读取 super.x 的时候，读的是 A.prototype.x，所以返回 undefined console.log(super.x); // undefined console.log(this.x); // 3 }}let b = new B();","link":"/2017/09/20/JavaScript/24/"},{"title":"JavaScript 中的 this","text":"this 是 JavaScript 语言的一个关键字它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用 随着函数使用场合的不同，this 的值会发生变化，但是有一个总的原则，那就是 this 指向的是，调用函数的那个对象 JavaScript 中函数的调用有以下几种方式： 为对象方法调用 作为函数调用 作为构造函数调用 使用 apply 或 call 调用 下面就按照调用方式的不同，分别讨论 this 的含义 作为对象方法调用在 JavaScript 中，函数也是对象，因此函数可以作为一个对象的属性，此时该函数被称为该对象的方法，在使用这种调用方式时，this 被自然绑定到该对象 1234567891011var point = { x: 0, y: 0, moveTo: function (x, y) { this.x = this.x + x; this.y = this.y + y; }};// this 绑定到当前对象，即 point 对象point.moveTo(1, 1) 纯粹的函数调用函数也可以直接被调用，此时 this 绑定到全局对象，在浏览器中，window 就是该全局对象（Node.js 中为 Global） 比如下面的例子，函数被调用时，this 被绑定到全局对象，接下来执行赋值语句，相当于隐式的声明了一个全局变量，这显然不是调用者希望的 12345678function makeNoSense(x) { this.x = x;}makeNoSense(5);// x 已经成为一个值为 5 的全局变量x; 对于内部函数，即声明在另外一个函数体内的函数，这种绑定到全局对象的方式会产生另外一个问题 我们仍然以前面提到的 point 对象为例，这次我们希望在 moveTo 方法内定义两个函数，分别将 x，y 坐标进行平移 结果可能出乎意料，不仅 point 对象没有移动，反而多出两个全局变量 x，y 123456789101112131415161718192021222324var point = { x: 0, y: 0, moveTo: function (x, y) { // 内部函数 var moveX = function (x) { this.x = x; }; // 内部函数 var moveY = function (y) { this.y = y; }; moveX(x); moveY(y); }};point.moveTo(1, 1);point.x; // ==&gt; 0 point.y; // ==&gt; 0 x; // ==&gt; 1 y; // ==&gt; 1 内部函数中的 this 成为全局的了，为了规避这一设计缺陷，一般使用变量替代的方法，该变量常被命名为 that/_this/self 12345678910111213141516171819202122var point = { x: 0, y: 0, moveTo: function (x, y) { var that = this; // 内部函数 var moveX = function (x) { that.x = x; }; // 内部函数 var moveY = function (y) { that.y = y; } moveX(x); moveY(y); }};point.moveTo(1, 1);point.x; // ==&gt;1 point.y; // ==&gt;1 一个简单的记忆方法，当函数当中嵌套函数就会形成闭包环境，这时的 this 指向就可能指向 window 了 作为构造函数调用所谓构造函数，就是通过这个函数生成一个新对象（object），实际上，它们甚至都不能说是一种特殊的函数类型，它们只是被 new 操作符调用的普通函数而已 包括内置对象函数在内的所有函数都可以用 new 来调用，这种函数调用被称为构造函数调用，实际上并不存在所谓的构造函数，只有对于函数的构造调用 使用 new 来调用函数，会自动执行以下操作 创建（或者说构造）一个全新的对象 这个新对象会被执行 [[原型]] 连接 这个新对象会绑定到函数调用的 this 如果函数没有返回其他对象，那么 new 表达式中的函数会自动返回这个新对象 这时，this 就指这个新对象， 如果不使用 new 调用，则和普通函数一样 12345678910111213141516function C() { this.a = 37;}var o = new C();console.log(o.a); // 37function C2() { this.a = 37; // 手动的设置了返回对象，与 this 绑定的默认对象被取消 return { a: 38 };}o = new C2();console.log(o.a); // 38 使用 apply 或 call 调用apply() 是函数对象的一个方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象，因此，this 指的就是这第一个参数 1234567891011121314function Point(x, y) { this.x = x; this.y = y; this.moveTo = function (x, y) { this.x = x; this.y = y; }}var p1 = new Point(0, 0);var p2 = { x: 0, y: 0 };p1.moveTo(1, 1);p1.moveTo.apply(p2, [10, 10]); 在上面的例子中，我们使用构造函数生成了一个对象 p1，该对象同时具有 moveTo 方法 使用对象字面量创建了另一个对象 p2，我们看到使用 apply 可以将 p1 的方法应用到 p2 上 这时候 this 也被绑定到对象 p2 上，另一个方法 call 也具备同样功能，不同的是最后的参数不是作为一个数组统一传入，而是分开传入的 注意，apply() 的参数为空时，默认调用全局对象 四种方式的优先级如下所示，优先级从上往下： 由 new 调用绑定到新创建的对象 如果是由 call 或者 apply（或者 bind）调用则绑定到指定的对象 如果是由上下文对象调用则绑定到那个上下文对象 默认：在严格模式下绑定到 undefined，否则绑定到全局对象 以上是 this 常见的几种使用方式，下面来看看一些不太常见的场景 原型链中的 this相同的概念在定义在原型链中的方法也是一致的，如果该方法存在于一个对象的原型链上，那么 this 指向的是调用这个方法的对象，表现得好像是这个方法就存在于这个对象上一样 123456789101112var o = { f: function () { return this.a + this.b; }};var p = Object.create(o);p.a = 1;p.b = 4;console.log(p.f()); // 5 对象 p 没有属于它自己的 f 属性，它的 f 属性继承自它的原型，但是这对于最终在 o 中找到 f 属性的查找过程来说没有关系 查找过程首先从 p.f 的引用开始，所以函数中的 this 指向 p，也就是说，因为 f 是作为 p 的方法调用的，所以它的 this 指向了 p getter 与 setter 中的 this作为 getter 或 setter 函数都会绑定 this 到从设置属性或得到属性的那个对象 1234567891011121314151617181920function modulus() { return Math.sqrt(this.re * this.re + this.im * this.im);}var o = { re: 1, im: -1, get phase() { return Math.atan2(this.im, this.re); }};Object.defineProperty(o, 'modulus', { enumerable: true, configurable: true, get: modulus});// -0.78... 1.4142...console.log(o.phase, o.modulus); DOM 事件处理函数中的 this当函数被用作事件处理函数时，它的 this 指向触发事件的元素 需要注意，IE 的 attachEvent() 中的 this 指向 window（IE11+ 已经支持 addEventListener()） 1234567891011121314151617// 被调用时，将关联的元素变成蓝色function bluify(e) { // 总是 true console.log(this === e.currentTarget); // 当 currentTarget 和 target 是同一个对象是为 true console.log(this === e.target); this.style.backgroundColor = '#A5D9F3';}// 获取文档中的所有元素的列表var elements = document.getElementsByTagName('*');// 将 bluify 作为元素的点击监听函数，当元素被点击时，就会变成蓝色for (var i = 0; i &lt; elements.length; i++) { elements[i].addEventListener('click', bluify, false);} 内联事件处理函数中的 this当代码被内联处理函数调用时，它的 this 指向监听器所在的 DOM 元素 123&lt;button onclick=\"alert(this.tagName.toLowerCase());\"&gt; Show inner this&lt;/button&gt; 上面的 alert 会显示 button，但是注意只有外层代码中的 this 是这样设置的，如果使用闭包（如下所示），则里面的 this 是指向 window/global 的 123&lt;button onclick=\"alert((function(){return this})());\"&gt; Show inner this&lt;/button&gt;","link":"/2017/10/09/JavaScript/27/"},{"title":"JavaScript 中的 call 和 apply","text":"call() 和 apply() 方法主要是用来扩充函数的作用域和改变 this 的指向（改变被调用函数的上下文），都接收两个参数 apply() 方法 第一个参数是作用域，第二个是参数数组，其中第二个参数可以是数组实例，也可以是 arguments 对象 call() 方法 也接收两个参数，仅仅在于和 apply() 的传参方式不同，传递函数的参数必须逐个写入 不过需要注意的是，调用 call 或者 apply 的对象必须是个函数 因为这两者是挂载在 Function 对象上的两个方法，只有函数才有这些方法 两者的区别123function().call(object, a, b, c ...)function().apply(object, [a, b, c ...]) 功能基本一样，都是对象 object 调用这里的 funciton() 不同之处是 call 参数从第二个开始都是传递给 funciton 的，可以依次罗列用 ',' 隔开 而 apply 只有两个参数，第二个是一个数组，其中存储了所有传递给 function 的参数 12345678910var bar = {baz: 'baz'};function foo () { console.log(this)}foo.call('bar');// 输出 Object {baz: 'baz'}// 其实就是让一个对象调用一个函数，在使用了 call 以后，即调用了显式绑定，this 就指向了所传进去的对象 call 和 apply 的第一个参数call 和 apply 用来改变函数的执行上下文（this），它们的第一个参数 thisArg 是个对象，即作为函数内的 this 在多数时候你传递什么给函数，那么它就是什么 1234567891011function fun() { alert(this);}fun.call(1); // 1fun.call('a'); // afun.call(true); // truefun.call({name: 'aaa'}); // [object Object] 有两种情况需要注意，传递 null 或 undefined 时，执行环境会是全局的（window/global） 可以参考规范 15.3.4.4 - Function.prototype.call() 12fun.call(null); // windowfun.call(undefined); // window 但是在严格模式下，给 call 和 apply 传入的任何参数也不再会转换 1234567'use strict'function fun() { alert(this);}fun.call(null); // nullfun.call(undefined); // undefined 另外一个例子 1234567function foo(x, y) { 'use strict'; console.log(x, y, this);}foo.apply(null); // undefined undefined nullfoo.apply(undefined); // undefined undefined undefined 原理call 和 apply 本质是一样的，区别就在于参数的不同 call 方法的定义 Function.prototype.call() 简单来说就是 call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法 apply() 方法在使用一个指定的 this 值和参数值必须是数组类型的前提下调用某个函数或方法 call() 和 apply() 的第一个参数是要调用函数的母对象，它是调用上下文，在函数体内通过 this 来获得它的引用，比如以对象 o 的方法来调用函数 f() 123f.call(o)f.apply(o) 大致原理如下所示 1234o.m = f; // 将 f 存储为 o 的临时方法o.m(); // 调用它，不传入参数delete o.m; // 将临时方法删除 在严格模式中，call() 和 apply() 的第一个参数都会变成 this 的值，哪怕传入的实参是原始值甚至是 null 或 undefined 在 ES3 或者非严格模式中，传入的 null 和 undefined 都会被全局对象代替，而其他原始值则会被相应的包装对象（wrapper object）所替代 简单来说就是，f.call(o) 其原理就是先通过 o.m = f 将 f 作为 o 的某个临时属性 m 存储，然后执行 m，执行完毕后将 m 属性删除 接下来，我们就可以尝试着手动来实现我们自己的 call 和 apply 方法 实现我们先来看看 call 的实现 想要手动来实现一个 call 方法，我们首先需要了解在使用 call 的过程中到底发生了哪些事情 根据上面的原理，我们可以整理出大致的实现思路，总的来说，分为四个步骤 首先需要设置上下文对象，简单来说，也就是 this 的指向，因为第一个参数是要调用函数的母对象，它是调用上下文 通过设置 context（上下文），来将函数的 this 绑定到 context 上 执行函数并且传递参数 删除临时属性，并且返回函数执行结果 我们可以根据以上来得出我们的第一版代码，如下 12345Function.prototype.call = function (context) { context.fn = this; context.fn(); delete context.fn;} 虽然可以勉强实现效果，但是不够完善，而且还有几个需要注意的地方 首先，call 方法是可以接收参数的 this 参数可以传递 null 或者不传，当为 null 的时候，需要将其指向 window 而且函数是可以指定返回值的 下面我们就来逐一完善 1234567891011121314151617181920Function.prototype.call = function (context, ...args) { // 根据之前关于 call 和 apply 的第一个参数可知 // 传递 null 或 undefined 时，执行环境会是全局的（window/global） // 而对于原始值，this 则会指向该原始值的实例对象 if (context === null || context === undefined) { context = window } else { context = Object(context) } // 绑定到 context 上 context.fn = this; // 这里注解见下方 let result = context.fn(...args); // 删除临时属性并且返回函数执行结果 delete context.fn; return result;}; 关于 let result = context.fn(...args) 的作用 我们最终的目的是为了达到类似于 context.fn(arg1, arg2, arg3 ...) 这样的调用方式 这里使用扩展运算符来达到参数传递的功能，如果不采用该方法，也可以使用字符串拼接的方式在配合 eval() 方法来实现 123456var args = [];// 从第二位开始循环for (var i = 1; i &lt; arguments.length; i++) { args.push('arguments[' + i + ']');}var result = eval('context.fn(' + args + ')'); 如果为了追求完美，那么这里还存在一个小小的问题，即 context.fn = this，这里我们只是假设不存在名为 fn 的属性，所以这里我们需要保证 fn 的唯一性 这里可以采用 ES6 提供的 Symbol 数据类型，直接添加即可 12var fn = Symbol()context[fn] = this 如果不使用 Symbol，也可以来手动模拟一个，简单来说就是随机定义一个属性名称，然后在进行赋值的时候判断一下 123456789101112function symbol(obj) { var unique_prop = '00' + Math.random(); if (obj.hasOwnProperty(unique_prop)) { // 如果已经存在这个属性，则递归调用，直到没有这个属性 arguments.callee(obj) } else { return unique_prop; }}// 使用var fn = symbol(context); 完整代码如下 123456789101112Function.prototype.call = function (context, ...args) { if (context === null || context === undefined) { context = window } else { context = Object(context) } let fn = Symbol() context[fn] = this let result = context[fn](...args) delete context[fn] return result}; 现在我们有了 call 方法，那么实现 apply 方法也是同样的思路 传递给函数的参数与 call 方法不一样，其他部分则跟 call 方法是一致的 apply 方法的第二个参数为类数组对象 实现如下 123456789101112131415161718Function.prototype.apply = function (context) { if (context === null || context === undefined) { context = window } else { context = Object(context) } // 绑定到 context 上 let fn = Symbol() context[fn] = this // 这里注解也见下方 let result = arguments[1] ? context[fn](...arguments[1]) : context[fn]() // 删除临时属性并且返回函数执行结果 delete context[fn] return result} 在这里我们需要判断一下，如果只传入了一个参数，则直接执行函数即可，如果传递了第二个参数，则依次执行函数并且传递函数参数 基本原理就是这样了，如果为了完善一些，在这里可以针对 apply 的第二个参数（类数组对象）来进行判断一下 123456789101112const args = arguments[1]let resultif (args) { if (!Array.isArray(args) &amp;&amp; !isArrayLike(args)) { throw new TypeError(`second parameter needs to be an array or class array object`); } else { args = Array.from(args) result = context[fn](...args) }} else { result = context[fn]()} 当中使用的 isArrayLike 方法如下 1234567891011function isArrayLike(o) { if (o &amp;&amp; // o 不是 null、undefined 等 typeof o === 'object' &amp;&amp; // o 是对象 isFinite(o.length) &amp;&amp; // o.length 是有限数值 o.length &gt;= 0 &amp;&amp; // o.length 为非负值 o.length === Math.floor(o.length) &amp;&amp; // o.length 是整数 o.length &lt; 4294967296) // o.length &lt; 2^32 return true else return false} 延伸下面是两个实际使用场景 123456789101112131415161718192021222324function sum(num1, num2) { return num1 + num2;}function callSum1(num1, num2) { // 使用 sum 这个函数来完成一次调用，调用的参数就是 callSum1 这个函数的参数 // apply 的第二个参数表示一组参数数组 return sum.apply(this, arguments);}function callSum2(num1, num2) { // 第二个参数是数组 return sum.apply(this, [num1, num2]);}callSum1(12, 22);callSum2(22, 32);function callSum3(num1, num2) { // call 是通过参数列表来完成传递，其余和 apply 没什么区别 return sum.call(this, num1, num2);}callSum3(32, 42); 另外一个实例 12345678910111213var color = 'red';function showColor () { alert(this.color);}function Circle (color) { this.color = color;}var c = new Circle('yellow');showColor.call(this); // 使用上下文来调用 showColor，结果是redshowColor.call(c); // 上下文对象是 c，结果就是 yellow 通过以上发现，使用 call 和 apply 以后，对象中可以不需要定义方法了 这就是 call 和 apply 的一种运用 this.init.apply(this, arguments)在 prototype 框架中有如下一段代码 12345678910111213141516171819202122var Class = { create: function () { return function () { this.initialize.apply(this, arguments); } }};// Class 使用方法如下var A = Class.create();A.prototype = { initialize: function (v) { this.value = v; }, showValue: function () { alert(this.value); }};var a = new A('helloWord!');a.showValue(); var a = new A('helloWord!') 其实这句话的含义就是构造个一个 function 复制给 a，这个 function 是 123function () { this.initialize.apply(this, arguments);} 这个 function 方法是用来做构造函数的。使用 function 构造对象时，会让构造出来的对象的 initialize 方法执行 apply() 方法 function 中的第一个 this 是指用 new 调用构造函数之后生成的对象，也就是前面的 a，那么第二个 this 也当然应该是指同一个对象 this 调用 initialize 方法，参数是 arguments 对象（参数的数组对象），在构造函数执行时，对象 a 就会去执行 initialize 方法来初始化 arguments 作为 create 返回的构造函数的实参数组 传递给方法 apply，在调用 initialize 时作为参数传递给初始化函数 initialize 那么在 var a = new A('helloWord!') 的时候 'helloWord!' 就是实参数组（虽然只有一个字符串），传递给方法 apply 然后在调用 initialize 的时候作为参数传递给初始化函数 initialize 一个类似的使用场景 12345678910111213141516171819+function () { function Circle(nRadius, sMessage) { this.init.apply(this, arguments); } Circle.prototype = { init: function (nRadius, sMessage) { this.nR = nRadius; this.sMessage = sMessage; }, PI: 3.14, fnGetArea: function () { return this.sMessage + ': ' + this.PI * this.nR * this.nR; } }; var c = new Circle(5, '构造初始化 面积'); alert(c.fnGetArea()); //构造初始化 面积: 78.5}(); Math.max.apply(null, arr)max() 方法可以返回两个指定的数中带有较大的值的那个数 12345var arr = [1, 3, 5, 7, 9, 11, 2, 4, 6, 8, 10];console.log(Math.max.apply(null, arr));// 使用 call 方法可以达到同样目的// Math.max.call(null, 1, 2, 3, 4, 5); Math.max() 方法，支持传递多个参数，比如：Math.max(1, 3, 5, 7, 9, 11) 但是它不支持直接传递一个数组作为参数，比如：Math.max(new Array(1, 3, 5, 7, 9, 11)) 这里，只要我们有方法把数组，一个一个拆分开来，传递到 Math.max() 方法中，就实现了传递数组的方法，这里就可以利用到 apply() 函数 所有函数都有 apply(作用域链, 参数) 这个方法，这个函数的参数接收一个数组，并且是将数组中的每个值分开来，传递给调用函数，所以就实现了传递一个数组，取得最大值的方法 Function.apply() 是 JavaScript 的一个 OOP 特性，一般用来模拟继承和扩展 this 的用途 xx.apply 是一个调用函数的方法，其参数为：apply(Function, Args) Function 为要调用的方法，Args 是参数列表，当 Function 为 null 时，默认为上文 即 1Math.max.apply(null, arr) 当然，在 ES6 以后，我们也可以使用 ... 运算符来简化操作 1Math.max(...arr) Array.prototype.slice.call(arguments, 0)在 JavaScript 中我们经常会看到 Array.prototype.slice.call(arguments, 0) 的写法，这个方法的作用是把类数组对象转换成一个真正的数组 这里涉及到 slice() 方法和 call() 方法 slice()方法数组和字符串都有这个 slice 方法，这个方法的作用是截取一段数据，在数组中，该方法的返回值是包含截取元素的组成的数组，在字符串中，该方法的返回值是包含截取字符串组成的字符串 1234// 参数 start 表示数组片段开始处的下标，如果是负数，它声明从数组末尾开始算起的位置// 参数 end 表示数组片段结束处的后一个元素的下标，如果没有指定这个参数，切分的数组包含从 start 开始到数组结束的所有元素// 如果这个参数是负数，它声明的是从数组尾部开始算起的元素（不包括结束位置）array.slice(start, end) 如果 slice() 方法没有传递参数，则默认是从 index 序列为 0 开始截取（见 MDN - Array.prototype.slice()） 需要注意的是，操作使用 slice() 生成的数组不会影响原数组，如下 12345678// slice() 方法var a = [1, 2, 3]var b = a.slice()b.push(4)console.log(a) // [1, 2, 3]console.log(b) // [1, 2, 3, 4] 下面来看几个示例 1234567[1, 2, 3, 4, 5, 6].slice(2, 4);[1, 2, 3, 4, 5, 6].slice(-4, -2);[1, 2, 3, 4, 5, 6].slice();'everything'.slice(2, 4);'everything'.slice(-4, -2);'everything'.slice(); 前两个的返回值均为 [3, 4]，为数组，而后两个的返回值分别为 'er' 和 'hi'，为字符串 如果之传入一个参数的话，那就是输出从开始位置到结束位置的所有元素 而如果不传递参数，则是从 0 开始计算（可以认为返回一个原对象的副本，因为 slice 方法返回的是一个新的数组） 在字符串中，和 slice() 方法类型的还有两个方法：substring() 和 substr() 方法 其中，substring() 方法表示返回从开始位置到结束位置的字符串，substr() 接收两个参数，第一个参数表示开始位置，第二个参数表示要截取的字符个数，和前两个方法略有不同 当传入方法的参数为负数时，这三种方法又略有不同： slice() 像上面说的，是负数加上字符串的长度得出相应的正值 substring() 方法的参数均置为零 substr() 方法的第一个参数为负值加上字符串长度得到的正值，第二个参数置为零 下面再来看看 Array.prototype.slice.call(arguments, 0) 具体含义 在 Array.prototype.slice.call(arguments, 0) 中，Array.prototype.slice 调用的是 Array 的原型方法，对于正真的数组是有 slice() 方法，但是对于像 arguments 或者自己定义的一些类数组对象虽然存在 length 等若干属性，但是并没有 slice() 方法 所以对于这种类数组对象就得使用原型方法来使用 slice() 方法，即 Array.prototype.slice（如果在自定义中的类数组对象中自定义了 slice() 方法，那么自然可以直接调用） 简单点说就是：对于 arguments 类数组，我们调用 Array.prototype.slice 原型方法，并用 call() 方法，将作用域限定在 arguments 中，这里 Array.prototype 就可以理解为 arguments，同参数 0 为 slice() 方法的第一个参数，即开始位置索引，通过这种方法就将 arguments 类数组转换成了真数组 Array.prototype.slice.call(arguments) 能将具有 length 属性的对象转成数组，除了 IE 下的节点集合 因为 IE 中的所有 DOM 对象都是以 COM 对象的形式实现的，这意味着 IE 中的 DOM 对象与原生 JavaScript 对象的行为或活动特点并不一致 12345678910111213var a = { length: 2, 0: 'first', 1: 'second' };Array.prototype.slice.call(a); // ['first', 'second']var a = { length: 2 };Array.prototype.slice.call(a); // [undefined, undefined] 猜测 slice 的内部实现12345678910Array.prototype.slice = function (start, end) { var result = new Array(); start = start || 0; // this 指向调用的对象，当用了 call 后，能够改变 this 的指向，也就是指向传进来的对象 end = end || this.length; for (var i = start; i &lt; end; i++) { result.push(this[i]); } return result;} 一个转成数组的通用函数1234567891011var toArray = function (s) { try { return Array.prototype.slice.call(s); } catch (e) { var arr = []; for (var i = 0, len = s.length; i &lt; len; i++) { arr.push(s[i]); } return arr; }} jQuery 中的 toArray()jQuery 中的方法 .toArray() 是将当前 jQuery 对象转换为真正的数组，转换后的数组包含了所有元素，方法 .toArray() 的实现巧妙地借用了数组的方法 slice() 12345678910111213141516//...// Save a reference to some core methodstoString = Object.prototype.toString,hasOwn = Object.prototype.hasOwnProperty,push = Array.prototype.push,slice = Array.prototype.slice,trim = String.prototype.trim,indexOf = Array.prototype.indexOf,toArray: function() { return slice.call(this, 0);},//... 连同 slice() 一起声明的还有 toString() 、hasOwn() 、trim() 、indexOf()，这里通过声明对这些核心方法的引用 使得在 jQuery 代码中可以借用这些核心方法的功能，执行时可通过方法 call() 和 apply() 指定方法执行的环境，即关键字 this 所引用的对象 call 和 apply 哪个速度更快一些通常来说，call 是要比 apply 快一些的，至于为什么，这就要看它们在被调用之后发生了什么 Function.prototype.apply (thisArg, argArray) 如果 IsCallable（Function） 为 false，即 Function 不可以被调用，则抛出一个 TypeError 异常 如果 argArray 为 null 或未定义，则返回调用 Function 的 [[Call]] 内部方法的结果，提供 thisArg 和一个空数组作为参数 如果 Type（argArray） 不是 Object，则抛出 TypeError 异常 获取 argArray 的长度，调用 argArray 的 [[Get]] 内部方法，找到属性 length， 赋值给 len 定义 n 为 ToUint32（len） 初始化 argList 为一个空列表 初始化 index 为 0 循环迭代取出 argArray，重复循环 while（index &lt; n） 将下标转换成 String 类型，初始化 indexName 为 ToString(index) 定义 nextArg 为 使用 indexName 作为参数调用 argArray 的 [[Get]] 内部方法的结果 将 nextArg 添加到 argList 中，作为最后一个元素 设置 index ＝ index＋1 返回调用 Function 的 [[Call]] 内部方法的结果，提供 thisArg 作为该值，argList 作为参数列表 Function.prototype.call (thisArg [ , arg1 [ , arg2, .. ] ] ) 如果 IsCallable（Function） 为 false，即 Function 不可以被调用，则抛出一个 TypeError 异常 定义 argList 为一个空列表 如果使用超过一个参数调用此方法，则以从 arg1 开始的从左到右的顺序将每个参数附加为 argList 的最后一个元素 返回调用 func 的 [[Call]] 内部方法的结果，提供 thisArg 作为该值，argList 作为参数列表 总结由于 apply 中定义的参数格式（数组），使得被调用之后需要做更多的事，需要将给定的参数格式改变（步骤 8 中所示）， 同时也有一些对参数的检查（步骤 2），而在 call 中却是不必要的 另外在 apply 中不管有多少个参数，都会执行循环，也就是步骤 6 - 8，而在 call 中也就是对应步骤 3 ，是有需要才会被执行","link":"/2018/04/16/JavaScript/32/"},{"title":"运算符优先级","text":"先来看看下面这个示例 12345678910111213var provider = { test: { $get: function () { return function anonymous(config) { console.log(this); // window }; } }};var type = 'test';var config = {};new provider[type].$get()(config); 这里需要明确两点，一个是构造函数的返回，另一个是 new 操作符的执行顺序 构造函数的返回简单来说 如果返回的是一个非引用类型的值时，实际上返回的是仍然是新创建的实例对象 如果返回的是一个引用类型的值时，返回的是引用对象本身 比如如下示例 12345678910111213function Person() { }const person = new Person();console.log(typeof person); // object// ----function Person() { return function () { }}const person = new Person();console.log(typeof person); // function new 操作符的执行顺序在 MDN 的 new 操作符描述中，语法是 1new constructor[([arguments])] 可以发现，参数 arguments 是可缺省的，那么就意味着，对于不含参数的构造函数而言，new Person() 和 new Person 是一样的 那么又会涉及到一个问题，为什么执行的时候是执行的 new Person()，而不是 (new Person)() 呢，这里就涉及到操作符的执行顺序 这里也只列举几个这里用到的运算符，更多详细的可以参考 MDN - 运算符优先级 优先级 运算类型 关联性 运算符 20 圆括号 n/a ( … ) 19 成员访问 从左到右 … . … new（带参数列表） n/a new … ( … ) 18 函数调用 从左到右 … ( … ) new（无参数列表） 从右到左 new … … 13 加法 从左到右 … + … 减法 从左到右 … - … 了解了原理之后，我们可以很轻松的将上面的问题解析为 12// 因为带参数列表的 new 优先级高于函数调用，所以不会先执行函数调用(new provider[type].$get())(config); 实战下面来看一个实例，下面的结果是多少 1var str = 'Hello' + true ? 'World' : 'JavaScript'; 结果是 World， 因为 + 运算符优先级是高于条件运算符的 其实就相当于执行了 ('Hello' + true) ? 'World' : 'JavaScript' 在来看一个操作符相关的问题 123456789101112131415161718192021222324252627282930313233function Foo() { getName = function () { console.log('1'); }; return this;}Foo.getName = function () { console.log('2');};Foo.prototype.getName = function () { console.log('3');};var getName = function () { console.log('4');};function getName() { console.log(5);}// 输出结果依次为多少Foo.getName();getName();Foo().getName();getName();new Foo.getName();new Foo().getName();new new Foo().getName();// 结果为 2 4 1 1 2 3 3 一个一个来看，首先我们来整理一下上面的代码，有几个需要注意的地方 1234567function Foo() { // 注意这里是全局的 getName = function () { console.log('1'); }; return this;} 还有下面这个，两者都会提升，但是函数声明的提升级别是要比 var 高的，所以实际执行的是 12345678function getName() { console.log(5);}// 会覆盖上面的var getName = function () { console.log('4');}; Foo.getName();函数 Foo 本身并没有执行，执行的是函数的属性 getName，输出的是 2 getName();这是在全局执行 getName()，根据我们上面的分析可知，输出的结果是 4 Foo().getName();因为 () 的优先级最高，所以首先运行 Foo()，全局的 getName 被覆盖成输出 console.log('1')，并且返回的 this 此时代表的是 window 也就是相当于执行了 window.getName()，所以输出的结果为 1 getName();这个因为之前调用了 Foo()，所以输出的结果仍然是 1 new Foo.getName();因为 . 操作符要比 new 优先级要高，所以执行的是 new (Foo.getName)()，所以输出为 2 new Foo().getName();根据优先级可知，带参数的 new 操作符是优先级最高的，所以执行的就是 (new Foo()).getName() 而 new Foo() 又会生成一个实例对象，但是生成的对象身上没有 getName() 的方法，那么就会去 prototype 当中寻找，所以输出的是 3 new new Foo().getName();老规矩，按照优先级添加括号，首先带参数的 new 操作符优先级最高，则为 new (new Foo()).getName() 然后就会发现和上面是类似的，. 操作符要比 new 优先级要高，所以可以转换为 new ((new Foo()).getName)()，所以输出的也为 3 升级版另外还有一个升级版本，如下 其实基本原理差不多，只需要理清两点即可 一个是构造函数的返回值 另一个是构造函数公有方法和原型链方法的优先级 12345678910111213141516171819202122232425262728293031323334353637383940function Foo() { this.getName = function () { console.log(3) return { getName: getName } } getName = function () { console.log(1) } return this}Foo.getName = function () { console.log(2)}Foo.prototype.getName = function () { console.log(6)}var getName = function () { console.log(4)}function getName() { console.log(5)}Foo.getName() // 2getName() // 4console.log(Foo()) // windowFoo().getName() // 1getName() // 1new Foo.getName() // 2new Foo().getName() // 3new Foo().getName().getName() // 3 1new new Foo().getName() // 3 关于最后两个结果 new Foo().getName().getName()根据之前的结论，其实执行的是 ((new Foo()).getName)().getName()，这里需要注意的是 ((new Foo()).getName) 返回的结果是 123456function () { console.log(3) return { getName: getName }} 然后在进行调用 ((new Foo()).getName)()，所以会输出 3，但是又再次返回了函数内部的一个对象 1234567891011{ getName: getName}// ==&gt;{ getName: function () { console.log(1) }} 然后再次调用这个对象的 getName 方法，所以会再次返回 1 new new Foo().getName()理清楚了上一步的操作，这里就很好理解了，其实调用的是 new ((new Foo()).getName)()，又因为 (new Foo()).getName 返回的是一个函数 就相当于 new 了一个函数，所以输出结果是 3，但是还会返回一个 getName 的对象，跟之前是一样的","link":"/2018/05/27/JavaScript/33/"},{"title":"JavaScript 并发模型","text":"JavaScript 的一大特点就是单线程，这意味着在任何时候只能有一段代码执行，JavaScript 主线程在运行时，会建立一个执行同步代码的栈和执行异步代码的队列 并发模型可以参考下面这个理论模型（转自网络） JavaScript 执行引擎的主线程运行的时候，产生堆（heap）和栈（stack） 程序中代码依次进入栈中等待执行，若执行时遇到异步方法，该异步方法会被添加到用于回调的队列（queue）中 即 JavaScript 执行引擎的主线程拥有一个执行栈（或者堆）和一个任务队列 栈（stack）：函数调用会形成了一个堆栈帧 堆（heap）：对象被分配在一个堆中，一个用以表示一个内存中大的未被组织的区域 队列（queue）：一个 JavaScript 运行时包含了一个待处理的消息队列 每一个消息都与一个函数相关联 当栈为空时，则从队列中取出一个消息进行处理 这个处理过程包含了调用与这个消息相关联的函数（以及因而创建了一个初始堆栈帧） 当栈再次为空的时候，也就意味着该消息处理结束 Event Loop 这里主要介绍两个点，queue 和 callback 关于 queue，如上文的解释，值得注意的是，除了 IO 设备的事件（比如 load）会被添加到 queue 中，用户操作产生的事件（比如 click，touchmove）同样也会被添加到 queue 中 队列中的这些事件会在主线程的执行栈被清空时被依次读取（队列先进先出，即先被压入队列中的事件会被先执行） 关于 callback，被主线程挂起来的代码，等主线程执行队列中的事件时，事件对应的 callback 代码就会被执行 针对上面的并发模型和 JavaScript 的同步异步运行机制，我们可以看到整个流程大致是这样的 所有同步任务都在主线程上执行，形成一个执行栈（并发模型的 stack） 主线程之外，还存在一个任务队列（并发模型的 queue），只要异步任务有了运行结果，就在任务队列中放置一个事件 一旦执行栈中的所有同步任务执行完毕，系统就会读取任务队列，看看里面有哪些事件和那些对应的异步任务，于是等待结束状态，进入执行栈开始执行 主线程不断重复上面的第三步 因为主线程从任务队列中读取事件的过程是循环不断的，因此这种运行机制又称为 Event Loop（事件循环） 简单总结就是，主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码调用各种外部 API，它们在任务队列中加入各种事件（click，load，done） 只要栈中的代码执行完毕，主线程就会去读取任务队列，依次执行那些事件所对应的回调函数 定时器定时器一般主要指 setTimeout() 和 setInterval() 这两个函数，如下 1234567console.log(1);setTimeout(function () { console.log(2);}, 5000);console.log(3); 需要注意的是，定时器只是将事件插入了任务队列，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数 下面我们就结合 Event Loop 看看单线程的 JavaScript 执行引擎是如何来执行该方法的 JavaScript 执行引擎主线程运行，产生 heap 和 stack 从上往下执行同步代码，console.log(1) 被压入执行栈，因为 console.log() 方法是 webkit 内核支持的普通方法而非 WebAPIs 的方法，因此立即出栈被引擎执行，输出 1 JavaScript 执行引擎继续往下，遇到 setTimeout() 异步方法（如上图，setTimeout() 属于 WebAPIs），将 setTimeout(callback, 5000) 添加到执行栈 因为 setTimeout() 属于 WebAPIs 中的方法，JavaScript 执行引擎在将 setTimeout() 出栈执行时，注册 setTimeout() 延时方法交由浏览器内核其他模块（以 webkit 为例，是 webcore 模块）处理 继续运行 setTimeout() 下面的 console.log(3) 代码，原理同步骤 2 当延时方法到达触发条件，即到达设置的延时时间时（5 秒后），该延时方法就会被添加至任务队列里，这一过程由浏览器内核其他模块处理，与执行引擎主线程独立 JavaScript 执行引擎在主线程方法执行完毕，到达空闲状态时，会从任务队列中顺序获取任务来执行 将队列的第一个回调函数重新压入执行栈，执行回调函数中的代码 console.log(2)，原理同步骤 2，回调函数的代码执行完毕，清空执行栈 JavaScript 执行引擎继续轮循队列，直到队列为空 执行完毕 以上就是一个基本的 JavaScript 并发模型 下面再来看一个经典的案例 1234567891011121314151617181920// 请写出下面代码的输出结果setTimeout(() =&gt; { console.log(1)}, 0);console.log(2);new Promise((res) =&gt; { console.log(3) res() console.log(4)}).then(() =&gt; { console.log(5)}).then(() =&gt; { console.log(6)})console.log(7)// 2 3 4 7 5 6 1 唯一需要注意的地方就是，新建的 promise 对象时需要传入一个函数参数，这个函数参数是同步代码 Macrotask 和 Microtask在之前定时器的示例当中，promise 在 resolve 后先于 setTimeout 执行，说明 promise 任务的优先级比 setTimeout 任务的优先级要高 这就引出了两个概念：Macrotask（宏任务）和 Microtask（微任务），两者的区别如下 Macrotask 包含 setTimeout，setInterval，setImmediate，I/O，UI rendering Microtask 包含 process.nextTick，Promises，Object.observe（废弃），MutationObserver 执行顺序Macrotask 和 Microtask 的执行顺序如下 在执行每个 Macrotask（宏任务）之前，会先检查有微任务队列中有没有任务需要处理，若有，就先将微任务队列中的任务全部放入同步执行栈中执行，直到微任务队列被清空 然后再执行宏任务队列中的任务，循环往复，比如下面这个例子 123456789101112131415161718192021setTimeout(() =&gt; { console.log(1)}, 0)new Promise((res) =&gt; { res()}).then(() =&gt; { console.log(4)}).then(() =&gt; { console.log(5)}).then(() =&gt; { console.log(6)}).then(() =&gt; { console.log(7)}).then(() =&gt; { console.log(8)}).then(() =&gt; { console.log(9)}).then(() =&gt; { console.log(10)}) 因此，这就能解释为什么 promise 会优先于 setTimeout 执行，即使 promise 的执行链很长 这是因为 setTimeout 属于 Macrotask，而 promise 属于 Microtask，在执行 Macrotask 之前需要先将 Microtask 队列清空 简单的总结就是 Microtask 会优先 Macrotask 执行 Microtask 会被循环提取到执行引擎主线程的执行栈，直到 Microtask 任务队列清空，才会执行 Macrotask 参考 并发模型与事件循环 JavaScript 的并发模型","link":"/2018/08/12/JavaScript/36/"},{"title":"Map / forEach","text":"先来看一看 MDN 上对 Map 和 ForEach 的定义 forEach() 方法对数组的每个元素执行一次提供的函数 map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果 两者的共同点 都是循环遍历数组中的每一项， forEach() 和 map() 里面每一次执行匿名函数都支持 3 个参数（数组中的当前项 item，当前项的索引 index，原始数组 input） 匿名函数中的 this 都是指 window 只能遍历数组 forEach()首先需要注意，forEach() 方法是没有返回值的 它不会返回执行结果，而是 undefined，也就是说，forEach() 会修改原来的数组（而 map() 方法会得到一个新的数组并返回） 123arr[].forEach(function (value, index, array) { // ...}) 参数 value 为数组中的当前项，index 当前项的索引，array 原始数组 数组中有几项，那么传递进去的匿名回调函数就需要执行几次 理论上这个方法是没有返回值的，仅仅是遍历数组中的每一项，不对原来数组进行修改 但是可以自己通过数组的索引来修改原来的数组 123456789let ary = [12, 23, 24, 42, 1];let res = ary.forEach(function (item, index, input) { input[index] = item * 10;})console.log(res); // --&gt; undefinedconsole.log(ary); // --&gt; 通过数组索引改变了原数组 map()是有返回值的，并且可以通过 return 操作符返回出来 123456arr[].map(function (value, index, array) { // ... return xxx}) 参数 value 为数组中的当前项，index 当前项的索引，array 原始数组 区别在于 map 的回调函数中支持 return 返回值 return 的是什么，相当于把数组中的这一项变为什么（并不影响原来的数组，只是相当于把原数组克隆一份，把克隆的这一份的数组中的对应项改变了） 12345678let ary = [12, 23, 24, 42, 1];let res = ary.map(function (item, index, input) { return item * 10;})console.log(res); // ==&gt; [120, 230, 240, 420, 10] 原数组拷贝了一份，并进行了修改console.log(ary); // ==&gt; [12, 23, 24, 42, 1] 原数组并未发生变化 速度对比可以使用 jsPref 来进行两者的速度比较，map-vs-foreach-speed-test 结果如下 哪个更好至于这两个方法哪个更好，完全取决于你想要做什么（使用场景） forEach 适合于你并不打算改变数据的时候，而只是想用数据做一些事情，比如打印数据 12345678910let arr = ['a', 'b', 'c', 'd'];arr.forEach(letter =&gt; { console.log(letter);});// a// b// c// d 而 map() 适用于你要改变数据值的时候，不仅仅在于它更快，而且返回一个新的数组 这样的优点在于你可以使用复合（map()，filter()，reduce() 等组合使用）来玩出更多的花样 1234let arr = [1, 2, 3, 4, 5];let arr2 = arr.map(num =&gt; num * 2).filter(num =&gt; num &gt; 5);// arr2 = [6, 8, 10] 我们首先使用 map 将每一个元素乘以 2，然后紧接着筛选出那些大于 5 的元素，最终结果赋值给 arr2 JavaScript 中数组迭代的方法汇总","link":"/2018/09/12/JavaScript/37/"},{"title":"跨域","text":"之所以会出现跨域问题，主要是因为 浏览器的同源策略 所引起的，简单来说 同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互，这是一个用于隔离潜在恶意文件的重要安全机制 受到同源限制 无法读取不同源的 Cookie、LocalStorage 和 IndexDB 无法获得不同源的 DOM 不能向不同源的服务器发送 Ajax 请求 不受同源限制 在浏览器中，&lt;script&gt;，&lt;img&gt;，&lt;iframe&gt;，&lt;link&gt; 等标签都可以跨域加载资源，而不受同源策略的限制 什么是跨域我们先来看看一个域名的组成，比如 1http://www.aaa.com:8080/script/index.js 一般由 协议（http://），子域名（www），主域名（aaa.com），端口号（8080），请求资源地址（script/index.js）组成 协议：网络协议遍及OSI通信模型（OSI 七层模型，常用协议有 TCP/IP、Http、FTP 协议等） 域名：Domain Name，网域，是由一串用点分隔的名字组成的 Internet 上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置） 端口：是设备与外界通讯交流的出口，分为物理端口和虚拟端口（比如常见的 80 端口） 当协议，子域名，主域名，端口号中任意一个不相同的时候，都算作不同域，不同域之间相互请求资源，就算作跨域 比如：http://www.aaa.com/index.html 请求 http://bbb.com/index.php JavaScript 出于安全方面的考虑，不允许跨域调用其他页面的对象 简单的理解就是因为 JavaScript 同源策略的限制，a.com 域名下的 JavaScript 无法操作 b.com 或是 c.a.com 域名下的对象 所谓同源策略，即同域名（ip），同端口，同协议 CORSCORS 全称 Cross-Origin Resource Sharing，是 W3C 的一个标准，它定义如何跨域访问资源 浏览器将 CORS 请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request），如下 请求方法是以下三种方法之一：HEAD、GET、POST http 的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type 只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain 只要同时满足以下两大条件，就属于简单请求，不同时满足上面两个条件，就属于非简单请求 简单请求浏览器会带上 Origin 的请求头发送到服务器，服务器根据 Origin 判断是否许可，如果许可就会带上 CORS 相关响应头，如果不在许可范围内就不会带上 CORS 相关的响应头 浏览器再根据响应头中是否有相关的 CORS 响应头，来判断拦截响应 body 和抛出错误 无论你是否需要用 JavaScript 通过 CORS 跨域请求资源，你都要了解 CORS 的原理 最新的浏览器全面支持，在引用外域资源时，除了 JavaScript 和 CSS 外，都要验证 CORS，例如当你引用了某个第三方 CDN 上的字体文件时 1234@font-face { font-family: 'FontAwesome'; src: url('http://cdn.com/fonts/fontawesome.ttf') format('truetype');} 如果该 CDN 服务商未正确设置 Access-Control-Allow-Origin，那么浏览器无法加载字体资源 非简单请求对于 PUT、DELETE 以及其他类型如 application/json 的 POST 请求，在发送 Ajax 请求之前 浏览器会先发送一个 OPTIONS 请求（带着 Origin、Access-Control-Request-Method、Access-Control-Request-Headers 等 CORS 相关的请求头的预检请求）到这个 URL 上，询问目标服务器是否接受 1234OPTIONS /path/to/resource HTTP/1.1Host: bar.comOrigin: http://my.comAccess-Control-Request-Method: POST 服务器必须响应并明确指出允许的 Method 1234HTTP/1.1 200 OKAccess-Control-Allow-Origin: http://my.comAccess-Control-Allow-Methods: POST, GET, PUT, OPTIONSAccess-Control-Max-Age: 86400 浏览器确认服务器响应的 Access-Control-Allow-Methods 头确实包含将要发送的 Ajax 请求的 Method，才会继续发送 Ajax，否则，抛出一个错误（可见下方实例） 由于以 POST、PUT 方式传送 JSON 格式的数据在 REST 中很常见，所以要跨域正确处理 POST 和 PUT 请求，服务器端必须正确响应 OPTIONS 请求 更多关于 CORS 的信息可以查阅 跨域资源共享 CORS 详解 处理跨域的方法处理跨域的方法有很多，比如之前常见的 JSONP，亦或者现在比较常用的 CORS，所以在这里小小的总结了一下解决跨域的相关方法，下面我们就一个一个来看 CORS也算是现在使用较多的一种方式，针对于普通跨域请求（简单请求），只服务端设置 Access-Control-Allow-Origin 即可，前端无须设置 Origin 表示本域，也就是浏览器当前页面的域，当 JavaScript 向外域（如 sina.com）发起请求后，浏览器收到响应后 首先检查 Access-Control-Allow-Origin 是否包含本域，如果是，则此次跨域请求成功，如果不是，则请求失败，JavaScript 将无法获取到响应的任何数据 假设本域是 my.com，外域是 sina.com，只要响应头 Access-Control-Allow-Origin 为 http://my.com，或者是 *，本次请求就可以成功 可见，跨域能否成功，取决于对方服务器是否愿意给你设置一个正确的 Access-Control-Allow-Origin，决定权始终在对方（服务器）手中 不过有一个需要注意的地方，跨域请求默认不会携带 Cookie 信息，如果需要携带，可以采取如下操作 1\"Access-Control-Allow-Credentials\": true 或者在请求当中配置 1http.post(url, data, { withCredentials: true }) 如果是非简单请求，前台则需要添加额外的 headers 来触发非简单请求，比如下面的示例，前台采用 Ajax 123456789101112131415var xhr = new XMLHttpRequest()xhr.withCredentials = truexhr.open('post', 'http://www.aaa.com', true)// 添加额外的 headers 来触发非简单请求xhr.setRequestHeader('Content-Type', 'application/json')xhr.send()xhr.onreadystatechange = function () { if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) { console.log(xhr.responseText) }} 后台采用 Node.js 123456789101112131415161718192021222324252627var http = require('http');var server = http.createServer();var qs = require('querystring');server.on('request', function (req, res) { var postData = ''; req.addListener('data', function (chunk) { postData += chunk; }); req.addListener('end', function () { postData = qs.parse(postData); // 跨域后台设置 res.writeHead(200, { 'Access-Control-Allow-Credentials': 'true', // 后端允许发送 Cookie 'Access-Control-Allow-Origin': 'http://www.aaa.com', // 允许访问的域（协议 + 域名 + 端口） 'Set-Cookie': 'x=123;Path=/;Domain=www.aaa.com;HttpOnly' // HttpOnly 的作用是让 JavaScript 无法读取 Cookie }); res.write(JSON.stringify(postData)); res.end(); });});server.listen('8000'); JSONPJSONP（JSON With Padding）是 JSON 的一种使用模式，可用于解决主流浏览器的跨域数据访问的问题 主要原理是借助 &lt;script&gt; 等标签的 src 属性可以请求不同域名下的资源，即 &lt;script&gt; 请求不受浏览器同源策略影响 实现过程主要通过网页客户端动态添加 &lt;script&gt; 标签内的 src 属性，向服务端发送请求（不受同源策略束缚） 当服务器收到请求后，将数据放在一个指定名字的回调函数里（作为参数）传回来，前台代码如下示例 12345678910111213// http://localhost:3000/jsonp.htmlvar script = document.createElement('script')script.src = 'http://localhost:3000/jsonp?callback=_callback'// 插入标签document.body.appendChild(script)// 回调处理函数var _callback = function (obj) { for (key in obj) { console.log('key: ' + key + ' value: ' + obj[key]) }} 上面的 &lt;script&gt; 标签会向本地服务器发送请求，这个请求的后面带了个 callback 参数，是用来告诉服务器回调方法的方法名的 因为服务器收到请求后，会把相应数据写进回调函数的参数位置，后端响应代码如下 1234567891011// 后端响应代码// http://localhost:3000/jsonpapp.get('/jsonp', (req, res) =&gt; { let callback = req.query.callback; let obj = { type: 'jsonp', name: 'weapon-x' }; res.writeHead(200, { 'Content-Type': 'text/javascript' }); res.end(callback + '(' + JSON.stringify(obj) + ')');}) 这样浏览器通过 &lt;script&gt; 下载的资源就是上面的脚本了，当 &lt;script&gt; 下载完成就会立即执行 也就是说这个请求返回后就会立即执行上面的脚本代码，而这个脚本代码就是调用回调方法和拿到 JSON 数据 但是有一个需要注意的地方，JSONP 只支持 GET 请求方式，因为本质上 &lt;script&gt; 加载资源就是 GET，那么如果要发 POST 请求该怎么办呢？ iframe + form如果想要发送 POST 请求，可以采用这种方式，主要原理是利用 iframe 标签的跨域能力，我们先来看看前台代码 123456789101112131415161718192021222324252627282930313233343536373839404142const requestPost = ({ url, data }) =&gt; { // 首先创建一个用来发送数据的 iframe，并且将其隐藏 const iframe = document.createElement('iframe') iframe.name = 'iframePost' iframe.style.display = 'none' document.body.appendChild(iframe) // 获取元素 const form = document.createElement('form') const node = document.createElement('input') // 注册 iframe 的 load 事件处理程序，如果你需要在响应返回时执行一些操作的话 iframe.onload = function() { console.log('post success') } // 在指定的 iframe 中执行 form form.action = url form.target = iframe.name form.method = 'post' for (let name in data) { node.name = name node.value = data[name].toString() form.appendChild(node.cloneNode()) } // 表单元素需要添加到主文档中 form.style.display = 'none' document.body.appendChild(form) form.submit() // 表单提交后，就可以删除这个表单，不影响下次的数据发送 document.body.removeChild(form)}// 使用方式requestPost({ url: 'http://localhost:3000', data: { msg: 'hello' }}) 后台来接收并处理数据 123456789101112// 处理成功失败返回格式的工具const { successBody } = require('./utli')class CrossDomain { static async iframePost(ctx) { let postData = ctx.request.body console.log(postData) ctx.body = successBody({ postData: postData }, 'success') }}module.exports = CrossDomain 我们再来看看其他一些在使用 iframe 过程中引起跨域的问题 document.domain + iframe这种方法有些局限性，仅限主域相同，子域不同的跨域应用场景 实现原理就是让两个页面都通过 JavaScript 强制设置 document.domain 为同一域名，这样一来就实现了同域 这里有两种场景 第一种场景是在父页面调用内嵌的 iframe 当中的元素，如下 父窗口 – http://www.aaa.com/a.html 子窗口（内嵌的 iframe） – http://www.aaa.com/b.html 这时候如果想在 a 页面里获取 b 页面里的 dom 进行操作，就会发现你不能获得 b 的 dom 比如使用 document.getElementById('myIFrame').contentWindow.document 或者 window.parent.document.body 都获取不到，都将因为两个窗口不同源而报错 在这个时候只需要在 a 页面里和 b 页面里把 document.domain 设置成相同的值就可以在两个页面里操作 dom 了 1234567891011121314&lt;!-- 父窗口当中内嵌子页面 --&gt;&lt;iframe id=\"myIFrame\" src=\"http://www.aaa.com/b.html\"&gt;&lt;/iframe&gt;&lt;script&gt; document.domain = 'domain.com' var user = 'admin'&lt;/script&gt;&lt;!-- 子页面当中设置相同的 domain --&gt;&lt;script&gt; document.domain = 'domain.com' // 获取父窗口中变量 alert('get js data from parent ==&gt; ' + window.parent.user)&lt;/script&gt; 第二种场景是共享 Cookie 引起的问题 在 a 页面里写入了 document.cookie = 'test1=hello'，但是在 b 页面当中是获取不到这个 Cookie 的 Cookie 是服务器写入浏览器的一小段信息，只有同源的网页才能共享，但是两个网页一级域名相同，只是二级域名不同，在这种情况下浏览器允许通过设置 document.domain 来共享 Cookie 另外，服务器也可以在设置 Cookie 的时候，指定 Cookie 的所属域名为一级域名，这样的话，二级域名或者三级域名不用做任何设置，都可以读取这个 Cookie 但是这里有一些需要注意的地方 document.domain 也是有限制的，虽然可读写，但只能设置成自身或者是高一级的父域且主域必须相同，所以只能解决一级域名相同二级域名不同的跨域问题 document.domain 只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexDB 无法通过这种方法跨域 window.name + iframewindow 对象有个 name 属性，该属性有个特征：即在一个窗口（window）的生命周期内，窗口载入的所有的页面都是共享一个 window.name 的 每个页面对 window.name 都有读写的权限，window.name 是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置 并且可以支持非常长的 name 值（2MB），这里可以分为下面几种情况 第一种情况是在同一个浏览器标签页里打开了不同域名下的页面 比如先在浏览器的一个标签页里打开了 http://www.aaa.com/a.html 页面，你通过 location.href = http://www.bbb.com/b.html 在同一个浏览器标签页里打开了不同域名下的页面 这时候这两个页面可以使用 window.name 来传递参数，因为 window.name 指的是浏览器窗口的名字，只要浏览器窗口相同，那么无论在哪个网页里访问值都是一样的 第二种情况和上面的 document.domain + iframe 当中的第一种场景类似，但是不同之处就是两个页面的一级域名也不相同，这时候 document.domain 就解决不了了 这个时候就可以使用 window.name 来解决，比如你在 b 页面里设定 window.name='hello'，你再返回到 a 页面，在 a 页面里访问 window.name，可以得到 hello 第三种情况比较少见，动态创建 iframe，利用 window.name 来传递数据，成功后再切换到同域代理页面，如下，这里分为三个页面 父窗口 – http://www.aaa.com/a.html 中间代理页面 – http://www.aaa.com/proxy.html，中间代理页，与 a.html 同域，内容为空即可 子窗口（内嵌的 iframe） – http://www.bbb.com/b.html（一级域名也不相同） 12345678910111213141516171819202122232425262728293031var proxy = function (url, callback) { // 防止页面无限刷新 var state = 0 var iframe = document.createElement('iframe') // 加载跨域页面 iframe.src = url // onload 事件会触发 2 次，第 1 次加载跨域页，并留存数据于 window.name iframe.onload = function () { if (state === 0) { // 第 1 次 onload 成功后（跨域页），切换到同域代理页面（指向当前域），为防止错误，可以设置为空白页面 iframe.contentWindow.location = 'http://www.aaa.com/proxy.html' state = 1 } else if (state === 1) { // 第 2 次 onload 成功后（同域的 proxy.html），读取同域 window.name 中数据 callback(iframe.contentWindow.name) // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域的 iframe 访问） iframe.contentWindow.document.write('') iframe.contentWindow.close() document.body.removeChild(iframe) } } document.body.appendChild(iframe)}// 请求跨域 b 页面数据proxy('http://www.bbb.com/b.html', function (data) { alert(data)}) 使用的话，在 b 页面当中直接设置 window.name 即可 12// b 页面window.name = 'This is page b data!' 通过 iframe 的 src 属性由外域转向本地域，跨域数据即由 iframe 的 window.name 从外域传递到本地域 这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作 location.hashlocation.hash 就是指 url 的 # 号后面的部分，这种情况一般使用在父窗口和 iframe 的子窗口之间通讯或者是 window.open 打开的子窗口之间的通讯 如果是两个不同域的页面 a 和 b 之间需要相互通信，则需要通过借助中间页 c 来实现，实现原理如下 1a.html（A 域） ==&gt; b.html（B 域） ==&gt; c.html（A 域） a 与 b 不同域只能通过 hash 值单向通信，b 与 c 也不同域也只能单向通信，但 c 与 a 同域，所以 c 可通过 parent.parent 访问 a 页面所有对象 实例如下，三个测试页面如下 A 域下的 a.html – http://www.aaa.com/a.html B 域下的 b.html – http://www.bbb.com/b.html A 域下的 c.html – http://www.ccc.com/c.html 12345678910111213141516171819202122232425262728293031323334353637&lt;!-- A 域下的 a.html（内嵌 B 域下的 b.html） --&gt;&lt;iframe id=\"iframe\" src=\"http://www.bbb.com/b.html\" style=\"display:none;\"&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById('iframe') // 向b.html传hash值 setTimeout(function () { iframe.src = iframe.src + '#user=zhangsan' }, 1000) // 开放给同域 c.html 使用的回调方法 function onCallback(res) { alert('data from c.html ==&gt; ' + res) }&lt;/script&gt;&lt;!-- B 域下的 b.html（内嵌 A 域下的 c.html） --&gt;&lt;iframe id=\"iframe\" src=\"http://www.aaa.com/c.html\" style=\"display:none;\"&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById('iframe') // 监听 a.html 传来的 hash 值，再传给 c.html window.onhashchange = function () { iframe.src = iframe.src + location.hash }&lt;/script&gt;&lt;!-- A 域下的 c.html --&gt;&lt;script&gt; // 监听 b.html 传来的 hash 值 window.onhashchange = function () { // 再通过操作同域 a.html 当中提供的回调函数，将结果传回 window.parent.parent.onCallback('hello: ' + location.hash.replace('#user=', '')) }&lt;/script&gt; postMessagepostMessage 是 HTML5 XMLHttpRequest Level 2 中的 API，且是为数不多可以跨域操作的 window 属性之一，它可用于解决以下方面的问题 页面和其打开的新窗口的数据传递 多窗口之间消息传递 页面与嵌套的 iframe 消息传递 上面三个场景的跨域数据传递 语法如下 1window.postMessage(message, targetOrigin, [transfer]) 有三个参数 data – 向目标窗口发送的数据，任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用 JSON.stringify() 序列化 origin – 协议 + 主机 + 端口号，也可以设置为 *，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为 '/' transfer – 可选参数，是一串和 message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权 另外消息的接收方必须有监听事件，否则发送消息时就会报错，如下所示 1The target origin provided ('http://localhost:3000') does not match the recipient window's origin ('http://localhost:3001'). 接收消息可以直接监听 window 对象的 message 事件即可 1window.addEventListener('message', callback) callback 接收到的 message 事件包含三个属性 data – 从其他 window 中传递过来的数据 origin – 调用 postMessage 时消息发送方窗口的 origin 需要注意的是，这个 origin 不能保证是该窗口的当前或未来 origin 因为 postMessage 被调用后可能被导航到不同的位置 source – 对发送消息的窗口对象的引用，可以使用此来在具有不同 origin 的两个窗口之间建立双向通信 简单来说，就是一个页面发送数据，另一个页面接收数据，下面来看一个实例 1234567891011121314151617181920212223242526272829303132333435&lt;!-- 父页面（内嵌一个 iframe，内容为页面 b） --&gt;&lt;iframe id=\"iframe\" src=\"http://www.bbb.com/index.html\" style=\"display:none\"&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById('iframe') iframe.onload = function () { var data = { name: 'zhangsan' } // 向 b 页面发送数据 iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.bbb.com') } // 接受 b 页面返回的数据 window.addEventListener('message', function (e) { alert('data from page b ==&gt; ' + e.data) }, false)&lt;/script&gt;&lt;!-- 子页面 --&gt;&lt;script&gt; // 接收 a 页面的数据 window.addEventListener('message', function (e) { alert('data from page a ==&gt; ' + e.data) var data = JSON.parse(e.data) if (data) { data.age = 18 // 处理后再发回给 a 页面 window.parent.postMessage(JSON.stringify(data), 'http://www.aaa.com') } }, false)&lt;/script&gt; Nginx 代理基本原理是我们请求的时候还是使用的前端域名，但是 Nginx 会帮我们把这个请求转发到真正的后端域名上，这样就可以避免跨域问题 Nginx 配置 123456789101112server{ # 监听 3000 端口 listen 3000; # 域名是 localhost server_name localhost; # 凡是类似 localhost:3000/api 这样的请求，都会转发到真正的服务端地址 http://localhost:3001 location ^ ~ /api { proxy_pass http://localhost:3001; }} 在请求的时候，还是跟往常一样正常请求即可 123456789101112// 请求的时候直接使用 http://localhost:3000// Nginx 会帮我们进行监听fetch('http://localhost:3000', { method: 'POST', headers: { 'Accept': 'application/json', 'Content-Type': 'application/json' }, body: JSON.stringify({ msg: 'hello' })}) Node.js 中间件代理跨域中间件实现跨域代理，原理大致与 Nginx 相同，都是通过启一个代理服务器，实现数据的转发 也可以通过设置 cookieDomainRewrite 参数修改响应头中 Cookie 中域名，实现当前域的 Cookie 写入，方便接口登录认证 利用 node + express + http-proxy-middleware 搭建一个 proxy 服务器 前台代码如下 12345678var xhr = new XMLHttpRequest()// 前端开关，浏览器是否读写 Cookiexhr.withCredentials = true// 访问 http-proxy-middleware 代理服务器xhr.open('get', 'http://www.aaa.com/login?user=zhangsan', true)xhr.send() 中间件服务器代码如下 123456789101112131415161718192021var express = require('express')var proxy = require('http-proxy-middleware')var app = express()app.use('/', proxy({ // 代理跨域目标接口 target: 'http://www.bbb.com', changeOrigin: true, // 修改响应头信息，实现跨域并允许带 Cookie onProxyRes: function (proxyRes, req, res) { res.header('Access-Control-Allow-Origin', 'http://www.aaa.com') res.header('Access-Control-Allow-Credentials', 'true') }, // 修改响应信息中的cookie域名 // 可以为 false，表示不修改 cookieDomainRewrite: 'www.aaa.com'}))app.listen(3000) 后台代码如下 123456789101112131415161718var http = require('http')var server = http.createServer()var qs = require('querystring')server.on('request', function (req, res) { var params = qs.parse(req.url.substring(2)) // 向前台写 Cookie // HttpOnly 表示脚本无法读取 res.writeHead(200, { 'Set-Cookie': 'x=123;Path=/;Domain=www.bbb.com;HttpOnly' }) res.write(JSON.stringify(params)) res.end()})server.listen('3000') 如果使用的是 webpack 构建的项目，可以使用 webpack-dev-server 代理接口跨域 在开发环境下，由于渲染服务和接口代理服务都是 webpack-dev-server 同一个，所以页面与代理接口之间不再跨域，无须设置 headers 跨域信息了 webpack.config.js 部分配置 12345678910111213141516module.exports = { entry: {}, module: {}, ... devServer: { historyApiFallback: true, proxy: [{ context: '/login', target: 'http://www.bbb.com', // 代理跨域目标接口 changeOrigin: true, secure: false, // 当代理某些 https 服务报错时用 cookieDomainRewrite: 'www.aaa.com' // 可以为 false，表示不修改 }], noInfo: true }} WebSocket 协议跨域WebSocket protocol 是 HTML5 一种新的协议，它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是 server push 技术的一种很好的实现 原生 WebSocket API 使用起来不太方便，我们可以选择使用 Socket.io，它很好地封装了 WebSocket 接口，提供了更简单、灵活的接口，也对不支持 WebSocket 的浏览器提供了向下兼容 前台代码如下 12345678910111213141516171819202122&lt;div&gt;user input：&lt;input type=\"text\"&gt;&lt;/div&gt;&lt;script src=\"./socket.io.js\"&gt;&lt;/script&gt;&lt;script&gt; var socket = io('http://www.bbb.com'); // 连接成功处理 socket.on('connect', function () { // 监听服务端消息 socket.on('message', function (msg) { console.log('data from server: ==&gt; ' + msg) }) // 监听服务端关闭 socket.on('disconnect', function () { console.log('Server socket has closed.') }) }) document.getElementsByTagName('input')[0].onblur = function () { socket.send(this.value) };&lt;/script&gt; Node.js 后台 1234567891011121314151617181920212223242526var http = require('http')var socket = require('socket.io')// http 服务var server = http.createServer(function (req, res) { res.writeHead(200, { 'Content-type': 'text/html' }) res.end()})server.listen('3000')// 监听 socket 连接socket.listen(server).on('connection', function (client) { // 接收信息 client.on('message', function (msg) { client.send('hello：' + msg) console.log('data from client: ==&gt; ' + msg) }) // 断开处理 client.on('disconnect', function () { console.log('Client socket has closed.') })})","link":"/2018/04/26/JavaScript/39/"},{"title":"遍历对象的几种方法","text":"先来小小的总结一下，大致有以下几种 Object.keys(obj) 返回所有可枚举属性（不包括原型中属性，不含 Symbol 属性） 如果参数不是一个对象，ES6 之前报错，之后强制转换为对象 返回数组 for...in 返回所有可枚举属性（包括原型中的属性，不含 Symbol 属性） 如果参数不是一个对象，ES6 之前报错，之后强制转换为对象 Object.getOwnPropertyNames(obj) 返回所有的自身属性（不包括原型中属性，不含 Symbol 属性，包括不可枚举（length）） 如果参数不是一个对象，ES6 之前报错，之后强制转换为对象 返回数组 Reflect.ownKeys(obj) 返回所有的自身属性（不管是否可枚举，不管是不是 Symbol，一律返回） 如果参数不是一个对象，报错 返回数组 for...of 返回当前对象上的每一个属性（不包括原型中的属性，包括 Symbol 属性） 对于普通的对象，for...of 不能直接使用，否则会报错，必须部署了 iterator 接口才能使用 Object.keys(obj)返回一个表示给定对象的所有可枚举属性的字符串数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性） 123456789var arr = ['a', 'b', 'c'];console.log(Object.keys(arr)); // ['0', '1', '2']// -------------------------------var an_obj = { 100: 'a', 2: 'b', 7: 'c' };console.log(Object.keys(an_obj)); // ['2', '7', '100'] 几个注意点： 返回所有可枚举属性（不包括原型中属性，不含 Symbol 属性）（如果参数不是一个对象，ES6 之前报错，之后强制转换为对象）（返回数组） 返回的是一个表示给定对象的所有可枚举属性的字符串数组（但不包括原型中的属性） 数组中属性名的排列顺序和使用 for...in 循环遍历该对象时返回的顺序一致 因为 for...in 语句无法保证遍历顺序，故 Object.keys(obj) 顺序也是无法保证的 原因如下 Chrome，Opera 的 JavaScript 解析引擎遵循的是新版 ECMA-262 第五版规范，因此，使用 for...in 语句遍历对象属性时遍历书序并非属性构建顺序 而 IE6，IE7，IE8，Firefox，Safari 的 JavaScript 解析引擎遵循的是较老的 ECMA-262 第三版规范，属性遍历顺序由属性构建的顺序决定 如果想要保证对象遍历的输出顺序，可以将对象转换为数组来进行操作 for…infor...in 语句以任意顺序遍历一个对象的可枚举属性，对于每个不同的属性，语句都会被执行 12345var obj = { a: 1, b: 2, c: 3 };for (var prop in obj) { console.log(prop); // a b c} 几个注意点： 返回所有可枚举属性（包括原型中的属性，不含 Symbol 属性）（如果参数不是一个对象，ES6 之前报错，之后强制转换为对象） for...in 循环只遍历可枚举属性，循环将迭代对象的所有可枚举属性和从它的构造函数的 prototype 继承而来的（包括被覆盖的内建属性）（即包括原型中的属性） for...in 不应该被用来迭代一个下标顺序很重要的 Array 同 Object.keys(obj) 一样，for...in 并不能够保证返回的是按一定顺序的索引，但是它会返回所有可枚举属性，包括非整数名称的和继承的 如果仅迭代自身的属性，而不是它的原型，可以使用： getOwnPropertyNames() 返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性）组成的数组 hasOwnProperty() 来确定某属性是否是对象本身的属性（一般使用这个来过滤） propertyIsEnumerable() 返回一个布尔值，表明指定的属性名是否是当前对象可枚举的自身属性 Object.getOwnPropertyNames(obj)Object.getOwnPropertyNames() 方法返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性）组成的数组（但不会获取原型链上的属性） 123var arr = ['a', 'b', 'c'];console.log(Object.getOwnPropertyNames(arr).sort()); // ['0', '1', '2', 'length'] 几个注意点： 返回所有的自身属性（不包括原型中属性，不含 Symbol 属性，包括不可枚举（length））（如果参数不是一个对象，ES6 之前报错，之后强制转换为对象）（返回数组） 返回指定对象的所有自身属性的属性名包括不可枚举属性组成的数组 不会获取原型链上的属性 枚举属性的顺序与通过 for...in 循环（或 Object.keys）迭代该对象属性时一致 如果只获取到可枚举属性，使用 Object.keys 或用 for...in 循环（配合 hasOwnProperty()） Reflect.ownKeys静态方法 Reflect.ownKeys() 返回一个由目标对象自身的属性键组成的数组 123Reflect.ownKeys({ z: 3, y: 2, x: 1 }); // [ 'z', 'y', 'x' ]Reflect.ownKeys([]); // ['length'] 几个注意点： 返回所有的自身属性（不管是否可枚举，不管是不是 Symbol，一律返回）（如果参数不是一个对象，报错）（返回数组） 返回值等同于 Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target)) for…offor...of 语句在可迭代对象（包括 Array, Map, Set, String, TypedArray（描述一个底层的二进制数据缓存区的一个类似数组（array-like）视图），arguments 对象等）上创建一个迭代循环，对每个不同属性的属性值，调用一个自定义的有执行语句的迭代挂钩 12345678910111213141516171819let iterable = [10, 20, 30];for (let value of iterable) { console.log(value);}// 10// 20// 30//-----------------------------let iterable = 'foo';for (let value of iterable) { console.log(value);}// 'f'// 'o'// 'o' 几个注意点： 返回当前对象上的每一个属性（对于普通的对象，for...of 不能直接使用，否则会报错，必须部署了 iterator 接口才能使用）（不包括原型中的属性，包括 Symbol 属性） 并不适用于所有的 object，可以迭代出任何拥有 iterator 的对象 for...of 遍历的是当前对象上的每一个属性值（不包括原型上的）","link":"/2019/06/28/JavaScript/42/"},{"title":"module.exports 和 exports","text":"很多时候，你会看到，在 Node.js 环境中，有两种方法可以在一个模块中输出变量 对 module.exports 赋值1234module.exports = { hello: hello, index: index} 直接使用 exports1exports.hello = hello; 针对方法二，但是你不可以直接对 exports 赋值 1234exports = { hello: hello, index: index} 代码虽然可以执行，但是模块并没有输出任何变量 这里就要提起 require() 这个方法了，但是在深入了解之前我们可以先看一下官方 API 的一个经典的例子，把 require 方法简化成了下面这个函数 12345678910function require(...) { // ... function (module, exports) { // Your module code here exports = some_func; // re-assigns exports, exports is no longer // a shortcut, and nothing is exported. module.exports = some_func; // makes your module export 0 } (module, module.exports); return module;} 通过观察传入进去的参数，我们可以看到 exports = module.exports，所以说，一开始这两个东西是指向同一个对象实例的（实际上是同一个变量，并且初始化为空对象 { } ），如下图所示： 如果直接添加一个方法，比如 exports.fn = func，那么由于 exports 指向 module.exports，由于复制引用的关系，相当于 module.exports 也添加了同样的方法，类似下图 123456// 在 exports 上添加了一个方法，module.exports 也添加了同样的方法，因为它们指向了同样的对象实例 exports.fn = function () { console.log(`hello world!`);}module.exports.fn(); // hello world! 如果给 exports 直接赋值，比如这里 exports = some_func，那么 exports 的指向就变了，但最后导出的是 module，因此，exports 指向的方法或者今后在 exports 上添加的方法都不会影响到 module.exports，因此不会被导出 引用官方 API 的一句话 As a guideline, if the relationship between exports and module.exports seems like magic to you, ignore exports and only use module.exports. 所以还是建议尽量使用 module.exports 但是在有的时候，比如我们要输出的是一个函数或者数组，那么，只能给 module.exports 赋值 1module.exports = function () { return 'foo'; }; 给 exports 赋值是无效的，因为赋值后，module.exports 仍然是空对象 {} （因为最后导出的是 module） 小结： 如果要输出一个键值对象 {}，可以利用 exports 这个已存在的空对象 {}，并继续在上面添加新的键值 如果要输出一个函数或数组，必须直接对 module.exports 对象赋值 所以我们可以得出结论：直接对 module.exports 赋值，可以应对任何情况 123module.exports = { foo: function () { return 'foo'; }}; 或者： 1module.exports = function () { return 'foo'; }; 总之，尽量使用 module.exports 来输出模块变量","link":"/2018/06/05/Node/04/"},{"title":"使用 Node.js 操作 MySQL","text":"首先需要安装 Node.js 的 mysql 模块 1$ npm install --save mysql mysql 模块是 Node.js 操作 mysql 的引擎，可以在 Node.js 环境下对 mysql 数据库进行建表，增、删、改、查等操作 使用 Node.js 来操作 mysql 一般有两种方式，一种是直接连接，还一种就是使用连接池 我们先来看看直接连接 直接连接 mysql首先先创建一个数据库，然后建立一张表，方便我们后面使用 Node.js 来进行操作 123456789101112131415161718192021create table user( uid int not null primary key auto_increment, uname varchar(100) not null, pwd varchar(100) not null)engine=myisam default charset=utf8;// 结果如下 ===&gt;+---------------------+| Tables_in_nodemysql |+---------------------+| user |+---------------------++-------+--------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+--------------+------+-----+---------+----------------+| uid | int(11) | NO | PRI | NULL | auto_increment || uname | varchar(100) | NO | | NULL | || pwd | varchar(100) | NO | | NULL | |+-------+--------------+------+-----+---------+----------------+ 然后就可以来写我们的 Node.js 程序了，新建一个 app.js： 1234567891011121314151617181920// 首先调用 mysql 模块var mysql = require('mysql');// 创建一个 connection 对象var connection = mysql.createConnection({ host: 'localhost', // 主机 user: 'root', // mysql 用户名 password: 'root', // mysql 密码 database: 'nodemysql', // 使用哪个数据库 port: '3306' // 端口号，mysql 默认为 3306});// 创建一个连接connection.connect(function (err) { if (err) { console.log(err); return; } console.log(`connection connect success!`)}) 连接成功以后就可以来执行相关的 mysql 操作了 1234567891011121314151617181920212223242526272829// 插入数据var userAddSql = 'insert into user(uname, pwd) values(?, ?)';var param = ['张三', 'pwd1'];connection.query(userAddSql, param, function (err, res) { if (err) { console.log(`insert err, ${err.message}`); return; } console.log(`insert success!`)})// 执行查询connection.query('select * from user', function (err, res) { if (err) { console.log(err) return; } console.log(`the solution is ${res[0].uname}`)})// 关闭连接connection.end(function (err) { if (err) { console.log(err.toString()); return; } console.log(`end success!`)}) 需要注意一点：如果在执行查询的时候如果有限定条件（where 一类）的话，需要这样来写 123connertion.query('select * from user where uid = ?', [1], function (err, res) { // ... }) 如果以上操作都成功的话，就可以在数据库中看到我们插入的数据了 12345+-----+-------+------+| uid | uname | pwd |+-----+-------+------+| 1 | 张三 | pwd1 |+-----+-------+------+ 以上就是直接连接 mysql 的方法了，在使用这种方式的时候，有一个地方需要注意 一个事件就有一个从开始到结束的过程，数据库会话操作执行完后，就需要关闭掉，以免占用连接资源 不过一般情况下，这种使用直接连接的方式比较少见，用的最多的就是连接池的方式，使用连接池连接的话比直连要效率很多，下面来看看具体怎么实现 连接池连接 mysql操作数据库是很复杂的读写过程，不只是一个会话，如果直接用会话操作，就需要每次会话都要配置连接参数，所以这时候就需要连接池管理会话 首先需要安装 mysql 支持，然后需要安装 mysqlpool 模块 12345// 安装 mysql 支持$ npm install mysql --save// 安装 mysqlpool 模块$ npm install node-mysql --save 我们可以新建一个 pool.js 把我们连接数据库的操作独立成一个单独的模块 1234567891011121314151617181920212223242526272829// 调用 mysql 模块var mysql = require('mysql');function OptPoll() { // 建立一个变量，用于检测是否连接过 this.flag = true; this.pool = mysql.createPool({ host: 'localhost', // 主机 user: 'root', // mysql 用户名 password: 'root', // mysql 密码 database: 'nodemysql', // 使用哪个数据库 port: '3306' // 端口号，mysql 默认为 3306 }) this.getPool = function () { if (this.flag) { // 监听 connection 事件 this.pool.on('connention', function (connection) { connection.query('set session auto_increment_increment = 1'); this.flag = false; }) } return this.pool; }}module.exports = OptPoll; 然后新建一个 app.js 导入之前的 pool，然后来执行插入，查询等操作 1234567891011121314151617181920212223242526272829303132var OptPool = require('./pool');var optPool = new OptPool();var pool = optPool.getPool();// 从连接池中获取一个连接pool.getConnection(function (err, conn) { // 插入 var userAddSql = 'insert into user(uname, pwd) values(?, ?)'; var param = ['李四', 'pwd2']; conn.query(userAddSql, param, function (err, res) { if (err) { console.log(`insert err ${err.message}`) return; } console.log(`insert success!`) // 如果在这里就放回连接池，后续在执行此操作会报错，原因见最下方 // conn.release(); }) // 查询 conn.query('select * from user', function (err, res) { if (err) { console.log(`query ${err}`) return; } console.log(res[1].uname); // 最后一步操作在放回连接池 conn.release(); })}) 操作成功后可以在数据库中看到： 123456+-----+-------+------+| uid | uname | pwd |+-----+-------+------+| 1 | 张三 | pwd1 || 2 | 李四 | pwd2 |+-----+-------+------+ 需要注意一点：在上述操作的最后一步有一个放回连接池的操作 如果之前已经调用过，即在插入操作中调用过，然后在查询的过程中又再一次的调用，那么就会直接报错 这是因为连接已经被放回连接池了，不能在操作了，为了确保不报错，在拿到连接池之后（pool.getConnection），直到最后一步操作的时候再使用 conn.release() 来放回连接池 async/await 封装由于 mysql 模块的操作都是异步操作，每次操作的结果都是在回调函数中执行，现在有了 async/await，就可以用同步的写法去操作数据库，如下 123456789101112131415161718192021222324252627282930const mysql = require('mysql');const pool = mysql.createPool({ host: 'localhost', user: 'root', password: 'root', database: 'my-database', port: '3306'});let query = function (sql, values) { return new Promise((resolve, reject) =&gt; { pool.getConnection(function (err, connection) { if (err) { reject(err) } else { connection.query(sql, values, (err, rows) =&gt; { if (err) { reject(err) } else { resolve(rows) } connection.release() }) } }) })}module.exports = { query } 使用也很简单，如下 1234567891011121314const { query } = require('./query')async function selectAllData() { let sql = 'SELECT * FROM my-table' let dataList = await query(sql) return dataList}async function getData() { let dataList = await selectAllData() console.log(dataList)}getData()","link":"/2018/09/05/Node/05/"},{"title":"Node.js 中的 libuv","text":"libuv 是一个高性能的，事件驱动的 I/O 库，并且提供了跨平台（如 windows, linux）的 API，在这里只是简单的介绍一下 详细可见 An Introduction to libuv，中文教程可以参考 Libuv 的中文教程 libuvlibuv 的官方文档在阐述其架构的时候有这么一张图 仅仅凭着这么一张图并不能让我们对其内部机制理解得透彻 简单来说，在 Node.js 里面 V8 充当的角色更多的是语法解析层面，另外它还充当了 JavaScript 和 C/C++ 的桥梁 但是我们都知道 Node.js 中一切皆可异步，但这并不是通过 V8 来实现的，充当这个角色的是 libuv 比如一个简单的 JavaScript 异步代码，使用 setTimeout 就可以 1234567setTimeout(function () { console.log('timeout 0'); }, 0);console.log('outter');// outter// timeout 0 想要深挖为什么会出现这样的结果，要首先来研究一下 libuv 的事件轮询机制 事件轮询机制（注意与浏览器中的 event loop 区分开来）event loop 是一个执行模型，在不同的地方有不同的实现，浏览器和 Node.js 基于不同的技术实现了各自的 event loop，但是不要混淆 Node.js 和浏览器中的 event loop 再次强调，Node.js 和浏览器的 event loop 是两个有明确区分的事物，不能混为一谈 简单来讲 Node.js 的 event 是基于 libuv，而浏览器的 event loop 则在 HTML 5 的规范中明确定义 libuv 已经对 event loop 作出了实现，而 HTML 5 规范中只是定义了浏览器中 event loop 的模型，具体实现留给了浏览器厂商 在 libuv 中，有一个句柄（handle）的概念，每个句柄中存储数据和回调函数之类的信息，句柄在使用前要添加到对应的队列（queue）或者堆（heap）中 其实只有定时器句柄使用了最小堆的数据结构，其他句柄使用队列的数据结构进行存储 libuv 在进行每一次事件轮询的时候都会从每个类型的句柄中，取出关联的队列或者堆结构进行处理 流程图如下所示 Node.js 的 event loop 分为 6 个阶段，每个阶段的作用如下 timers – 执行 setTimeout() 和 setInterval() 中到期的 callback I/O callbacks – 上一轮循环中有少数的 I/Ocallback 会被延迟到这一轮的这一阶段执行 idle, prepare – 仅内部使用 poll – 最为重要的阶段，执行 I/O callback，在适当的条件下会阻塞在这个阶段 check – 执行 setImmediate 的 callback close callbacks – 执行 close 事件的 callback，例如 socket.on('close',func) 如果想要具体了解其内部执行流程，可以参考这篇文章中的 源码解析部分 上面的图片可以简化成下面的流程 123456789101112131415161718 ┌───────────────────────┐┌─&gt;│ timers ││ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │ I/O callbacks ││ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │ idle, prepare ││ └──────────┬────────────┘ ┌────────────────┐│ ┌──────────┴────────────┐ │ incoming: ││ │ poll │&lt;──────┤ connections, ││ └──────────┬────────────┘ │ data, etc. ││ ┌──────────┴────────────┐ └────────────────┘│ │ check ││ └──────────┬────────────┘│ ┌──────────┴────────────┐└──┤ close callbacks │ └───────────────────────┘ event loop 的每一次循环都需要依次经过上述的阶段，每个阶段都有自己的 callback 队列 每当进入某个阶段，都会从所属的队列中取出 callback 来执行，当队列为空或者被执行 callback 的数量达到系统的最大数量时，进入下一阶段 这六个阶段都执行完毕称为一轮循环，下面我们来分类查看 timers 阶段在 timer 阶段其实使用一个最小堆而不是队列来保存所有元素（其实也可以理解，因为 timeout 的 callback 是按照超时时间的顺序来调用的，并不是先进先出的队列逻辑） 然后循环取出所有到期的 callback 执行 I/O callbacks 阶段根据 libuv 的文档，一些应该在上轮循环 poll 阶段执行的 callback，因为某些原因不能执行，就会被延迟到这一轮的循环的 I/O callbacks 阶段执行 换句话说这个阶段执行的 callbacks 是上轮残留的 idle 和 prepare 阶段idle 和 prepare 回调，仅仅在内部使用 poll 阶段poll 阶段的任务就是阻塞等待监听的事件来临，然后执行对应的 callback，其中阻塞是带有超时时间的，以下几种情况都会使得超时时间为 0 uv_run 处于 UV_RUN_NOWAIT 模式下 uv_stop() 被调用 没有活跃的 handles 和 request 有活跃的 idle handles 有等待关闭的 handles 如果上述都不符合，则超时时间为距离现在最近的 timer，如果没有 timer 则 poll 阶段会一直阻塞下去 check 阶段check 回调，在 Node.js 中被用作运行 setImmediate 回调 close 阶段循环关闭所有的 closing handles 线程模型接下来我们可以了解一下 libuv 的线程模型，因为要想实现一个无堵塞的事件轮询必须依靠线程 libuv 中大体上可以把线程分为两类，一类是事件轮询线程，一类是文件 IO 处理线程 第一类事件轮询线程是单线程，另外一类称其为文件 IO 处理线程多少有些不准确，因为他不仅能处理文件 IO，还能处理 DNS 解析，也能处理用户自己编写的 Node.js 扩展中的逻辑 它是一个线程池，如果你想自己编写一个 C++ 扩展来处理耗时业务的话，也会用上它 我们这里拿文件 IO 处理来作为示例，来描述这两类线程之前是怎么通信的 libuv 在处理完一个文件 IO 操作后，会把处理后的结果发送到 pending 队列中，事件轮询线程读取 pending 队列，执行回调函数 12345var fs = require('fs');fs.exists(__filename, function (exists) { console.log(exists);}); 需要注意的是：fs.exists 是 Node.js 自带的函数，已经不再推荐使用 这里我们仅仅用来讲解原理（可以使用 fs.stat() 或者 fs.access() 来替代） 该函数在调用的时候传了两个参数，第一个 __filename 是 Node.js 中的一个全局变量，它的值其实是当前执行文件的所在路径 第二个参数是一个回调函数，回调函数中 exists 用来表示当前是否存在，很明显当前这段代码最终打印的结果肯定是 true 当然我们这里更关心的是整个流程处理，下面用一副数据流向图来将上面流程总结一下 参考 Linux IO 概览 Libuv 源码阅读 The Node.js Event Loop, Timers, and process.nextTick() 不要混淆nodejs和浏览器中的 event loop","link":"/2019/07/05/Node/06/"},{"title":"Flux","text":"Flux 是 Facebook 用于构建客户端 Web 应用程序的基本架构，我们可以将 Flux 看做一种应用程序中的数据流的设计模式，而 Redux 正是基于 Flux 的核心思想实现的一套解决方案 Flux 应用中的数据以单一方向流动 视图产生动作消息，将动作传递给调度器 调度器将动作消息发送给每一个数据中心 数据中心再将数据传递给视图 可以简化为以下流程 1View（视图层） ==&gt; Action（请求层） ==&gt; Dispatcher（传输层） ==&gt; Store（处理层） ==&gt; 最后再次回到 View 比如用户在视图上（view）点击了一个按钮，即发送了一个 action，然后 action 发送到 Dispatcher 中（调度器） Dispatcher 来分配这个 action（比如要指派给谁去做任务）给 Store（在一个 flux 结构中，store 可以有多个，注意和 react-redux 区分） 在 Store 中的作用就是存储并修改数据，然后传递给 View 进行渲染（渲染到虚拟 DOM 当中） 单一方向数据流还具有以下特点 集中化管理数据，常规应用可能会在视图层的任何地方或回调进行数据状态的修改与存储，而在 Flux 架构中，所有数据都只放在 Store 中进行储存与管理 可预测性，在双向绑定或响应式编程中，当一个对象改变时，可能会导致另一个对象发生改变，这样会触发多次级联更新，对于 Flux 架构来讲，一次 Action 触发，只能引起一次数据流循环，这使得数据更加可预测 方便追踪变化，所有引起数据变化的原因都可由 Action 进行描述，而 Action 只是一个纯对象，因此十分易于序列化或查看 为什么要使用 Flux当使用的是 MVC 或者 MVVM 架构设计模式的时候，有一个缺点，就是当项目越来越大，逻辑越来越复杂的时候，数据间的流动就会显得十分混乱 flux 就是致力于解决数据有序传输问题的架构设计模式（flux 中最大的哲学就是数据是单向流动的） Flux 的工作流 在 Flux 中会有以下几个角色的出现 Dispacher – 调度器，接收到 Action 并将它们发送给 Store Action – 动作消息，包含动作类型与动作描述 Store – 数据中心，持有应用程序的数据，并会响应 Action 消息 View – 应用视图，可展示 Store 数据，并实时响应 Store 的更新 Dispatcher Dispatcher 接收 Action，并且要把这些 Action 分派给已经注册到 Dispatcher 的 Store 上 所有的 Store 都将接收所有的 Action 在每个 App 中，应该确保只有一个 Dispatcher 的实例 Store Store 是在 App 中持有数据的东西，Stores 将要在 App 的 Dispatcher 身上注册，以确保它们可以接收 Actions 存在 Store 中的数据只能够因为响应 Action 才能有所改变 在 Store 中不能够有公共的 setter 函数，仅能够有 getter 函数 Stores 决定了它们愿意响应哪些 Actions 无论什么时候，Store 中的数据改变了，就会触发一个 change 事件 在一个 App 中可能有很多 Store Action Action 定义了我们 App 中内部的 API 它们捕获所有可能改变 App 的任何途径、方法 它们是简单的 JSON 对象，并且要有 'type' 属性，和其他一些数据属性 1234{ type: 'delete-todo', todoId: '123'} Action 应该具有一个语义化的命名 所有的 Store 都将接收同一个 Action，并且通过这同一个 Action，Store 会知道它们要清除和更新哪些数据 Views 从 Store 中来的数据将被展示在 View 上 View 层可以使用任何框架 当一个视图想要使用从某一个 Store 中来的数据，它必须订阅 subscribe（订阅）一下该 Store 的 change 事件 当 Store 发射（emit）了 change 事件，此时 View 就能够得到新的数据并且重新渲染 如果一个组件要使用 Store，但是没有订阅这个 Store，就会出现问题（BUG） Action 最常见的产生原因实在 App 的某一个部分因用户的交互行为，而被此 View dispatch（派发） 出来了 Flux 与 React 在靠近视图的顶层结构中，有一个特殊的视图层，在这里我们称为视图控制器（View Controller） 它用于从 Store 中获取数据并将数据传递给视图层及其后代，并负责监听 Store 中的数据改变事件 当接受到事件时，首先视图控制器会从 Store 获取最新的数据，并调用自身的 setState 或 forceUpdate 函数，这些函数会触发 View 的 render 与所有后代的 re-render 方法 通常我们会将整个 Store 对象传递到 View 链的顶层，再由 View 的父节点依次传递给后代所需要的 Store 数据，这样能保证后代的组件更加的函数化，减少了 Controller-View 的个数也意味着使更好的性能","link":"/2019/02/22/React/05/"},{"title":"Redux 官方示例剖析","text":"示例参考的是官方提供的 counter-vanilla（见 redux/examples/counter-vanilla/index.html） 1234567891011// reducerfunction counter(state = 0, action) { switch (action.type) { case 'INCREMENT': return state + 1 case 'DECREMENT': return state - 1 default: return state }} Action 一般都是大写字母（约定） 它描述了一个 action 如果使当前 state 改变为下一个 state state 的形式取决于你，它可以是一个基本类型值，可以是一个数组，也可以是一个对象等等 唯一需要注意的就是，永远不要去更改当前的 state，而是应该返回一个新的 state 对象 1var store = Redux.createStore(counter) 首先创建一个 redux 的 store，用它来持有 app 的 store store 的 API 及其简单，就三个，subscribe，dispatch 和 getState subscribe - 让 store 去注册一个视图 dispatch - 分发一个命令 getState - 返回一个状态 1store.subscribe(render) 使用 store 的 subscribe() 方法，将 store 订阅了视图，render 是一个函数 其实简单来说就是，每次当 state 变化的时候就会执行该函数 通常情况下是与 react 来配合使用 调整示例，添加一个每次点击增加 2 的按钮 12345678910111213141516171819202122232425262728// reducerfunction counter(state = 0, action) { switch (action.type) { case 'ADDTWO': return state + 2 default: return state }}// 创建一个 store，有三个方法，subscribe，dispatch 和 getStatevar store = Redux.createStore(counter)// 得到 span 元素var valueEl = document.getElementById('value')// 渲染函数并且调用function render() { valueEl.innerHTML = store.getState().toString()}render()store.subscribe(render)// 加 2document.getElementById('addTwo').onclick = function () { store.dispatch({ type: 'ADDTWO' })} 调整示例，添加一个输入框，然后点击的时候加上输入框内的值 12345678910111213141516function counter(state = 0, action) { switch (action.type) { case 'ADDNUMBER': return state + action.number default: return state }}// ...// 增加输入框内的值document.getElementById('addNumber').onclick = function () { var number = Number(document.getElementById('textNumber').value); store.dispatch({ type: 'ADDNUMBER', number: number })} 综合以上示例，简单来说，点击按钮的时候，使 store 去 disptch 一个命令 这时需要注意了，数据存储在 store 中，然后 store 给自己 dispatch 了一条命令，然后自己再去识别给自己发送的命令（case），然后改变存储在自己 store 中的 state（return） 之所以这样设计，就是因为在 reducer 中可以看见整个程序的 state 会发生怎样的变化，虽然不知道什么时候会变化，但是知道其可以做出什么样的变化，知道其不能够做出什么样的变化 这就是 Redux 的哲学，让 state 可以被预期 这也就是下面的 reducer 存在的意义 12345678910111213141516171819202122232425// reducer 清单function counter(state = 0, action) { switch (action.type) { case 'INCREMENT': return state + 1 case 'ADDNUMBER': return state + action.number case 'DECREMENT': return state - 1 case 'aaa': return state + xxx; case 'bbb': return state - xxx; case 'ccc': return state * xxx; case 'ddd': return state / xxx; // ... default: return state }} 综上： 我们不是直接去修改 state，而是指定了一个简单的 JSON 对象（类似指令，type）去描述我们想要什么事情发生，这个 JSON 称之为 action 然后声明一个特定的 reducer 的函数去指定每一个 action 要如何改变整个 app 的 store 注意这个整个，看下面的示例，先将 state 默认值设置为一个对象（不再是简单的数字） 12345678910111213141516// reducerfunction counter(state, action) { if (state == undefined) { state = { 'm': 5, 'n': 10 } } switch (action.type) { case 'INCREMENT': return state.m + 1 case 'ADDNUMBER': return state.m + action.number default: return state }} 直接使用类似上面的 return state.m + 1 是没有效果的，这时需要返回的是整个 state 的值（建议使用 ES6 中的 ... 运算符）即 123456789101112131415161718192021222324252627282930313233343536// reducerfunction counter(state, action) { if (state == undefined) { state = { 'm': 5, 'n': 10 } } // switch (action.type) { // case 'INCREMENT': // return { 'm': state.m + 1 } // case 'DECREMENT': // return { 'm': state.m - 1 } // case 'ADDNUMBER': // return { 'm': state.m + action.number } // default: // return state // } switch (action.type) { case 'INCREMENT': return { ...state, 'm': state.m + 1 } case 'DECREMENT': return { ...state, 'm': state.m - 1 } case 'ADDNUMBER': return { ...state, 'm': state.m + action.number } default: return state }}// ...// 渲染函数并且调用function render() { valueEl.innerHTML = store.getState().m;}","link":"/2019/03/14/React/07/"},{"title":"React 中的路由","text":"一个最基本的路由，通过 URL 判断进入哪个页面（组件部件） 1234567891011121314151617181920212223242526272829303132333435363738394041class First extends Component { constructor(props) { super(props); } render() { return &lt;p&gt;First&lt;/p&gt; }}class Second extends Component { constructor(props) { super(props); } render() { return &lt;p&gt;Second&lt;/p&gt; }}class App extends Component { constructor(props) { super(props); } render() { return &lt;div&gt;&lt;/div&gt; }}// ...render(( &lt;Router history={hashHistory}&gt; &lt;Route path='/' component={App} /&gt; &lt;Route path='first' component={First} /&gt; &lt;Route path='second' component={Second} /&gt; &lt;/Router&gt;), document.getElementById('box')); 首先，Router 是一个容器，history 属性定义了是用何种方式处理页面的 URL，常用的有三种方式 browserHistory：通过 URL 的变化改变路由，比较推荐的一种方式 hashHistory：通过 #/，其实就像是单页面应用中常见的 hashbang 方式，example.com/#/path/path.. createMemoryHistory：Memory history 并不会从地址栏中操作或是读取，它能够帮助我们完成服务器端的渲染，我们得手动创建 history 对象 然后，在容器中使用 Route 组件定义各个路由，通过 path 指定路径（不区分大小写），通过 component 指定该路径使用的组件 也可以直接在 Router 容器上直接用 routes 属性定义各个路由，如 1234567891011let routes = &lt;div&gt; &lt;Route path='/' component={App} /&gt; &lt;Route path='first' component={First} /&gt; &lt;Route path='second' component={Second} /&gt; &lt;/div&gt;;render( &lt;Router routes={routes} history={hashHistory}&gt;&lt;/Router&gt;, document.getElementById('box')); 需要注意的是 {routes} 中只能有一个父级，所以这里加了 &lt;div&gt; 标签 另外，路由 Route 也可以嵌套，在上面的例子中，嵌套起来可能更符合实际情况 需要注意的是，这里的 App 在父级，为了获取子级的 First 与 Second 组件，需要在 App 组件中添加 this.props.children 获取 1234567891011121314151617181920class App extends Component { constructor(props) { super(props); } render() { return &lt;div&gt;{this.props.children}&lt;/div&gt; }}render(( &lt;Router history={hashHistory}&gt; &lt;Route path='/' component={App}&gt; &lt;Route path='first' component={First} /&gt; &lt;Route path='second' component={Second} /&gt; &lt;/Route&gt; &lt;/Router&gt;), document.getElementById('box')); 同样的，可以直接在 Router 中用 routes 属性定义路由 1234567let routes = &lt;Route path='/' component={App}&gt; &lt;Route path='first' component={First} /&gt; &lt;Route path='second' component={Second} /&gt; &lt;/Route&gt;;render(&lt;Router routes={routes} history={hashHistory}&gt;&lt;/Router&gt;, document.getElementById('box')); 其他组件除了基本的 Route 之外，IndexRoute、Redirect、IndexRedirect、Link、IndexLink 等 IndexRoute: 在主页面会用到，如上个例子中，在路径 '/' 下我们看到的是空白页面，可以添加默认的页面组件用于导航 Link: 可以认为是 &lt;a&gt; 标签在 React 中的实现，使用 to 属性定义路径，还可以通过 activeClass 或 activeStyle 定义 active 的样式 IndexLink: 类似 Link，推荐用来定义指向主页面的链接，当然也可以随意定义 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class First extends Component { constructor(props) { super(props); } render() { return ( &lt;p&gt;First&lt;IndexLink to='/' activeStyle={{ color: 'red' }}&gt;Basic&lt;/IndexLink&gt;&lt;/p&gt; ) }}class Second extends Component { constructor(props) { super(props); } render() { return &lt;p&gt;Second&lt;/p&gt; }}class Basic extends Component { constructor(props) { super(props); } render() { return ( &lt;ul role='nav'&gt; &lt;li&gt;&lt;IndexLink to='/' activeStyle={{ color: 'red' }}&gt;Basic&lt;/IndexLink&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to='/first' activeStyle={{ color: 'red' }}&gt;First&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to='/Second' activeClass='active'&gt;Second&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; ) }}class App extends Component { constructor(props) { super(props); } render() { return &lt;div&gt; {this.props.children} &lt;/div&gt; }}render(( &lt;Router history={hashHistory}&gt; &lt;Route path='/' component={App}&gt; &lt;IndexRoute component={Basic} /&gt; &lt;Route path='first' component={First} /&gt; &lt;Route path='second' component={Second} /&gt; &lt;/Route&gt; &lt;/Router&gt;), document.getElementById('box')); Redirect: 从 from 路径重定向到 to 路径 IndexRedirect: 在主页面，直接重定向到 to 路径 12345678910111213render(( &lt;Router history={hashHistory}&gt; &lt;Route path='/' component={App}&gt; &lt;IndexRoute component={Basic} /&gt; &lt;IndexRedirect to='first' /&gt; &lt;Redirect from='second' to='first' /&gt; &lt;Route path='first' component={First} /&gt; &lt;Route path='second' component={Second} /&gt; &lt;/Route&gt; &lt;/Router&gt;), document.getElementById('box')); path 规则path 定义的路由的路径，在 hashHistory 中，它的主页路径是 #/ 自定义 Route 路由通过与父 Route 的 path 进行合并，在与主页路径合并，得到最终的路径 path 的语法如下 :paramName 匹配 URL 的一个部分，直到遇到下一个 /、?、# () 表示 URL 的这个部分是可选的 * 匹配任意字符（非贪婪模式），直到模式里面的下一个字符为止 ** 匹配任意字符（贪婪模式），直到下一个 /、?、#为止 1234&lt;Route path='/hello/:name'&gt; // 匹配 /hello/abc 和 /hello/def&lt;Route path='/hello(/:name)'&gt; // 匹配 /hello, /hello/abc, 和 /hello/def&lt;Route path='/files/*.*'&gt; // 匹配 /files/hello.jpg 和 /files/hello.html&lt;Route path='/**/*.jpg'&gt; // 匹配 /files/hello.jpg 和 /files/path/to/file.jpg 而 :name 可以通过 this.props.params 中取到 1234567891011121314151617class First extends Component { constructor(props) { super(props); } render() { return ( &lt;p&gt;First {this.props.params.name} &lt;IndexLink to='/' activeStyle={{ color: 'red' }}&gt;Basic&lt;/IndexLink&gt; &lt;/p&gt; ) }}// ...&lt;Route path='/:name' component={First} /&gt; onEnter、onLeave 钩子在路由的跳转中，我们可能需要在进入页面或离开页面的时候做一些特殊操作，Route 通过 onEnter 与 onLeave 定义了这两个行为 1234567&lt;Route path='first' component={First} onEnter={(nextState, replace) =&gt; { console.log(nextState); alert('onEnter'); // replace('second');}} onLeave={() =&gt; { alert('onLeave');}} /&gt; 如上，带两个参数，通过 replace 可以更新路径，把注释去掉后，进入 '/first' 时立马跳转值 '/second'，这在检测登录时应该比较有用","link":"/2019/01/12/React/04/"},{"title":"React-Redux","text":"React-Redux 将所有组件分成两大类，UI 组件（presentational component）和容器组件（container component） UI 组件UI 组件有以下几个特征 只负责 UI 的呈现，不带有任何业务逻辑 没有状态（即不使用 this.state 这个变量） 所有数据都由参数（this.props）提供 不使用任何 Redux 的 API 因为不含有状态，UI 组件又称为纯组件，即它像纯函数一样，纯粹由参数决定它的值 容器组件容器组件的特征恰恰相反 负责管理数据和业务逻辑，不负责 UI 的呈现 带有内部状态 使用 Redux 的 API 总之，只要记住一句话，UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑 在 React-Redux 当中比较常用的 API 就两个，一个是提供的一个组件 &lt;Provider&gt;，另一个就是 connect() 方法 connect()React-Redux 提供 connect 方法，用于从 UI 组件生成容器组件，connect 的意思就是将这两种组件连起来 1234567891011121314151617181920212223242526272829303132333435import { connect } from 'react-redux';const mapStateToProps = (state) =&gt; { return { inputValue: state.inputValue, list: state.list }}const mapDispatchToProps = (dispatch) =&gt; { return { handleInputChange(e) { const action = { type: 'change_input_value', value: e.target.value } dispatch(action); }, handleSubmit() { const action = { type: 'add_todo_item' } dispatch(action); }, handleDelete(index) { const action = { type: 'delete_todo_item', index } dispatch(action); } }}export default connect(mapStateToProps, mapDispatchToProps)(TodoList); 上面代码中，connect 方法接受两个参数，mapStateToProps 和 mapDispatchToProps，它们定义了 UI 组件的业务逻辑 前者负责输入逻辑，即将 state 映射到 UI 组件的参数（props），后者负责输出逻辑，即将用户对 UI 组件的操作映射成 Action connect() 方法有两个比较重要的参数，mapStateToProps 和 mapDispatchToProps（都是函数） mapStateToProps官方解释如下： 如果你传入了这个参数，那么这个组件将会注册 redux 的 store 的更新信息（简单的可以理解为虚拟 DOM 那样，即变化了会自动更新） 即意味着无论什么时候 store 更新了，mapStateToProps 函数将会被调用 mapStateToProps 的返回值必须是一个 plain object（简单的对象），这个对象将和组件的 props 融合，也就是说返回的对象中的 key 将自动成为组件的 props 中的成员（就比如上例中的 App 组件中的参数） 如果不想订阅 store 的更新，可以不用传入该参数，此时使用 null 来占位即可（不能不传） 抛开官方那些比较繁琐的解释，本质上 mapStateToProps() 就是一个函数，它的作用就是建立一个从（外部的）state 对象到（UI 组件的）props 对象的映射关系 作为函数，mapStateToProps 执行后应该返回一个对象，里面的每一个键值对就是一个映射 123456const mapStateToProps = (state) =&gt; { return { inputValue: state.inputValue, list: state.list }} 这个函数内部返回的键值对可以被 connect() 传入的参数组件所拿到（上例中的 App），即 App 组件当中可以拿到传递过去的参数（state）（当作 props 来使用） 而 &lt;/Provider&gt; 中传递的 store 之所以可以被全局使用，也是依靠的这个函数（间接的通过参数传递过去了） 然后最重要的一点就是：它可以得到全局唯一的 store 中的 state mapDispatchToPropsmapDispatchToProps 是 connect 函数的第二个参数，用来建立 UI 组件的参数到 store.dispatch 方法的映射 也就是说，它定义了哪些用户的操作应该当作 Action，传给 Store 官方解释如下： 如果传入了第二个参数，并且是一个函数，那么这个函数将获得 dispatch 方法（可以发出 action，也可以导致 state（store） 改变） 即 connect() 方法第一个参数来获得 state（但是不能修改），第二个参数可以用来修改 state（但是最终都传递回了 App 组件） 它接收参数 dispatch（dispatch 是 store 中用来分发命令的 API，这里简化了），返回一个总的 actions 清单对象 1234567891011121314151617const mapDispatchToProps = (dispatch) =&gt; { return { handleInputChange(e) { const action = { type: 'change_input_value', value: e.target.value } dispatch(action); }, handleSubmit() { const action = { type: 'add_todo_item' } dispatch(action); }, }} &lt;Provider&gt;connect 方法生成容器组件以后，需要让容器组件拿到 state 对象，才能生成 UI 组件的参数 React-Redux 提供 Provider 组件，可以让容器组件拿到 state 12345678910111213import React from 'react';import ReactDOM from 'react-dom';import TodoList from './TodoList';import { Provider } from 'react-redux';import store from './store';const App = ( &lt;Provider store={store}&gt; &lt;TodoList /&gt; &lt;/Provider&gt;)ReactDOM.render(App, document.getElementById('root')); 在上面的示例当中，Provider 在根组件外面包了一层，这样一来 App 的所有子组件就默认都可以拿到 state 了","link":"/2019/03/25/React/08/"},{"title":"Redux、Flux 和 React-Redux 三者之间的区别","text":"三者的区别关系如下： Flux 传统的 redux 简化了 flux 的流程 一般 flux 的流程是： view 触发 action 中的方法 action 发送 dispatch store 接收新的数据进行合并，触发 View 中绑定在 store 上的方法 通过修改局部 state，改变局部 view Redux而 redux 的流程则是： view 直接触发 dispatch 将 action 发送到 reducer 中后，根节点上会更新 props，改变全局 view redux 将 view 和 store 的绑定从手动编码中提取出来，形成了一个统一的规范最后放在了自己的体系中 而在基本的 redux 流程中，action 只是充当了一个类似于 topic 之类的角色（类似 type 属性），reducer 会根据这个 topic 确定需要如何返回新的数据 数据的结构处理也从 store 中移到了 reducer 中 Redux 数据流如下图所示 记住一句话：redux 的基本原理实际上就是围绕着 store 进行的 这个 store 不是 flux 中的 store，而是 redux 提供的 createStore 方法创建的 createStore 方法接收 reducer 函数和初始化的数据（currentState），并将这两个参数并保存在 store 中 createStore 时传入的 reducer 方法会在 store 的 dispatch 被调用的时候再被调用，接收 store 中的 state 和action，根据业务逻辑修改 store 中的 state Storestore 中包含 subscribe()、dispatch()、getState() 和 replaceReducer() 这四个方法 其中，subscribe 和 dispatch 顾名思义就是订阅和发布的功能 subscribe 接收一个回调（listener），当 dispatch 触发时，执行 reducer 函数去修改当前数据（currentState），并执行 subscribe 传入的回调函数（listener） 而 getState 是获取当前 store 的 state(currentState) 至于 replaceReducer方法，就是动态替换 reducer 函数（一般使用较少） Middlewareredux 中的 middleware 简单来说只是针对于 dispatch 方法做了 middleware 处理，也就是说，只接受一个 action 对象，例如官方示例中的 123456const createStoreWithMiddleware = applyMiddleware( thunkMiddleware, loggerMiddleware)(createStore);store = createStoreWithMiddleware(rootReducer, initialState); redux 的 middleware 用 reduceRight 的方法，将 applyMiddleware 方法中的参数串起来，原始的 dispatch 方法会最后执行，比如下图所示： 而如果需要自定义 middleware 只需要注意这个 middleware 只接收一个 action，执行后也需要返回一个 action，如果需要执行下一步，调用 next(action) 即可 React-Reduxreact-redux，是对 redux 流程的一种封装，使其可以适配与 react 的代码结构 react-redux 首先提供了一个 Provider 组件（用来包裹），可以将从 createStore 返回的 store 放入 context 中，使子集可以获取到 store 并进行操作 123&lt;Provider store={store}&gt; {() =&gt; &lt;App /&gt;}&lt;/Provider&gt; 大致逻辑如下 首先 react-redux 提供了 connect 方法，将原始根节点包装在 Connect 下，在 Connect 中的 state 存储不可变对象，并将 state 对象中的 props 和 store 中的 dispatch 函数传递给原始根节点 Connect 在 componentDidMount 中，给 store 添加 listener 方法（handleChange），每当 store 中的 dispatch 被调用时执行 handleChange 而 handleChange 会去修改 state 中的 porps，使原始根节点重新 render，并且 Connect 已经在 shouldComponentUpdate 实现了 PureRender 功能 handleChange 更新 state 中的 props 逻辑主要由三个函数构成，这三个函数都由 connect 方法传入（前两个参数用的较多） 12345connect( mapStateToProps, mapDispatchToProps, mergeToProps)(App); 第一个函数接收 store 中 state 和 props，使页面可以根据当前的 store 中 state 和 props返回新的 stateProps 第二个函数接收 store 中的 dispatch 和 props，使页面可以复写 dispatch 方法，返回新的 dispatchProps 第三个函数接收前两个函数生成的 stateProps 和 dispatchProps，在加上原始的 props 合并成新的 props 并传给原始根节点的 props React-Redux 中的流程如下图 首先 View 触发 dispatch 然后进入 reducer，修改 store 中的 state ，再将新的 state 和 props 传入 handleChange 中，生成更符合页面的 props，最后传给原始根节点重新 render","link":"/2019/04/02/React/09/"},{"title":"reducer、函数式编程，以及数组中的 reduce() 方法","text":"注意区分三者的区别 纯函数（reducer）在 reducer 中指定状态数据转换的逻辑，一般都是依靠着纯函数来改变数据 即每次传入一个 state 和 action，得到的 state 都是确定的，可以预测的 1(state, action) =&gt; state 所谓的纯函数即不产生副作用的函数 相同的输入，结果始终相同 不对外部环境进行操作 比如下面三种情况都不能属于纯函数 函数体中调用了 Math.random()（随机性） 函数体中调用了 Date.now()（随机性） 还有下面这种，调用了不确定的外部变量 12345var a = 0;function do(b) { return a + b}; 函数式编程一个简单的例子 123456789101112131415car = driveForward(car);car = stop(car);car = removePassenger(car, passenger);// ==&gt;car = removePassenger(stop(driveForward(car)), passenger);// ==&gt;function uber(car, passenger) { return removePassenger(stop(driveForward(car)), passenger);}car = uber(car, passenger); 再来看一个示例 12345678910111213141516171819202122232425var next = 1;var otherVar;function next() { otherVar = doSomeThing(); return next++;}it('gets the next number', function () { expect(next().toBe(1))})// 这种情况下 next 的值是被改变了的，可以换成下面的写法function next() { return current + 1;}it('gets the next number', function () { var current = 1; expect(next(current)).toBe(2) // current 的值并没有改变 expect(current).toBe(1)}) 为什么要这样使用，有以下几个原因 结果总是可以预见的 更容易理解 app 的逻辑 更容易进行单元测试，不依赖外部的环境，不调用外部的变量 组件、工具函数高度分离，很容易复用、复合 数组中的 reduce() 方法reduce() 方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始缩减，最终为一个值 1arr.reduce(callback, [initialValue]) 它接收两个参数，callback 和 initialValue callback 参数，表示执行数组中每个值的函数，包含四个参数 previousValue 上一次调用回调返回的值，或者是提供的初始值（initialValue） currentValue 数组中当前被处理的元素 index 当前元素在数组中的索引 array 调用 reduce 的数组 initialValue 参数，表示作为第一次调用 callback 的第一个参数 reduce 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：初始值（或者上一次回调函数的返回值），当前元素值，当前索引，以及调用 reduce 的数组 回调函数第一次执行时，previousValue 和 currentValue 可以是一个值 如果 initialValue 在调用 reduce 时被提供，那么第一个 previousValue 等于 initialValue ，并且 currentValue 等于数组中的第一个值 如果 initialValue 未被提供，那么 previousValue 等于数组中的第一个值，currentValue 等于数组中的第二个值 例如执行下面的代码 123[0, 1, 2, 3, 4].reduce(function (previousValue, currentValue, index, array) { return previousValue + currentValue;}); 回调被执行四次，每次的参数和返回值如下表： previousValue currentValue index array return value first call 0 1 1 [0, 1, 2, 3, 4] 1 second call 1 2 2 [0, 1, 2, 3, 4] 3 third call 3 3 3 [0, 1, 2, 3, 4] 6 fourth call 6 4 4 [0, 1, 2, 3, 4] 10 reduce 的返回值是回调函数最后一次被调用的返回值（10） 如果把初始值作为第二个参数传入 reduce，最终返回值变为 20，结果如下： 123[0, 1, 2, 3, 4].reduce(function (previousValue, currentValue, index, array) { return previousValue + currentValue;}, 10); previousValue currentValue index array return value first call 10 0 0 [0, 1, 2, 3, 4] 10 second call 10 1 1 [0, 1, 2, 3, 4] 11 third call 11 2 2 [0, 1, 2, 3, 4] 13 fourth call 13 3 3 [0, 1, 2, 3, 4] 16 fifth call 16 4 4 [0, 1, 2, 3, 4] 20 比如一个将数组所有项相加的例子 1234// 结果为 6var total = [0, 1, 2, 3].reduce(function (a, b) { return a + b;});","link":"/2019/04/03/React/10/"},{"title":"Redux 源码初探","text":"先来看看 Redux 的源码目录，如下所示 12345678├── utils/│ ├── warning.js // 控制台显示警告信息├── applyMiddleware.js├── bindActionCreators.js├── combineReducers.js├── compose.js├── createStore.js├── index.js // 入口文件 可以发现，除开 index 和 warning 以外，剩余的五个就是 Redux 的 API，下面一个一个来看 compose(…functions)compose() 方法没有任何依赖，是一个纯函数 12345678910111213141516171819202122232425/** * 使用方法为： * compose(f, g, h)(...arg) =&gt; f(g(h(...args))) * * 值得注意的是，它用到了 reduceRight，因此执行顺序是 从右到左 * * ==》 reduceRight() 方法的功能和 reduce() 功能是一样的 * 不同的是 reduceRight() 从数组的末尾向前将数组中的数组项做累加 * * @param {多个函数，用逗号隔开} * @return {函数} */export default function compose(...funcs) { if (funcs.length === 0) { return arg =&gt; arg } if (funcs.length === 1) { return funcs[0] } const last = funcs[funcs.length - 1] const rest = funcs.slice(0, -1) return (...args) =&gt; rest.reduceRight((composed, f) =&gt; f(composed), last(...args))} 这里的关键点在于，可传入初始值，因为 reduce/reduceRight 仅仅是方向的不同 123456789101112131415var arr = [1, 2, 3, 4, 5];var re1 = arr.reduce(function (total, i) { return total + i});console.log(re1); // 15// ==================================var re2 = arr.reduce(function (total, i) { return total + i}, 100);console.log(re2); // 115 一个比较完整的示例 123456789101112131415161718192021222324252627282930313233343536function func1(num) { console.log('func1 获得参数 ' + num); return num + 1;}function func2(num) { console.log('func2 获得参数 ' + num); return num + 2;}function func3(num) { console.log('func3 获得参数 ' + num); return num + 3;}var re1 = func3(func2(func1(0)));console.log('re1：' + re1);console.log('===============');// 使用 redux 提供的 compose() 方法var re2 = Redux.compose(func3, func2, func1)(0);console.log('re2：' + re2);// ===============================================// 执行结果如下// func1 获得参数 0// func2 获得参数 1// func3 获得参数 3// re1：6// ===============// func1 获得参数 0// func2 获得参数 1// func3 获得参数 3// re2：6 combineReducers(reducers)因为在 flux 中是根据不同的功能拆分出多个 store 分而治之 而 Redux 只允许应用中有唯一的 store，通过拆分出多个 reducer 分别管理对应的 state 简单来说，这个函数的作用就是通过逐层下分管理对应部分的 state（拆分 state，各个模块管理自己的 state，最后合并） 无论是 dispatch 哪个 action，都会流通所有的 reducer 这也是为何 reducer 必须返回其对应的 state 的原因（否则整合状态树时，该 reducer 对应的键值就是 undefined） 12345678910111213141516171819202122232425262728function combineReducers(reducers) { var reducerKeys = Object.keys(reducers) var finalReducers = {} for (var i = 0; i &lt; reducerKeys.length; i++) { var key = reducerKeys[i] if (typeof reducers[key] === 'function') { finalReducers[key] = reducers[key] } } var finalReducerKeys = Object.keys(finalReducers) // 返回合成后的 reducer return function combination(state = {}, action) { var hasChanged = false var nextState = {} for (var i = 0; i &lt; finalReducerKeys.length; i++) { var key = finalReducerKeys[i] var reducer = finalReducers[key] var previousStateForKey = state[key] // 获取当前子 state var nextStateForKey = reducer(previousStateForKey, action) // 执行各子 reducer 中获取子 nextState nextState[key] = nextStateForKey // 将子 nextState 挂载到对应的键名 hasChanged = hasChanged || nextStateForKey !== previousStateForKey } return hasChanged ? nextState : state }} bindActionCreators(actionCreators, dispatch)这个函数主要用于分发 action（比如使用 dispatch(ActionCreator(...))），实现自动 dispatch 123456789101112131415161718192021// 为 Action Creator 加装上自动 dispatch 功能function bindActionCreator(actionCreator, dispatch) { return (...args) =&gt; dispatch(actionCreator(...args))}export default function bindActionCreators(actionCreators, dispatch) { // 类型判断... var keys = Object.keys(actionCreators) var boundActionCreators = {} for (var i = 0; i &lt; keys.length; i++) { var key = keys[i] var actionCreator = actionCreators[key] if (typeof actionCreator === 'function') { // 逐个装上自动 dispatch 技能 boundActionCreators[key] = bindActionCreator(actionCreator, dispatch) } } return boundActionCreators} createStore()源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193import isPlainObject from 'lodash/isPlainObject'import $$observable from 'symbol-observable'// Redux 的私有 action 常量export var ActionTypes = { INIT: '@@redux/INIT'}/** * @param {函数} reducer 不多解释了 * @param {对象} preloadedState 主要用于前后端同构时的数据同步 * @param {函数} enhancer 很牛逼，可以实现中间件、时间旅行，持久化等 * @return {Store} * * ==&gt; Redux 仅提供 applyMiddleware 这个 Store Enhancer */export default function createStore(reducer, preloadedState, enhancer) { // 省略部分代码，后续会用到 // 这里的代码用于中间件（判断），见后面的 applyMiddleware(...middlewares) var currentReducer = reducer var currentState = preloadedState // 这就是整个应用的 state var currentListeners = [] // 用于存储订阅的回调函数，dispatch 后逐个执行 var nextListeners = currentListeners // 至于为什么使用两个存放回调函数的变量，见下方 var isDispatching = false /** * 之所以使用两个存放回调函数的变量 * * 有这样一种情况，试想在 dispatch 后，回调函数正在被逐个执行（for 循环进行时） * 假设回调函数队列原本是这样的 [a, b, c, d] * * 现在 for 循环执行到第 3 步，亦即 a、b 已经被执行，准备执行 c * 但是此时 a 被取消订阅，那么此时回调函数队列就变成了 [b, c, d] * 那么第 3 步就对应换成了 d * * 为了避免这个问题，本函数会在上述场景中把 * currentListeners 复制给 nextListeners * * 这样的话，dispatch 后，在逐个执行回调函数的过程中 * 如果有新增订阅或取消订阅，都在 nextListeners 中操作 * 让 currentListeners 中的回调函数得以完整地执行 * * 既然新增是在 nextListeners 中 push，因此毫无疑问 * 新的回调函数不会在本次 currentListeners 的循环体中被触发 * * =================================================================== * * 简单总结就是： * currentListeners 中的回调函数依次完整地执行 * 而如果有新增订阅或取消订阅，都在 nextListeners 中操作 * */ // 这个函数的作用就是避免发生上述情况 ============ ① function ensureCanMutateNextListeners() { if (nextListeners === currentListeners) { nextListeners = currentListeners.slice() } } /** * 返回 state */ function getState() { return currentState } /** * 这里需要注意的就是，回调函数中如果需要获取 state，请每次都使用 getState() 来获取（而不是开头用一个变量缓存住它） * 因为回调函数执行期间，有可能有连续几个 dispatch 让 state 改得物是人非 * 而且别忘了，dispatch 之后，整个 state 是被完全替换掉的 * * @param {函数} 想要订阅的回调函数 * @return {函数} 取消订阅的函数 */ function subscribe(listener) { if (typeof listener !== 'function') { throw new Error('Expected listener to be a function.') } var isSubscribed = true // 避免 ① 的情况 ensureCanMutateNextListeners() // 新增订阅在 nextListeners 中操作 nextListeners.push(listener) // 返回一个取消订阅的函数 return function unsubscribe() { if (!isSubscribed) { return } isSubscribed = false // 避免 ① 的情况 ensureCanMutateNextListeners() var index = nextListeners.indexOf(listener) // 取消订阅还是在 nextListeners 中操作 nextListeners.splice(index, 1) } } /** * 用于改变应用状态（不要直接修改 state，而是 dispatch 一个 action） * * 内部的实现是：往 reducer 中传入 currentState 以及 action * 用其返回值替换 currentState，最后逐个触发回调函数 * * 如果 dispatch 的不是一个对象类型的 action（同步的），而是 Promise/thunk（异步的） * 则需引入 redux-thunk 等中间件来反转控制权（见下方） * * @param &amp; @return {对象} action */ function dispatch(action) { if (!isPlainObject(action)) { throw new Error( 'Actions must be plain objects. ' + 'Use custom middleware for async actions.' ) } if (typeof action.type === 'undefined') { throw new Error( 'Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?' ) } if (isDispatching) { throw new Error('Reducers may not dispatch actions.') } try { isDispatching = true // 关键点：currentState 与 action 会流通到所有的 reducer // 所有 reducer 的返回值整合后，替换掉当前的 currentState // 简单来说：往 reducer 中传入 currentState 以及 action currentState = currentReducer(currentState, action) } finally { isDispatching = false } // 令 currentListeners 等于 nextListeners，表示正在逐个执行回调函数（这就是上面 ① 中的判定条件） var listeners = currentListeners = nextListeners // 逐个触发回调函数 for (var i = 0; i &lt; listeners.length; i++) { listeners[i]() } return action // 为了方便链式调用，dispatch 执行完毕后，返回 action } /** * 主要用于代码分离按需加载、热替换等情况（这个用的较少） * * @param {函数} nextReducer */ function replaceReducer(nextReducer) { if (typeof nextReducer !== 'function') { throw new Error('Expected the nextReducer to be a function.') } // 就直接把传入的 nextReducer 赋给 currentReducer currentReducer = nextReducer // 触发生成新的 state 树 dispatch({ type: ActionTypes.INIT }) } /** * 这是留给 可观察/响应式库 的接口（详情 https://github.com/zenparsing/es-observable） * 扩展可见：rxjs * @return {observable} */ function observable() { 略 } // 这里 dispatch 只是为了生成 应用初始状态 dispatch({ type: ActionTypes.INIT }) return { dispatch, subscribe, getState, replaceReducer, [$$observable]: observable }} 反转控制权所谓的反转控制权即 在同步场景下，dispatch(action) 的这个 action 中的数据是同步获取的，并没有控制权的切换问题 但异步场景下，则需要将 dispatch 传入到回调函数，待异步操作完成后，回调函数自行调用 dispatch(action) 简单来说就是：在异步 Action Creator 中自行调用 dispatch 就相当于反转控制权 它们的作用也仅仅就是把 dispatch 等传入异步 Action Creator 罢了 applyMiddleware(…middlewares)在此之前，先来看看 middleware 本质上，Redux 引入中间件机制，其实就是为了将在 dispatch 前后所做的事情统一起来 诸如统一的日志记录、引入 thunk 统一处理异步 Action Creator 等都属于中间件，比如下面就是一个简单的打印动作前后 state 的中间件 1234567891011121314151617181920212223242526272829// 比较优雅的写法const printStateMiddleware = ({ getState }) =&gt; next =&gt; action =&gt; { console.log('state before dispatch', getState()) let returnValue = next(action) console.log('state after dispatch', getState()) return returnValue}// 一般的写法function printStateMiddleware(middlewareAPI) { // ① &lt;== 中间件内可用的 API return function (dispatch) { // ② &lt;== 传入上级中间件处理逻辑（若无则为原 store.dispatch） // ③ &lt;== 整个函数将会被传到下级中间件（如果有的话）作为它的 dispatch 参数 return function (action) { console.log('state before dispatch', middlewareAPI.getState()) // dispatch 的返回值其实还是 action var returnValue = dispatch(action) console.log('state after dispatch', middlewareAPI.getState()) // 将 action 返回给上一个中间件（实际上可以返回任意值，或不返回） return returnValue } }} Store Enhancer（增强器）Store 增强器就是对生成的 store API 进行改造，这是它与中间件最大的区别（中间件不修改 store 的 API） 而改造 store 的 API 就要从它的缔造者 createStore 入手，例如 Redux 的 applyMiddleware 就是一个 Store 增强器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 这个函数前面有提到过，其实就是 compose(f, g, h)(action) ====&gt; f(g(h(action)))import compose from './compose'// 传入中间件export default function applyMiddleware(...middlewares) { // 传入 createStore return function (createStore) { // 返回一个函数签名跟 createStore 一模一样的函数，即返回的是一个增强版的 createStore return function (reducer, preloadedState, enhancer) { // 用原 createStore 先生成一个 store，其包含 getState / dispatch / subscribe / replaceReducer 四个 API var store = createStore(reducer, preloadedState, enhancer) var dispatch = store.dispatch // 指向原 dispatch var chain = [] // 存储中间件的数组 // 提供给中间件的 API（其实都是 store 的 API） var middlewareAPI = { getState: store.getState, dispatch: (action) =&gt; dispatch(action) } // 给中间件 \"组装上\" API，见上面的 ① chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)) // 串联所有中间件 dispatch = compose(...chain)(store.dispatch) // 例如，chain 为 [M3, M2, M1]，而 compose 是从右到左进行 \"包裹\" 的，那么 // M1 的 dispatch 参数为 store.dispatch // M2 的 dispatch 参数为 M1 的 ② // M3 的 dispatch 参数为 M2 的 ② // 最后，我们得到串联后的中间件链：M3(M2(M1(store.dispatch))) // 也就是所谓的：中间件的洋葱模型 return { ...store, // store 的 API 中保留 getState/subsribe/replaceReducer dispatch // 新 dispatch 覆盖原 dispatch，往后调用 dispatch 就会触发 chain 内的中间件链式串联执行 } } }} 其实最终返回的虽然还是 store 的那四个 API，但其中的 dispatch 函数的功能被增强了，这就是所谓的 Store Enhancer 一个综合案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function inc() { return { type: 'INCREMENT' };}function dec() { return { type: 'DECREMENT' };}function reducer(state, action) { state = state || { counter: 0 }; switch (action.type) { case 'INCREMENT': return { counter: state.counter + 1 }; case 'DECREMENT': return { counter: state.counter - 1 }; default: return state; }}// 见上方function printStateMiddleware(middlewareAPI) { return function (dispatch) { return function (action) { console.log('dispatch 前：', middlewareAPI.getState()); var returnValue = dispatch(action); console.log('dispatch 后：', middlewareAPI.getState(), '\\n'); return returnValue; }; };}var enhancedCreateStore = Redux.applyMiddleware(printStateMiddleware)(Redux.createStore);var store = enhancedCreateStore(reducer);store.dispatch(inc());store.dispatch(inc());store.dispatch(dec());// ============================================// 输出结果为// dispatch 前：{ counter: 0 }// dispatch 后：{ counter: 1 }// dispatch 前：{ counter: 1 }// dispatch 后：{ counter: 2 }// dispatch 前：{ counter: 2 }// dispatch 后：{ counter: 1 } 上述的案例中，生成 store 的代码中其实可以将中间件放到 createStore 中 1234var store = Redux.createStore( reducer, Redux.applyMiddleware(printStateMiddleware)) 如果有多个中间件以及多个增强器，还可以这样写 12345678910111213141516import { createStore, applyMiddleware, compose } from 'redux'const store = createStore( reducer, preloadedState, // 可选参数，前后端同构的数据同步 compose( // 顺序是从右到左 applyMiddleware( // 关乎中间件的增强器，必须置于 compose 执行链的最后 middleware1, middleware2, middleware3 ), enhancer3, enhancer2, enhancer1 )) 之所以可以这样使用，是因为在 createStore 的源码的开头部分 1234567891011121314151617181920212223242526export default function createStore(reducer, preloadedState, enhancer) { // ... if (typeof preloadedState === 'function' &amp;&amp; typeof enhancer === 'undefined') { // 只传入 reducer 和 Store Enhancer 这两个参数的情况 enhancer = preloadedState preloadedState = undefined } if (typeof enhancer !== 'undefined') { if (typeof enhancer !== 'function') { throw new Error('Expected the enhancer to be a function.') } // 存在 enhancer 就立即执行，返回增强版的 createStore &lt;== 注① return enhancer(createStore)(reducer, preloadedState) } if (typeof reducer !== 'function') { throw new Error('Expected the reducer to be a function.') } // ...} 如果有多个中间件以及多个增强器（有多个 enhancer），则注①中的代码会执行多次，生成最终的超级增强版 store 比如上例中 compose 内部的执行顺序示意图 123456789101112131415161718192021原 createStore ———— │ ↓return enhancer1(createStore)(reducer, preloadedState, enhancer2) | ├———————→ createStore 增强版 1 │ ↓return enhancer2(createStore1)(reducer, preloadedState, enhancer3) | ├———————————→ createStore 增强版 1 + 2 │ ↓return enhancer3(createStore1 + 2)(reducer, preloadedState, applyMiddleware(m1, m2, m3)) | ├————————————————————→ createStore 增强版 1 + 2 + 3 │ ↓return appleMiddleware(m1, m2, m3)(createStore1 + 2 + 3)(reducer, preloadedState) | ├——————————————————————————————————→ 生成最终增强版 store","link":"/2019/06/05/React/11/"},{"title":"Vue 中一些容易忽视的知识点","text":"主要记录一些在使用 Vue 开发过程中容易忽视的知识点 用 key 管理可复用的元素比如 123456789&lt;template v-if=\"loginType === 'username'\"&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder=\"Enter your username\"&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder=\"Enter your email address\"&gt;&lt;/template&gt; 上面的代码中切换 loginType 将不会清除已经输入的内容 因为两个模板使用了相同的元素，input 不会被替换掉——仅仅是替换了它的 placeholder 如果要解决这种问题，只需添加一个具有唯一值的 key 属性即可 123456789&lt;template v-if=\"loginType === 'username'\"&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder=\"Enter your username\" key=\"username-input\"&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder=\"Enter your email address\" key=\"email-input\"&gt;&lt;/template&gt; 替换数组由于 JavaScript 的限制，Vue 不能检测以下变动的数组 当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue 当你修改数组的长度时，例如：vm.items.length = newLength 为了解决第一类问题，以下两种方式都可以实现和 vm.items[indexOfItem] = newValue 相同的效果，同时也将触发状态更新 1Vue.set(app.items, indexOfItem, newValue) 1app.items.splice(indexOfItem, 1, newValue) 为了解决第二类问题，可以使用 splice 1app.items.splice(newLength) 对象更改检测注意事项由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除 123456789var vm = new Vue({ data: { // vm.a 现在是响应的 a: 1 }})// vm.b 不是响应的vm.b = 2; 对于已经创建的实例，Vue 不能动态添加根级别的响应式属性，但是可以使用 Vue.set(object, key, value) 方法向嵌套对象添加响应式属性 12345678910111213var vm = new Vue({ data: { userProfile: { name: 'zhangsan' } }})// 添加一个新的响应属性 ageVue.set(vm.userProfile, 'age', 22)// 也可以使用 vm.$set 实例方法vm.$set(this.userProfile, 'age', 22) 有时可能需要为已有对象赋予多个新属性，比如使用 Object.assign() 或者 _.extend() 在这种情况下，应该用两个对象的属性创建一个新的对象 1234567891011// 不要像这样Object.assign(this.userProfile, { age: 22, favoriteColor: 'Vue Green'})// 而是像这样this.userProfile = Object.assign({}, this.userProfile, { age: 22, favoriteColor: 'Vue Green'}) 特殊的 is 特性当使用 DOM 作为模板时（例如，使用 el 选项来把 Vue 实例挂载到一个已有内容的元素上），你会受到 HTML 本身的一些限制 因为 Vue 只有在浏览器解析、规范化模板之后才能获取其内容 尤其要注意，像 ul、ol、table、select 这样的元素里允许包含的元素有限制，而另一些像 option 这样的元素只能出现在某些特定元素的内部 在自定义组件中使用这些受限制的元素时会导致一些问题，例如： 123&lt;table&gt; &lt;my-row&gt;...&lt;/my-row&gt;&lt;/table&gt; 自定义组件 my-row 会被当作无效的内容，因此会导致错误的渲染结果，变通的方案是使用特殊的 is 特性 123&lt;table&gt; &lt;tr is=\"my-row\"&gt;&lt;/tr&gt;&lt;/table&gt; 应当注意，如果使用来自以下来源之一的字符串模板，则没有这些限制： &lt;script type=&quot;text/x-template&quot;&gt; JavaScript 内联模板字符串 .vue 组件 因此，请尽可能使用字符串模板","link":"/2018/04/11/Vue/01/"},{"title":"Vue 中的 Mixin","text":"有一种很常见的情况：有两个非常相似的组件，他们的基本功能是一样的，但他们之间又存在着足够的差异性 在这种情况下就可以选择使用 Mixin 示例有两个不同的提示组件，它们的作用都是通过切换状态（Boolean 类型）来展示或者隐藏模态框或提示框 除了功能相似，没有其他共同点，看起来不一样，用法不一样，但是逻辑是一样的 1234567891011121314151617181920212223242526272829303132333435// 模态框const Modal = { template: '#Modal', data() { return { isShow: false } }, methods: { toggleShow() { this.isShow = !this.isShow; } }, components: { appChild: Child }}// 提示框const Tooltip = { template: '#Tooltip', data() { return { isShow: false } }, methods: { toggleShow() { this.isShow = !this.isShow; } }, components: { appChild: Child }} 这里就可以使用 Mixin 来提取可以被重用的地方 12345678910111213141516171819202122232425262728const toggle = { data() { return { isShow: false } }, methods: { toggleShow() { this.isShow = !this.isShow; } }}const Modal = { template: '#Modal', mixins: [toggle], components: { appChild: Child }}const Tooltip = { template: '#Tooltip', mixins: [toggle], components: { appChild: Child }} 完整示例可以见 Sarah Drasner 提供的 Mixin 的例子 如果在项目当中使用的话，也是同样的操作 1234567891011// 引入 Child 和 Mixinimport Child from './Child'import { toggle } from \"./toggle\"export default { name: 'modal', mixins: [toggle], components: { appChild: Child }} 埋点应用一个比较通用的需求，在用户进入页面和离开页面的时候记录记录在当前页面的停留时间 使用 Mixin， 简化代码如下 123456789101112131415161718192021222324252627282930313233343536373839// mixin.jslet cache = null;export default { methods: { sendEnterPage() { cache = this.$router console.log('enter page', cache) }, sendLeavePage() { console.log('leave page', cache) } }, mounted() { this.sendEnterPage() }, destroyed() { this.sendLeavePage() }}// 使用import sendPage from './mixin'export default { data() { return { text: 'hello world' } }, mixins: [sendPage], methods: { logic() { console.log('do the logic about hello page') } }, mounted() { this.logic() }} 使用局部的 mixin 可以发现，mounted，destroyed 等组件中的生命周期方法与 mixin 是合并的 而 methods 当中的方法则是覆盖的，具体是通过 mergeOptions 方法实现的","link":"/2018/04/15/Vue/02/"},{"title":"在 Vue 中使用 jsx","text":"平常在写 vue 组件的时候一般使用的都是模版，但是在一些需要自定义内容的场景下就会用到 vue 中的 render 函数 但是 render 函数的语法非常繁琐，通常一个非常简单的模版在写成 render 函数之后就会变得十分繁琐 所以可以采用 jsx 的语法来进行编写 在使用 jsx 之前需要安装一个 babel 插件 babel-plugin-transform-vue-jsx 如果是使用 vue-cli 构建的项目的话，只需要安装下面三个依赖 12345npm install\\ babel-plugin-syntax-jsx\\ babel-plugin-transform-vue-jsx\\ babel-helper-vue-jsx-merge-props\\ --save-dev 然后在 .babelrc 文件当中配置一下即可 1'plugins': ['transform-runtime', 'transform-vue-jsx'], 简单示例配置完成之后，我们就可以在 vue 当中编写 jsx 了 1234567891011121314151617// test 组件export default { props: ['onClick', 'isShow'], data() { return { test: 123 } }, render() { return ( &lt;div class='test' onClick={this.onClick}&gt; {this.test} {this.isShow + ''} &lt;/div&gt; ) }} 需要注意的几点： render 方法是 vue 2.0 才支持的 vue 当中的 jsx 语法和 react 当中的 jsx 语法存在一定的区别 下面是一个涵盖大部分 vue jsx 语法的示例： 12345678910111213141516render(h) { return ( &lt;div id='foo' domPropsInnerHTML='bar' onClick={this.clickHandle} nativeOnClick={this.nativeClickHandle} class={{ foo: true, bar: false }} style={{ color: 'red', fontSize: '14px' }} key='key' ref='ref' refInFor slot='slot' &gt;&lt;/div&gt; )} DOM 属性需要加上 domProps 前缀（style 等不需要） react 使用的是 className，vue 使用的是 class 事件监听是以 on 或 nativeOn 开头 经过编译后为： 12345678910111213141516171819202122232425262728render(h) { return h('div', { attrs: { id: 'foo' }, domProps: { innerHTML: 'bar' }, on: { click: this.clickHandler }, nativeOn: { click: this.nativeClickHandler }, class: { foo: true, bar: false }, style: { color: 'red', fontSize: '14px' }, key: 'key', ref: 'ref', refInFor: true, slot: 'slot' })} 注意事项 在模板中引入 jsx 的组件，可以通过 components 引用，另外 props 的编写从驼峰变为连接符 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div class='wrapper'&gt; &lt;Text :on-click='clickHandle' :is-show='show' &gt;&lt;/Text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Test from './Test.vue' export default { name: 'hello', components: { Test }, data() { return { msg: 'welcome', show: true } }, methods: { clickHandle() { this.show = !this.show; } } }&lt;/script&gt; 如果反之，即在 jsx 里面引入 vue 模版组件，除了连接符的属性转换为驼峰式，还有一个需要注意的就是指令 如果使用了 jsx，那么内置的指令都不会生效（除了 v-show） 可以手动使用 jsx 来进行描述，使用 v-name={value} 语法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;script&gt;import Vue from 'vue'Vue.directives('my-directive', { inserted: function(el) { el.style.fontWeight = 900 }})export default { props: ['onClick', 'isShow'], data() { return { test: 123 } }, methods: { afterLeave() { console.log('afterLeave') } }, render() { const directives = [{ name: 'my-directive', value: 666, modifiers: { abc: true } }]; return ( &lt;transition onAfterLeave={this.afterLeave} name='fade'&gt; &lt;div class='test' onClick={this.onClick} v-show={this.isShow} v-my-directive &gt; { this.test } { this.isShow + '' } &lt;/div&gt; &lt;/transition&gt; ) }}&lt;/script&gt;&lt;style&gt;.fade-enter-active, .fade-leave-active { transition: opacity .5s}.fade-enter, .fade-leave-to { opacity: 0}&lt;/style&gt; 还可以用原生 vNode 的数据格式使用自定义指令 12345const directives = [ { name: 'my-dir', value: 123, modifiers: { abc: true } }] return &lt;div {...{ directives }}/&gt; 简化 Vue 中的 createElement 嵌套写法的函数一般用于创建带有附加元素的组件，比如 Tooltip 等，代码如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 简化 createElement 嵌套写法class VNode { constructor(tag, props = {}, children = []) { // 初始化容器，传递过来的 props 和子元素 this.tag = tag this.props = props this.children = children } // 用于添加子元素 push(vnode) { if (this.isArray(vnode)) { this.children.push(...vnode) } else { if (vnode) { this.children.push(vnode) } } return this } isArray(o) { return Object.prototype.toString.call(o) === '[object Array]' } // 渲染 resolve(h) { var children = this.children.map(child =&gt; { if (child instanceof VNode) { return child.resolve(h) } else { return child } }) return h(this.tag, this.props, children) }}// div.dy-tooltip-popup ==&gt; [div, dy-tooltip-popup]function createElement(tag, props = {}, children = []) { if (tag.indexOf('.') !== -1) { var [realTag, className] = tag.split('.') tag = realTag if (className !== '') { var classList = className.split() if (!props['class']) { props['class'] = {} } classList.forEach(el =&gt; { props['class'][el.trim()] = true }) } } return new VNode(tag, props, children)}export { createElement} 使用方式如下： 12345678910111213141516171819import { createElement } from './createElement'// ...render(h) { var $wrapper = createElement('div.dy-tooltip-popup', { style: { top: this.top + 'px', left: this.left + 'px', visibility: this.visibility, opacity: this.opacity }, // 用于标记 Tooltip 弹出方向，这里可以忽略 attrs: { 'x-placement': this.placement } }).push(createElement('div.dy-tooltip-popup-inner', {}, [this.content])) return $wrapper.resolve(h)} 完整代码可见 ToolTip","link":"/2018/04/29/Vue/03/"},{"title":"axios 中跨域访问的问题","text":"一般分为两种情况 服务端不支持跨域比如在开发过程中遇到下面这种情况 12No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'http://xxx.com' is therefore not allowed access. 这种情况可以在服务端修改相关配置支持跨域即可亦或是使用 webpack 提供的 proxyTable 12345678// 在 config/index.js 中的 proxyTable 中添加proxyTable: { '/WebService.asmx': { target: 'http://localhost:8080/jsnf_service/', logLevel: 'debug', changeOrigin: true }}, 这样就可以正常使用 axios 进行 Ajax 请求了，但是这样只能在开发模式下使用，打包部署的时候可以使用 nginx 做代理来解决 服务端支持跨域这里又分为两种情况 一种是服务端支持跨域，但是不能响应 OPTIONS 请求 这种情况一般说明 Nginx 不能响应 OPTIONS 请求，比如在控制台当中看到的以下信息 12345General Request URL: http://... Request Method: OPTIONS Status Code: 405 Not Allowed // ... 出现 OPTIONS 请求的原因 http 访问控制（CORS） 跨源资源共享标准通过新增一系列 http 头，让服务器能声明哪些来源可以通过浏览器访问该服务器上的资源 另外，对那些会对服务器数据造成破坏性影响的 http 请求方法（特别是 GET 以外的 http 方法，或者搭配某些 MIME 类型的 POST 请求） 标准强烈要求浏览器必须先以 OPTIONS 请求方式发送一个预请求（preflight request），从而获知服务器端对跨源请求所支持 http 方法 在确认服务器允许该跨源请求的情况下，以实际的 http 请求方法发送那个真正的请求 服务器端也可以通知客户端，是不是需要随同请求一起发送信用信息（包括 Cookies 和 http 认证相关数据） 解决方法： 如果服务端支持简单请求所谓的简单请求： 只使用 GET，HEAD 或者 POST 请求方法 如果使用 POST 向服务器端传送数据，则数据类型（Content-Type）只能是 application/x-www-form-urlencoded，multipart/form-data 或 text/plain 中的一种 不会使用自定义请求头（类似于 X-Modified 这种） 可以使用官方提供的解决方式，见 Using application/x-www-form-urlencoded format 另外一种情况如果服务器端支持跨域，那么可以采用 JSONP 来进行请求 jsonp 实际上就是通过添加 script 标签来添加的，请求回来的数据也是 JavaScript 格式 但是 axios 目前还不支持，只能自己手动创建 script 标签，把请求的地址赋给 script 标签的 src 属性，最后添加到 head 标签上，等到请求返回再把标签删掉 123456789101112131415161718jsonpRequest: function (a, e) { this._ajaxTimer &amp;&amp; clearTimeout(this._ajaxTimer); this._ajaxTimer = setTimeout(function () { var request_script = document.createElement('script'); request_script.setAttribute('id', 'request_script'); request_script.src = 'http://xxxx' + '&amp;t=' + Date.now(); window.callback = function (response) { // 移除脚本 document.body.removeChild(document.getElementById('request_script')); console.log(response.content); } document.body.appendChild(request_script); }, 500);},","link":"/2018/05/11/Vue/05/"},{"title":"Vuex 中的 State，Getter，Mutation，Action","text":"Vuex 使用单一状态树，每个应用将仅仅包含一个 store 实例，从 store 实例中读取状态最简单的方式就是在计算属性当中返回某个状态 StateVuex 通过 Store 选中，将状态从根组件注入到每一个子组件当中 123456new Vue({ el: '#app', store, components: { Counter }, template: `&lt;div&gt;&lt;counter&gt;&lt;/counter&gt;&lt;/div&gt;`}) 子组件可以通过 this.$store 访问到该 store 的实例 12345678const Counter = { template: `&lt;div&gt;{{ count }}&lt;/div&gt;`, computed: { count() { return this.$store.state.count } }} Getter简单的来说，可以将其理解为 store 的计算属性 getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算 接收 state 作为第一个参数 12345678910111213const store = new Vuex.store({ state: { todos: [ { id: 1, text: '...', done: true }, { id: 2, text: '...', done: false }, ] }, getters: { doneTodos: state =&gt; { return state.todos.filter(todo =&gt; todo.done) } }}) 外部调用 1store.getters.doneTodos // [{ id: 1, text: '...', done: true }] 也可以接受其他的 getter 作为第二个参数 1234567891011121314151617getters: { // ... doneTodosCount: (state, getters) =&gt; { return getters.doneTodos.length }}store.getters.doneTodosCount // 1// 在组件当中使用computed: { doneTodosCount() { return this.$store.getters.doneTodosCount }} 也可以返回一个函数，来实现给 getter 传参 12345678getters: { // ... getTodoById: (state) =&gt; (id) =&gt; { return state.todos.find(todo =&gt; todo.id === id) }}store.getters.getTodoById(2) // { id: 2, text: '...', done: false } Mutation更改 Vuex 的 store 中的状态的唯一方法就是提交 mutation，非常类似于事件 每个 mutation 都有一个事件类型（type）和一个回调函数（handler） 回调函数就是进行状态更改的地方，并且接收 state 作为第一个参数 12345678910const store = new Vuex.Store({ state: { count: 1 }, mutations: { increment(state) { state.count++ } }}) 需要注意： 不能直接调用 mutation handle 应当以相应的 type 调用 store.commit 方法 1store.commit('increment') 同时可以向 store.commit 传入额外的参数，即 mutation 的载荷（payload） 1234567891011121314151617// ...mutations: { increment(state, payload) { state.count += payload.amount; }}store.commit('increment', { amount: 10})// 等同于store.commit({ type: 'increment', payload: 10}) Mutation 的提交 必须是同步函数（若是异步，则可能存在当 mutation 触发的时候，回调函数还没有被调用的情况） mutation 的提交可以使用 this.$store.commit('...') 或者可以使用 mapMutations 辅助函数将组建中的 methods 映射为 store.commit 调用，如下所示 123456789101112131415161718import { mapMutations } from 'Vuex';export default { // ... methods: { ...mapMutations([ // 将 this.increment() 映射为 this.$store.commit('increment') 'increment', // 将 this.incrementBy(amount) 映射为 this.$store.commit('incrementBy', amount) 'incrementBy' ]), ...mapMutations({ // 将 this.add() 映射为 this.$store.commit('increment') add: 'increment' }) }} Action 提交的是 mutation，而不是直接变更状态 可以包含任意异步操作 一个简单的 action 123456789101112131415const store = new Vuex.store({ state: { count: 0 }, mutations: { increment(state) { state.count++ } }, actions: { increment(context) { context.commit('increment') } }}) Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此可以调用 context.commit 提交一个 mutation 分发 ActionAction 通过 store.dispatch 方法触发 1store.dispatch('increment') 之所以这样使用，是因为 mutation 必须同步执行，而 Action 则不必如此，可以在其内部执行异步操作 123456789101112131415161718actions: { increment({ commit }) { setTimeout( () =&gt; { commit('incrementAsync') }, 1000) }}// 同时也支持载荷方式store.dispatch('incrementAsync', { amount: 10})// 等同于store.dispatch({ type: 'incrementAsync', amount: 10}) 组件当中 Action 的分发同 Mutation 类似，可以使用 this.$store.dispatch('...') 或者使用 mapActions 辅助函数 组合 Action因为 store.dispatch 返回的是一个 promise 对象，所以可以使用 then() 方法来进行处理 亦或是可以使用 async/await 1234567891011// 假设 gotData() 与 gotOtherData() 均返回 Promiseactions: { async actionA({ commit }) { commit('gotData', await gotData()) }, async actionB({ commit }) { // 等待 actionA 完成 await dispatch('actionA') commit('gotOtherData', await gotOtherData()) }}","link":"/2018/08/15/Vue/06/"},{"title":"Vuex 框架核心流程","text":"流程图 Vuex 为 Vue Components 建立起了一个完整的生态圈，包括开发中的 API 调用一环，围绕这个生态圈，简要介绍一下各模块在核心流程中的主要功能 Vue Components Vue 组件，HTML 页面上负责接收用户操作等交互行为 执行 dispatch 方法触发对应 action 进行回应 dispatch 操作行为触发方法，是唯一能执行 action 的方法 actions 操作行为处理模块，负责处理 Vue Components 接收到的所有交互行为，包含同步或者异步的操作 支持多个同名方法，按照注册的顺序依次触发，向后台 API 请求的操作就在这个模块中进行，包括触发其他 action 以及提交 mutation 的操作 该模块提供了 promise 的封装，以支持 action 的链式触发 commit 状态改变提交操作方法，对 mutation 进行提交 是唯一能执行 mutation 的方法 mutations 状态改变操作方法，是 Vuex 修改 state 的唯一推荐方法，其他修改方式在严格模式下将会报错 该方法只能进行同步操作，且方法名只能全局唯一，操作之中会有一些 hook 暴露出来，以进行 state 的监控等 state 页面状态管理容器对象，集中存储 Vue components 中 data 对象的零散数据 全局唯一，以进行统一的状态管理，页面显示所需的数据从该对象中进行读取，利用 Vue 的细粒度数据响应机制来进行高效的状态更新 getters state 对象读取方法，图中没有单独列出该模块，应该被包含在了 render 中 Vue Components 通过该方法读取全局 state 对象 总结如下： Vue 组件接收交互行为，调用 dispatch 方法触发 action 相关处理 若页面状态需要改变，则调用 commit 方法提交 mutation 修改 state 通过 getters 获取到 state 新值，重新渲染 Vue Components，界面随之更新 目录结构 目录 介绍 module 提供 module 对象与 module 对象树的创建功能 plugins 提供开发辅助插件，如时光穿梭功能，state 修改的日志记录功能等 helpers.js 提供 action、mutations 以及 getters 的查找 API index.js 是源码主入口文件，提供 store 的各 module 构建安装 mixin.js 提供了 store 在 Vue 实例上的装载注入 util.js 提供了工具方法如 find、deepCopy、forEachValue 以及 assert 等方法","link":"/2018/08/13/Vue/07/"},{"title":"Store","text":"我们在使用 Vuex 的时候，通常会实例化 Store 类，然后传入一个对象，包括我们定义好的 actions，getters，mutations，state 等，甚至当我们有多个子模块的时候，我们可以添加一个 modules 对象 Store 对象的逻辑比较复杂，下面有一个构造方法的整体逻辑流程 环境判断12345678910// store.js ==&gt; https://github.com/vuejs/vuex/blob/dev/src/store.js// 使用断言函数，// 确保 Vue 的存在，也就是在实例化 Store 之前，必须要保证之前的 install 方法已经执行过// 另外一点就是需要支持 promise 语法，因为 Vuex 是依赖 promise 的if (process.env.NODE_ENV !== 'production') { assert(Vue, `must call Vue.use(Vuex) before creating a store instance.`) assert(typeof Promise !== 'undefined', `vuex requires a Promise polyfill in this browser.`) assert(this instanceof Store, `Store must be called with the new operator.`)} assert 函数是一个简单的断言函数 1234// util.jsexport function assert(condition, msg) { if (!condition) throw new Error(`[vuex] ${msg}`)} 数据初始化、module 树构造然后根据 new 构造传入的 options 或默认值，初始化内部数据 1234567// 利用解构赋值，拿到 options 里面的 plugins 和 strict// plugins 表示应用的插件// strict 表示是否开启严格模式const { plugins = [], strict = false} = options 12345678910111213141516171819202122232425// 是否在进行提交状态标识，作用是保证对 Vuex 中 state 的修改只能在 mutation 的回调函数中// 而不能在外部随意修改 statethis._committing = false// 存储用户定义的所有的 actionsthis._actions = Object.create(null)this._actionSubscribers = []// mutationsthis._mutations = Object.create(null)// 封装后的 getters 集合对象this._wrappedGetters = Object.create(null)// 用于支持 store 分模块传入，存储分析后的 modulesthis._modules = new ModuleCollection(options)// 模块命名空间 mapthis._modulesNamespaceMap = Object.create(null)// 订阅函数集合，Vuex 提供了 substcribe 功能，用来存储所有对 mutation 变化的订阅者this._subscribers = []// 一个 Vue 对象的实例，主要是利用 Vue 实例方法 $watch 来观测变化this._watcherVM = new Vue() new ModuleCollection(options)调用 new Vuex.Store(options) 时传入的 options 对象，用于构造 MoudleCollection 类 12345678910111213141516171819202122232425262728293031323334353637383940// module/module-collection.jsclass ModuleCollection { constructor(rawRootModule) { // 将传入的 options 对象整个构造为一个 module 对象 // 并循环调用 register() 方法为其中的 modules 属性进行模块注册，使其都成为 module 对象 // 最后 options 对象被构造成一个完整的组件树 // register root module (Vuex.Store options) this.register([], rawRootModule, false) } // ... register(path, rawModule, runtime = true) { // ... // 分割模块的情况 const newModule = new Module(rawModule, runtime) if (path.length === 0) { this.root = newModule // &lt;=== 这里是 ① } else { const parent = this.get(path.slice(0, -1)) parent.addChild(path[path.length - 1], newModule) } // register nested modules if (rawModule.modules) { forEachValue(rawModule.modules, (rawChildModule, key) =&gt; { this.register(path.concat(key), rawChildModule, runtime) }) } }}// util.jsexport function forEachValue(obj, fn) { Object.keys(obj).forEach(key =&gt; fn(obj[key], key))} 然后绑定 dispatch 与 commit 方法 123456789101112131415161718192021// 把 Store 类的 dispatch 和 commit 方法的 this 指针指向当前 store 的实例上// bind commit and dispatch to selfconst store = thisconst { dispatch, commit } = this// 封装替换原型中的 dispatch 和 commit 方法，详细解释见下方this.dispatch = function boundDispatch(type, payload) { return dispatch.call(store, type, payload)}this.commit = function boundCommit(type, payload, options) { return commit.call(store, type, payload, options)}// 是否开启严格模式this.strict = strict// state 没有放在上面 options 对象中初始化了，改为在 module/module.js 下初始化// 详细可见 module/module.jsconst state = this._modules.root.state dispatch 和 commit 方法dispatchdispatch 的功能是触发并传递一些参数（payload）给对应 type 的 action 因为支持两种调用方式，所以在 dispatch 中，先进行参数的适配处理，然后判断 action type 是否存在，若存在就逐个执行 12345678910111213141516171819202122232425dispatch(_type, _payload) { // check object-style dispatch const { type, payload } = unifyObjectStyle(_type, _payload) // 配置参数处理 const action = { type, payload } // 当前 type 下所有 action 处理函数集合 const entry = this._actions[type] if (!entry) { if (process.env.NODE_ENV !== 'production') { console.error(`[vuex] unknown action type: ${type}`) } return } // 订阅者函数遍历执行，传入当前的 action 对象和当前的 state this._actionSubscribers.forEach(sub =&gt; sub(action, this.state)) return entry.length &gt; 1 ? Promise.all(entry.map(handler =&gt; handler(payload))) : entry[0](payload)} commit12345678910111213141516171819202122232425262728293031323334353637commit(_type, _payload, _options) { // check object-style commit const { type, payload, options } = unifyObjectStyle(_type, _payload, _options) // 同上 const mutation = { type, payload } const entry = this._mutations[type] if (!entry) { if (process.env.NODE_ENV !== 'production') { console.error(`[vuex] unknown mutation type: ${type}`) } return } // 专用修改 state 方法，其余修改 state 的方法均为非法修改 this._withCommit(() =&gt; { entry.forEach(function commitIterator(handler) { handler(payload) }) }) // 同上，传入参数的不同 this._subscribers.forEach(sub =&gt; sub(mutation, this.state)) if ( process.env.NODE_ENV !== 'production' &amp;&amp; options &amp;&amp; options.silent ) { console.warn( `[vuex] mutation type: ${type}. Silent option has been removed. ` + `Use the filter functionality in the vue-devtools` ) }} 初始化核心 - Store1234567891011// init root module.// this also recursively registers all sub-modules// and collects all module getters inside this._wrappedGettersinstallModule(this, state, [], this._modules.root)// initialize the store vm, which is responsible for the reactivity// (also registers _wrappedGetters as computed properties)resetStoreVM(this, state)// apply pluginsplugins.forEach(plugin =&gt; plugin(this)) 上面这三个方法就是 Store 的核心内容了 installModule 主要完成模块的 state，mutations，actions 和 getters 的注册工作 resetStoreVM 这个方法是对 state 和 getters 进行最后的使用处理，从而用户可以调用这些状态 plugins 这个不用多说，应用插件 接下来会详细介绍 Store 中的三个核心方法 installModule，resetStoreVM 和 plugins","link":"/2018/08/25/Vue/09/"},{"title":"初始化装载与注入","text":"在展开之前我们先来看看 Vuex 到底是如何在项目当中进行装载与注入的 入口文件我们先来看入口处的 export 函数到底导出了哪些东西 详细见 vuejs/vuex 注：可能版本不同而导致内容有所不同，但是我们关心的仅仅是几个核心方法 123456789// https://github.com/vuejs/vuex/blob/dev/src/index.jsexport default { Store, install, mapState, mapMutations, mapGetters, mapActions} 装载与注入我们一般在使用 Vuex 的时候如下所示 123456789101112131415161718192021// store.jsimport Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)// 创建并导出 store 对象export default new Vuex.Store()// index.js 文件引入import Vue from 'vue'import App from './../pages/app.vue'import store from './store.js'new Vue({ el: '#root', router, store, // &lt;== 这里注入 render: h =&gt; h(App)}) 除了 Vue 的初始化代码，只是多了一个 store 对象的传入，我们来看下源码中的实现方式 12345678// store.js// 定义局部变量 Vue，用于判断是否已经装载和减少全局作用域查找let Vue// 判断若处于浏览器环境下且加载过 Vue，则执行 install 方法if (!Vue &amp;&amp; typeof window !== 'undefined' &amp;&amp; window.Vue) { install(window.Vue)} 若是首次加载，将局部 Vue 变量赋值为全局的 Vue 对象，并执行 applyMixin 方法 12345678910111213// store.jsexport function install(_Vue) { if (Vue &amp;&amp; _Vue === Vue) { if (process.env.NODE_ENV !== 'production') { console.error( '[vuex] already installed. Vue.use(Vuex) should be called only once.' ) } return } Vue = _Vue applyMixin(Vue)} 下面是 applyMixin 的源码，如果是 2.x 以上的版本，可以使用 hook 的形式进行注入，即在 beforeCreated 钩子前插入初始化代码（vuexInit） 123456789101112131415161718192021222324252627282930313233export default function (Vue) { const version = Number(Vue.version.split('.')[0]) if (version &gt;= 2) { Vue.mixin({ beforeCreate: vuexInit }) } else { // override init and inject vuex init procedure // for 1.x backwards compatibility. const _init = Vue.prototype._init Vue.prototype._init = function (options = {}) { options.init = options.init ? [vuexInit].concat(options.init) : vuexInit _init.call(this, options) } } /** * Vuex init hook, injected into each instances init hooks list. */ function vuexInit() { const options = this.$options // 将初始化 Vue 根组件时传入的 store 设置到 this 对象的 $store 属性上 // 子组件从其父组件引用 $store 属性，层层嵌套进行设置 if (options.store) { this.$store = typeof options.store === 'function' ? options.store() : options.store } else if (options.parent &amp;&amp; options.parent.$store) { this.$store = options.parent.$store } }} 这也就是为什么我们在 Vue 的组件中可以通过 this.$store.xxx 来访问到 Vuex 的各种数据和状态的原因了 因为在任意组件中执行 this.$store 都能找到装载的那个 store 对象 如下图所示，页面的结构为 对应的 store 流向","link":"/2018/08/19/Vue/08/"},{"title":"webpack 中的 loader 和 plugin","text":"webpack 是一个模块打包器（module bundler），提供了一个核心，核心提供了很多开箱即用的功能，同时它可以用 loader 和 plugin 来扩展 webpack 常用配置包括：devtool、entry、output、module、resolve、plugins、externals 等 这里主要介绍 webpack 常用的 loader 和 plugin webpack 允许我们使用 loader 来处理文件，loader 是一个导出为 function 的 Node.js 模块，可以将匹配到的文件进行一次转换，同时 loader 可以链式传递 使用方式一般 loader 的使用方式分为三种： webpack.config.js 中配置（较多）12345678910module.exports = { module: { rules: [ { test: /\\.txt$/, use: 'raw-loader' } ] }} 通过命令行参数方式1webpack --module-bind 'txt=raw-loader' 通过内联使用1import txt from 'raw-loader!./file.txt'; 一些比较常用的 loader 样式：style-loader、css-loader、less-loader、sass-loader 等 文件：raw-loader、file-loader 、url-loader 等 编译：babel-loader、coffee-loader 、ts-loader 等 校验测试：mocha-loader、jshint-loader 、eslint-loader 等 比如下面配置，可以匹配 .scss 的文件，分别经过 sass-loader、css-loader、style-loader 的处理 123456789101112131415module.exports = { module: { rules: [ { test: /\\.scss$/, use: [ { loader: 'style-loader' }, { loader: 'css-loader', options: { sourceMap: true, modules: true } }, { loader: 'sass-loader', options: { sourceMap: true } } ], exclude: /node_modules/ } ] }} style-loader 将创建一个 style 标签将 CSS 文件嵌入到 html 中 css-loader 处理其中的 @import 和 url() sass-loader 转化 sass 为 CSS 文件，并且包一层 module.exports 成为一个 js module 其他一些相关 loader 介绍 vue-loader、coffee-loader、babel-loader 等可以将特定文件格式转成 JavaScript 模块 将其他语言转化为 JavaScript 语言和编译下一代 JavaScript 语言（ES6） file-loader、url-loader 可以处理（静态）资源 file-loader 可以复制和放置资源位置，并可以指定文件名模板，用 hash 命名更好利用缓存 url-loader 可以将小于配置 limit 大小的文件转换成内敛 data url 的方式，减少请求 raw-loader 可以将文件以字符串的形式返回 imports-loader、exports-loader 等可以向模块注入变量或者提供导出模块功能，常见场景是 jQuery 插件注入 $，imports-loader?$=jQuery 禁用 AMD，imports-loader?define=false 等同于 var $ = require('jQuery') 和 var define = false; expose-loader 暴露对象为全局变量","link":"/2018/09/12/Vue/13/"},{"title":"vue 和 node 交互过程中跨域相关问题","text":"问题发现在前端代码中使用 vue-resource 的 $.http.post() 方法去访问后端 RestAPI 的时候，会发现在 Chrome 浏览器下报错 1XMLHttpRequest cannot load http://localhost:3000/. Origin http://localhost is not allowed by Access-Control-Allow-Origin. 注：服务器均为本地，即 localhost，这个问题在使用 $.http.get() 方法去读取本地文件（比如同目录下的 1.txt）的时候也会发生 大致代码如下，只摘选了部分重点内容： 1234567891011121314151617181920212223242526272829// 前台 vue 代码// ...methods: { reg: function () { this.$.http.post(\"localhost:3000/api/users\", { // ... }).then(function (data) { // ... }) }}// ...// ======================================================// 后台 node 代码// ...router.post(\"/api/users\", (req, res, next) =&gt; { // ...})// ... 这个时候可以在 Chrome 浏览器中的网络请求中看到，请求方式变成了 OPTIONS，本质上这就是跨域问题，这也是网络应用安全模型中很重要的一个概念，即 同源准则（same-origin policy） 简单来说，就是 非简单请求 在跨域时，浏览器会默认自动帮你发一个 OPTIONS 请求到服务器端去请求服务器来确认该请求的合法性 服务器端必须得有相应的路由处理该请求，并认真返回 200 响应，然后浏览器才会再次发出正常的，你所需要的请求 也就是说，跨域的情况下 不能随意加 http 请求 header 头，否则会先有一次对服务器的先导请求，也就是前面提到过的 OPTIONS 请求，然后再是正式的请求，并且这个 OPTIONS 请求不能被缓存，效率很低，而且也后端来配合 解决方法解决方法也很简单，一种是可以使用 Node.js 提供的 cors 模块 另外一种就是使用 xhr2.0 当中的 CROS 来处理 这里面就会涉及到 header 头信息的定义，这里可以参考 w3c 中的 header 定义 和 header 头信息详解 浏览之后可以发现，其中两个跨域相关的 header 属性定义如下 Access-Control-Allow-Origin 允许的域（可以直接设为 *，表示任意） Access-Control-Allow-Headers 允许的 header 类型 这个时候只需要在后台手动添加一个头信息，即可解决问题，如下 123456789101112131415app.all('*', (req, res, next) =&gt; { res.header('Access-Control-Allow-Origin', '*'); res.header('Access-Control-Allow-Headers', 'Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild'); res.header('Access-Control-Allow-Methods', 'PUT, POST, GET, DELETE, OPTIONS'); if (req.method == 'OPTIONS') { // 让 options 请求快速返回 res.send(200); } else { next(); }});","link":"/2018/09/18/Vue/14/"},{"title":"Angular-CLI 与其整体架构","text":"因为年后公司项目转向 Angular 架构了，只有暂时性的放下 vue 和 react，赶紧抓紧时间学习 Angular 跟上大部队的脚步才是 俗话说得好，技多不压身，就当学习一门新的框架了，XD Angular 在 2.x 之后的版本中相较与 1.x 的版本变化很多，说其为两个不同的框架也不为过 在新的版本当中，提供了一个 Angular-CLI 的脚手架，用于实现自动化开发工作流程，它可以创建一个新的 Angular 应用程序，并附带以下相关工具 运行带有 LiveReload 支持的开发服务器，以便在开发过程中预览应用程序 添加功能到现有的 Angular 应用程序（提供了一系列 ng xxx 相关命令） 运行应用程序的单元测试 运行应用程序的端到端（E2E）测试 构建应用程序 那么就先从最基本的 Angular-CLI 生成的目录结构以及相关初始化入口文件开始 Angular-CLI 目录结构12345678910111213141516171819202122232425262728293031323334353637├── e2e 端到端│ ├── app.e2e-spec.ts 端到端测试文件│ ├── app.po.ts 端到端测试入口文件│ └── tsconfig.e2e.json 用于端到端测试的 typescript 编译器的配置文件├── node_modules 第三方依赖包├── src 项目主文件所在目录│ ├── app 组件所在文件夹│ │ ├── app.component.css 组件的样式文件│ │ ├── app.component.html 组件的 HTML 模板文件│ │ ├── app.component.spec.ts 组件的单元测试文件│ │ ├── app.component.ts 组件定义文件│ │ └── app.module.ts 模块定义配置文件│ ├── assets 静态资源│ │ └── .gitkeep assets 目录用于存放图片等静态资源文件，构建时会拷贝到发布包里，新创建时一般为空│ │ 但是由于 git 会忽略空文件夹，放置 .gitkeep 这个空文件以保证目录得到管理│ ├── environments 环境│ │ ├── environment.prod.ts 生产环境配置文件，在 .angular-cli.json 中被 mapping，mapping 值为 prod│ │ └── environment.ts 开发环境配置，在 .angular-cli.json 中被 mapping，mapping 值为 dev│ ├── favicon.ico 网页左上角显示的图标│ ├── index.html 项目主页│ ├── main.ts Angular 程序的入口│ ├── polyfills.ts 不同浏览器，比如一些老旧的浏览器及版本的支持│ ├── styles.css 全局的样式│ ├── test.ts 单元测试入口│ ├── tsconfig.app.json Angular 应用的 typescript 编译器的配置文件│ ├── tsconfig.spec.json 单元测试的 typescirpt 编译器的配置文件│ ├── tsconfig.app.json Angular 应用的 typescript 编译器的配置文件│ └── typings.d.ts 项目中使用的 typescript 类型的引用文件├── .angular-cli.json CLI 的配置文件，可以设定项目的基础信息，比如构建后的目标目录名称等├── .editorconfig 编辑器的配置文件├── .gitignore 为了保证自动生成的文件不被提交的 git 配置文件├── karma.conf.js karma 单元测试的配置文件├── package.json npm 的配置文件以及第三方依赖包├── protractor.conf.js protractor 的端到端测试的配置文件├── README.md 项目的基本信息，主要包含使用 cli 命令如何对项目进行 构建/测试/运行 等├── tsconfig.json typescirpt 编译器的配置文件└── tslint.json 提供给 TSLint 和 Codelyzer 的配置信息 app.module.ts这个模块的作用是告诉 Angular 如何组装该应用 12345678910111213141516171819202122232425262728293031// app.module.ts// 浏览器解析的模块import { BrowserModule } from '@angular/platform-browser';// Angular 核心模块import { NgModule } from '@angular/core';// 自定义模块import { AppComponent } from './app.component';// @NgModule 装饰器将 AppModule 标记为 Angular 模块类（也称为 NgModule 类）// @NgModule 接受一个元数据对象，告诉 Angular 如何编译和启动应用@NgModule({ // 引入当前项目运行的组件，自定义组件都需要引入并且在这个里面进行配置（定义） declarations: [ AppComponent ], // 引入其他的模块，表示当前的项目依赖哪些模块（比如请求数据的模块等） imports: [ BrowserModule ], // 注入服务 providers: [], // 默认的启动哪个组件 bootstrap: [AppComponent]})// 导出模块，因为是根模块，所以不需要导出任何东西，默认为空即可// 但是需要注意，一定要写，即使导出为空export class AppModule { } app.component.ts1234567891011121314151617// app.component.ts// 引入 Angular 中的 Component 组件import { Component } from '@angular/core';@Component({ // 使用组件的名称 selector: 'app-root', // 组件对应的 html templateUrl: './app.component.html', // 组件对应的 css styleUrls: ['./app.component.css']})// 数据export class AppComponent { title = 'app';} 整体架构整体架构可以如下图所示 Angular 使用扩展语法编写 HTML 模版，使用组件对其进行管理，通过服务来添加应用逻辑，最后使用模块来对组件进行打包 通过引导根模块来启动应用，Angular 在浏览器中接管、展现应用的内容，根据操作指令响应用户的交互 Angular 的架构主要分为四大块 组件 – Angular 应用的基本构件块，可以简单的理解为一个组件就是一段带有业务逻辑和数据的 HTML 指令 – 允许向 HTML 元素添加自定义行为 模块 – 模块用来将应用中不同的部分组织成一个 Angular 框架可以理解的单元（组件） 服务 – 用来封装可从用的业务逻辑 启动过程整个启动过程是通过引导模块来进行的，每个 Angular 应用至少应该有一个模块，而此模块被称为根模块（App Module） 根模块 @NgModule 装饰器所谓的根模块，也就是我们的 app.module.ts 文件，如下所示 12345678910111213141516171819202122232425262728import { BrowserModule } from '@angular/platform-browser';import { NgModule } from '@angular/core';import { AppComponent } from './app.component';// @NgModule 装饰器用来为模块定义元数据@NgModule({ // declarations 列出了应用中的顶层组件，包括引导性组件 AppComponent 和我们自己创建的组件 // 在 module 里面声明的组件在 module 范围内都可以直接使用 // 也就是说在同一 module 里面的任何 Component 都可以在其模板文件中直接使用声明的组件 declarations: [ AppComponent, ... ], // 引入相关依赖 // BrowserModule 提供了运行在浏览器中的应用所需要的关键服务（Service）和指令（Directive） // 这个模块所有需要在浏览器中跑的应用都必须引用 imports: [ BrowserModule ], // providers 列出会在此模块中 \"注入\" 的服务（Service） providers: [], // bootstrap 指明哪个组件为引导性组件（默认的是 AppComponent） // 当 Angular 引导应用时，它会在 DOM 中渲染这个引导性组件 // 并把结果放进 index.html 的该组件的元素标签中（默认为 app-root） bootstrap: [AppComponent]})export class AppModule { } 而根模块在 Angular 程序的入口 main.ts 中被使用，也就是所谓的引导过程 Angular 通过在 main.ts 中引导 AppModule 来启动应用，但是针对不同的平台 Angular 提供了很多引导选项 默认的采用是即时（JIT）编译器动态引导，一般多用在进行开发调试的时候 12345678910111213141516// main.ts// 连同 Angular 编译器一起发布到浏览器import { enableProdMode } from '@angular/core';import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';import { AppModule } from './app/app.module';import { environment } from './environments/environment';if (environment.production) { enableProdMode();}// 对 AppModule 进行引导// Angular 编译器在浏览器中编译并引导该应用platformBrowserDynamic().bootstrapModule(AppModule) .catch(err =&gt; console.log(err)); 另一种方式是使用预编译器（AoT - Ahead-Of-Time）进行静态引导，静态方案可以生成更小、启动更快的应用 建议优先使用它，特别是在移动设备或高延迟网络下，使用 static 选项，Angular 编译器作为构建流程的一部分提前运行，生成一组类工厂 它们的核心就是 AppModuleNgFactory，引导预编译的 AppModuleNgFactory 的语法和动态引导 AppModule 类的方式很相似 12345678// 不把编译器发布到浏览器import { platformBrowser } from '@angular/platform-browser';// 静态编译器会生成一个 AppModule 的工厂 AppModuleNgFactoryimport { AppModuleNgFactory } from './app.module.ngfactory';// 引导 AppModuleNgFactoryplatformBrowser().bootstrapModuleFactory(AppModuleNgFactory); 模块化Anagulr 应用是模块化的，被称为 NgModule @NgModule 是一个装饰器，装饰器其实是函数，是用来 ‘装饰’ 函数，它可以把元数据附加到类上 NgModule 装饰器用来描述模块属性，常见的模块属性如下所示 属性 说明 declarations 声明本模块中拥有的视图类，Angular 有三种视图类：组件，指令和管道 exports declarations 的子集，可用于其他模块的组件模版 imports 本模块声明的组件模板需要的类所在的其他模块 providers 服务的创建者，并加入到全局服务列表中，可用于应用任何部分 bootstrap 指定应用的主视图（根组件），它是所有其他视图的宿主 有两个地方需要注意 exports 属性并不是必须的，因为其他组件无需导入根模块，所以根模块也不需要导出 只有根模块才能设置 bootstrap 属性 组件和 @NgModule 类似，@Component 为 Angular 的组件装饰器，主要属性如下 属性 说明 selector CSS 选择器，它告诉 Angular 在父级 HTML 中查找 selector 中定义的标签，创建并插入该组件 template/templateUrl 组件或者组件 HTML 模块的相对地址 providers 组件所需服务的依赖注入提供商数组，这是在告诉 Angular 该组件的构造函数可能需要一个服务，这样组件就可以从服务中获得数据 在根模块的 bootstrap 属性中设定了 AppComponent 组件，说明根模块引导的为 AppComponent 组件 1234567891011import { Component } from '@angular/core';@Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css']})export class AppComponent { title = 'Angular Examples';} 装饰器 @Component 将三个东西结合在了一起，selector 和 HTML 模板以及 CSS 样式 通过插值的方式保证数据进行交互和传递 通过修改填充的内容则可以直接影响输出 通过 CSS 样式直接调整显示，做到数据和显示的分离 这也就是整体 Angular 程序的启动过程，不过特别需要注意的是 当组件编写完成后还需要进行组件声明后才能使用，每个组件都必须在一个 Angular 模块而且只能在一个 Angular 模块中进行声明 双向绑定示例在新的版本当中，使用 Angular 双向绑定与之前有所不同 因为需要在当前模块中首先引入 FormsModule 模块才能使用双向绑定 12345678910111213// 当前所在的模块 xx.module.ts，特别需要注意，要使用双向绑定，需要引入 FormsModule 模块import { BrowserModule } from '@angular/platform-browser'import { NgModule } from '@angular/core'import { AppComponent } from './app.component'import { FormsModule } from '@angular/forms'@NgModule({ imports: [ BrowserModule, FormsModule ], declarations: [ AppComponent ], bootstrap: [ AppComponent ]})export class AppModule { } 123456789101112131415161718192021// 组件部分 xx.component.tsimport { Component } from '@angular/core'import { platformBrowserDynamic } from '@angular/platform-browser-dynamic'import { AppModule } from './app.module'// 定义组件的元信息@Component({ selector: 'my-app', templateUrl: './app.component.html'})// 定义组件类export class AppComponent { hero: Hero = { name: 'zhangsan' }}export class Hero { name: String} 然后在模版当中使用即可，注意要使用 [(...)]=&quot;&quot; 格式来进行绑定 12// 模版文件 xx.component.html&lt;input [(ngModel)]=\"hero.name\" placeholder=\"name\"&gt;","link":"/2018/12/12/Angular/01/"},{"title":"Angular 中的装饰器","text":"Angular 中的装饰器可以简单的总结为以下几句 它是一个表达式 该表达式被执行后，返回一个函数 函数的入参分别为 target、name 和 descriptor 执行该函数后，可能返回 descriptor 对象，用于配置 target 对象 它分为 类装饰器 （Class decorators） 属性装饰器 （Property decorators） 方法装饰器 （Method decorators） 参数装饰器 （Parameter decorators） TypeScript 中的装饰器123456789101112131415161718192021222324252627// 类装饰器// 用来装饰类的，它接收一个参数：// target: TFunction - 被装饰的类declare type ClassDecorator = &lt;TFunction extends Function&gt;(target: TFunction) =&gt; TFunction | void;// 属性装饰器// 用来装饰类的属性，它接收两个参数：// target: Object - 被装饰的类// propertyKey: string | symbol - 被装饰类的属性名declare type PropertyDecorator = (target:Object, propertyKey: string | symbol ) =&gt; void;// 方法装饰器// 用来装饰类的属性，它接收三个参数// target: Object - 被装饰的类// propertyKey: string | symbol - 方法名// descriptor: TypePropertyDescript - 属性描述符declare type MethodDecorator = &lt;T&gt;(target:Object, propertyKey: string | symbol, descriptor: TypePropertyDescript&lt;T&gt;) =&gt; TypedPropertyDescriptor&lt;T&gt; | void;// 参数装饰器// 用来装饰函数参数，它接收三个参数// target: Object - 被装饰的类// propertyKey: string | symbol - 方法名// parameterIndex: number - 方法中参数的索引值declare type ParameterDecorator = (target: Object, propertyKey: string | symbol, parameterIndex: number ) =&gt; void Angular 内置装饰器 类装饰器 - @Component、@NgModule、@Pipe、@Injectable 属性装饰器 - @Input、@Output、@ContentChild、@ContentChildren、@ViewChild、@ViewChildren 方法装饰器 - @HostListener、@HostBinding 参数装饰器 - @Inject、@Optional、@Self、@SkipSelf、@Host 这里主要介绍 @Input，@Output，@ViewChild，@ViewChildren，@HostListener 和 @HostBinding 六种 InputInput 是属性装饰器，用来定义组件内的输入属性，一般用来实现父组件向子组件传递数据 @Input()123456789101112131415161718192021222324252627282930313233343536// counter.component.tsimport { Component, Input } from '@angular/core';@Component({ selector: 'exe-counter', template: ` &lt;p&gt;当前值: {{ count }}&lt;/p&gt; &lt;button (click)=\"increment()\"&gt; + &lt;/button&gt; &lt;button (click)=\"decrement()\"&gt; - &lt;/button&gt; `})export class CounterComponent { @Input() count: number = 0; increment() { this.count++; } decrement() { this.count--; }}// app.component.tsimport { Component } from '@angular/core';@Component({ selector: 'exe-app', template: ` &lt;exe-counter [count]=\"initialCount\"&gt;&lt;/exe-counter&gt; `})export class AppComponent { initialCount: number = 5;} @Input(‘bindingPropertyName’)Input 装饰器支持一个可选的参数，用来指定组件绑定属性的名称 如果没有指定，则默认使用 @Input 装饰器，装饰的属性名，如下所示 12345678910111213// counter.component.tsexport class CounterComponent { @Input('value') count: number = 0;}// app.component.ts@Component({ selector: 'exe-app', // 绑定的时候如果写成 [value]，那么在 @Input() 接收的时候指定为 value 即可 template: ` &lt;exe-counter [value]=\"initialCount\"&gt;&lt;/exe-counter&gt; `}) inputs还可以使用 inputs 属性将绑定的输入属性名称直接写到 @Component({}) 的元数据当中 12345678910111213141516171819// counter.component.tsexport class CounterComponent { @Input('value') count: number = 0;}// app.component.ts@Component({ selector: 'exe-app', template: ` &lt;exe-counter [value]=\"initialCount\"&gt;&lt;/exe-counter&gt; `, // 如果模版当中指定的为 [count]=\"initialCount\" // 可以直接写为 inputs: ['count'] inputs: ['count: value']})export class CounterComponent { count: number = 0;} 不过需要注意的是，不能同时使用 @Input 装饰器，或在 @Directive、@Component inputs 字段中定义同一个输入属性 123456789// 错误的使用方式@Component({ selector: 'exe-counter', inputs:['count: value'] })export class CounterComponent { @Input('value') count: number = 0;} @Input 和 inputs 两者的区别它们都是用来定义输入属性，而不同的地方在于 inputs 定义在指令的 metadata 信息中，开发者对指令的输入属性一目了然 此外对于未选用 TypeScript 作为开发语言的开发者，也只能在 metadata 中定义指令的输入属性 @Input 属于属性装饰器，通过它可以一起定义属性的访问描述符（public、private、protected） 1@Input() public attr: string; @Output 与其类似 1@Output('countChange') change: EventEmitter&lt;number&gt; = new EventEmitter&lt;number&gt;(); setter &amp; gettersetter 和 getter 是用来约束属性的设置和获取，它们提供了一些属性读写的封装，可以让代码更便捷，更具可扩展性 通过 setter 和 getter 方式，我们对类中的私有属性进行了封装，能避免外界操作影响到该私有属性 123456789101112131415161718192021222324252627282930313233import { Component, Input } from '@angular/core';@Component({ selector: 'exe-counter', template: ` &lt;p&gt;当前值: {{ count }} &lt;/p&gt; &lt;button (click)=\"increment()\"&gt; + &lt;/button&gt; &lt;button (click)=\"decrement()\"&gt; - &lt;/button&gt; `})export class CounterComponent { _count: number = 0; biggerThanTen: boolean = false; @Input() set count (num: number) { this.biggerThanTen = num &gt; 10; this._count = num; } get count(): number { return this._count; } increment() { this.count++; } decrement() { this.count--; }} OutputOutput 是属性装饰器，用来定义组件内的输出属性，主要用来实现子组件将信息通过事件的形式通知到父级组件 EventEmitterOutput 属性装饰器一般是和 EventEmitter 一起相互配合来使用的，先看 EventEmitter 12345let numberEmitter: EventEmitter&lt;number&gt; = new EventEmitter&lt;number&gt;(); numberEmitter.subscribe((v: number) =&gt; console.log(v));numberEmitter.emit(10); 具体的应用流程为 子指令创建一个 EventEmitter 实例，并将其作为输出属性导出 子指令调用已创建的 EventEmitter 实例中的 emit(payload) 方法来触发一个事件 而父指令通过事件绑定（eventName）的方式监听该事件，并通过 $event 对象来获取 payload 对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// counter.component.tsimport { Component, Input, Output, EventEmitter } from '@angular/core';@Component({ selector: 'exe-counter', template: ` &lt;p&gt;当前值: {{ count }}&lt;/p&gt; &lt;button (click)=\"increment()\"&gt; + &lt;/button&gt; &lt;button (click)=\"decrement()\"&gt; - &lt;/button&gt; `})export class CounterComponent { @Input() count: number = 0; @Output() change: EventEmitter&lt;number&gt; = new EventEmitter&lt;number&gt;(); increment() { this.count++; this.change.emit(this.count); } decrement() { this.count--; this.change.emit(this.count); }}// app.component.tsimport { Component } from '@angular/core';@Component({ selector: 'exe-app', template: ` &lt;exe-counter [count]=\"initialCount\" (change)=\"countChange($event)\"&gt;&lt;/exe-counter&gt; `})export class AppComponent { initialCount: number = 5; countChange(ev: number) { console.log(ev) }} @Output(‘bindingPropertyName’)同 @Input 一样，@Output 装饰器支持一个可选的参数，用来指定组件绑定属性的名称 如果没有指定，则默认使用 @Output 装饰器，装饰的属性名 12345678910111213// counter.component.tsexport class CounterComponent { @Output('counterChange') change: EventEmitter&lt;number&gt; = new EventEmitter&lt;number&gt;();}// app.component.ts@Component({ template: ` &lt;exe-counter [count]=\"initialCount\" (counterChange)=\"countChange($event)\"&gt;&lt;/exe-counter&gt; `}) outputs同 inputs 一样，也支持在组建内部添加 outputs 属性，但是和上面一样不太推荐这种写法 ngOnChanges当数据绑定输入属性的值发生变化的时候，Angular 将会主动调用 ngOnChanges 方法 它会获得一个 SimpleChanges 对象，包含绑定属性的新值和旧值，它主要用于监测组件输入属性的变化 1234567891011121314151617181920212223242526import { Component, Input, SimpleChanges, OnChanges } from '@angular/core';@Component({ selector: 'exe-counter', template: ` &lt;p&gt;当前值: {{ count }}&lt;/p&gt; &lt;button (click)=\"increment()\"&gt; + &lt;/button&gt; &lt;button (click)=\"decrement()\"&gt; - &lt;/button&gt; `})export class CounterComponent implements OnChanges{ @Input() count: number = 0; ngOnChanges(changes: SimpleChanges) { console.dir(changes['count']); } increment() { this.count++; } decrement() { this.count--; }} 可以在控制台当中看到 SimpleChanges 对象的一些值（包括新值和旧值） 需要注意的是，当手动改变输入属性的值，是不会触发 ngOnChanges 钩子的 @ViewChild()通过 @ViewChild() 装饰器可以获得子组件的引用，从而可以在父组件当中来直接调用子组件的方法 12// 父组件&lt;app-header #child1&gt;&lt;/app-header&gt; 12345678910111213141516171819export class AppComponent implements OnInit{ @ViewChild('child1') child1: HeaderComponent; ngOnInit() { this.child1.run('...'); }}// 子组件export class HeaderComponent implements OnInit { constructor() { } ngOnInit() { } run(name) { console.log(name); }} @ViewChild 使用类型查询1234567891011121314151617181920212223242526272829303132333435// child.component.tsimport { Component, OnInit } from '@angular/core';@Component({ selector: 'exe-child', template: ` &lt;p&gt;Child Component&lt;/p&gt; `})export class ChildComponent { name: string = 'child-component';}// app.component.tsimport { Component, ViewChild, AfterViewInit } from '@angular/core';import { ChildComponent } from './child.component';@Component({ selector: 'my-app', template: ` &lt;h4&gt;Welcome to Angular World&lt;/h4&gt; &lt;exe-child&gt;&lt;/exe-child&gt; `,})export class AppComponent { // 通过 @ViewChild() 来获取子组件 @ViewChild(ChildComponent) childCmp: ChildComponent; ngAfterViewInit() { console.dir(this.childCmp); }} ViewChildrenViewChildren 用来从模版视图中获取匹配的多个元素，返回的结果是一个 QueryList 集合 123456789101112131415161718192021import { Component, ViewChildren, QueryList, AfterViewInit } from '@angular/core';import { ChildComponent } from './child.component';@Component({ selector: 'my-app', template: ` &lt;h4&gt;Welcome to Angular World&lt;/h4&gt; &lt;exe-child&gt;&lt;/exe-child&gt; &lt;exe-child&gt;&lt;/exe-child&gt; &lt;exe-child&gt;&lt;/exe-child&gt; `,})export class AppComponent { @ViewChildren(ChildComponent) childCmps: QueryList&lt;ChildComponent&gt;; ngAfterViewInit() { console.dir(this.childCmps); }} 运行之后可以在控制台当中看到输出多个 ChildComponent 小结ViewChild 装饰器用于获取模板视图中的元素，它支持 Type 类型或 string 类型的选择器 同时支持设置 read 查询条件，以获取不同类型的实例 ViewChildren 装饰器是用来从模板视图中获取匹配的多个元素，返回的结果是一个 QueryList 集合 HostListener &amp; HostBinding在介绍 HostListener 和 HostBinding 属性装饰器之前，我们可以先来了解一下 Host Element（宿主元素） 宿主元素的概念同时适用于指令和组件，对于指令来说，应用指令的元素，就是宿主元素 如果在自定义组件中使用的话，那么自定义组件就是宿主元素 HostListenerHostListener 是属性装饰器，用来为宿主元素添加事件监听 HostListenerDecorator 装饰器定义如下 1234export interface HostListenerDecorator { (eventName: string, args?: string[]): any; new (eventName: string, args?: string[]): any;} 使用 1234567891011121314import { Directive, HostListener } from '@angular/core';@Directive({ selector: 'onClicks'})export class onClicks { @HostListener('click') onClick() { // ... }} 此外还可以监听宿主元素外，其他对象产生的事件，比如 window 或 document 对象 一个点击目标区域会添加背景颜色，点击其他区域取消掉高亮 1234567891011121314151617181920export class SetBackgroundDirective { constructor( private el: ElementRef, private re: Renderer2 ) {} @HostListener('document:click', ['$event']) onClick(btn: Event) { if (this.el.nativeElement.contains(event.target)) { this.highlight('yellow'); } else { this.highlight(null); } } highlight(color: string) { this.re.setStyle(this.el.nativeElement, 'backgroundColor', color); }} Host Event Listener还可以使用 host 参数来进行绑定（不太建议使用这种方式，推荐使用装饰器风格） 123456789101112131415import { Directive } from '@angular/core';@Directive({ selector: 'button[counting]', host: { '(click)': 'onClick($event.target)' }})export class CountClicks { numberOfClicks = 0; onClick(btn: HTMLElement) { console.log('button', btn, 'number of clicks:', this.numberOfClicks++); }} HostBindingHostBinding 是属性装饰器，用来动态设置宿主元素的属性值，定义如下 1234export interface HostBindingDecorator { (hostPropertyName?: string): any; new (hostPropertyName?: string): any;} 应用 123456789101112131415161718@Directive({ selector: '[exeButtonPress]'})export class ExeButtonPress { @HostBinding('attr.data') data = 'button'; @HostBinding('class.active') isActive: boolean; @HostListener('mouseenter') enter() { this.isActive = true; } @HostListener('mouseleave') leave() { this.isActive = false; }} 和上面一样，我们也可以在指令的元数据当中来进行绑定（同样的不建议这样使用） 123456789101112131415161718192021@Directive({ selector: '[exeButtonPress]', host: { 'data': 'button', '[class.active]': 'isActive' }})export class ExeButtonPress { isActive: boolean; @HostListener('mouseenter') enter() { this.isActive = true; } @HostListener('mouseleave') leave() { this.isActive = false; }}","link":"/2018/01/15/Angular/05/"},{"title":"ExpressionChangedAfterItHasBeenCheckedError","text":"最近在开发过程中，遇到了 ExpressionChangedAfterItHasBeenCheckedError 这个错误 google 一翻后，发现各种说法众说纷纭，所有抽出时间深入了解一下这个错误，做一下总结，也可以避免以后在遇到这个问题的时候不知道怎么处理 简单来说，这个错误主要涉及到 Angular 的变化监测机制，更多详细可见 Angular 中的变化检测机制 Angular 中的变化监测机制每个 Angular 应用都是以组件树的形态呈现的，Angular 在变化监测阶段会按以下的顺序对每个组件执行如下操作（标记为 List1） 更新所有绑定在子 component/directive 上的属性 调用所有子 component/directive 的 ngOnInit，ngOnChanges，ngDoCheck 生命周期函数 解析、更新当前组件 DOM 上的 value 运行子 component 的变化监测流程（List1） 调用所有子 component/directive 上的 ngAfterViewInit 生命周期 每一步操作后，Angular 会保存与这次操作有关的 values 值，这个值被存在组件 view 的 oldValues 属性中 在开发模式下，所有组件完成变化监测之后 Angular 会开始下一个监测流程，第二次监测流程并不会再次执行上面列出的变化监测流程，而会比较之前变化监测循环保存的值（存在 oldValues 中的）与当前监测流程的值是否一致（标记为 List2） 检查被传递到子组件的 values（oldValues）与当前组件要被用于更新的 values（instance.value）是否一致 检查被用于更新 DOM 元素的 values（oldValues）与当前要被用于这些组件更新的 values（instance.value）是否一致 对所有子 component 执行相同的检查 需要注意的是：这些额外的检查（List2）只发生在开发模式下 出现原因接下来我们来看一个例子，假设你有一个父组件 A 和一个子组件 B，A 组件中有两个属性 name 和 text，A 组件的模板中使用了 name 属性 1template: '&lt;span&gt;{{name}}&lt;/span&gt;' 然后在模板中加入 B 组件，并且通过输入属性绑定给 B 组件输入 text 属性 12345678910111213// A 组件当中使用 B 组件@Component({ selector: 'a-comp', template: ` &lt;span&gt;{{name}}&lt;/span&gt; &lt;b-comp [text]=\"text\"&gt;&lt;/b-comp&gt; `})export class AComponent { name = 'I am A component'; text = 'A message for the child component';} 那么 Angular 在开始变化监测后会发生什么呢？ List1 变化监测会从 A 组件开始检查，第一步将 text 表达式中的 A message for the child component 向下传递到 B 组件，并且将这个值存在 view 上 1view.oldValues[0] = 'A message for the child component'; 然后到了变化监测列表里的第二步，调用相应的生命周期函数 接下来执行第三步，将 name 表达式解析为 I am A component 文本，将解析好的值更新到 DOM 上，并且存入 oldValues 1view.oldValues[1] = 'I am A component'; 最后 Angular 对 B 组件执行相同的操作（List1），一旦 B 组件完成以上的操作，此次变化监测循环便完成了 但是如果 Angular 在开发模式下运行，那么将会执行另一个监测流程（List2） text 属性在传递给 B 组件时的值是 A message for the child component 并存入 oldValues ，现在想象一下 A 组件在此之后将 text 的值更新为 updated text 然后 List2 的第一步将会检查 text 属性是否被改变 12AComponentView.instance.text === view.oldValues[0]; // false'updated text' === 'A message for the child component'; // false 这个时候 Angular 就该抛出这个错误了 1ExpressionChangedAfterItHasBeenCheckedError 同理，如果更新已经被渲染在 DOM 中并且被存在 oldValues 中的 name 属性，也会抛出相同的错误 12AComponentView.instance.name === view.oldValues[1]; // false'updated name' === 'I am A component'; // false 现在你可能会有些疑惑，这些值怎么会被改变呢？ 数据改变的原因罪魁祸首一般都是子组件或指令，下面我们来详细的看一下之前的示例 我们将在子组件的 ngOnInit（此时数据已绑定）生命周期钩子中更新 text 属性 12345678910// B 组件export class BComponent { @Input() text; constructor(private parent: AppComponent) { } ngOnInit() { this.parent.text = 'updated text'; }} 我们可以看到预期的错误 123Error: ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value: 'A message for the child component'. Current value: 'updated text'. 现在我们对被用于父组件模板的 name 属性做相同的操作 123ngOnInit() { this.parent.name = 'updated name';} 这时候程序并没有报错，为什么会这样呢？ 如果你仔细看变化监测（List1）的执行顺序，你会发现子组件的 ngOnInit 将在当前 component 的 DOM 更新之前被调用（在记录 oldValues 前改变了数据），这就是为什么上面的例子中更改 name 属性却不会报错 然后我们来利用一个在 DOM 中 values 更新之后的钩子来做实验，比如 ngAfterViewInit 是一个不错的选择 123456789export class BComponent { @Input() text; constructor(private parent: AppComponent) {} ngAfterViewInit() { this.parent.name = 'updated name'; }} 我们又一次得到了预期的错误 123AppComponent.ngfactory.js:8 ERROR Error: ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value: 'I am A component'. Current value: 'updated name'. 当然现实中遇到的情况会更加错综复杂，父组件中属性在二次监测之前被更新通常是使用的外部服务或 observabals 间接导致的，但是其本质原因是相同的 可行解决方案如果你 google 过这个错误，那么你应该看过一些回答推荐使用异步更新数据和强制增加一个变化监测循环两种方法来解决这个错误 比如在动态创建组件的情况下，解决这个问题最好的方案是改变创建组件时所处的生命周期钩子 虽然这两种方式都可以解决问题，但是还是更推荐重新设计你的应用而不是使用这两种方法来解决这个问题 异步更新你应该注意到一件事，不管是变化监测还是第二次的验证 digest 都是同步执行的 这意味着如果我们在代码中异步更新属性的值，那么在第二次验证循环运行时这些属性是不会被改变的，那么也就不会报错了 123456789101112131415161718export class BComponent { name = 'I am B component'; @Input() text; constructor(private parent: AppComponent) {} ngOnInit() { setTimeout(() =&gt; { this.parent.text = 'updated text'; }); } ngAfterViewInit() { setTimeout(() =&gt; { this.parent.name = 'updated name'; }); }} 确实没有错误抛出，setTimeout 将函数加入 macrotask 队列中，函数会在下一个 VM 周期里被调用 也可以通过使用 promise 里的 then 回调将函数加入当前 VM 周期其他同步代码被执行完之后 1Promise.resolve(null).then(() =&gt; this.parent.name = 'updated name'); Promise.then 并不会被放入 macrotask，而是创建一个 microtask microtask 队列将在当前周期中所有同步代码被执行完毕之后执行，因此属性的更新会发生在验证步骤之后 另外补充一个知识点，给 EventEmitter 传一个 true 能使事件的 emit 变为异步 1new EventEmitter(true); 强制变化监测另一个解决方案是在父组件 A 的第一和第二次验证之间强制加一个变化监测循环 触发强制变化监测的最佳位置是在 ngAfterViewInit 生命周期内，这时候所有的子组件的流程都已经执行完毕，所以随便在之前的哪个位置改变父组件的属性都无所谓 12345678910export class AppComponent { name = 'I am A component'; text = 'A message for the child component'; constructor(private cd: ChangeDetectorRef) { } ngAfterViewInit() { this.cd.detectChanges(); }} 一样没有报错，但是其实这里有个问题，当在父组件 A 中触发新添加的变化监测时，Anuglar 同样会为所有的子组件运行一次变化监测，那么父组件可能会被又一次更新 为什么需要第二次监测循环Angular 强制使用至上而下的单向数据流，在父元素完成变化监测之后不允许内部子组件在第二次变化监测前改变父组件的属性，这能确保第一次变化监测后的组件树是稳定的 如果在监测循环周期里有属性的改变导致依赖这些属性的使用者需要同步更新变化，那么这棵组件树就是不稳定的 上面例子中子组件 B 依赖父组件的 text 属性，每当属性的值改变，在这些改变被传递到 B 组件之前这棵组件树都处于不稳定的状态 这同样体现在 DOM 与属性之间的关系上，DOM 作为这些属性的使用者，然后将这些属性渲染到 UI 界面上，如果某些属性没有同步更新到界面上，用户将会看到错误的界面 所以如果你在数据同步过程完成之后再通过子组件修改父组件中的属性会发生什么呢？ 是的，你留下了一个不稳定的组件树，其中数据变更的顺序将无法预测，大部分时候这将会给用户呈现出一个有错误数据的页面，而且问题的排查将十分困难 可能你会问了，那为什么不等到组件树稳定之后再进行变化监测呢？ 答案很简单，组件树可能永远不会稳定下来，一个子组件更新了父组件中的属性，父组件的属性又更新子组件的状态，子组件状态的更新又触发更新父组件的属性… 这将是个无限循环，之前展示了很多组件对属性直接更新或依赖的情况，但实际中的应用对属性的更新和依赖通常是间接，不易排查的 最后一个问题是，为什么第二次循环监测只在开发模式下运行？ 我猜想这是因为数据层不稳定在框架运行时并不会产生引人关注的错误，毕竟数据在下一次监测循环后就会稳定下来，当然，在开发时期将可能得错误解决总好过在上线后的应用中排查错误 实例一：共享服务地址见 demo01 这个应用中父组件和子组件共用一个共享服务，子元素通过共享服务设置一个属性的值并反映到父元素上，这个模式下子元素改变父元素的值的方式并不像上面简单例子中那么显而易见，是间接更新了父元素的属性 实例二：同步事件广播地址见 demo02 这个应用中父元素监听一个子元素广播的事件，这个事件导致父元素的属性被更新，这个属性又被用于子元素的 Input 绑定，这同样间接更新了父元素的属性 实例三：动态的组件实例化地址见 demo03 这种模式与之前两种模式略有不同，前两种模式都是 List2 中的第一步检测抛出的错误，而这种模式是由 DOM 更新检测（List2 第二步）抛出的错误，这个应用中父组件在 ngAfterViewInit 生命周期中动态添加子组件 该生命周期发生在当前组件 DOM 初次更新之后，而添加子组件将会修改 DOM 结构，那么前后两次 DOM 中所使用的 values 值就不同了（前提是子组件带有新的 value 引用），所以抛出了错误 解决这个问题最好的方案是改变创建组件时所处的生命周期钩子，动态创建组件的流程就可以被移到 ngOnInit 中 即使文档中说明了 ViewChildren 只能在 ngAfterViewInit 之后被获取到，但是创建视图时就在填充子组件了，所以能提前获取 ViewChildren 参考 ExpressionChangedAfterItHasBeenCheckedError ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked on ng 4 Everything you need to know about change detection in Angular","link":"/2019/03/11/Angular/07/"},{"title":"深入 Angular Component","text":"关于组件的概念，现在使用已经很广泛了，我们今天就来深入的了解一下 Angular 当中的 Component 在正式展开之前，我们先来了解一下 Web Components Web ComponentsW3C 为统一组件化标准方式，提出 Web Components 的标准，它允许我们创建可重用的定制元素（它们的功能封装在代码之外）并且在 Web 应用中使用它们 Web Components 标准主要包括以下几个重要的概念 Custom elements（自定义元素） 可以创建自定义的 HTML 标记和元素 Shadow DOM（影子 DOM） 用于将封装的 Shadow DOM 树附加到元素（与主文档 DOM 分开呈现）并控制其关联的功能 通过这种方式，可以保持元素的功能私有，这样就可以被脚本化和样式化的同时而不用担心与文档的其他部分发生冲突 HTML templates（HTML 模板） 简单来说就是使用 &lt;template&gt; 和 &lt;slot&gt; 标签去预定义一些内容，但并不加载至页面，而是将来使用 JavaScript 代码去初始化它 可以作为自定义元素结构的基础被多次重用 下面我们就通过一个简单的示例来看看 Web Components 到底是怎么使用的 例子摘取自 mdn/web-components-examples，但是稍微调整了一下 使用方式很简单，直接在页面当中使用我们自定义的组件即可，如下 123&lt;!-- 使用 --&gt;&lt;component-a text=\"我是自定义组件 A\"&gt;&lt;/component-a&gt;&lt;component-b text=\"我是自定义组件 B\"&gt;&lt;/component-b&gt; 具体实现如下 123456789101112131415161718192021222324252627282930313233// 定义组件 A 和 Bwindow.customElements.define('component-a', class extends HTMLElement { constructor() { super(); const pElem = document.createElement('p'); pElem.textContent = this.getAttribute('text'); const shadowRoot = this.attachShadow({ mode: 'open' }); shadowRoot.appendChild(pElem); } });window.customElements.define('component-b', class extends HTMLElement { constructor() { super(); const pElem = document.createElement('p'); pElem.textContent = this.getAttribute('text'); const shadowRoot = this.attachShadow({ mode: 'closed' }); shadowRoot.appendChild(pElem); } });document.querySelector('html').addEventListener('click', e =&gt; { console.log(e.composed); console.log(e.composedPath());}); 很简单的一个示例，就算没有了解过 Web Components 相关知识也可以看懂大概，我们来简单的梳理一下 window.customElements，简单来说就是用来定义一个自定义标签（custom elements） attachShadow，给指定的元素挂载一个 Shadow DOM，并且返回它的 ShadowRoot，简单来说就是返回指定 Shadow DOM 封装模式，有下面两种方式 open 指定为开放的封装模式 closed 指定为关闭的封装模式，会让该 ShadowRoot 的内部实现无法被 JavaScript 访问及修改，也就是说将该实现不公开（比如 &lt;video&gt; 标签） 另外，在 Web Components 当中也是有生命周期回调函数存在的，可以指定多个不同的回调函数，它们将会在元素的不同生命时期被调用 主要有下面四个 connectedCallback – 当 customElements 首次被插入文档 DOM 时，被调用 disconnectedCallback – 当 customElements 从文档 DOM 中删除时，被调用 adoptedCallback – 当 customElements 被移动到新的文档时，被调用 attributeChangedCallback – 当 customElements 增加、删除、修改自身属性时，被调用 上面就是一个简单的 Web Components 示例，这里也就只简单的介绍一下，如果想了解更多，可以参考 Web Components 在了解了 Web Components 的基本概念以后，我们就来看看 Angular 当中的 Component Angular Component在 Angular 当中，Component 属于指令的一种，即组件继承于指令（详细可见 packages/core/src/metadata/directives.ts） 所以我们可以简单的将其理解为拥有模板的指令（其它两种是属性型指令和结构型指令），基本组成如下 1234567@Component({ selector: 'hello', templateUrl: './hello.component.html', styleUrls: ['./hello.component.scss']})export class HelloComponent implements OnInit { } 主要分为以下几部分 组件装饰器，每个组件类必须用 @component 进行装饰才能成为 Angular 组件 组件元数据，指的是 selector、template 这一系列的属性 组件模板，每个组件都会关联一个模板，这个模板最终会渲染到页面上，页面上这个 DOM 元素就是此组件实例的宿主元素 一般来说有两种引入方式 templateUrl 和 template，区别就是内联和外链 组件类，组件实际上也是一个普通的类，组件的逻辑都在组件类里定义并实现 组件接口，组件可以定义内部需要实现的接口（比如上面的 OnInit 对应着组件的生命周期钩子 ngOnInit()） 组件元数据主要分为两种，自身元数据属性和从 core/Directive 上继承过来的，先来看自身元数据属性 自身元数据属性 名称 类型 作用 animations AnimationEntryMetadata[] 设置组件的动画 changeDetection ChangeDetectionStrategy 设置组件的变化监测策略 encapsulation ViewEncapsulation 设置组件的视图包装选项 entryComponents any[] 设置将被动态插入到该组件视图中的组件列表 interpolation [string, string] 自定义组件的插值标记，默认是双大括号 moduleId string 设置该组件在 ES/CommonJS 规范下的模块 id，它被用于解析模板样式的相对路径 styleUrls string[] 设置组件引用的外部样式文件 styles string[] 设置组件使用的内联样式 template string 设置组件的内联模板 templateUrl string 设置组件模板所在路径（外链） viewProviders Provider[] 设置组件及其所有子组件（不含 ContentChildren）可用的服务 从 core/Directive 继承 名称 类型 作用 exportAs string 设置组件实例在模板中的别名，使得可以在模板中调用 host {[key: string]: string} 设置组件的事件、动作和属性等 inputs string[] 设置组件的输入属性 outputs string[] 设置组件的输出属性 providers Provider[] 设置组件及其所有子组件（含 ContentChildren）可用的服务（依赖注入） queries {[key: string]: any} 设置需要被注入到组件的查询 selector string 设置用于在模板中识别该组件的 css 选择器（组件的自定义标签） 下面我们就来看看一些比较常用的元数据的具体含义 inputs有两种写法，第一种方式不太推荐使用，用的比较多的是下面那种，推荐在组件当中使用 @Input() 来进行接收 12345678@Component({ selector: 'hello-component', inputs: ['param']})export class HelloComponent { param: any;} 等价于下面这种 1234567@Component({ selector: 'hello-component'})export class HelloComponent { @Input() param: any;} outputs同上，和 inputs 类似 12345678@Component({ selector: 'hello-component', outputs: ['test']})export class HelloComponent { test = new eventEmitter&lt;false&gt;();} 等价于 1234567@Component({ selector: 'hello-component'})export class HelloComponent { @Output() test = new eventEmitter&lt;false&gt;();} hosthost 主要用来绑定事件，同上面一样，还是推荐使用 @HostBinding 来进行绑定 123456789101112131415@Component({ selector: 'hello-component', host: { '(click)': 'onClick($event.target)', // 事件 'role': 'nav', // 属性 '[class.pressed]': 'isPressed', // 类 }})export class HelloComponent { isPressed: boolean = true; onClick(elem: HTMLElement) { console.log(elem); }} 等价于 123456789101112131415@Component({ selector: 'hello-component'})export class HelloComponent { @HostBinding('attr.role') role = 'nav'; @HostBinding('class.pressed') isPressed: boolean = true; @HostListener('click', ['$event.target']) onClick(elem: HTMLElement) { console.log(elem); }} queries主要用来视图查询，就是 @ViewChild 另外一种写法，推荐使用 @ViewChild 装饰器 1234567891011121314@Component({ selector: 'hello-component', template: ` &lt;input #theInput type='text' /&gt; &lt;div&gt;Demo Component&lt;/div&gt; `, queries: { theInput: new ViewChild('theInput') }})export class HelloComponent { theInput: ElementRef;} 等价于 1234567891011@Component({ selector: 'hello-component', template: ` &lt;input #theInput type='text' /&gt; &lt;div&gt;Demo Component&lt;/div&gt; `})export class HelloComponent { @ViewChild('theInput') theInput: ElementRef;} queries这个主要用来内容查询使用的，也就是 @ContentChild 装饰器，不过一般情况下使用较少，模版如下 123&lt;my-list&gt; &lt;li *ngFor=\"let item of items;\"&gt;{{item}}&lt;/li&gt;&lt;/my-list&gt; 123456789101112131415161718192021@Directive({ selector: 'li'})export class ListItem {}@Component({ selector: 'my-list', template: ` &lt;ul&gt; &lt;ng-content&gt;&lt;/ng-content&gt; &lt;/ul&gt; `, queries: { items: new ContentChild(ListItem) }})export class MyListComponent { items: QueryList&lt;ListItem&gt;;} 等价于 123456789101112@Component({ selector: 'my-list', template: ` &lt;ul&gt; &lt;ng-content&gt;&lt;/ng-content&gt; &lt;/ul&gt; `})export class MyListComponent { @ContentChild(ListItem) items: QueryList&lt;ListItem&gt;;} styleUrls 和 styles这两个元数据一般是用来设置样式，styleUrls 和 styles 是允许同时指定的，不过两者之间存在优先级的关系，如下 1模板内联样式 &gt; styleUrls &gt; styles 不过一般还是建议使用 styleUrls 引用外部样式表文件，这样代码结构相比 styles 更清晰、更易于管理 changeDetection这个参数主要用来设置组件的变换检测机制，有两种取值方式 Default 和 OnPush，默认为 Default ChangeDetectionStrategy.Default 组件的每次变化监测都会检查其内部的所有数据（引用对象也会深度遍历），以此得到前后的数据变化 ChangeDetectionStrategy.OnPush 组件的变化监测只检查输入属性（即 @Input 修饰的变量）的值是否发生变化，当这个值为引用类型（Object，Array 等）时，则只对比该值的引用 显然，OnPush 策略相比 Default 降低了变化监测的复杂度，很好地提升了变化监测的性能 如果组件的更新只依赖输入属性的值，那么在该组件上使用 OnPush 策略是一个很好的选择 encapsulation关于这个属性的详细介绍可以参考 Angular 的 ViewEncapsulation 简单来说就是控制视图的封装模式，有三种模式，原生（Native）、仿真（Emulated）和无（None） 生命周期当 Angular 使用构造函数新建组件后，就会按下面的顺序在特定时刻调用这些生命周期钩子方法 生命周期钩子 调用时机 ngOnChanges 在 ngOnInit 之前调用，或者当组件输入数据（通过 @Input 装饰器显式指定的那些变量）变化时调用 ngOnInit 第一次 ngOnChanges 之后调用，建议此时获取数据，不要在构造函数中获取 ngDoCheck 每次变化监测发生时被调用 ngAfterContentInit 使用将外部内容嵌入到组件视图后被调用，第一次 ngDoCheck 之后调用且只执行一次（只适用组件） ngAfterContentChecked ngAfterContentInit 后被调用，或者每次变化监测发生时被调用（只适用组件） ngAfterViewInit 创建了组件的视图及其子视图之后被调用（只适用组件） ngAfterViewChecked ngAfterViewInit，或者每次子组件变化监测时被调用（只适用组件） ngOnDestroy 销毁指令或者组件之前触发，此时应将不会被垃圾回收器自动回收的资源（比如已订阅的观察者事件、绑定过的 DOM 事件、通过 setTimeout 或 setInterval 设置过的计时器等等）手动销毁掉","link":"/2019/08/27/Angular/09/"},{"title":"Angular 中的表单","text":"在 Angular 当中存在两种表单处理的方式：模版式表单和响应式表单 两者的区别为 不管是哪种表单，都有一个对应的数据模型来存储表单的数据，在模版式表单中，数据模型是由 Angular 基于你组件模版中的指令隐式创建的，而在响应式表单中，你通过编码明确的创建数据模型然后将模版上的 HTML 元素与底层的数据模型连接在一起 数据模型并不是一个任意的对象，它是一个由 angular/forms 模块中的一些特定的类，如 FormControl，FormGroup，FormArray 等组成的，在模版式表单中，你是不能直接访问到这些类的 响应式表单并不会替你生成 HTML，模版仍然需要你自己来编写，响应式表单不能在模版当中去操作数据模型，只能在代码中操作，模版式表单不能在代码中去操作，只能在模版当中操作 模版式表单（模版驱动表单）表单的数据模型是通过组件模版中的相关指令来定义的，因为使用这种方式定义表单的数据模型的时候 我们会受限于 HTML 的语法，所以模版驱动方式只适合用于一些简单的场景 主要包括这样几个指令：NgForm，NgModel，NgModelGroup NgForm使用 NgForm 用来代表整个表单，在 Angular 应用中会被自动的添加到 form 元素上 需要注意：不仅限于 form 元素，对于 div 元素如果手动指定 ngForm 效果也是一样的 NgForm 指令隐式的创建了一个 FormGroup 类的实例，这个类用来代表表单的数据模型并且存储表单的数据 123456789&lt;form #myForm=\"ngForm\" (ngSubmit)=\"onSubmit(myForm.value)\"&gt; &lt;div&gt;用户名：&lt;input type=\"text\"&gt;&lt;/div&gt; &lt;div&gt;密码：&lt;input type=\"text\"&gt;&lt;/div&gt; &lt;button type=\"submit\"&gt;登录&lt;/button&gt;&lt;/form&gt;&lt;div&gt; {{myForm.value | json}}&lt;/div&gt; NgModel代表表单中的一个字段，这个指令会隐式的创建一个 FormControl 的实例来代表字段模型 并用这个 FormControl 类型的对象来存储字段的值，比如上面的示例，在 input 当中输入的值并不会反应在下方，这是因为 input 标签并没有绑定 ngModel 指令 不过需要注意的是，绑定的时候直接使用 ngModel 即可，不需要添加任何括号，但是同时需要为绑定的元素添加一个 name 属性 1&lt;div&gt;用户名：&lt;input type=\"text\" ngModel name=\"username\"&gt;&lt;/div&gt; 也可以单独的绑定 ngModel 123&lt;div&gt;用户名：&lt;input #username=\"ngModel\" type=\"text\" ngModel name=\"username\"&gt;&lt;/div&gt;&lt;div&gt;{{username.value}}&lt;/div&gt; NgModelGroup代表的是表单的一部分，它允许你将一些表单字段组织在一起形成更清晰的层次关系 和上面一样，也会创建一个 FormGroup 类的一个实例，这个实例会在 NgForm 对象的 value 属性中表现为一个嵌套的对象 12345&lt;div ngModelGroup=\"userinfo\"&gt; &lt;div&gt;用户名：&lt;input #username=\"ngModel\" type=\"text\" ngModel name=\"username\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;{{username.value}}&lt;/div&gt; 生成的数据为 12345{ 'userinfo': { 'username': '' }} 响应式表单使用响应式表单时，通过编写 TypeScript 代码而不是 HTML 代码来创建一个底层的数据模型 在这个模型定义好了以后，可以使用一些特定的指令，将模版上的 HTML 元素与底层的数据模型连接在一起，若使用模版式表单表单，则导入 FormsModule，若使用响应式表单，则导入 ReactiveFormsModule 与模版式表单不同，创建一个响应式表单需要两步 首先需要创建一个数据模型，用来保存表单数据的数据结构，简称模型，它由定义在 Angular 中的 forms 模块中的三个类组成 FormControl，FormGroup 和 FormArray 然后需要使用一些指令将模版中的 HTML 元素连接到这个数据模型上 响应式表单的指令响应式表单使用一组与模版式表单完全不同的指令（全部来源于 ReactiveFormModule 模块） 类名 指令（这一列的需要使用属性绑定语法） 指令（这一列不需要） FormGroup formGroup formGroupName FormControl formControl formControlName FormArray formArrayName 响应式表单中所有的指令都是以 form 开头的，所以可以很容易的和模版式表单（比如 ngModel）区分开来，这些 form 开头的指令是不能进行引用的（比如 #myForm=&quot;ngForm&quot;） 模版式表单当中拿不到 FormControl，FormGroup 和 FormArray 这三个类，而在响应式表单当中可以直接访问数据模型相关的类（由于它们是不可以引用的，所以不能在模版当中去操作数据模型，只能在代码当中操作） FormGroup既可以代表表单的一部分，也可以用于代表整个表单，它是多个 FormControl 的集合 FormGroup 将多个 FormControl 的值和状态聚合在一起，比如在表单验证中，如果其中一个 FormControl 是无效的，那么整个 FormGroup 就是无效的 FormArray与 FormGroup 类似，但是有一个额外的长度属性，一般来说，FormGroup 用来代表整个表单或者表单字段的一个固定子集 而 FormArray 通常用来代表一个可以增长的字段集合，但是它里面的字段是没有 key 属性的，只能通过序列去查询 FormControl它是构成表单的基本单位，通常情况下会用来代表一个 input 元素，但是也可以用来代表一个更为复杂的 UI 组件，比如日历，下拉选择块等 保存着与其关联的 HTML 元素当前的值以及元素的校验状态，还有元素是否被修改过的相关信息 1234export class ReactiveFormComponent implements OnInit { // FormControl 这个构造函数可以接收一个参数，用来指定 FormControl 的初始值 username: FormControl = new FormControl('zhangsan')} 指令的具体作用formGroup一般我们会使用绑定到一个 form 标签的 formGroup 对象来代表整个表单，比如 1&lt;form [formGroup]=\"formModel\"&gt;&lt;/form&gt; 这样一来，表单的处理方式就会变成一个响应式表单的处理方式 formGroupName在模版当中使用 formGroupName 来连接一个 formGroup，比如 formGroupName='dataRange' 在组件中使用 FormGroup 来构造对应的指定名称 formControlName必须声明在一个 formGroup 之内来连接 formGroup 之内的 formControl 和页面上的 DOM 元素 formArrayName同 formControlName 类似，同样必须用在 formGroup 之内 因为在 formArrayName 当中没有序列号，所以一般和 *ngFor 指令配合使用 formControl不能使用在模版当中的 formGroup 的内部，只能用在外部与某个单独的元素（input）绑定起来 再次强调 在响应式表单当中，所有的指令都是以 form 开头的（模版式表单才是以 ngxxx 开头） 如果指令以 Name 结尾，不需要使用属性绑定的语法，直接等于一个属性的名称即可（字符串），同时，这些属性只能用在 formGroup 覆盖的范围之内 如果指令不是以 Name 结尾，则需要使用属性绑定的语法（[]=&quot;&quot;） 使用 FormBuild 简化写法简化了定义表单结构的语法，相对于直接使用 FormGroup，FormControl 和 FormArray 使用 FormBuild 可以让我们使用更少的代码定义出同样的数据结构，来重构上面的示例 12345678910111213formModel: FormGroup;constructor(private fb: FormBuilder) { this.formModel = fb.group({ username: ['zhangsan'], phone: [''], dateRange: fb.group({ from: [''], to: [''] }), emails: fb.array(['123@126.com', '456@126.com']) });} 使用 FormBuilder 可以简化我们的代码，同时提供了更多了配置 比如 fb.group({}) 方法，调用其就相当于 new FormGroup({})，但是其还可以接收一个额外的参数用来校验这个 formGroup 而对于其中的 formControl 则采用了一个数组（['']）的形式来进行初始化，同时还可以额外接收两个参数 12// 如果多于三个参数，其他的元素会被忽略username: ['初始值', 校验方法, 异步的校验方法], 完整示例前提需要在当前模块下导入 ReactiveFormsModule 并且在 imports 当中进行添加 12345678import { ReactiveFormsModule } from '@angular/forms';@NgModule({ // ... imports: [ ReactiveFormsModule ]}) 模版如下 123456789101112131415161718192021222324252627&lt;form [formGroup]=\"formModel\" (submit)=\"onSubmit()\"&gt; &lt;!-- 使用 formControl 来进行绑定，但是这样 username 属性进入不到表单内部 所以可以将其放入到 formGroup 内部，同时改变绑定写法（否则会报错） 在外部：&lt;input type=\"text\" [formControl]=\"username\"&gt; 在内部：&lt;input type=\"text\" formControlName=\"username\"&gt; 然后在组件中将 username 移动至 formModel 当中即可 --&gt; &lt;input formControlName=\"username\"&gt; &lt;input formControlName=\"phone\"&gt; &lt;!-- 使用 formGroupName 来指定组件当中的 formGroup 名称 --&gt; &lt;div formGroupName=\"dateRange\"&gt; 起始日期：&lt;input type=\"date\" formControlName=\"from\"&gt; 结束日期：&lt;input type=\"date\" formControlName=\"to\"&gt; &lt;/div&gt; &lt;div&gt; &lt;ul formArrayName=\"emails\"&gt; &lt;!-- 获得 formModel 当中 emails，然后使用 controls 来获取当中的集合（即数组） --&gt; &lt;li *ngFor=\"let email of this.formModel.get('emails').controls; let i = index;\"&gt; &lt;!-- 使用 formControlName 将其和循环下标绑定在一起，注意需要使用属性绑定语法 --&gt; &lt;input type=\"text\" [formControlName]=\"i\"&gt; &lt;/li&gt; &lt;/ul&gt; &lt;button type=\"button\" (click)=\"addEmail()\"&gt;新增 Email&lt;/button&gt; &lt;/div&gt; &lt;button type=\"submit\"&gt;保存&lt;/button&gt;&lt;/form&gt; 组件如下 123456789101112131415161718192021222324252627282930313233import { FormGroup, FormControl, FormArray } from '@angular/forms';export class ReactiveFormComponent implements OnInit { // FormControl 这个构造函数可以接收一个参数，用来指定 FormControl 的初始值 username: FormControl = new FormControl('zhangsan'); formModel: FormGroup = new FormGroup({ username: new FormControl('zhangsan'), dateRange: new FormGroup({ from: new FormControl(), to: new FormControl() }), emails: new FormArray([ new FormControl('123@126.com'), new FormControl('456@126.com') ]) }); constructor() { } ngOnInit() { } onSubmit() { console.log(this.formModel.value); } addEmail() { // 拿到了是一个 FormArray 类型的对象，所以强制转换一下类型 const emails = this.formModel.get('emails') as FormArray; // 点击新增的时候添加一个 input emails.push(new FormControl()); }} 自定义表单控件我们来尝试着将一个普通的模版封装为自定义表单控件，需要首先引入 ControlValueAccessor 然后将接口定义为 ControlValueAccessor，其内部有三个方法，需要我们自己去手动实现 123456789101112131415161718192021222324252627282930import { ControlValueAccessor } from '@angular/forms'export class ImageListSelectComponent implements ControlValueAccessor { public propagateChange = (_: any) =&gt; {} // 这个方法用来写入值，就像之前的设置初始值，或者在方法内部写入值 // 比如 this.form.patchValue 或者 this.form.setValue writeValue(obj: any): void { this.selected = obj; } // 如果表单的 value 或者值发生了变化，需要通知表单，定义一个空函数接收系统传递的一个函数 // 在表单发生变化的时候 emit 这个事件通知表单需要进行更新 registerOnChange(fn: any): void { } // 指明表单控件什么情况下算是 Touch 状态，需要告诉给表单 // 定义一个空函数来进行接收 registerOnTouched(fn: any): void { this.propagateChange = fn; } // 然后在发生变化的时候，emit 通知表单发生了变化 onChange(i) { this.propagateChange(this.selected); }} 然后需要指定依赖池 1234567891011121314151617181920212223242526import { forwardRef } from '@angular/core';// 引入 NG_VALUE_ACCESSOR 令牌import { NG_VALUE_ACCESSOR, NG_VALIDATORS } from '@angular/forms'@Component({ providers: [ { // 将自身注册到这个令牌上 provide: NG_VALUE_ACCESSOR, // useExisting 使用已有的，也就是自身 // 然后这里存在一个问题，在元数据当中，自身可能没有被创建，所以注册不到令牌上面 // 所以这里使用 forwardRef() 方法，就可以引用自身了 // 会等待实例化之后才会进行引用，这样写不影响使用 useExisting 注册到依赖池当中 useExisting: forwardRef( () =&gt; ImageListSelectComponent), // 类似 NG_VALUE_ACCESSOR 这种令牌，本身都是 多对一 的 // 比如多个控件使用同一个令牌 multi: true }, // 验证同理，也需要是可以验证的 { provide: NG_VALIDATORS, useExisting: forwardRef( () =&gt; ImageListSelectComponent), multi: true } ]}) 添加自定义认证 1234567validate(c: FormControl): {[key: string]: any} { return this.selected ? null : { imageListInvalid: { valid: false } }} 完整代码如下： 12345678910111213141516171819&lt;!-- 模版 --&gt;&lt;div&gt; &lt;span&gt;{{title}}&lt;/span&gt; &lt;img [src]=\"selected\" class=\"avatar\"&gt;&lt;/div&gt;&lt;div class=\"scroll-container\"&gt; &lt;md-grid-list [cols]=\"cols\" [rowHeight]=\"rowHeight\"&gt; &lt;md-grid-tile *ngFor=\"let item of items; let i = index\"&gt; &lt;div class=\"image-container\" (click)=\"onChange(i)\"&gt; &lt;img class=\"avatar\" [src]=\"item\"&gt; &lt;div class=\"after\"&gt; &lt;div class=\"zoom\"&gt; &lt;md-icon&gt;checked&lt;/md-icon&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/md-grid-tile&gt; &lt;/md-grid-list&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import { Component, Input, forwardRef } from '@angular/core';import { ControlValueAccessor, NG_VALUE_ACCESSOR, NG_VALIDATORS, FormControl } from '@angular/forms'@Component({ selector: 'app-image-list-select', templateUrl: './image-list-select.component.html', styleUrls: ['./image-list-select.component.scss'], providers: [ { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef( () =&gt; ImageListSelectComponent), multi: true }, { provide: NG_VALIDATORS, useExisting: forwardRef( () =&gt; ImageListSelectComponent), multi: true } ]})export class ImageListSelectComponent implements ControlValueAccessor { @Input() title = '选择'; @Input() cols = '6'; @Input() rowHeight = '64px'; @Input() items: string[] = []; public selected: string; public propagateChange = (_: any) =&gt; {} constructor() { } onChange(i) { this.selected = this.items[i]; this.propagateChange(this.selected); } writeValue(obj: any): void { this.selected = obj; } registerOnChange(fn: any): void { this.propagateChange = fn; } registerOnTouched(fn: any): void { } validate(c: FormControl): {[key: string]: any} { return this.selected ? null : { imageListInvalid: { valid: false } } }} 使用： 1234567&lt;!-- 选择头像 --&gt;&lt;app-image-list-select [cols]=\"6\" [items]=\"items\" formControlName=\"avatar\"&gt;&lt;/app-image-list-select&gt; 这样一来就可以进行初始化操作了 123456789101112131415161718192021222324import { FormBuilder, FormGroup } from '@angular/forms'export class RegisterComponent implements OnInit { public items: string[] = [ 'assets/avatar/01.jpg', 'assets/avatar/02.jpg', 'assets/avatar/03.jpg', 'assets/avatar/04.jpg' ]; form: FormGroup; constructor(private fb: FormBuilder) { } ngOnInit() { this.form = this.fb.group({ email: [], name: [], password: [], repeat: [], avatar: ['assets/1.jpg'] }) }}","link":"/2019/05/27/Angular/10/"},{"title":"rxjs 高阶操作符","text":"这里只简单的介绍常用的三个高阶操作符，更多的可以参见官方文档 RxJS flatMap当流中的每个元素其本身又是一个流的情况下，高阶操作符就是用来处理这样的情况 1234567Rx.Observable .fromEvent(a, 'keyup') .pluck('target', 'value') .map(_ =&gt; Rx.Observable.interval(100)) .subscribe(val =&gt; { val.subscribe(val =&gt; console.log(val)) }) 像这样一层一层的调用不是很好的方法，所以我们可以采用 flatMap（在 rxjs 中是 mergeMap 的别名） 12345Rx.Observable .fromEvent(a, 'keyup') .pluck('target', 'value') .flatMap(_ =&gt; Rx.Observable.interval(100)) .subscribe(val =&gt; console.log(val)) 每次触发都会从新生成一个新流，而两个新流则是并行，其中的每一个流并没有断开 mergeMap 会保证所有的订阅，保证外层元素所对应的子流的订阅 switchMap与 flatMap 有些不同，它会断开之前的流，转而从新生成一个新流 12345Rx.Observable .fromEvent(a, 'keyup') .pluck('target', 'value') .switchMap(_ =&gt; Rx.Observable.interval(1000)) .subscribe(val =&gt; console.log(val)) 一旦有新的外层元素进来，它就会抛弃掉这个元素之前的外层元素所关联的子元素 count计算源的发送数量，并当源完成时发出该数值 简单来说就是：将流中的数据做一个统计，然后输出出来（最后也是一个值），也就是告知之前的任务已经全部完成了 比如一个删除列表的操作 1234567891011del(project: Project): Observable&lt;Project&gt; { // 用 mergeMap 的原因是因为如果在删除过程中有新的 id 进来，原有的删除操作还是需要继续做的 // 而且新的删除操作也会操作，即所有外层元素的流进来以后，它对应的子流全部都要保持住 const delTasks$ = Observable.from(project.list) .mergeMap(id =&gt; this.http.delete(url)) .count() // 汇总以后不用去关心其外层的流，利用 switchMap 执行删除操作 // 因为最后希望返回一个 project 对象，所以使用 mapTo 进行转换一下 return delTasks$.switchMap(_ =&gt; this.http.delete(url)) .mapTo(project)} Observable 的冷和热简单来说，两者的区别可以分为一个为看视频，一个为看电视直播 虽然都是同样的内容，但是视频每次都必须需要从头开始看，这就是冷的 Observable 而电视直播，无论合适进来，看到的都是同样的内容，这就是热的 Observable 12345678// 冷的 Observableconst count$ = Rx.Observable.interval(1000)const sub1 = count$.subscribe(v =&gt; console.log(v))setTimeout(() =&gt; { const sub2 = count$.subscribe(v =&gt; console.log(v))}, 2000) 每次有新的流进来，都是从头开始计算，下面来看看热的 12345678// 热的 Observable，添加上 share() 即可const count$ = Rx.Observable.interval(1000).share();const sub1 = count$.subscribe(v =&gt; console.log(v))setTimeout(() =&gt; { const sub2 = count$.subscribe(v =&gt; console.log(v))}, 2000) 可以发现，后进来的流会将之前的全部抛弃掉，直接从进来时候的流的位置跟着往下走 SubjectSubject 其实是观察者模式的实现，所以当观察者订阅 Subject 对象时，Subject 对象会把订阅者添加到观察者列表中 每当有 Subject 对象接收到新值时，它就会遍历观察者列表，依次调用观察者内部的 next() 方法，把值一一送出 Subject 既是 Observable 对象，又是 Observer 对象，是一个特殊的对象，一方面可以作为流的组成也就是输出的一方，另一方可以作为流的观察一方即接收的一方 当有新消息时，Subject 会对内部的 observers 列表进行组播 (multicast) Subject 之所以具有 Observable 中的所有方法，是因为 Subject 类继承了 Observable 类，在 Subject 类中有五个重要的方法 next – 每当 Subject 对象接收到新值的时候，next 方法会被调用 error – 运行中出现异常，error 方法会被调用 complete – Subject 订阅的 Observable 对象结束后，complete 方法会被调用 subscribe – 添加观察者 unsubscribe – 取消订阅 (设置终止标识符、清空观察者列表) 因为其同时实现了两个接口，在一些特殊的情景下会非常有用，下面是两个延伸方法 ReplaySubject 两者相差不多，Replay 会保留最新的 N 个值 BehaviorSubject 与上面使用方法一致，不过是一种特殊形式，会保留最新的一个值 12345678910111213141516171819// 调整一下上面的示例，这种情况下依然是一种冷的 Observableconst counter$ = Rx.Observable.interval(1000).take(5);const observer1 = { next: (v) =&gt; console.log(`v1 &gt;&gt; ${v}`), error: (err) =&gt; console.log(err), complete: (_) =&gt; console.log(`Completed -`)}const observer2 = { next: (v) =&gt; console.log(`v2 &gt;&gt; ${v}`), error: (err) =&gt; console.log(err), complete: (_) =&gt; console.log(`Completed -`)}counter$.subscribe(observer1)setTimeout(() =&gt; { counter$.subscribe(observer2)}, 2000) 可以发现，此时的输出结果是一样的 但是此时面临的情况为，需要执行两次 subscribe() 操作，而有时的场景为定义好的序列应该会在什么时刻来进行触发，只需要执行一次操作，两个序列都会执行，所以在这种情况下就可以使用 Subject 12345678910111213141516171819202122// 利用 subject 来进行中转，这种情况下成为了热的 Observableconst counter$ = Rx.Observable.interval(1000).take(5);const subject = new Rx.Subject();const observer1 = { next: (v) =&gt; console.log(`v1 &gt;&gt; ${v}`), error: (err) =&gt; console.log(err), complete: (_) =&gt; console.log(`Completed -`)}const observer2 = { next: (v) =&gt; console.log(`v2 &gt;&gt; ${v}`), error: (err) =&gt; console.log(err), complete: (_) =&gt; console.log(`Completed -`)}subject.subscribe(observer1)setTimeout(() =&gt; { subject.subscribe(observer2)}, 2000)counter$.subscribe(subject); subject.next()可以往流中推送两个新值 12345678subject.next(10);subject.next(11);subject.subscribe(observer1)setTimeout(() =&gt; { subject.subscribe(observer2)}, 2000)counter$.subscribe(subject); 但是需要注意的是，添加的位置很重要，比如上面这样，与之前的输出是一样的，流中的数据没有改变 这时因为在推送新值的时候，还没有进行订阅 12345678910// 调整为这样即可subject.subscribe(observer1)subject.next(10);subject.next(11);setTimeout(() =&gt; { subject.subscribe(observer2)}, 2000)counter$.subscribe(subject); 可以看到第一个流中就有推送的新值存在了，但是第二个流中是没有新值的，因为在第二个流开始订阅的时候，推送新值的时间点已经过去了 Rx.ReplaySubject()将过去发生的一些事件进行重播，比如将之前发生的两个事件发生重播 1234567891011121314151617181920const subject = new Rx.ReplaySubject(2);subject.next(10);subject.next(11);// ...// v1 &gt;&gt; 10// v1 &gt;&gt; 11// v1 &gt;&gt; 0// v2 &gt;&gt; 11// v2 &gt;&gt; 0// v1 &gt;&gt; 1// v2 &gt;&gt; 1// v1 &gt;&gt; 2// v2 &gt;&gt; 2// v1 &gt;&gt; 3// v2 &gt;&gt; 3// v1 &gt;&gt; 4// v2 &gt;&gt; 4// Completed -// Completed - 可以发现，第一个流重播的为 10 和 11，而第二个流重播的则是 11 和 0，因为当第二个流开始重播的时候发现前两个的输出分别为 11 和 0 Rx.BehaviorSubject()123const subject = new Rx.BehaviorSubject();subject.next(10);subject.next(11); 而 BehaviorSubject() 只会记住最新的值 一个示例 1234567891011121314151617181920// 使用 BehaviorSubject 去存储，因为其总是可以记住上一次的一个最新值private _dragData = new BehaviorSubject&lt;DragData&gt;(null);// 在开始拖拽的时候，把流中新增一个 data 元素，把这个最新值 next 出去setDragData(data: DragData) { this._dragData.next(data);}// 当放到否个区域的时候，可以得到这个 Observable，所以取值的时候就会取到最新的 data// 尽管在拖拽的过程中值已经发射完了，但是依然可以得到上一次发射之后最新的一个值// this._dragData.asObservable() 的作用是将 Subject 转换成 ObservablegetDragData(): Observable&lt;DragData&gt; { return this._dragData.asObservable();}// 清空的时候将一个 null 放到这个流中// 可以保证在其他误接收的地方会发现这是一个 null，即没有这个值clearDragData() { this._dragData.next(null);} Async Pipe在常规编程中，如果得到一个 Observable 数组，在页面当中是没有办法去直接使用，需要去 Subscribe 一下 然后声明一个成员的本地变量，用来得到返回的数据，然后在用于页面渲染 但是有了 Async Pipe 上面这些操作都不需要了，这样在页面当中就可以直接使用 Observable，并且不需要去取消订阅 12345&lt;md-option *ngFor='let item of memberRestlts$ | async' [value]='item' (onSelectionChange)='handleMembersSelection(item)'&gt;{{item.email}}&lt;/md-option&gt; 12345this.memberRestlts$ = this.form.get('memberSearch').valueChanges .debounceTime(300) .distinctUntilChanged() .filter(s =&gt; s &amp;&amp; s.length &gt; 1) .switchMap(str =&gt; this.service$.serachUsers(str)) 按照之前的操作，我们应当去 subscribe 一下，但是这里使用了 Async Pipe，就不需要那么多麻烦的操作 12// 直接定义一个流memberRestlts$: Observable&lt;User[]&gt;; 然后让本地这个流等于我们组合后的流，然后在 html 模版当中便可以直接使用，别忘了加上 | async 一些需要手动取消订阅释放资源的场景表单当中的场景123456789ngOnInit() { this.form = new FormGroup({...}); // 监听表单值的变化 this.valueChanges = this.form.valueChanges.subscribe(console.log);}ngOnDestroy() { this.valueChanges.unsubscribe();} 路由当中的场景1234567ngOnInit() { this.route.params.subscribe(console.log);}ngOnDestroy() { // 手动执行取消订阅的操作} Renderer 服务12345678910111213constructor( private renderer: Renderer2, private element: ElementRef) { }ngOnInit() { this.click = this.renderer .listen(this.element.nativeElement, 'click', handler);}ngOnDestroy() { this.click.unsubscribe();} interval() &amp; fromEvent()12345678910111213141516constructor(private element : ElementRef) { }interval: Subscription;click: Subscription;ngOnInit() { this.interval = Observable.interval(1000).subscribe(console.log); this.click = Observable .fromEvent(this.element.nativeElement, 'click') .subscribe(console.log);}ngOnDestroy() { this.interval.unsubscribe(); this.click.unsubscribe();} Redux Store12345678910111213141516constructor(private store: Store) { }todos: Subscription;ngOnInit() { /** * select(key : string) { * return this.map(state =&gt; state[key]).distinctUntilChanged(); * } */ this.todos = this.store.select('todos').subscribe(console.log); }ngOnDestroy() { this.todos.unsubscribe();} 无需手动释放资源场景 AsyncPipe 当组件销毁的时候，async 管道会自动执行取消订阅操作，进而避免内存泄 @HostListener 如果使用 @HostListener 装饰器，添加事件监听时，我们无法手动取消订阅 如果需要手动移除事件监听的话，可以使用以下的方式 12345// subscribethis.handler = this.renderer.listen('document', 'click', event =&gt;{...});// unsubscribethis.handler(); Finite Observable当你使用 http 服务或 timer Observable 对象时，你也不需要手动执行取消订阅操作 12345ngOnInit() { // 表示 1s 后发出值，然后就结束了 Observable.timer(1000).subscribe(console.log); this.http.get('http://api.com').subscribe(console.log);}","link":"/2019/06/08/Angular/12/"},{"title":"float、display、position、vertical-align、line-height","text":"float误解float 的常见用法一般用来横向排版或者多列布局（bootstrap 中的栅格系统也是通过 float 来实现的），并且在 CSS3 并未普及前，多列布局的解决方案一般也是通过 float 来实现的 但是 float 被设计出来的初衷只是仅仅用于来实现文字环绕图片的效果 坍塌现象比如在一个 div 元素中放置了一个设置了 float 属性的图片，这样一来会导致 div 的高度坍塌，根本原因在于设置 float 的元素会脱离文档流 另外要提到的一点就是，如果普通的 div 没有设置宽度，那么它的默认宽度则会充满整个屏幕，但是如果给 div 设置了 float 属性行，它的宽度就不再是占据整个屏幕，而是其宽度会自动调整为包裹住里面内容的宽度 此时虽然 div 体现了包裹性，但是它的 display 样式是没有变化的，仍然是 block 清除 float想要解决上面出现的坍塌问题也很简单，一般常见的有下面几种 为父元素添加 overflow: hidden 或者父元素也设置为浮动 再或者设置 clear: both displaydisplay 是设计 CSS 版面配置中最重要的属性，每个 HTML 元素都有一个预设的 display 值，不同的元素属性会有不同的预设值 大部分元素的 display 属性，预设值通常是 block 或 inline 其中一个 若该元素的 display 属性被标示为 block 就被称为「区块元素」，若被标示为 inline 就称为「行内元素」 display 的属性有很多，这里主要介绍的是 block，inline 和 none block比如 div 就是一个标准的区块元素 一个区块元素会让其内容从新的一行开始显示，并尽可能的撑满容器 其他常用的区块元素包括 p、form 以及一些 HTML5 新出现的元素（header、footer、section 等） inline网页的所有元素，除了块就是流，而且流都是包含在块里面的（最外层的 body 就是一个块） 常用的 inline 就是文字和图片，它是没有大小和形状的，它的宽度取决于父容器的宽度 针对 inline 的标签，你设置宽度和高度是无效的，该元素实际的宽度和高度都是 auto，并不是我们设定的值 将 inline 元素转化为块级元素常见的方式有 display: block，display: table 等等，这里提两种不是很常见的 一种是对 inline 元素设置 float 另一种就是对 inline 元素设置 position: absolute/fixed 需要注意的是，在 IE7 以下是不支持给块级元素设置 inline-block 样式 但是可以通过如下方法来进行解决，首先将其变成行内元素，使用具有行内元素的特性，然后触发 haslayout，使其具有块级元素的特性，如此就可以模拟出 inline-block 的效果 12345div{ display: inline-block; *display: inline; zoom: 1;} none另一个常用的 display 值是 none 有一些特殊的元素 display 预设值会套用 none 属性值，它通常会搭配 JavaScript 一起使用 我们可以通过 JavaScript 动态修改元素的 display 属性，用以隐藏或显示该元素，而不是将元素从页面中删除或重建 display 和 visibility 属性的区别如下 把 display 设定成 none 不会保留元素原本该显示的空间 但是 visibility: hidden 会让元素的内容看不见，但会保留原本内容应该显示的空间，只是看不到内容而已 display: none 的节点不会被加入 Render Tree，而 visibility: hidden 则会，所以如果某个节点最开始是不显示的，设为 display: none 是更优的 positionposition 常用的属性一般有四个 static/relative/absolute/fixed 另外 CSS3 又提供了三个新的属性，分别为 center/page/sticky，虽然实现的效果很好，但是兼容性不是很好（IE11 暂时都不支持），所以一般很少去使用 static 和 fixed其中 static（静态定位）是默认值，即所有的元素如果不设置其他的 position 值，它的 position 值就是 static fixed 其实和 absolute 一样，唯一区别在于 fixed 永远根据浏览器来确定位置，和其他元素没有关系 relativerelative 会导致自身位置的相对变化，而不会影响其他元素的位置、大小的变化，这是 relative 的要点之一 另外，relative 还会产生一个新的定位上下文 relative 元素的定位永远是相对于元素自身位置的，和其他元素没关系，也不会影响其他元素 absoluteabsolute 元素脱离了文档结构，和 relative 不同，只要元素会脱离文档结构，它就会产生破坏性，导致父元素坍塌 同时 absolute 元素也具有包裹性和跟随性，而且 absolute 元素会悬浮在页面上方，会遮挡住下方的页面内容，也会使得元素已有的 float 失效（不过 absolute 和 float 一起使用的场景不太常见） 一般通过给 absolute 元素设置 top、left 值来控制其所在的位置，但是它所依据定位的基准点与 fixed 不同 它的纵向和横向的偏移量主要依靠以下来定位的 浏览器递归查找该元素的所有父元素，如果找到一个设置了 position: relative/absolute/fixed 的元素，就以该元素为基准定位 如果没找到，就以浏览器边界定位 vertical-alignvertical-align 用来设置垂直对齐方式，所有垂直对齐的元素都会影响行高 注意：IE7- 浏览器中 vertical-align 的百分比值不支持小数行高，且取 baseline、middle、text-bottom 等值时与标准浏览器在展示效果不一样，常用的解决办法是将行内元素设置 display: inline-block 它的取值方式有很多种 123456789101112131415161718192021baseline // 元素的基线与父元素的基线对齐sub // 降低元素的基线到父元素合适的下标位置super // 升高元素的基线到父元素合适的上标位置bottom // 把对齐的子元素的底端与行框底端对齐text-bottom // 把元素的底端与父元素内容区域的底端对齐top // 把对齐的子元素的顶端与行框顶端对齐text-top // 把元素的顶端与父元素内容区域的顶端对齐middle // 元素的中垂点与父元素的基线加 1/2 父元素中字母X的高度对齐px // 元素相对于基线 上/下 偏移 pxx% // 相对于元素的 line-height 值inherit // 从父元素继承属性的值 综合一些常用情况，简单来说就是： 对齐操作必定涉及操作元素和参考系元素 而 vertical-align 的值全是指参考系元素的位置 而操作元素则以 baseline 或 linebox 上中下作对齐 默认对齐方式为 baseline，数量值均是相对于 baseline 而言 仅对 inline-level 和 table-cell 元素有效 有的时候会遇到 inline-block 底部会有空隙的问题（比如一个 div 当中嵌套一张图片） inline-block 元素在块级元素中留空隙就是因为图像的默认垂直对齐方式是基线对齐（基线对齐在原理上图像底边与匿名文本大写英文字母 X 的底边对齐） 而匿名文本是有行高的，所以X的底边距离行框有一段距离，这段距离就是图像留出的空隙 常用的解决办法 display: block，因为垂直对齐方式只能作用于行内元素，更改为块级元素，会使垂直对齐方式失效 设置父级的 line-height: 0，这样使匿名文本与行框的距离为 0 使用 vertical-align: top/middle/bottom line-heightline-height，一般也称为行高，指的是相邻文本行基线间的距离，至于什么是基线，可以参考下图 从上到下四条线分别是顶线、中线、基线、底线，那么行高是指上下文本行的基线间的垂直距离，即如上图所示中的两条红线间垂直距离（实际在数值上，行高也等于其它相同颜色间的距离） 行高 line-height 实际上只影响行内元素和其他行内内容，而不会直接影响块级元素，也可以为一个块级元素设置 line-height，但这个值只是应用到块级元素的内联内容时才会有影响，在块级元素上声明 line-height 会为该块级元素的内容设置一个最小行框高度 常用术语如下图所示： 内容区对于行内非替换元素或匿名文本某一部分，font-size 和 font-family 确定了内容区的高度，在宋体情况下，如果一个行内元素的 font-size 为 15px，则内容区的高度为 15px，而在其他字体情况下，内容区的高度并不等于字体大小 行内框内容区加上行间距等于行内框，如果一个行内非替换元素的 font-size 为 15px，line-height 为 21px，则相差 6px 用户代理将这 6 像素一分为二，将其一半分别应用到内容区的顶部和底部，这就得到了行内框 当 line-height 小于 font-size 时，行内框实际上小于内容区 行框行框定义为行中最高行内框的顶端到最低行内框底端之间的距离，而且各行框的顶端挨着上一行行框的底端 框属性 内边距、外边距和边框不影响行框的高度，即不影响行高 行内元素的边框边界由 font-size 而不是 line-height 控制 外边距不会应用到行内非替换元素的顶端和底端 margin-left、padding-left、border-left 应用到元素的开始处，而 margin-right、padding-right、border-right 应用到元素的结尾处 替换元素行内替换元素需要使用 line-height 值，从而在垂直对齐时能正确地定位元素，因为 vertical-align 的百分数值是相对于元素的 line-height 来计算的，对于垂直对齐来说，图像本身的高度无关紧要，关键是 line-height 的值 默认地，行内替换元素位于基线上，如果向替换元素增加下内边距、外边距或边框，内容区会上移 替换元素的基线是正常流中最后一个行框的基线，除非该替换元素内容为空或者本身的 overflow 属性值不是 visible，这种情况下基线是 margin 底边缘 150% 与 1.5 的区别主要区别如下： 父元素设置 line-height: 1.5 会直接继承给子元素 子元素根据自己的 font-size 再去计算子元素自己的 line-height 实际行高 = 1.5 * 子元素的 font-size 父元素设置 line-height: 150% 是会先计算好 line-height 值 然后把这个计算值给子元素继承，子元素继承拿到的就是最终的值了 此时子元素设置 font-size 对其 line-height 是无影响的 line-height 与图片的表现inline 水平元素 vertical-align 默认基线对齐 比如图片和文字在一排排列，这个时候如果字体的 line-height 过大，而图片又是根据文字的基线来排列的，这个时候图片底部便会出现间距 例如消除图片底部间距这个问题和之前的 inline-block 底部会有空隙的问题是一致的 解决办法一种就是将图片块状化，这时就无基线对齐，因为 vertical-align 属性只对内联，内联块状元素有效 另一种就是使用 vertical-align：bottom 来将图片的底线对齐，或者减小行高（这时基线的位置会上移）","link":"/2018/11/28/CSS/05/"},{"title":"关于子容器属性 flex 取值问题","text":"参考 CSS 伸缩盒布局模组 主要分为两部分，容器和元素，这里主要说的是应用在元素身上的 flex 属性取值的问题 下面是一些 flex 布局常用的属性和一些取值介绍 需要注意的是，如果将元素的 display 属性设置为 flex，那么其就转换为了 flex 容器 在设为 flex 容器后，其子元素的 float、clear 和 vertical-align 属性都将失效 容器的属性有下面六个属性是应用在容器上面的 flex-direction 属性决定主轴的方向（即项目的排列方向） row（默认值） 主轴为水平方向，起点在左端 row-reverse 主轴为水平方向，起点在右端 column 主轴为垂直方向，起点在上沿 column-reverse 主轴为垂直方向，起点在下沿 flex-wrap 默认情况下，项目都排在一条线（轴线）上，如果一条轴线排不下，如何换行 nowrap（默认） 不换行 wrap 换行，第一行在上方 wrap-reverse 换行，第一行在下方 flex-flow 为 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap justify-content 定义了项目在主轴上的对齐方式（左右） flex-start（默认值） 左对齐 flex-end 右对齐 center 居中 space-between 两端对齐，项目之间的间隔都相等 space-around 每个项目两侧的间隔相等，所以，项目之间的间隔比项目与边框的间隔大一倍 align-items 定义项目在交叉轴上如何对齐（上下） flex-start 交叉轴的起点对齐 flex-end 交叉轴的终点对齐 center 交叉轴的中点对齐 baseline 项目的第一行文字的基线对齐 stretch（默认值） 如果项目未设置高度或设为 auto，将占满整个容器的高度 align-content 定义了多根轴线的对齐方式如果项目只有一根轴线，无效（意思就是内容分为多行，类似 line-height） flex-start 与交叉轴的起点对齐 flex-end 与交叉轴的终点对齐 center 与交叉轴的中点对齐 space-between 与交叉轴两端对齐，轴线之间的间隔平均分布 space-around 每根轴线两侧的间隔都相等，所以，轴线之间的间隔比轴线与边框的间隔大一倍 stretch（默认值） 轴线占满整个交叉轴 元素的属性有下面六个属性是应用在元素身上的 order 定义项目的排列顺序，数值越小，排列越靠前，默认为 0 flex-grow 定义项目的放大比例，默认为 0，即如果存在剩余空间，也不放大 如果所有项目的 flex-grow 属性都为 1，则它们将等分剩余空间（如果有的话） 如果一个项目的 flex-grow 属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍（类似合并单元格） flex-shrink 定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小 如果所有项目的 flex-shrink 属性都为 1，当空间不足时，都将等比例缩小 如果一个项目的 flex-shrink 属性为 0，其他项目都为 1，则空间不足时，前者不缩小 flex-basis 定义了在分配多余空间之前，项目占据的主轴空间 浏览器根据这个属性，计算主轴是否有多余空间，它的默认值为 auto，即项目的本来大小 它可以设为跟 width 或 height 属性一样的值，则项目将占据固定空间 flex 是 flex-grow, flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto，后两个属性可选 align-self 允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性（父级容器指定的排列方式） 默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch 除了 auto，其他都与 align-items 属性完全一致 flex下面就来看看 flex 这个应用在元素身上的属性 首先明确一点是， flex 是 flex-grow、flex-shrink、flex-basis 的缩写 flex 的默认值是以上三个属性值的组合，假设以上三个属性同样取默认值，则 flex 的默认值是 0 1 auto，如下，是等同的 1234567.item {flex: 222 233 244px;}.item { flex-grow: 222; flex-shrink: 233; flex-basis: 244px;} 当 flex 取值为 none，则计算值为 0 0 auto，如下是等同的 1234567.item {flex: none;}.item { flex-grow: 0; flex-shrink: 0; flex-basis: auto;} 当 flex 取值为 auto，则计算值为 1 1 auto，如下是等同的 1234567.item {flex: auto;}.item { flex-grow: 1; flex-shrink: 1; flex-basis: auto;} 当 flex 取值为一个非负数字，则该数字为 flex-grow 值，flex-shrink 取 1，flex-basis 取 0%，如下是等同的 1234567.item {flex: 1;}.item { flex-grow: 1; flex-shrink: 1; flex-basis: 0%;} 当 flex 取值为一个长度或百分比，则视为 flex-basis 值，flex-grow 取 1，flex-shrink 取 1，有如下等同情况 注意 0% 是一个百分比而不是一个非负数字 12345678910111213141516.item-1 {flex: 0%;}.item-1 { flex-grow: 1; flex-shrink: 1; flex-basis: 0%;}.item-2 {flex: 24px;}.item-1 { flex-grow: 1; flex-shrink: 1; flex-basis: 24px;} 当 flex 取值为两个非负数字，则分别视为 flex-grow 和 flex-shrink 的值，flex-basis 取 0%，如下是等同的 1234567.item {flex: 2 3;}.item { flex-grow: 2; flex-shrink: 3; flex-basis: 0%;} 当 flex 取值为一个非负数字和一个长度或百分比，则分别视为 flex-grow 和 flex-basis 的值，flex-shrink 取 1，如下是等同的 1234567.item {flex: 2333 3222px;}.item { flex-grow: 2333; flex-shrink: 1; flex-basis: 3222px;} flex-basis 规定的是子元素的基准值，所以是否溢出的计算与此属性息息相关，flex-basis 规定的范围取决于 box-sizing 这里主要讨论以下 flex-basis 的取值情况 auto 首先检索该子元素的主尺寸，如果主尺寸不为 auto，则使用值采取主尺寸之值，如果也是 auto，则使用值为 content content 指根据该子元素的内容自动布局，有的用户代理没有实现取 content 值，等效的替代方案是 flex-basis 和主尺寸都取 auto 百分比 根据其包含块（即伸缩父容器）的主尺寸计算，如果包含块的主尺寸未定义（即父容器的主尺寸取决于子元素），则计算结果和设为 auto 一样 实例页面布局如下 12345&lt;div class=\"parent\"&gt; &lt;div class=\"item-1\"&gt;&lt;/div&gt; &lt;div class=\"item-2\"&gt;&lt;/div&gt; &lt;div class=\"item-3\"&gt;&lt;/div&gt;&lt;/div&gt; 应用的 CSS 如下 12345678910111213141516171819202122232425.parent { display: flex; width: 600px;}.parent&gt;div { height: 100px;}.item-1 { width: 9999px; flex: 2 1 0%; background: lightskyblue;}.item-2 { width: 100px; flex: 2 1 auto; background: turquoise;}.item-3 { flex: 1 1 200px; background: darkturquoise;} 最终效果如下 主轴上父容器总尺寸为 600px，那么子元素的总基准值是 0% + auto + 200px = 300px，其中 0% 即 0 宽度 auto 对应取主尺寸即 100px 所以剩余空间为 600px - 300px = 300px，伸缩放大系数之和为 2 + 2 + 1 = 5，那么剩余空间分配如下 item-1 和 item-2 各分配 2/5，各得 120px item-3 分配 1/5，得 60px 所以各项目最终宽度为 item-1 = 0% + 120px = 120px item-2 = auto + 120px = 220px item-3 = 200px + 60px = 260px 当 item-1 基准值取 0% 的时候，是把该项目视为零尺寸的，故即便声明其尺寸为 9999px，也并没有什么用，形同虚设 而 item-2 基准值取 auto 的时候，根据规则基准值使用值是主尺寸值即 100px，故这 100px 是会用来计算基准值，而不会纳入剩余空间","link":"/2019/01/12/CSS/09/"},{"title":"session 和 cookie","text":"这篇在跟着学习 node-lessons 过程中遇到的一些问题整合而成 众所周知，http 是一个无状态协议，所以客户端每次发出请求时，下一次请求无法得知上一次请求所包含的状态数据，如何能把一个用户的状态数据关联起来呢？ 比如在某个页面中，你进行了登陆操作，而当你跳转到商品页时，服务端如何知道你是已经登陆的状态？ cookie首先产生了 cookie 这门技术来解决这个问题，cookie 是 http 协议的一部分，它的处理分为如下几步 服务器向客户端发送 cookie 常使用 http 协议规定的 set-cookie 头操作 规范规定 cookie 的格式为 name = value 格式，且必须包含这部分 浏览器将 cookie 保存 每次请求浏览器都会将 cookie 发向服务器 其他可选的 cookie 参数会影响将 cookie 发送给服务器端的过程，主要有以下几种 path：表示 cookie 影响到的路径，匹配该路径才发送这个 cookie expires 和 maxAge：告诉浏览器这个 cookie 什么时候过期，expires 是 UTC 格式时间，maxAge 是 cookie 多久后过期的相对时间，当不设置这两个选项时，会产生 session cookie，session cookie 是 transient 的，当用户关闭浏览器时，就被清除，一般用来保存 session 的 session_id secure：当 secure 值为 true 时，cookie 在 http 中是无效，在 https 中才有效 httpOnly：浏览器不允许脚本操作 document.cookie 去更改 cookie，一般情况下都应该设置这个为 true，这样可以避免被 xss 攻击拿到 cookie express 中的 cookieexpress 在 4.x 版本之后，session 管理和 cookies 等许多模块都不再直接包含在 express 中，而是需要单独添加相应模块 express4 中操作 cookie 使用 cookie-parser 模块 123456789101112131415161718192021222324var express = require('express');// 首先引入 cookie-parser 这个模块var cookieParser = require('cookie-parser');var app = express();app.listen(3000);// 使用 cookieParser 中间件，cookieParser(secret, options)// 其中 secret 用来加密 cookie 字符串（下面会提到 signedCookies）// options 传入上面介绍的 cookie 可选参数app.use(cookieParser());app.get('/', function (req, res) { // 如果请求中的 cookie 存在 isVisit, 则输出 cookie // 否则，设置 cookie 字段 isVisit, 并设置过期时间为1分钟 if (req.cookies.isVisit) { console.log(req.cookies); res.send('再次欢迎访问'); } else { res.cookie('isVisit', 1, { maxAge: 60 * 1000 }); res.send('欢迎第一次访问'); }}); sessioncookie 虽然很方便，但是使用 cookie 有一个很大的弊端，cookie 中的所有数据在客户端就可以被修改，数据非常容易被伪造 那么一些重要的数据就不能存放在 cookie 中了，而且如果 cookie 中数据字段太多会影响传输效率 为了解决这些问题，就产生了 session，session 中的数据是保留在服务器端的 session 的运作通过一个 session_id 来进行，session_id 通常是存放在客户端的 cookie 中，比如在 express 中，默认是 connect.sid 这个字段 当请求到来时，服务端检查 cookie 中保存的 session_id 并通过这个 session_id 与服务器端的 session data 关联起来，进行数据的保存和修改 这意思就是说，当你浏览一个网页时，服务端随机产生一个 1024 比特长的字符串，然后存在你 cookie 中的 connect.sid 字段中 当你下次访问时，cookie 会带有这个字符串，然后浏览器就知道你是上次访问过的某某某，然后从服务器的存储中取出上次记录在你身上的数据 由于字符串是随机产生的，而且位数足够多，所以也不担心有人能够伪造，伪造成功的概率比坐在家里编程时被邻居家的狗突然闯入并咬死的几率还低 session 可以存放在内存、cookie 本身、redis 或 memcached 等缓存中，或者放置于数据库中 线上来说，缓存的方案比较常见，存数据库的话，查询效率相比前三者都太低，不推荐；cookie session 有安全性问题，下面会提到 express 中操作 session 要用到 express-session 这个模块 主要的方法就是 session(options)，其中 options 中包含可选参数，主要有 name：设置 cookie 中，保存 session 的字段名称，默认为 connect.sid store：session 的存储方式，默认存放在内存中，也可以使用 redis，mongodb 等，express 生态中都有相应模块的支持 secret：通过设置的 secret 字符串，来计算 hash 值并放在 cookie 中，使产生的 signedCookie 防篡改 cookie：设置存放 session id 的 cookie 的相关选项，默认为 (default: { path: '/', httpOnly: true, secure: false, maxAge: null }) genid：产生一个新的 session_id 时，所使用的函数， 默认使用 uid2 这个 npm 包 rolling：每个请求都重新设置一个 cookie，默认为 false resave：即使 session 没有被修改，也保存 session 值，默认为 true 在内存中存储 sessionexpress-session 默认使用内存来存 session，对于开发调试来说很方便 1234567891011121314151617181920212223242526var express = require('express');// 首先引入 express-session 这个模块var session = require('express-session');var app = express();app.listen(5000);// 按照上面的解释，设置 session 的可选参数app.use(session({ secret: 'recommand 128 bytes random string', // 建议使用 128 个字符的随机字符串 cookie: { maxAge: 60 * 1000 }}));app.get('/', function (req, res) { // 检查 session 中的 isVisit 字段 // 如果存在则增加一次，否则为 session 设置 isVisit 字段，并初始化为 1 if (req.session.isVisit) { req.session.isVisit++; res.send('&lt;p&gt;第 ' + req.session.isVisit + '次来此页面&lt;/p&gt;'); } else { req.session.isVisit = 1; res.send('欢迎第一次来这里'); console.log(req.session); }}); 在 redis 中存储 sessionsession 存放在内存中不方便进程间共享，因此可以使用 redis 等缓存来存储 session 假设你的机器是 4 核的，你使用了 4 个进程在跑同一个 node web 服务，当用户访问进程 1 时，他被设置了一些数据当做 session 存在内存中，而下一次访问时，他被负载均衡到了进程 2，则此时进程 2 的内存中没有他的信息，认为他是个新用户，这就会导致用户在我们服务中的状态不一致 使用 redis 作为缓存，可以使用 connect-redis 模块来得到 redis 连接实例，然后在 session 中设置存储方式为该实例 12345678910111213141516171819202122232425var express = require('express');var session = require('express-session');var redisStore = require('connect-redis')(session);var app = express();app.listen(5000);app.use(session({ // 假如你不想使用 redis 而想要使用 memcached 的话，代码改动也不会超过 5 行 // 这些 store 都遵循着统一的接口，凡是实现了那些接口的库，都可以作为 session 的 store 使用 // 比如都需要实现 .get(keyString) 和 .set(keyString, value) 方法 // 编写自己的 store 也很简单 store: new redisStore(), secret: 'somesecrettoken'}));app.get('/', function (req, res) { if (req.session.isVisit) { req.session.isVisit++; res.send('&lt;p&gt;第 ' + req.session.isVisit + '次来到此页面&lt;/p&gt;'); } else { req.session.isVisit = 1; res.send('欢迎第一次来这里'); }}); 我们可以运行 redis-cli 查看结果，如图可以看到 redis 中缓存结果 各种存储的利弊上面我们说到，session 的 store 有四个常用选项： 内存 cookie 缓存 数据库 其中，开发环境存内存就好了，一般的小程序为了省事，如果不涉及状态共享的问题，用内存 session 也没问题，但内存 session 除了省事之外，没有别的好处 cookie session 我们下面会提到，现在说说利弊，用 cookie session 的话，是不用担心状态共享问题的，因为 session 的 data 不是由服务器来保存，而是保存在用户浏览器端，每次用户访问时，都会主动带上他自己的信息，当然在这里，安全性之类的，只要遵照最佳实践来，也是有保证的，它的弊端是增大了数据量传输，利端是方便 缓存方式是最常用的方式了，即快，又能共享状态，相比 cookie session 来说，当 session data 比较大的时候，可以节省网络传输，推荐使用 数据库 session，除非你很熟悉这一块，知道自己要什么，否则还是老老实实用缓存吧 signedCookiecookie 虽然很方便，但是使用 cookie 有一个很大的弊端，cookie 中的所有数据在客户端就可以被修改，数据非常容易被伪造 其实不是这样的，那只是为了方便理解才那么写，要知道，计算机领域有个名词叫签名，专业点说，叫信息摘要算法 比如我们现在面临着一个菜鸟开发的网站，他用 cookie 来记录登陆的用户凭证，相应的 cookie 长这样： dotcom_user=zhangsan，它说明现在的用户是 zhangsan 这个用户，如果我在浏览器中装个插件，把它改成 dotcom_user=lisi，服务器一读取，就会误认为我是 lisi，然后我就可以进行 lisi 才能进行的操作了 OK，现在我有一些数据，不想存在 session 中，想存在 cookie 中，怎么保证不被篡改呢？答案很简单，签个名 假设我的服务器有个秘密字符串，是 this_is_my_secret_and_fuck_you_all，我为用户 cookie 的 dotcom_user 字段设置了个值 zhangsan cookie 本应是 1{ dotcom_user: 'zhangsan' } 这样的，而如果我们签个名，比如把 dotcom_user 的值跟我的 secret_string 做个 sha1 1sha1('this_is_my_secret_and_fuck_you_all' + 'zhangsan') === '4850a42e3bc0d39c978770392cbd8dc2923e3d1d' 然后把 cookie 变成这样 1234{ dotcom_user: 'zhangsan', 'dotcom_user.sig': '4850a42e3bc0d39c978770392cbd8dc2923e3d1d',} 这样一来，用户就没法伪造信息了，一旦它更改了 cookie 中的信息，则服务器会发现 hash 校验的不一致 毕竟他不懂我们的 secret_string 是什么，而暴力破解哈希值的成本太高 cookie-sessioncookie-session 的实现跟 signedCookies 差不多 不过 cookie-session 我个人建议不要使用，有受到回放攻击的危险 回放攻击指的是，比如一个用户，它现在有 100 积分，积分存在 session 中，session 保存在 cookie 中，他先复制下现在的这段 cookie，然后去发个帖子，扣掉了 20 积分，于是他就只有 80 积分了，而他现在可以将之前复制下的那段 cookie 再粘贴回去浏览器中，于是服务器在一些场景下会认为他又有了 100 积分 如果避免这种攻击呢？这就需要引入一个第三方的手段来验证 cookie session，而验证所需的信息，一定不能存在 cookie 中，这么一来，避免了这种攻击后，使用 cookie session 的好处就荡然无存了，如果为了避免攻击而引入了缓存使用的话，那不如把 cookie session 也一起放进缓存中 session cookie初学者容易犯的一个错误是，忘记了 session_id 在 cookie 中的存储方式是 session cookie，即，当用户一关闭浏览器，浏览器 cookie 中的 session_id 字段就会消失 常见的场景就是在开发用户登陆状态保持时 假如用户在之前登陆了你的网站，你在他对应的 session 中存了信息，当他关闭浏览器再次访问时，你还是不懂他是谁，所以我们要在 cookie 中，也保存一份关于用户身份的信息 比如有这样一个用户 1{ username: 'zhangsan', age: 22, company: 'baidu', location: 'beijing' } 我们可以考虑把这四个字段的信息都存在 session 中，而在 cookie，我们用 signedCookies 来存个 username 登陆的检验过程伪代码如下 12345678910111213if (req.session.user) { // 获取 user 并进行下一步 next()} else if (req.signedCookies['username']) { // 如果存在则从数据库中获取这个 username 的信息，并保存到 session 中 getuser(function (err, user) { req.session.user = user; next(); });} else { // 当做为登陆用户处理 next();}","link":"/2017/11/26/HTTP/02/"},{"title":"Http 缓存机制","text":"先来简单说一下 Web 缓存，所谓 Web 缓存，是一种保存 Web 资源副本并在下次请求时直接使用该副本的技术 Web 缓存可以分为这几种，浏览器缓存、CDN 缓存、服务器缓存、数据库数据缓存 因为可能会直接使用副本免于重新发送请求或者仅仅确认资源没变无需重新传输资源实体 Web 缓存可以减少延迟加快网页打开速度、重复利用资源减少网络带宽消耗、降低请求次数或者减少传输内容从而减轻服务器压力， 缓存的流程简单来说，浏览器在请求一个资源时，使用缓存的流程大概如下， 首先浏览器会判断，这个资源是否有缓存，没有的话，正常请求 如果有缓存的话，浏览会判断缓存是否过期，如果缓存没有过期，则直接使用，此时就是 200（from cache），通过上次缓存留下的 cache-control，max-age 和 Expires（需要注意的是，cache-control 的优先级高于 Expires，下面会详细介绍） 如果浏览器的缓存过期了，它会请求服务器，服务器会校验缓存的数据是否真的发生了更改 如果服务器端发现数据没有变，就会返回一个 304 告诉浏览器，你请求的数据 Not Modified，可以继续用缓存，同时浏览器会更新缓存首部的过期时间等信息 这里浏览器发起请求时，会用到上次缓存首部的 Last-Modified/E-tag 具体做法是取出上次缓存的 Last-Modified 的值，放在本次请求 header 的 If-Modified-Since 中 取出上次缓存的 E-tag 的值，放在本次请求 header 中的 If-None-Match 中 服务器会据此判断资源是否发生过修改，浏览器中的缓存是否依然可用 如果服务器端修改了上次缓存的内容，则直接返回 200，并携带新的内容 强缓存和协商缓存浏览器 http 缓存可以分为强缓存和协商缓存，强缓存和协商缓存最大也是最根本的区别是 强缓存命中的话不会发请求到服务器（比如 chrome 中的 200 from memory cache） 协商缓存一定会发请求到服务器，通过资源的请求首部字段验证资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回 但是不会返回这个资源的实体，而是通知客户端可以从缓存中加载这个资源（304 not modified） 所以上图可以简单的调整为 而浏览器 http 缓存由 http 报文的首部字段决定 浏览器对于请求资源，拥有一系列成熟的缓存策略 按照发生的时间顺序分别为存储策略，过期策略，协商策略，其中存储策略在收到响应后应用，过期策略和协商策略则在发送请求前应用 简单来说 缓存参数下面表格表示的就是 http header 中与缓存有关的 key key 描述 存储策略 过期策略 协商策略 Pragma http1.0 字段，指定缓存机制 ✔️ ✔️ Cache-Control 指定缓存机制，覆盖其它设置 ✔️ Expires http1.0 字段，指定缓存的过期时间 ✔️ Last-Modified 资源最后一次的修改时间 ✔️ ETag 唯一标识请求资源的字符串 ✔️ 而缓存协商策略用于重新验证缓存资源是否有效，有关的 key 如下 key 描述 If-Modified-Since 缓存校验字段，值为资源最后一次的修改时间，即上次收到的 Last-Modified 值 If-Unmodified-Since 同上，处理方式与之相反 If-Match 缓存校验字段，值为唯一标识请求资源的字符串，即上次收到的 ETag 值 If-None-Match 同上，处理方式与之相反 下面就按控制强缓存的字段按优先级介绍 PragmaPragma 是 http/1.1 之前版本遗留的通用首部字段，仅作为于 http/1.0 的向后兼容而使用 虽然它是一个通用首部，但是它在响应报文中时的行为没有规范，依赖于浏览器的实现 RFC 中该字段只有 no-cache 一个可选值，会通知浏览器不直接使用缓存，要求向服务器发请求校验新鲜度，因为它优先级最高，当存在时一定不会命中强缓存 Cache-ControlCache-Control 是一个通用首部字段，也是 http/1.1 控制浏览器缓存的主流字段，和浏览器缓存相关的是如下几个响应指令 指令 参数 说明 private 无 表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它） public 可省略 表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存 no-cache 可省略 缓存前必需确认其有效性 no-store 无 不缓存请求或响应的任何内容 max-age=[s] 必需 响应的最大值 max-age设置缓存的存在时间（单位为 s），相对于发送请求的时间，只有响应报文首部设置 Cache-Control 为非 0 的 max-age 或者设置了大于请求日期的 Expires 才有可能命中强缓存 当满足这个条件，同时响应报文首部中 Cache-Control 不存在 no-cache、no-store 且请求报文首部不存在 Pragma 字段，才会真正命中强缓存 no-cache表示请求必须先与服务器确认缓存的有效性，如果有效才能使用缓存（协商缓存），无论是响应报文首部还是请求报文首部出现这个字段均一定不会命中强缓存 Chrome 硬性重新加载（Command + shift + R）会在请求的首部加上 Pragma：no-cache 和 Cache-Control：no-cache no-store表示禁止浏览器以及所有中间缓存存储任何版本的返回响应，一定不会出现强缓存和协商缓存，适合个人隐私数据或者经济类数据 public表明响应可以被浏览器、CDN 等等缓存 private响应只作为私有的缓存，不能被 CDN 等缓存，如果要求 http 认证，响应会自动设置为 private ExpiresExpires 是一个响应首部字段，它指定了一个日期/时间，在这个时间/日期之前，http 缓存被认为是有效的 无效的日期比如 0，表示这个资源已经过期了，如果同时设置了 Cache-Control 响应首部字段的 max-age 则 Expires 会被忽略，它也是 http/1.1 之前版本遗留的通用首部字段，仅作为于 http/1.0 的向后兼容而使用 下面再来看看控制协商缓存的字段 Last-Modified / If-Modified-SinceIf-Modified-Since 是一个请求首部字段，并且只能用在 GET 或者 HEAD 请求中 Last-Modified 是一个响应首部字段，包含服务器认定的资源作出修改的日期及时间 当带着 If-Modified-Since 头访问服务器请求资源时，服务器会检查 Last-Modified 如果 Last-Modified 的时间早于或等于 If-Modified-Since 则会返回一个不带主体的 304 响应，否则将重新返回资源 需要注意的是，如果 http/1.1 缓存或服务器收到的请求既带有 If-Modified-Since，又带有 etag 实体标签条件首部 那么只有这两个条件都满足时，才能返回 304 NotModified 响应 语法格式如下 123If-Modified-Since: &lt;day-name&gt;, &lt;day&gt; &lt;month&gt; &lt;year&gt; &lt;hour&gt;:&lt;minute&gt;:&lt;second&gt; GMTLast-Modified: &lt;day-name&gt;, &lt;day&gt; &lt;month&gt; &lt;year&gt; &lt;hour&gt;:&lt;minute&gt;:&lt;second&gt; GMT ETag / If-None-MatchETag 是一个响应首部字段，它是根据实体内容生成的一段 hash 字符串，标识资源的状态，由服务端产生 If-None-Match 是一个条件式的请求首部，如果请求资源时在请求首部加上这个字段，值为之前服务器端返回的资源上的 ETag 则当且仅当服务器上没有任何资源的 ETag 属性值与这个首部中列出的时候，服务器才会返回带有所请求资源实体的 200 响应 否则服务器会返回不带实体的 304 响应，ETag 优先级比 Last-Modified 高，同时存在时会以 ETag 为准 语法格式如下 12345If-None-Match: &lt;etag_value&gt;If-None-Match: &lt;etag_value&gt;, &lt;etag_value&gt;, …If-None-Match: * ETag 属性之间的比较采用的是弱比较算法，即两个文件除了每个比特都相同外，内容一致也可以认为是相同的 例如，如果两个页面仅仅在页脚的生成时间有所不同，就可以认为二者是相同的 因为 ETag 的特性，所以相较于 Last-Modified 有一些优势 某些情况下服务器无法获取资源的最后修改时间 资源的最后修改时间变了但是内容没变，使用 ETag 可以正确缓存 如果资源修改非常频繁，在秒以下的时间进行修改，Last-Modified 只能精确到秒 整体流程 优先级若同时存在各种缓存头时，各缓存头优先级及生效情况如下 强缓存和对比缓存同时存在，如果强缓存还在生效期则强制缓存覆盖对比缓存，对比缓存不生效 如果强缓存不在有效期，对比缓存生效，即：强缓存优先级 &gt; 对比缓存优先级 pragma，和 cache-control 类似，前者是 http1.0 内容，后者是 http1.1 内容 并且 pragma 优先级 &gt; cache-control 优先级，不过前者目前基本不使用 强缓存 expires 和 cache-control 同时存在时，则 cache-control 会覆盖 expires expires 无论有没有过期都无效，即 cache-control 优先级 &gt; expires 优先级 对比缓存 Etag 和 Last-Modified 同时存在时，则 Etag 会覆盖 Last-Modified Last-Modified 不会生效，即 ETag优先级 &gt; Last-Modified 优先级 针对于一般的项目，由于 CSS 和 JavaScript 在打包时加了 md5 值，建议直接使用强缓存，并且 expires 和 cache-control 同时使用，建议设置时长为 7 天较为妥当，图片文件由于没有加 md5 值，建议采用对比缓存，html 文件也建议采用对比缓存 浏览器的不同表现需要注意的是，当我们不设置 cache-control，只设置对比缓存，在不同浏览器下会有不同的表现 chrome 会直接从本地缓存获取，其他会请求服务器返回 304，这时候有两种方式让他们的响应一致 设置 cache-control: public, max-age=0;，这里的 public 是关键 因为默认值是 private，表示其他代理都不要缓存，只有服务器缓存，而 max-age 又为 0 所以每次都会发起 200 的请求，设置 public 的意思就是允许其他各级代理缓存资源，因此如果资源没改变会返回 304 直接设置 max-age = 1000，即是一秒之后内容过期，目的是触发浏览器缓存，也能达到想要 304 的效果 如何让浏览器不缓存静态资源实际上，工作中很多场景都需要避免浏览器缓存，除了浏览器隐私模式，请求时想要禁用缓存 还可以设置请求头: Cache-Control: no-cache, no-store, must-revalidate 当然，还有一种常用做法，即给请求的资源增加一个版本号，比如 1&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"../css/style.css?version=2.1.1\"/&gt; 这样做的好处就是你可以自由控制什么时候加载最新的资源 不仅如此，HTML 也可以禁用缓存，即在页面的 &lt;head&gt; 节点中加入 &lt;meta&gt; 标签 1&lt;meta http-equiv=\"Cache-Control\" content=\"no-cache，no-store，must-revalidate\"/&gt; 上述虽能禁用缓存，但只有部分浏览器支持，而且由于代理不解析 HTML 文档，故代理服务器也不支持这种方式 总结Expires / Cache-Control 用来设置缓存时间，即资源有效时间（状态码 200（from cache）），可避免请求发送到服务器 Last-Modified / ETag 用来判断资源是否被修改了（状态码 304（not change）），可避免传输相同的资源内容，造成带宽和时间的浪费 使用原则 需要兼容 http 1.0 的时候需要使用 Expires，不然可以考虑直接使用 Cache-Control 需要处理一秒内多次修改的情况，或者其他 Last-Modified 处理不了的情况，才使用 ETag，否则使用 Last-- Modified 对于所有可缓存资源，需要指定一个 Expires 或 Cache-Control，同时指定 Last-Modified 或者 Etag 可以通过标识文件版本名、加长缓存时间的方式来减少 304 响应","link":"/2017/12/12/HTTP/04/"},{"title":"域名发散与收敛","text":"先扩展一个知识：performance - 监控网页与程序性能 域名发散在 PC 时代为了突破浏览器的域名并发限制，遵循这样一条定律：http 静态资源采用多个子域名 目的是充分利用现代浏览器的多线程并发下载能力，由于浏览器的限制，每个浏览器，允许对每个域名的连接数一般是有上限的，附一张网上流传甚广的图： 域名发散出现的原因其实是在以前，服务器的负载能力差，网速慢，设备差，稍微流量大一点 Server 就崩溃了 为了保护你的服务器不崩溃，浏览器要对 max connections 有所限制，如果每个用户的 max connections 不限制的话， 结果就是服务器的负载能力会低至冰点（另外也有说是关于 DDOS） 所以 PC 时代对静态资源优化时，通常将静态资源分布在几个不同域，保证资源最完美地分域名存储，以提供最大并行度，让客户端加载静态资源更为迅速 假设现在浏览器对每个域名连接数为 1，那么现实情况是 浏览器解析完我们的文档之后开始发起请求，对文件进行加载，然后一个一个文件 在 max connections 下进行排队下载 但如果我们使用了域名分散之后，使用多个 domain 进行资源的下载，就有 这样完全可以省略掉排队的时间.提升网页加载的速度 域名收敛这里首先会涉及到一个问题，为什么你手机打开网页时，白屏时间会这么长？ 一个网页白屏时间是由下面几部分决定的 所以，网页的优化就可以从上述几个部分开始，这里我们要提及的就是 DNS 优化, 即域名收敛，那么什么是域名收敛呢 顾名思义，域名收敛的意思就是建议将静态资源只放在一个域名下面，而非发散情况下的多个域名下 上面也说到了，域名发散可以突破浏览器的域名并发限制，那么为要反其道而行之呢？ 因为因地制宜，不同情况区别对待，域名发散是 PC 时代的产物，而现在进入移动互联网时代，通过无线设备访问网站，App 的用户已占据了很大一部分比重，而域名收敛正是在这种情况下提出的 这里就不能不提到 http 请求了 简单来说就说就是 1）、 DNS 域名解析 ==&gt; 2）、 发起 TCP 的 3 次握手 ==&gt; 3）、 建立 TCP 连接后发起 http 请求 ==&gt; 4）、 服务器响应 http 请求 ==&gt; 5）、 … 在这里第一步，也是关键的第一步 DNS 解析，在移动端的 http 请求耗时中，DNS 解析占据了大部分时间 在深入了解 DNS 解析之前，先科普一下 域名结构 域名结构或者叫命名空间，是一个树状结构，有树就得有根，这个根是一个点 &quot;.&quot;（dot） 以 www.example.com 为例，完整的形式应该是 www.example.com.（注意最后有一个点），就是根结点 root ，只不过平时是浏览器或者系统的解析器自动帮我们补全了 我们要想获取根域都有那些，可以在终端下直接使用 dig 命令（需要安装 dig 指令），如下: 根节点之后就是顶级域名，就是 .cn，.com，.gov 这些，顶级域划分为通用顶级域 （com、org、net 等）和国家与地区顶级域（cn、hk、us、tw 等） 我们可以继续使用 dig 查看一下 顶级域名的解析路径，加上 + trace 参数选项，意思是追踪 DNS 解析过程，如下： 可以看到是先到根节点，再查找到 com ，就是根结点会告知下一个结点 com 在哪，就是 com. 172800 IN NS [a-m].gtld-servers.net 顶级域之后就是我们熟知的一级域名，譬如 www.example.com 中的 example 就是一级域 NS上面两张 dig 命令贴图中间出现了很多次 NS ，NS 即是 NameServer，大部分情况下又叫权威名称服务器简称权威 什么是权威呢，通俗点讲其实是某些域的权威，也就是权威上面有这些域的最新，最全的数据，所有这些域的数据都应该以此为准（只有权威可以增删改这些域的数据），就像上面 dig com + trace 的结果可以看到，com 的权威是上面的 13 个根域，同理，所有的顶级域（cn、org、net 等等）的权威都是根域 DNS 解析其实上面就是 DNS 解析的一个大致过程，即迭代解析 一个完整的 DNS 解析过程如下（摘自 域名收敛–前端优化） Step1: 首先拿到 URL 后，浏览器会寻找本地的 DNS 缓存，看看是否有对应的 IP 地址，如果缓存中存在那就好了，如果没有，那就得向 DNS Server 发送一个请求，找到你想要的 IP 地址 Step2: 首先他会向你的 ISP（互联网服务提供商）相关的 DNS servers 发送 DNS query，然后这些 DNS 进行递归查询（recursive），所谓的递归查询，就是能够直接返回对应的 IP 地址，而不是其他的 DNS server 地址 Step3: 如果上述的 DNS Servers 没有你要的域名地址，则就会发送迭代查询，即会先从 root nameservers 找起， 即是假如你要查询 www.example.com ，会先从包含根结点的 13 台最高级域名服务器开始 Step4: 接着，以从右向左的方式递进，找到 com，然后向包含 com 的 TLD（顶级域名）nameservers 发送 DNS 请求，接着找到包含 example 的 DNS server Step5: 现在进入到了 example.com 部分，即是现在正在询问的是权威服务器，该服务器里面包含了你想要的域名信息，也就是拿到了最后的结果 record Step6: 递归查询的 DNS Server 接受到这 record 之后, 会将该 record 保存一份到本地，如果下一次你再请求这个 domain 时，我就可以直接返回给你了，由于每条记录都会存在 TLL ，所以 server 每隔一段时间都会发送一次请求，获取新的 record Step7: 最后，再经由最近的 DNS Server 将该条 record 返回， 同样，你的设备也会存一份该 record 的副本 之后，就是 TCP 的事了，下面是一张萌萌的简化图： 梳理一下，迭代查询的过程如下： . ==&gt; com. ==&gt; .exampl.com. ==&gt; www.example.com. ==&gt; IP adress 关于 TTLTTL 是 Time To Live 的缩写，该字段指定 IP 包被路由器丢弃之前允许通过的最大网段数量，TTL 是 IPv4 包头的一个 8 bit 字段 简单的说它表示 DNS 记录在 DNS 服务器上缓存时间 DNS 解析其实是一个很复杂的过程，在 PC 上，我们采用域名发散策略，是因为在 PC 端上，DNS 解析通常而言只需要几十 ms ，完全可以接受的 而移动端，2G / 3G / 4G / WIFI 网络，而且移动 4G 容易在信号不理想的地段降级成 2G ，通过大量的数据采集和真实网络抓包分析（存在 DNS 解析的请求），DNS 的消耗相当可观，2G 网络大量 5-10s，3G 网络平均也要 3-5s（数据来源于淘宝）， 下面附上在 2G / 3G / 4G / WIFI 情况下 DNS 递归解析的时间 （ms）： 因为在增加域的同时，往往会给浏览器带来 DNS 解析的开销，所以在这种情况下，提出了域名收敛，减少域名数量可以降低 DNS 解析的成本 下图是手机端页面加载数和域名分散数的关系: 在 2 个域名分散条件下，网页的加载速度提升较大，而第 3 个以后就比较慢了， 所以，一般来说，域名分散的数量最好在 3 以下 HttpDNS上面过程如果顺利，本地 DNS 有缓存，也就是几十 ms 到几百 ms 的事情，不顺利，几秒到十几秒都有可能 严格来讲，DNS 才是我们发出去的第一个请求，所以减少开销就两条路： 第一个就是减少 DNS 的请求 第二个就是缩短 DNS 解析路径 第一个就是做域名收敛的主要原因，相比于 PC 是对于域名的并发限制，无线上来说对并发的要求会弱很多（一般尽量是第一屏，后面使用懒加载） 第二个就是缩短解析路径，这里所说的缩短解析路径其实就说各级的缓存：本机的缓存，LocalDNS 的缓存，不过他们或多或少也不靠谱，尤其是运营商的 LocalDNS 给你劫持一下，篡改一下都是常有的事情，于是这个情况下，就有了 HttpDNS HttpDNS 是为了解决移动端 DNS 解析请求而生的，顺便解决 DNS 劫持，合并请求和缓存结果进而提高解析质量 结论在移动网络环境下，减少非必要 DNS 请求，将相关域名收敛成一个，可以尝到缓存的红利，进而可以减少打开页面时间，移动端减少 DNS 解析时间有两种方式： 减少 DNS 请求 缩短 DNS 解析路径 从上面的各种网络环境下 DNS 解析时间对比，减少 DNS 请求是我们做域名收敛的主要原因，HttpDNS 的诞生不仅可以合并请求，缩短 DNS 解析路径，还有防止运营商劫持等功效 关于 SPDY单纯的在移动端采用域名收敛并不能很大幅度的提升性能，很重要的一点是，在移动端建连的消耗非常大，而 SPDY 协议可以完成多路复用的加密全双工通道，显著提升非 wifi 环境下的网络体验，当域名收敛配合 SPDY 才能最大程度发挥他们的效用，达到事半功倍 所谓 SPDY 就是一种开放的网络传输协议，由 Google 开发，用来发送网页内容，基于传输控制协议（TCP）的应用层协议 ，是 http/2 的前身 SPDY 的作用就是，在不增加域名的情况下，解除最大连接数的限制，主要的特点就是多路复用，他的目的就是致力于取消并发连接上限 那么相比 http，SPDY 具体的优势在哪里呢： 多路复用 请求优化SPDY 规定在一个 SPDY 连接内可以有无限个并行请求，即允许多个并发 http 请求共用一个 TCP 会话 这样 SPDY 通过复用在单个 TCP 连接上的多次请求，而非为每个请求单独开放连接，这样只需建立一个 TCP 连接就可以传送网页上所有资源，不仅可以减少消息交互往返的时间还可以避免创建新连接造成的延迟，使得 TCP 的效率更高 此外，SPDY 的多路复用可以设置优先级，而不像传统 http 那样严格按照先入先出一个一个处理请求，它会选择性的先传输 CSS 这样更重要的资源，然后再传输网站图标之类不太重要的资源，可以避免让非关键资源占用网络通道的问题，提升 TCP 的性能 支持服务器推送技术服务器可以主动向客户端发起通信向客户端推送数据，这种预加载可以使用户一直保持一个快速的网络 SPDY 压缩了 Http 头舍弃掉了不必要的头信息，经过压缩之后可以节省多余数据传输所带来的等待时间和带宽 强制使用 SSL 传输协议Google 认为 Web 未来的发展方向必定是安全的网络连接，全部请求 SSL 加密后，信息传输更加安全 看看 SPDY 的作用图： 参考： SPDY协议介绍 15年双11手淘前端技术巡演 - H5性能最佳实践 HttpDNS 服务详解 DNS（wiki 无线性能优化：域名收敛 域名收敛–前端优化(二) 域名发散–前端优化(三)","link":"/2017/12/01/HTTP/03/"},{"title":"JavaScript 中的事件，冒泡与捕获","text":"所谓事件，说的就是用户或浏览器自身执行的某种动作，诸如 click、load、mouseover 等 事件处理程序响应某个事件的函数就叫事件处理程序（或事件侦听器） HTML 事件处理程序1&lt;input type=\"button\" value=\"click me\" onclick=\"alert(1)\"&gt; 在 html 中指定事件处理程序有个缺点，即 html 与 JavaScript 代码紧密耦合，如果要更换处理程序，就要改动两个地方 html 代码和 JavaScript 代码 DOM 0 级事件处理程序123btn.onclick = function () { alert('DOM0');} 以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理 1btn.onclick = null; // 删除事件处理程序 DOM 2 级事件处理程序定义了两个方法 addEventListener() 和 removeEventListener() 接收三个参数，要处理的事件名，做为事件处理程序的函数，布尔值（true 表示捕获阶段，false 表示冒泡阶段） 123btn.addEventListener('click', 'show', false);btn.removeEventListener('click', 'show', false); 普通添加事件的方法不支持添加多个事件，最下面的事件会覆盖上面的，而事件绑定（addEventListener）方式添加事件可以添加多个 几个需要注意的地方 eventName 的值均不含 on，例如注册鼠标点击事件 eventName 为 click 处理函数中的 this 依然指的是指当前 DOM 元素 通过 addEventListener 添加的事件处理程序，只能通过 removeEventListener 来删除（也就是说 addEventListener 添加的匿名函数将无法被删除） IE 事件处理程序123attachEvent() // 添加事件detachEvent() // 添加事件 接收相同的两个参数，事件处理程序的名称和事件处理程序的函数，不使用第三个参数的原因是 IE8 级更早版本只支持冒泡型事件，所以 attachEvent 添加的事件都会被添加到冒泡阶段 123btn.attachEvent('onclick', show);btn.detachEvent('onclick', show) 注意，通过 attachEvent 添加的事件第一个参数是 'onclick' 而非标准事件中的 'click' 在使用 attachEvent 方法和 DOM0 级事件处理程序的主要区别在于事件处理程序的作用域 采用 DOM0 级处理方式，事件处理程序会在其所属元素的作用域内运行，而使用 attachEvent，事件处理程序会在全局作用域内运行，因此 this 等于 window 123456var btn = document.getElementById('btn');btn.attachEvent('onclick', function () { // 此处 this 是 window alert(this);}); 跨浏览器的事件处理程序事件对象 在触发 DOM 上的事件的时候都会产生一个对象 事件对象 event DOM 中的事件对象 type 属性 用于获取事件的类型 target 属性 用于获取事件目标 stopPropagation() 方法 用于阻止事件冒泡 preventDefault() 方法 阻止事件的默认行为 兼容方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var eventHandle = { // 添加 addEvent: function (el, type, fn) { if (el.addEventListener) { el.addEventListener(type, fn, false); } else if (el.attachEvent) { el.attachEvent('on' + type, fn); } }, // 删除 removeEvent: function (el, type, fn) { if (el.removeEventListener) { el.removeEventListener(type, fn, false); } else if (el.detachEvent) { el.detachEvent('on' + type, fn); } }, // 事件对象 getEvent: function (e) { return e ? event : window.event; }, // 事件监听的元素 getElement: function (e) { return e.target || e.srcElement; }, // 阻止冒泡 stopBubble: function (e) { if (e &amp;&amp; e.stopPropagation) { e.stopPropagation(); } else { window.event.cancelBubble = true; } }, // 阻止默认行为 stopDefault: function (e) { if (e &amp;&amp; e.preventDefault) { e.preventDefault(); } else { window.event.returnValue = false; } return false; }} 关于 event event 代表事件的状态，例如触发 event 对象的元素、鼠标的位置及状态、按下的键等等 event 对象只在事件发生的过程中才有效 firefox 里的 event 跟 IE 里的不同，IE 里的是全局变量，随时可用，firefox 里的要用参数引导才能用，是运行时的临时变量 在 IE/Opera 中是 window.event，在 Firefox 中是 event，而事件的对象，在 IE 中是 window.event.srcElement，在 Firefox 中是 event.target，Opera 中两者都可用 下面两句效果相同： 12345function a(e){ var e = (e) ? evt : ((window.event) ? window.event : null); // firefox 下 window.event 为 null, IE 下 event 为 null var e = e || window.event;} 在 jQuery 当中阻止事件冒泡的方法如下 12345// 阻止事件冒泡e.stopPropagation()// 阻止事件默认行为e.preventDefault() return false 等效于同时调用 e.preventDefault() 和 e.stopPropagation() 事件委托使用事件委托技术能让你避免对特定的每个节点添加事件监听器,事件监听器是被添加到它们的父元素上 事件监听器会分析从子元素冒泡上来的事件，找到是哪个子元素的事件，也就是利用冒泡的原理，把事件加到父级上，触发执行效果，可以提高性能 看一个例子，需要触发每个 li 来改变他们的背景颜色 12345&lt;ul &gt; &lt;li&gt;111111&lt;/li&gt; &lt;li&gt;222222&lt;/li&gt; &lt;li&gt;333333&lt;/li&gt;&lt;/ul&gt; 12345678for(var i = 0; i &lt; li.length; i++) { li[i].onmouseover = function () { this.style.background = 'red'; } li[i].onmouseout = function () { this.style.background = ''; }} 利用循环可以达到我们的目的，但是如果说我们可能有很多个 li 用 for 循环的话就比较影响性能了 所以这里可以尝试使用用事件委托的方式来实现 1234567891011121314151617ul.onmouseover = function (ev) { var ev = ev || window.event; var target = ev.target || ev.srcElement; if (target.nodeName.toLowerCase() == 'li') { target.style.background = 'red'; }}ul.onmouseout = function (ev) { var ev = ev || window.event; var target = ev.target || ev.srcElement; if (target.nodeName.toLowerCase() == 'li') { target.style.background = ''; }} 还有另外一个好处，就是新添加的元素还会有之前的事件 比如我们要实现一个点击 btn 动态的添加 li 的效果，相比利用 for 循环来实现，利用事件委托机制也可以达成我们的目标 12345678910111213141516171819202122ul.onmouseover = function (ev) { var ev = ev || window.event; var target = ev.target || ev.srcElement; if (target.nodeName.toLowerCase() == 'li') { target.style.background = 'red'; }}ul.onmouseout = function (ev) { var ev = ev || window.event; var target = ev.target || ev.srcElement; if (target.nodeName.toLowerCase() == 'li') { target.style.background = ''; }}btn.onclick = function () { iNow++; var li = document.createElement('li'); li.innerHTML = 1111 * iNow; oUl.appendChild(li);} 事件流，冒泡与捕获所谓事件流，即为了描述事件的传播而规定的一个事件传播方向，分为两个阶段，事件捕获和事件冒泡 正常情况下，事件先从最外层的元素向内捕获，然后从最内层的元素往外层传播 事件的触发一定是按照事件流的顺序而来 DOM 0 级1234567btn.onclick = function () { alert(1)}btn.onclick = function () { alert(2)} 只能监听冒泡阶段，如果给同一个对象，同一个事件名绑定多个监听，后面的会覆盖掉之前的 this 指向的是触发事件的 DOM 元素 IE 6，7，8 中事件只能冒泡到 document，不能继续冒泡到 window 对象上 所以一般不能给 window 添加 click 事件 DOM 2 级123btn.addEventListener('click', function () { // ...}, false) 最后一个参数，true 表示捕获阶段，而 false 则表示为冒泡阶段 几个注意事项： 所有现代浏览器都支持事件冒泡，并且会将事件一直冒泡到 window 对象 如果不是最内层的元素同时绑定有捕获和冒泡事件，改变事件绑定的先后顺序，不会影响执行结果，依然是先捕获后冒泡 如果是最内层的元素同时绑定有捕获和冒泡事件，则哪个事件写在前面就先执行哪一个，不再区分捕获或冒泡 可以对同一个元素绑定多个事件监听函数，彼此之间不会覆盖，按先后顺序执行 this 指向的是触发事件的元素（也就是事件传播到的这个元素） 一个比较完整的案例，页面布局如下 1234567&lt;div id='box1'&gt; &lt;div id='box2'&gt; &lt;div id='box3'&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 测试相关代码如下 12345678910111213141516171819202122232425262728293031box2.onclick = function () { alert('A');};box2.onclick = function () { alert('B');};box2.addEventListener('click', function () { alert('C');}, false);box2.addEventListener('click', function () { alert('D');}, false);box2.addEventListener('click', function () { alert('E');}, true);box2.addEventListener('click', function () { alert('F');}, true);box3.addEventListener('click', function () { alert('G');}, false);box3.addEventListener('click', function () { alert('H');}, true); 执行后的结果依次为：E =&gt; F =&gt; G =&gt; H =&gt; B =&gt; C =&gt; D 最后总结如下 DOM 0 级添加到冒泡阶段 DOM 0 级同名事件会发生覆盖 true 表示捕获阶段，false 表示冒泡阶段，会先执行捕获 DOM 2 级同名事件不会覆盖，按先后顺序执行 DOM 2 级最内层的元素不区分冒泡和捕获，按先后顺序执行（无论是 DOM 0 级还是 DOM 2 级）","link":"/2016/11/14/JavaScript/01/"},{"title":"ALT 与 TITLE 的区别","text":"首先需要明确一下概念，alt 是 html 标签的属性，而 title 既是 html 的标签，又是 html 属性 ALT 属性最常见用在 &lt;img&gt; 标签上，一般来说，alt 属性是一个非必需的属性，但是 W3Schools 中说明图片必须要加 alt 它用于在图像无法显示或者用户禁用图像显示时，代替图像显示在浏览器中的内容，强烈推荐在文档的每个图像中都使用这个属性 这样即使图像无法显示，用户还是可以看到关于丢失了什么东西的一些信息，而且对于残疾人来说，alt 属性通常是他们了解图像内容的唯一方式 而如果是对于那些装饰性的图片来说，可以使用空的值来进行表示，如 alt=&quot;&quot;，而不是使用不相关的替换文字 用法alt 属性只能用在 img、area 和 input 元素中（包括 applet 元素） 对于 input 元素，alt 属性意在用来替换提交按钮的图片，比如 1&lt;input type=\"image\" src=\"test.gif\" alt=\"提交\" /&gt; TITLE 属性title 属性规定关于元素的额外信息，这些信息通常会在鼠标移到元素上时显示一段工具提示文本（tooltip text） title 属性有一个很好的用途，即为链接添加描述性文字，特别是当连接本身并不是十分清楚的表达了链接的目的 这样就使得访问者知道那些链接将会带他们到什么地方，他们就不会加载一个可能完全不感兴趣的页面 另外一个潜在的应用就是为图像提供额外的说明信息，比如日期或者其他非本质的信息 用法title 属性可以用在除了 base，basefont，head，html，meta，param，script 和 title 之外的所有标签，但是并不是必须的 TITLE 标签&lt;title&gt; 元素可定义文档的标题，浏览器会以特殊的方式来使用标题，并且通常把它放置在浏览器窗口的标题栏或状态栏上 同样，当把文档加入用户的链接列表或者收藏夹或书签列表时，标题将成为该文档链接的默认名称 &lt;title&gt; 标签是 &lt;head&gt; 标签中唯一要求包含的东西 易于混淆的部分通常容易搞错的是 title 和 alt 这两个属性同时用于 img 标签的时候 在旧版本的 IE 浏览器中，鼠标经过图像时显示的提示文字是 alt 的内容，而忽略了 title 属性 因此，如果想在 IE 中显示 title 的内容，要么 title 属性和 alt 一致，要么 alt 内容为空，不过，在新版的 IE（IE8及以上）中，已不会出现这种情况了 另外，当 a 标签内嵌套 img 标签时，起作用的是 img 的 title 属性 SEOalt 标签属于图片中的属性标签，完整的图片属性应该包含 src，alt，title 三种属性 虽然 alt 标签不是直接的排名因素，但是在图片中加入 alt 标签利于搜索引擎解读图片的内容，并在一定程度上提升关键词排名的效果 使用 alt 属性还具有搜索引擎优化效果，因为搜素引擎是无法直接读取图像的信息的，alt可以为其提供文字信息所以对搜索引擎比较友好 图片描述最好是用简短的语句，描述这张图片的内容，如果是链接，则描述链接的作用，并带上关键词 不好的习惯是每张图片都没有 alt 标签，而不可取的是，对于每个标签都采用关键词堆砌，这样就有可能会导致被视为垃圾网站 alt 标签是一个通用术语，而不是写法，实际上 alt 是 img 标签中的一个替代文本属性，简单点来说 alt 标签就是用来描述图像内容的意思","link":"/2017/01/10/JavaScript/02/"},{"title":"JavaScript 中的作用域","text":"在看作用域之前，我们先来看看 IIFE（立即执行函数表达式），也就是所谓的立即执行函数，那么为什么需要 IIFE 传统的方法啰嗦，定义和执行分开写 传统的方法直接污染全局命名空间（浏览器里的 global 对象，如 window） 转变表达式的办法有很多，最常见的办法是把函数声明用一对 () 包裹起来，于是就变成了立即执行函数 IIFE一个简单的 IIFE 123// 这里是故意换行，实际上可以和下面的括号连起来(function foo() {...})(); 这就等价于： 1234// 这就不是定义，而是表达式了var foo = function () {...};foo(); 但是之前我们说不行的那个写法，其实也可以直接用括号包起来，这也是一种等价的表达式 1(function foo(){...}()); 另外，刚才说过转变表达式的方式很多，的确还有很多别的写法，比如 123456789101112131415!function foo() { // ...}();// or+function foo() { // ...}();// orvoid function () { // ...}(); 所谓不去污染全局命名空间，是因为 IIFE 创建了一个新的函数作用域，你真正的业务代码被封装在其中，自然就不会触碰到全局对象了 如果你需要全局对象，那就 pass 给 IIFE 123void function (global) { // 在这里，global 就是全局对象了}(this) // 在浏览器里，this 就是 window 对象 变量提升（Hoisting）先看一个例子 12345678910var a = 1;function foo () { if (!a) { var a = 2; } alert(a);};foo(); // 输出 2 之所以输出 2，这就是所谓的变量提升了 所谓声明变量 1var a; 所谓定义变量 1var a = 1; 声明：是指你声称某样东西的存在，比如一个变量或一个函数，但你没有说明这样东西到底是什么，仅仅是告诉解释器这样东西存在而已 定义：是指你指明了某样东西的具体实现，比如一个变量的值是多少，一个函数的函数体是什么，确切的表达了这样东西的意义 总结下来就是： 123var a; // 这是声明a = 1; // 这是定义（赋值）var a = 1; // 合二为一，声明变量的存在并赋值给它 当你以为你只做了一件事情的时候（var a = 1），实际上解释器把这件事情分解成了两个步骤 一个是声明（var a），另一个是定义（a = 1） 可以把之前的例子稍微转换一下，就成了如下 123456789101112var a;a = 1;function foo() { var a; // 关键在这里 if (!a) { a = 2; } alert(a); // 此时的 a 并非函数体外的那个全局变量}foo() 如代码所示，在进入函数体后解释器声明了新的变量 a，而无论 if 语句的条件如何，都将为新的变量 a 赋值为 2 作用域（Scoping）JavaScript 在 ES6 之前是没有块级作用域的（Block Scoping），只有函数作用域（Function Scoping） 当解析器读到 if 语句的时候，它发现此处有一个变量声明和赋值，于是解析器会将其声明提升至当前作用域的顶部（这是默认行为，并且无法更改），这个行为就叫做 Hoisting JavaScript 只有函数作用域！ 所以在上文当中，若是想要 alert(a) 弹出那个 1，也可以创建有一个新的作用域，就是利用之前所说的 IIFE 123456789101112131415var a = 1;function foo() { // 这个就是 IIFE，它会创建一个新的函数作用域 // 并且该作用域在 foo() 的内部，所以 alert 访问不到 // 不过这个作用域可以访问上层作用域，这就叫 闭包 if (!a) { (function() { var a = 2; }()); }; alert(a);};foo(); 请始终保持作用域内所有变量的声明放置在作用域的顶部 因为这样可以避免 Hoisting 特性给你带来的困扰，也可以很明确的告诉所有阅读代码的人（包括你自己）在当前作用域内有哪些变量可以访问 但是，变量声明的提升并非 Hoisting 的全部 在 JavaScript 中，有四种方式可以让命名进入到作用域中（按优先级） 语言定义的命名：比如 this 或者 arguments，它们在所有作用域内都有效且优先级最高，所以在任何地方你都不能把变量命名为 this 之类的，这样是没有意义的 形式参数：函数定义时声明的形式参数会作为变量被 hoisting 至该函数的作用域内，所以形式参数是本地的，不是外部的或者全局的，当然你可以在执行函数的时候把外部变量传进来，但是传进来之后就是本地的了 函数声明：函数体内部还可以声明函数，不过它们也都是本地的了 变量声明：这个优先级其实还是最低的，不过它们也都是最常用的 Hosting 只提升了命名，没有提升定义 函数声明与函数表达式的差别先看两个例子 12345678910111213141516171819// test1function test () { foo(); function foo() { alert('出现'); }}test();// test2function test () { foo(); var foo = function() { alert('不会出现'); }}test(); 在第一个例子里，函数 foo 是一个声明，既然是声明就会被提升（特意包裹了一个外层作用域，因为全局作用域需要你的想象，不是那么直观，但是道理是一样的），所以在执行 foo() 之前，作用域就知道函数 foo 的存在了 这叫做：函数声明（Function Declaration），函数声明会连通命名和函数体一起被提升至作用域顶部 然而在第二个例子里，被提升的仅仅是变量名 foo，至于它的定义依然停留在原处，因此在执行 foo() 之前，作用域只知道 foo 的命名，不知道它到底是什么，所以执行会报错（通常会是：foo is not a function） 这叫做：函数表达式（Function Expression），函数表达式只有命名会被提升，定义的函数体则不会 变量对象JavaScript 解释器之所以可以找到我们定义的函数和变量，全部依靠的变量对象（VO） 变量对象（Variable Object，缩写为 VO）是一个抽象概念中的对象，它用于存储执行上下文中 变量 函数声明 函数参数 VO 按照如下顺序填充： 函数参数（若为传入，初始化该参数值为 undefined） 函数声明（若发生命名冲突，会覆盖） 变量声明（初始化变量值为 undefined，若发生命名冲突，会忽略） 来看看以下几个实例，可以加深我们理解 VO 123456function foo (x, y, z) { function x () {}; alert(x); // function x () {}}foo(100); 在初始化阶段，先初始化函数的参数，参数 x 即为传进来的参数，为 100，但是在处理函数声明的时候，发生冲突，x 会被覆盖，所以返回的是一个函数对象 12345678910111213141516171819202122232425262728// var fn 的时候，发现 fn 已经在函数声明的时候定义过了，所以会忽略function foo(x, y, z) { function fn() { }; var fn; console.log(fn); // function fn () {}}foo(100);// 跟上例是一样的，但是在代码执行阶段，fn 会被执行赋值操作function foo(x, y, z) { function fn() { }; var fn = 1; console.log(fn); // 1}foo(100);// 在看一个容易出错的，最终会输出 100 和 0var num = 0;function a(num) { num = 100; console.log(num);}a();console.log(num); 函数表达式不会影响 VO，比如 var a = function foo(){} 这里的 foo 是函数表达式的名称，这个是不会记录到 VO 中的，这也是为什么我们不能在外部通过 foo 来获取到这个函数对象 实战先来看几个 setTimeout 相关的问题： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 第一个var a = 6;setTimeout(function () { alert(a); // 输出 66 a = 666;}, 1000);a = 66;// 第二个var a = 6;setTimeout(function () { var a = 666; alert(a); // 输出 666}, 1000);a = 66;//第三个var a = 6;setTimeout(function () { alert(a); // 输出 undefined var a = 666;}, 1000);a = 66;//第四个var a = 6;setTimeout(function () { a = 666; alert(a); // 输出 666}, 1000);a = 66;//第五个var a = 6; setTimeout(function(){ alert(a); var a = 66; }, 1000);a = 666; alert(a); // 666, undefined; 这几个问题涉及到了 setTimeout 的工作原理，执行环境与作用域还有函数的创建与调用 首先先说一下 setTimeout(function(){ }, time) 函数，现在在我们的 JavaScript 文件中有这么一段代码：setTimeout(a(), 5000) 在执行流执行到 setTimeout 代码时，并不会原地踏步地等待执行完毕后再向下执行，而是会告诉浏览器，我这段代码要等待 5 秒之后再执行，然后立即向下执行接下来的代码 现在可以先解决第一个问题了 首先定义了一个局部变量 a，并且 a = 6 ，然后执行流遇到了 setTimeout()，告诉浏览器，我 1 秒之后再执行这段代码，此时 a 仍然为 6 然后跳过 setTimeout() 中的代码继续向下执行，就碰到了 a = 66，将 a 赋值为 66 ，一秒过去了之后，浏览器开始调用 setTimeout() 函数中的匿名函数，遇到了 alert(a)，在此之前匿名函数中并没有创造局部变量 a，所以随着作用域链由内向外搜寻看看有没有变量 a，当搜寻到外部函数的作用域时，发现 a 已经被赋值成了 66，则返回结果，最终弹出窗口显示 66 第二个问题中，由于在 setTimeout() 的匿名函数中拥有了一个局部变量 a，所以最后 alert(a) 输出的是 666，（因为 var a = 666; 定义了局部变量 a，并且赋值为 666，根据变量作用域链，全局变量处在作用域末端，优先访问了局部变量，从而覆盖了全局变量） 至于第三个问题，涉及到了一个函数的创建与执行的区别，前面的运行同上面两个类似所以，直到执行流遇到 alert(a) 的时候，开始搜寻当前环境下有没有 a 变量，最终发现了一个 a 变量（被前置的，当前为 undefined），但是在未执行 var a = 666 之前，a 并没有被赋值，所以 alert(a) 的最终结果为 undefined，这也解释了为什么第四个最终会输出 666 至于最后一个，需要注意的是是先弹出 666，然后才是 undefined，（异步处理，声明提前） 再来看几个比较绕的： 12345678910111213141516171819function test() { var a = 1; setTimeout(function () { alert(a); a = 3; }, 1000); a = 2; setTimeout(function () { alert(a); a = 4; }, 3000);};test();alert(0); 首先 setTimeout 是一个异步延迟函数，上面说过了的，先弹出 0 是很明显的，因为 test 中的两个 alert() 都被延迟了，再弹出 0 之前 test 中的 a 是 2 所以在弹出 0 之后的第一个定时器中的 alert 就是 2 了，在弹 2 之后执行了赋值操作 a = 3，所以第二个定时器弹出的为 3","link":"/2017/01/18/JavaScript/03/"},{"title":"Fetch","text":"首先我们先来看看 Fetch 与 jQuery 的 ajax() 方法的一些不同点 基于 promise 设计 当接收一个代表错误的 http 状态码的时候，从 fetch() 返回的 promise 不会被标记为 reject，即使该 http 响应的状态码是 404 或 500，相反，它会将 promise 状态标记为 resolve（但是会将 resolve 的返回值的 ok 属性设置为 false），仅当网络故障或请求被阻止时，才会标记为 reject 默认情况下，fetch 不会从服务端发送或接收任何 cookies，如果站点依赖用户 session，则会导致未经认证的请求（要发送 cookie，必须设置 credentials 选项），credentials 是 request 接收的只读属性，用于表示用户代理是否应该在跨域请求的情况下从其他域发送 cookies（与 XHR 的 withCredentials 标志相似） 基本语法12345fetch(url, options).then(function (response) { // handle http response}, function (err) { // handle network error}) 示例12345678910111213141516171819202122232425// 因为现在支持性不是很好，所以需要兼容require('babel-polyfill');require('es6-promise').polyfill()import 'whatwg-fetch'fetch(url, { method: 'POST', body: JSON.stringify(data), headers: { 'Content-Type': 'application/json' }, credentials: 'same-origin'}).then(function (response) { response.status // =&gt; number 100-599 response.statusText // =&gt; String response.headers // =&gt; Headers response.url // =&gt; String response.text().then(function (responseText) { // ... })}, function (err) { err.message // =&gt; String}); 相关参数url定义要获取的资源 一个 USVString 字符串，包含要获取资源的 URL 一个 Reauest 对象 options（可选）一个配置项对象，包括所有对请求的设置，可选的参数有 methods - 请求方法，GET、POST headers - 请求的头信息，形式为 Headers 对象或 ByteString body - 请求的 body 信息，可能是 bold，BufferSource，FormData，URLSearchParams 或者 USVString 对象（GET 或 HEAD 方法的请求不包含 body 信息） mode - 请求的模式，如 cors，no-cors，some-origin credentials - 请求的 credentials，如 omit，same-origin，include cache - 请求的 cache 模式，如 default，no-store，reload，no-cache，force-cache，only-if-cached response一个 promise，resolve 时回传 Response 对象 属性如下 status (number) http - 请求结果参数 100–599 statusText (String) - 服务器返回的状态报告 ok (boolean) - 如果返回 200 表示请求成功则为 true headers (Headers) - 返回头部信息 url (String) - 请求的地址 方法如下 text() - 以 string 的形式生成请求 text json() - 生成 JSON.parse(responseText) 的结果 blob() - 生成一个 Blob arrayBuffer() - 生成一个 ArrayBuffer formData() - 生成格式化的数据，可用于其他的请求 其他方法 clone() Response.error() Response.redirect() response.headers has(name) (boolean) - 判断是否存在该信息头 get(name) (String) - 获取信息头的数据 getAll(name) (Array) - 获取所有头部数据 set(name, value) - 设置信息头的参数 append(name, value) - 添加 header 的内容 delete(name) - 删除 header 的信息 forEach(function(value, name){ ... }, [thisContext]) - 循环读取 header 的信息 实例GET123456// HTMLfetch('./index.html').then(function (response) { return response.text()}).then(function (body) { document.body.innerHTML = body}) 123456789// IMAGEvar img = document.querySelector('img')fetch('index.jpg').then(function (response) { return response.blob()}).then(function (bold) { let objectURL = URL.createObjectURL(bold) img.src = objectURL}) 1234567// JSONfetch(url) .then(response =&gt; { return response.json() }) .then(data =&gt; console.log(data)) .catch(err =&gt; console.log(err)) POST1234567891011121314151617181920212223242526272829303132fetch('/users', { methods: 'POST', headers: { 'Accept': 'application/json', 'Content-Type': 'application/json' }, body: JSON.stringify({ name: 'zhangsan', login: 'zhangsan' })})// 检查请求状态function checkStatus(response) { if (response.status &gt;= 200 &amp;&amp; response.status &lt; 300) { return response } else { let err = new Error(response.statusText) err.response = response throw err }}function parseJSON(response) { return response.json()}fetch('/users') .then(checkStatus) .then(parseJSON) .then(data =&gt; console.log(data)) .catch(err =&gt; console.log(err)) 文件上传 1234567891011// File Uploadlet input = document.querySelector('input[type=\"file\"]')var data = new FormData()data.append('file', input.files[0])data.append('user', 'zhangsan')fetch('/upload', { method: 'POST', body: data})","link":"/2017/03/09/JavaScript/08/"},{"title":"constructor、__proto__ 和 prototype 区别和关系","text":"constructor 属性返回对创建此对象的数组函数的引用，它是不会影响任何 JavaScript 的内部属性的 constructor看下面一段代码 1234567891011function Foo() { // ... }// true Foo.prototype.constructor === Foo;var a = new Foo();// truea.constructor === Foo; 看起来 a.constructor === Foo 为 true 则意味着 a 确实有一个指向 Foo 的 .constructor 属性，但是事实不是这样 实际上，.constructor 引用同样被委托给了 Foo.prototype，而 Foo.prototype.constructor 默认指向 Foo Foo.prototype 的 .constructor 属性只是 Foo 函数在声明时的默认属性 如果你创建了一个新对象并替换了函数默认的 .prototype 对象引用，那么新对象并不会自动获得 .constructor 属性 思考下面的代码 12345678function Foo() { }Foo.prototype = {}; // 创建一个新原型对象，这个操作相当于重写了函数的原型，不推荐这么操作var a1 = new Foo();a1.constructor === Foo; // false a1.constructor === Object; // true a1 并没有 .constructor 属性，所以它会委托 prototype 链上的 Foo.prototype，但是这个对象也没有 .constructor 属性（不过默认的 Foo.prototype 对象有这个属性） 所以它会继续委托，这次会委托给委托链顶端的 Object.prototype，这个对象有 .constructor 属性，指向内置的 Object() 函数 当然，你可以给 Foo.prototype 添加一个 .constructor 属性，不过这需要手动添加一个符合正常行为的不可枚举的属性 1234567891011121314function Foo() { }// 创建一个新原型对象Foo.prototype = {};// 需要在 Foo.prototype 上修复丢失的 .constructor 属性 // 新对象属性起到 Foo.prototype 的作用 Object.defineProperty(Foo.prototype, 'constructor', { enumerable: false, writable: true, configurable: true, // 让 .constructor 指向 Foo value: Foo}); 实际上，对象的 .constructor 会默认指向一个函数，这个函数可以通过对象的 .prototype 引用 .constructor 并不是一个不可变属性，它是不可枚举（参见上面的代码）的，但是它的值是可写的（可以被修改） 此外，你可以给任意 prototype 链中的任意对象添加一个名为 constructor 的属性或者对其进行修改，你可以任意对其赋值 所以这是一个非常不可靠并且不安全的引用，通常来说要尽量避免使用这些引用 但是有的时候，为了将实例的构造器的原型对象暴露出来，比如写了一个插件，别人得到的都是你实例化后的对象 如果想扩展下对象，就可以用 instance.constructor.prototype 去修改或扩展原型对象 1234567891011121314151617var a, b;(function () { function A(arg1, arg2) { this.a = 1; this.b = 2; } A.prototype.log = function () { console.log(this.a); } a = new A(); b = new A();})()a.log(); // 1b.log(); // 1 因为 A 在闭包里，所以现在我们是不能直接访问 A 的，那如果我们想给类 A 增加新方法，那么就可以通过访问 constructor 就可以了 1234567// a.constructor.prototype 在 chrome，firefox 中可以通过 a.__proto__ 直接访问a.constructor.prototype.log2 = function () { console.log(this.b)}a.log2(); // 2b.log2(); // 2 或者我们想知道 a 的构造函数有几个参数？ 1a.constructor.length 或者再复杂点，我想知道 a 的构造函数的参数名是什么 12a.constructor.toString().match(/\\(.*\\)/).pop().slice(1,-1).split(',');// ['arg1', 'arg2'] __proto__ 与 prototype所谓的 __proto__ 即隐式原型，注意与 prototype（显式原型）分别开来 __proto__ .__proto__ 并不存在于你正在使用的对象中，实际上，它和其他的常用函数（.toString()、.isPrototypeOf(..)，等等）一样，存在于内置的 Object.prototype 中（它们是不可枚举的） .__proto__ 看起来很像一个属性，但是实际上它更像一个 getter/setter .__proto__ 的实现大致上是这样的 12345678910Object.defineProperty(Object.prototype, '__proto__', { get: function () { return Object.getPrototypeOf(this); }, set: function (o) { // ES6 中的 setPrototypeOf(..) Object.setPrototypeOf(this, o); return o; }}); prototype所有普通对象都有内置的 Object.prototype，指向原型链的顶端（比如说全局作用域），如果在原型链中找不到指定的属性就会停止 toString()、valueOf() 和其他一些通用的功能都存在于 Object.prototype 对象上，因此语言中所有的对象都可以使用它们 JavaScript 中这个机制的本质就是对象之间的关联关系，简单来说 prototype 机制就是指对象中的一个内部链接引用另一个对象 两者间的联系记住以下两点 __proto__ 是每个对象都有的一个属性，而 prototype 是函数才会有的属性 __proto__ 指向的是构造该对象的构造函数的原型，而 prototype 指向的，是以当前函数作为构造函数构造出来的对象的原型对象 明确以下三点 通过 Function.prototype.bind 方法构造出来的函数是个例外，它没有 prototype 属性 Object.prototype 这个对象，它的 __proto__ 指向的是 null 通过 Object.create(null) 创建出来的对象没有 __proto__，如下 123var obj = Object.create(null);obj.__proto__; // undefined 理解下面这个图 接下来详细说明 显式原型每一个函数在创建之后都会拥有一个名为 prototype 的属性，也就是所谓的显式原型（explicit prototype property），这个属性指向函数的原型对象 显式原型的作用用来实现基于原型的继承与属性的共享 隐式原型JavaScript 中任意对象都有一个内置属性 prototype，在 ES5 之前没有标准的方法访问这个内置属性 但是大多数浏览器都支持通过 __proto__ 来访问，也就是所谓的隐式原型（implicit prototype link），ES5 中有了对于这个内置属性标准的 Get 方法 Object.getPrototypeOf() 隐式原型的作用是构成原型链，同样用于实现基于原型的继承，举个例子，当我们访问 obj 这个对象中的 x 属性时，如果在 obj 中找不到，那么就会沿着 __proto__ 依次查找 二者的关系隐式原型指向创建这个对象的函数（constructor）的 prototype 通过下面的一些实例巩固一下12345678910111213141516171819202122var obj = { a: 1 };console.log(obj.__proto__ === Object.prototype); // truevar str = new String('123');console.log(str.__proto__ === String.prototype); // truefunction Point() { };// 注意，这里链接到的不是 Point.prototypevar Circle = Object.create(Point);console.log(Circle.__proto__ === Point); // trueconsole.log(Circle.__proto__ === Point.prototype); // falsevar p = new Point();console.log(Point.__proto__); // function Empty() {}console.log(Point.prototype); // Point {}console.log(p.__proto__); // Point {}console.log(p.prototype); // undefined 一些说明123456789101112131415161718192021222324252627// obj 一般对象var obj = {}console.log(obj.constructor) // function Object() { }console.log(obj.prototype) // undefinedconsole.log(obj.__proto__) // Object { } [ 注意，这个是对象，不是构造函数 Object () { } ]console.log(obj.__proto__.constructor) // function Object() { }console.log(obj.__proto__.__proto__) // nullconsole.log(obj.__proto__.prototype) // undefined// -------------------------------------------------------------------------// 函数（包括普通函数，构造函数，原生函数 [Array，Object，String 等]）function fn() { }console.log(fn.constructor) // Function() { }console.log(fn.prototype) // Object { constructor: function } 构造函数console.log(fn.__proto__) // function () { } 空函数 emptyconsole.log(fn.__proto__.constructor) // Function() { }console.log(fn.__proto__.__proto__) // Object { } [ 注意这个是对象，不是构造函数 Object () { } ]console.log(fn.__proto__.prototype) // undefined Array.prototype.proto 指向什么？Array.prototype 也是一个对象，对象就是由 Object() 这个构造函数创建的，因此 1Array.prototype.__proto__ === Object.prototype; // true 也可以理解为，所有的内建对象都是由 Object() 创建而来 自定义对象12345678910111213141516171819202122// 1. 默认情况下function Foo() { }var foo = new Foo()Foo.prototype.__proto__ === Object.prototype // true 理由同上// 2. 其他情况 // （1）function Bar() { } // 这时我们想让 Foo 继承 BarFoo.prototype = new Bar()Foo.prototype.__proto__ === Bar.prototype // true// （2）Foo.prototype = { // 我们不想让 Foo 继承谁，但是我们要自己重新定义 Foo.prototype a: 10, b: -10}// 这种方式就是用了对象字面量的方式来创建一个对象，根据前文所述 Foo.prototype.__proto__ === Object.prototype // true 以上两种情况都等于完全重写了 Foo.prototype，所以 Foo.prototype.constructor 也跟着改变了，于是乎 constructor 这个属性和原来的构造函数 Foo() 也就切断了联系 instanceofinstanceof 操作符的内部实现机制和隐式原型、显式原型有直接的关系，instanceof 的左值一般是一个对象，右值一般是一个构造函数，用来判断左值是否是右值的实例，它的内部实现原理是这样的 123456// 设 L instanceof R // 通过判断L.__proto__.__proto__ ..... === R.prototype // 最终返回 true or false 也就是沿着 L 的 __proto__ 一直寻找到原型链末端，直到等于 R.prototype 为止 知道了这个也就知道为什么以下这些奇怪的表达式为什么会得到相应的值了 1234567Function instanceof Object // true Object instanceof Function // true Function instanceof Function // trueObject instanceof Object // trueNumber instanceof Number // false","link":"/2017/04/06/JavaScript/10/"},{"title":"Object.defineProperty()","text":"Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个已经存在的属性，并返回这个对象 123456// obj 需要定义属性的对象// prop 需定义或修改的属性的名字// descriptor 将被定义或修改的属性的描述符// 返回值 返回传入函数的对象，即第一个参数 objObject.defineProperty(obj, prop, descriptor) 对象里目前存在的属性描述符有两种主要形式，数据描述符和存取描述符 数据描述符是一个拥有可写或不可写值的属性 存取描述符是由一对 getter-setter 函数功能来描述的属性 描述符必须是两种形式之一，不能同时是两者，并且数据描述符和存取描述符不能混合使用 在 ES5 之前，JavaScript 语言本身并没有提供可以直接检测属性特性的方法，比如判断属性是否是只读 但是从 ES5 开始，所有属性都具备了属性描述符 12345678910111213141516var myObject = { a: 2}Object.getOwnPropertyDescriptor(myObject, a);/*{ value: 2, writable: true, enumerable: true, configurable: true}*/ 如你所见，这个普通的对象属性对应的属性描述符（也被称为数据描述符，因为它只保存一个数据值），不仅仅只有一个 2 它还包含了另外三个特性，writable（可写），enumerable（可枚举），configurable（可配置） 在创建普通属性时属性描述符会使用默认值，我们也可以使用 Object.defineProperty(...) 来添加一个新属性或者修改一个已有属性（如果它是 configurable），并对特性进行设置 12345678910var myObject = {}Object.defineProperty(myObject, 'a', { value: 2, writable: true, configurable: true, enumerable: true});myObject.a; // 2 我们使用 defineProperty(...) 给 myObject 添加了一个普通的属性并显式的指定了一些特性，然而，一般不会使用这种方式，除非你想修改属性描述符 默认情况下，使用 Object.defineProperty() 增加的属性值是不可改变的 Writablewritable 决定是否可以修改属性的值 123456789101112var myObject = {}Object.defineProperty(myObject, a, { value: 2, writable: false, // 不可写 configurable: true, enumerable: true})myObject.a = 3;myObject.a; // 2 如你所见，我们对于属性值的修改静默失败（silently failed），如果在严格模式（'use strict'）下，还会导致出错 简单来说，你可以把 writable: false 看作是属性不可改变，相当于空操作的 setter（后面会提到） Configurable只有属性是可配置的，就可以使用 defineProperty(...) 方法来修改属性描述符 123456789101112131415161718192021222324var myObject = { a: 2}myObject.a = 3;myObject.a; // 3Object.defineProperty(myObject, 'a', { value: 4, writable: true, configurable: false, // 不可配置 enumerable: true})myObject.a; // 4myObject.a = 5;myObject.a; // 5Object.defineProperty(myObject, 'a', { value: 6, writable: true, configurable: true, enumerable: true}) // TypeError 最后一个 defineProperty(...) 会产生一个 TypeError 错误，不管是不是处于严格模式，尝试修改一个不可配置的属性描述符都会出错 注意，把 configurable 修成为 false 是单向操作，无法撤销 但是有一个例外，即便属性是 configurable: false ，我们还是可以把 writable 的状态由 true 改成 false，但是无法由 false 改成 true 除了无法修改，configurable: false 还会禁止删除这个属性 12345678910111213141516171819202122var myObject = { a: 2};myObject.a; // 2delete myObject.a;myObject.a; // undefinedObject.defineProperty(myObject, 'a', { value: 2, writable: true, configurable: false, enumerable: true});myObject.a; // 2delete myObject.a;myObject.a; // 2 如你所见，最后一个 delete 语句（静默）失败了，因为属性是不可配置的 在本例中，delete 只用来直接删除对象的（可删除）属性，如果对象的某个属性是某个对象或者函数的最后一个引用者，对这个属性执行 delete 操作之后，这个未引用的对象或者函数就可以被垃圾回收（是一个删除对象属性的操作，仅此而已） Enumerable这个描述符控制的是属性是否会出现在对象的属性枚举中，比如说 for..in 循环，如果把 enumerable 设置成 false，这个属性就不会出现在枚举中，虽然仍然可以正常访问它，相对地，设置成 true 就会让它出现在枚举中 如果你不希望某些特殊属性出现在枚举中，那就把它设置成 enumerable: false 简单总结一下 Writable 如果在 Object.defineProperty() 中定义了 writable: false，重新给对象赋值的话是无效的 严格模式（'use strict'）下，还会导致出错 Configurable 如果在 Object.defineProperty() 中定义了 configurable: false，可以重新给对象赋值 但是不管是不是处于严格模式，不能再重新使用 Object.defineProperty 来重新配置属性，这样的操作会导致报错 把 configurable 修成为 false 的操作是单向操作，是无法撤销的！（同时也会禁止删除这个属性） 但是可以把 writable 的状态由 true 改成 false，但是无法由 false 改成 true（同样是单向操作） Enumerable 如果在 Object.defineProperty() 中定义了 enumerable: false，属性就不会出现在对象的属性枚举中 比如说 for..in 循环，虽然仍然可以正常访问它 不变性有时候你会希望属性或者对象是不可改变（无论有意还是无意）的，在 ES5 中可以通过很多种方法来实现 很重要的一点是，所有的方法创建的都是浅不变形，也就是说，它们只会影响目标对象和它的直接属性，如果目标对象引用了其他对象（数组、对象、函数，等），其他对象的内容不受影响，仍然是可变的 123myImmutableObject.foo; // [1, 2, 3]myImmutableObject.foo.push( 4 );myImmutableObject.foo; // [1, 2, 3, 4] 对象常量结合 writable: false 和 configurable: false 就可以创建一个真正的常量属性（不可修改、重定义或者删除） 1234567var myObject = {}Object.defineProperty(myObject, 'FAVORITE_NUMBER', { value: 42, writable: false, configurable: false}); 禁止扩展如果你想禁止一个对象添加新属性并且保留已有属性，可以使用 Object.preventExtensions(..) 12345678var myObject = { a: 2};Object.preventExtensions(myObject);myObject.b = 3;myObject.b; // undefined 在非严格模式下，创建属性 b 会静默失败，在严格模式下，将会抛出 TypeError 错误 密封Object.seal(..) 会创建一个密封（seal）的对象，这个方法实际上会在一个现有对象上调用 Object.preventExtensions(..) 并把所有现有属性标记为 configurable: false 所以，密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性（虽然可以修改属性的值） 冻结Object.freeze(..) 会创建一个冻结对象，这个方法实际上会在一个现有对象上调用 Object.seal(..) 并把所有数据访问属性标记为 writable: false，这样就无法修改它们的值 [[Get]]先看以下代码 12345var myObject = { a: 2};myObject.a; // 2 myObject.a 是一次属性访问，但是这条语句并不仅仅是在 myObjet 中查找名字为 a 的属性，虽然看起来好像是这样 在语言规范中，myObject.a 在 myObject 上实际上是实现了 [[Get]] 操作（有点像函数调用，[[Get]]()） 对象默认的内置 [[Get]] 操作首先在对象中查找是否有名称相同的属性，如果找到就会返回这个属性的值 然而，如果没有找到名称相同的属性，按照 [[Get]] 算法的定义会执行另外一种非常重要的行为（遍历可能存在的 [[Prototype]] 链，也就是原型链） 如果无论如何都没有找到名称相同的属性，那 [[Get]] 操作会返回值 undefined， 12345var myObject = { a: 2};myObject.b; // undefined 注意，这种方法和访问变量时是不一样的，如果你引用了一个当前词法作用域中不存在的变量，并不会像对象属性一样返回 undefined，而是会抛出一个 ReferenceError 异常， 1234567var myObject = { a: undefined }; myObject.a; // undefined myObject.b; // undefined 从返回值的角度来说，这两个引用没有区别 — 它们都返回了 undefined 然而，尽管乍看之下没什么区别，实际上底层的 [[Get]] 操作对 myObject.b 进行了更复杂的处理 由于仅根据返回值无法判断出到底变量的值为 undefined 还是变量不存在，所以 [[Get]] 操作返回了 undefined [[Put]]既然有可以获取属性值的 [[Get]] 操作，就一定有对应的 [[Put]] 操作 [[Put]] 被触发时，实际的行为取决于许多因素，包括对象中是否已经存在这个属性（这是最重要的因素） 属性是否是访问描述符？如果是并且存在 setter 就调用 setter 属性的数据描述符中 writable 是否是 false？如果是，在非严格模式下静默失败，在严格模式下抛出 TypeError 异常 如果都不是，将该值设置为属性的值 Getter 和 Setter对象默认的 [[Put]] 和 [[Get]] 操作分别可以控制属性值的设置和获取 在 ES5 中可以使用 getter 和 setter 部分改写默认操作，但是只能应用在单个属性上，无法应用在整个对象上，getter 是一个隐藏函数，会在获取属性值时调用，setter 也是一个隐藏函数，会在设置属性值时调用 当你给一个属性定义 getter、setter 或者两者都有时，这个属性会被定义为访问描述符（和数据描述符相对） 对于访问描述符来说，JavaScript 会忽略它们的 value 和 writable 特性，取而代之的是关心 set 和 get（还有 configurable 和 enumerable）特性 12345678910111213141516171819202122var myObject = { // 给 a 定义一个 getter get a() { return 2; }};Object.defineProperty( myObject, // 目标对象 'b', // 属性名 { // 描述符 // 给 b 设置一个 getter get: function () { return this.a * 2 }, // 确保 b 会出现在对象的属性列表中 enumerable: true });myObject.a; // 2myObject.b; // 4 不管是对象文字语法中的 get a() {..}，还是 defineProperty(..) 中的显式定义，二者都会在对象中创建一个不包含值的属性，对于这个属性的访问会自动调用一个隐藏函数，它的返回值会被当作属性访问的返回值 123456789var myObject = { // 给 a 定义一个getter get a() { return 2; }};myObject.a = 3;myObject.a; // 2 由于我们只定义了 a 的 getter，所以对 a 的值进行设置时 set 操作会忽略赋值操作，不会抛出错误，而且即便有合法的 setter，由于我们自定义的 getter 只会返回 2，所以 set 操作是没有意义的 为了让属性更合理，还应当定义 setter，和你期望的一样，setter 会覆盖单个属性默认的 [[Put]]（也被称为赋值）操作，通常来说 getter 和 setter 是成对出现的（只定义一个的话通常会产生意料之外的行为） 12345678910111213var myObject = { // 给 a 定义一个 getter get a() { return this._a_; }, // 给 a 定义一个 setter set a(val) { this._a_ = val * 2; }};myObject.a = 2;myObject.a; // 4 参考 《You Don’t Know JS》 《JavaScript 高级程序设计》 MDN - Object.defineProperty()","link":"/2017/05/02/JavaScript/14/"},{"title":"Function.prototype.bind()","text":"要想改变被调用函数的上下文，可以使用 call 或 apply 方法，但如果重复使用就会很不方便，因为每次都要把上下文对象作为参数传递，而且还会使代码变得不直观 针对这种情况，我们可以使用 bind 方法来永久地绑定函数的上下文，使其无论被谁调用，上下文都是固定的 基本语法bind 方法的定义见 Function.prototype.bind() 使用方式如下 1fun.bind(thisArg[, arg1[, arg2[, ...]]]) bind() 方法会创建一个新函数，当这个新函数被调用时，它的 this 值是传递给 bind() 的第一个参数, 它的参数是 bind() 的其他参数和其原本的参数 bind 返回的绑定函数也能使用 new 操作符创建对象（这种行为就像把原函数当成构造器），提供的 this 值被忽略，同时调用时的参数被提供给模拟函数 bind 方法与 call、apply 最大的不同就是前者返回一个绑定上下文的函数，而后两者是直接执行了函数 还可以写成 fn.bind(obj, arg1)(arg2) 一句话概括就是 该方法创建一个新函数，称为绑定函数，绑定函数会以创建它时传入 bind 方法的第一个参数作为 this，传入 bind 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数 12345678910111213141516171819202122var someuser = { name: 'abc', func: function () { console.log(this.name); }};var foo = { name: 'foobar'};foo.func = someuser.func;foo.func(); // 输出 foobar foo.func1 = someuser.func.bind(someuser);foo.func1(); // 输出 abc func = someuser.func.bind(foo);func(); // 输出 foobar func2 = func;func2(); // 输出 foobar 上面代码直接将 foo.func 赋值为 someuser.func，调用 foo.func() 时，this 指针为 foo，所以输出结果是 foobar foo.func1 使用了 bind 方法，将 someuser 作为 this 指针绑定到 someuser.func，调用 foo.func1() 时，this 指针为 someuser，所以输出结果是 abc 全局函数 func 同样使用了 bind 方法，将 foo 作为 this 指针绑定到 someuser.func，调用 func() 时，this 指针为 foo，所以输出结果是 foobar 而 func2 直接将绑定过的 func 赋值过来，与 func 行为完全相同 使用 bind 绑定参数表bind 方法还有一个重要的功能：绑定参数表，如下例所示 1234567891011var person = { name: 'foo', says: function (act, obj) { console.log(this.name + ' ' + act + ' ' + obj); }};person.says('loves', 'bar'); // 输出 foo loves bar fooLoves = person.says.bind(person, 'loves');fooLoves('you'); // 输出 foo loves you 可以看到，fooLoves 将 this 指针绑定到了 person，并将第一个参数绑定到 loves，之后在调用 fooLoves 的时候，只需传入第三个参数 这个特性可以用于创建一个函数的捷径，之后我们可以通过这个捷径调用，以便在代码多处调用时省略重复输入相同的参数，也就是下面会说到的 currying 理解 bind尽管 bind 很优美，还是有一些令人迷惑的地方，例如下面的代码 12345678910111213141516var someuser = { name: 'abc', func: function () { console.log(this.name); }};var foo = { name: 'foobar'};func = someuser.func.bind(foo);func(); // 输出 foobar func2 = func.bind(someuser);func2(); // 输出 foobar 全局函数 func 通过 someuser.func.bind 将 this 指针绑定到了 foo，调用 func() 输出了 foobar 我们试图将 func2 赋值为已绑定的 func 重新通过 bind 将 this 指针绑定到 someuser 的结果， 而调用 func2 时却发现输出值仍为 foobar， 即 this 指针还是停留在 foo 对象上，这是为什么呢？要想解释这个现象，我们必须了解 bind 方法的原理，让我们看一个 bind 方法的简化版本（不支持绑定参数表） 123someuser.func.bind = function(self) { return this.call(self);}; 假设上面函数是 someuser.func 的 bind 方法的实现，函数体内 this 指向的是 someuser.func，因为函数也是对象，所以 this.call(self) 的作用就是以 self 作为 this 指针调用 someuser.func 123456789// 将 func = someuser.func.bind(foo) 展开func = function() { return someuser.func.call(foo); };// 再将 func2 = func.bind(someuser) 展开func2 = function() { return func.call(someuser);}; 从上面展开过程我们可以看出，func2 实际上是以 someuser 作为 func 的 this 指针调用了 func，而 func 根本没有使用 this 指针，所以两次 bind 是没有效果的 bind 与 currying比如我们有一个函数 123function add(a, b, c) { return a + b + c;} add 函数的作用是把参数 a, b, c 进行拼接（或者说相加），但是有的时候不需要一次把这个函数都调用完成 而是调用一次把前两个参数传完了以后，然后得到了这样的一个函数，再去调用，并且每次传入第三个值 1234// 由于我们不需要改变它的 this，所以随便传入一个 undefined/null ，但是我们提供了额外的参数 100var func = add.bind(null, 100);func(1, 2); // 103 然后我们拿到这样一个 bind 函数以后，相当于这个 100 就会固定赋值给第一个参数，也就是这里的 a 参数， 然后在调用的时候传入 1 和 2 参数，1 和 2 就会分别给 b 和 c，所以，最后的结果为 103 currying 的实现12345678910111213141516171819// 扩展 Function，方便我们可以直接使用 . 来进行调用Function.prototype.curry = function () { var slice = Array.prototype.slice, that = this, args = slice.apply(arguments); return function () { return that.apply(null, args.concat(slice.apply(arguments))); }}// 定义方法 addvar add = function (a, b) { return a + b;}// 应用var add1 = add.curry(1);console.log(add1(5)) // 6 bind 与 new123456789function foo() { this.b = 100; return this.a;}var func = foo.bind({ a: 1 });func(); // 1new func(); // {b: 100} 声明了一个全部变量 b，并且把它的值赋为 100，然后返回全局变量 a，这样我们直接调用的话，那么 this 就会指向 bind 这样的一个参数，所以 return this.a 就会返回 1 如果使用了 new，ruturn 除非是对象，如果不是对象，将会把 this 做为返回值，并且 this 会被初始化为默认的一个空对象，这个对象的原型为 foo.prototype 所以说，我们用 new 去调用的话，这种情况下，即使我们使用了 bind 方法，但是这个 this 依然会指向没有 bind 的时候所指向的（正常状态），这样一个空对象的 b 属性会被赋值为 100，然后整个这个对象会做为返回值返回，会忽略这样一个 return bind 详解bind 方法主要实现以下功能 一个是绑定函数里面的 this（或者说改变函数里面的 this 指向） 另一个就是把函数拆分为不同的子函数，即柯里化功能 还有就是在 new 调用的时候，忽略掉 bind 的作用（通过 instanceof 判断函数是否通过 new 调用，来决定绑定的 context） 其实在使用 bind 的时候，无非就分为两种情况，一种是直接调用，另一种就是 new 调用，如下所示 12345678910function foo(c) { this.b = 100; console.log(c); return this.a;}var func = foo.bind({a: 1}, 20);func(); // 20 1new func(); // 20 {b: 100} 先来看一个简单的实现方式 12345678910Function.prototype.bind = Function.prototype.bind || function (context) { // 保存 this const self = this; // 保存第一部分参数（拆分） const args = Array.prototype.slice.call(arguments, 1); return function () { // 合并参数（实现 currying 功能） return self.apply(context, args.concat(Array.prototype.slice.call(arguments))); }} 一个较为完善的实现 1234567891011Function.prototype.bind = function (oThis, ...args) { const context = this let fToBind = function (...params) { // 判断是否通过 new 调用，如果是 new 调用就绑定到 this 上，否则就绑定到传入的 oThis 上 const context = this instanceof fToBind ? this : Object(oThis) // 老规矩，利用 apply 绑定 this 指向并且传递参数 return context.apply(context, ...args, ...params) } fToBind.prototype = Object.create(context.prototype) return fToBind} 再来对比看一下完整的实现方式，摘选自 MDN 123456789101112131415161718192021222324252627282930313233343536373839404142if (!Function.prototype.bind) { // 传入的 oThis 就是 foo.bind({a: 1}, 20) 中传入的对象 {a: 1} Function.prototype.bind = function (oThis) { if (typeof this !== \"function\") { throw new TypeError(\"Function.prototype.bind - what is trying to be bound is not callable\"); } // 调用数组方法，剔除掉第一个参数，得到剩余参数 var aArgs = Array.prototype.slice.call(arguments, 1), // 这里的 this 指向函数对象 foo fToBind = this, fNOP = function () { }, // 最后返回的就是这个对象，其实就是 fToBind.apply(...) // 在不调用 func 的情况下，func 本质就是返回的 apply(..) 函数 fBound = function () { // 这里的 this 指的是调用 bind 后 func 的执行环境 // 第一点，见最后 return fToBind.apply(this instanceof fNOP ? this : oThis, // 这里的 arguments 和上面的不一样，这里是 func() 的执行环境 // 比如 foo.bind({a: 1}, 20) 中剩余的参数 20 和调用 func(b, c) 时的参数 b 和 c // 这里就利用 aArgs.concat() 连接了起来，实现了柯里化的功能 // 单单执行 bind 的时候是空数组（类数组对象），因为 arguments 是指向 实参 对象的引用 // 只有在函数调用的时候，传入了实参以后，才会有 arguments 对象 aArgs.concat(Array.prototype.slice.call(arguments))); }; // 第二点，见最后 fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound; };} 比较好理解的地方都直接标记在注释当中了，现在就剩下比较饶的两点，一个一个来看 简单来说就是分为以下两种情况，第一种就是直接调用的情况 正常调用的时候，即 func()，此时 func() 中的 this 是指向 window 的，所以 this instanceof fNOP 为 false 此时执行的是 fToBind.apply(oThis, ...)，这里的 oThis 也就是传入 bind() 的第一个参数对象 {a: 1} 所以这时 foo() 函数中的 this 就可以指向这个参数对象（{a: 1}） 而 bind() 后剩余的参数（比如 bind({a: 1}, 20) 中的 20）和 fBound 的一些自己的参数，这个就是通过最后的 aArgs.concat() 拼接完成的 第二种就是 new 调用的情况 当在对 func() 使用 new 的时候，本质上 func() 就是作为构造函数在使用了，所以此时的 this 指向的是一个空对象（见最后） 这时的 this instanceof fNOP 就为 true 了，而此时执行的也就是 fToBind.apply(this, ...) 所以这时的 this 就作为 foo() 函数中调用的 this，也就不再指向 bind() 后的参数对象了，而是作为函数体内正常的 this 使用 这也就忽略掉 bind 的作用了（即 new 了以后，this 和 bind() 后绑定的参数没有关系了） 关于 this 指向的是一个空对象当一个函数被作为一个构造函数来使用（使用 new 关键字），它的 this 与即将被创建的新对象绑定（见 构造函数中的 this） 当构造器返回的默认值是一个 this 引用的对象时，可以手动设置返回其他的对象，如果返回值不是一个对象，返回 this（不指定，则默认为一个空对象） 12345function foo() { console.log(this.__proto__ === foo.prototype) // true}new foo() 关于 fNOP.prototype = this.prototype在之前的代码中有这么一段 123456fNOP = function () { },// ...fNOP.prototype = this.prototype;fBound.prototype = new fNOP(); 之所以会拷贝一个 fNOP 的 prototype 给 fBound，由于是拷贝所以修改 fBound 的 prototype 不会影响到 fNOP 的 prototype 其实这两种方法是等价的： 123456fNOP.prototype = this.prototype;fBound.prototype = new fNOP();// ==&gt; 两者是相等的fBound.prototype = Object.creat(this.prototype); 如果直接使用 fBound.prototype = this.prototype; 的话，那么在改变 func 的 prototype 的时候，foo 的 prototype 也会跟着变，所以不推荐","link":"/2017/05/07/JavaScript/15/"},{"title":"闭包与作用域链","text":"所谓闭包「官方」的解释是：是指拥有多个变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分 看起来有点绕，换个说法，简而言之，闭包就是： 闭包就是函数的局部变量集合，只是这些局部变量在函数返回后会继续存在 闭包就是就是函数的堆栈在函数返回后并不释放，我们也可以理解为这些函数堆栈并不在栈上分配而是在堆上分配 当在一个函数内定义另外一个函数就会产生闭包 做为局部变量都可以被函数内的代码访问，这个和静态语言是没有差别，闭包的差别在于局部变变量可以在函数执行结束后仍然被函数外的代码访问 这意味着函数必须返回一个指向闭包的引用，或将这个引用赋值给某个外部变量，才能保证闭包中局部变量被外部代码访问 但是在 ECMAScript 中，函数对象中定义的内部函数（inner function） 是可以直接访问外部函数的局部变量，通过这种机制，我们就可以以如下的方式完成对闭包的访问了 12345678910111213function greeting(name) { // local variable var text = 'Hello ' + name; // 每次调用时，产生闭包，并返回内部函数对象给调用者 return function () { alert(text); }}var sayHello = greeting('Closure');// 通过闭包访问到了局部变量 textsayHello() 上述代码的执行结果是：Hello Closure，因为 sayHello() 函数在 greeting 函数执行完毕后，仍然可以访问到了定义在其之内的局部变量 text 闭包模型在本质上来说，闭包就是将函数内部和函数外部连接起来的一座桥梁 闭包可以用在许多地方，它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中 在 ECMAscript 的脚本的函数运行时，每个函数关联都有一个执行上下文场景（Execution Context） ，这个执行上下文场景中包含三个部分 文法环境（The LexicalEnvironment） 变量环境（The VariableEnvironment） this 绑定 我们可以将文法环境想象成一个对象，该对象包含了两个重要组件，环境记录（Enviroment Recode），和外部引用（指针） 环境记录包含包含了函数内部声明的局部变量和参数变量，外部引用指向了外部函数对象的上下文执行场景 全局的上下文场景中此引用值为 null，这样的数据结构就构成了一个单向的链表，每个引用都指向外层的上下文场景 比如上面的例子，sayHello 函数在最下层，上层是函数 greeting，最外层是全局场景 当 sayHello 被调用的时候，sayHello 会通过上下文场景找到局部变量 text 的值，因此在屏幕的对话框中显示出 'Hello Closure' 作用域链在 JavaScript 中当进行函数的调用，会为每一个函数增加一个属性 Scope，通过这个属性来指向一块内存，这块内存中包含有所有的上下文使用的变量 当在某个函数中调用了新函数之后，新函数依然会有一个作用域来执行原有的函数的 Scope 和自己新增加的 Scope，这样就形成了一个链式结构，这就是 JavaScript 中的作用域链 123456789101112131415161718192021var color = 'red';var showColor = function () { alert(this.color);}function changeColor() { var anotherColor = 'blue'; function swapColor() { var tempColor = anotherColor; anotherColor = color; color = tempColor; } swapColor();}showColor(); // redchangeColor();showColor(); // blue 作用域链图如下所示 在看一个实例 123456789101112131415161718192021function compareObjectFunction(prop) { return function (obj1, obj2) { if (obj1[prop] &gt; obj2[prop]) { return 1; } else if (obj1[prop] &lt; obj2[prop]) { return -1; } else { return 0; } }}var o1 = { name: 'zhangsan', age: 20 };var o2 = { name: 'lisi', age: 30 };var compare = compareObjectFunction('age');// 此时就是比较 o1 和 o2 了var rel = compare(o1, o2);console.log(rel); 在传统语言中（比如 Java），以上代码执行完成后，prop 就会被释放，但是在 JavaScript 中，这个作用域却被放大了 在 JavaScript 中，prop 在这里依然可以访问，这种通过返回函数来扩大函数的作用域的方法就是闭包，以上函数的作用域链图如下所示 闭包中的作用域变量123456789101112131415161718function fn1() { var fns = new Array(); // i 这个变量是保存在 fn1 这个作用域中的 for (var i = 0; i &lt; 10; i++) { // 数组中 fns 的值是一组数组 fns[i] = function () { return i; } } return fns;}var fs = fn1();for (var i = 0; i &lt; fs.length; i++) { console.log(fs[i]());} 我们期望的是输出 0 ~ 9，但是此时通过闭包来调用所有函数，当输出i的时候会去上一级的作用域中查找，这个时候 i 的值已经为 10，所以连续输出 10 个 10 修改一下，使用闭包来达到我们的期望： 1234567891011121314151617181920function fn2() { var fns = new Array(); // i 这个变量是保存在 fn1 这个作用域中的 for (var i = 0; i &lt; 10; i++) { +function (num) { fns[num] = function () { return num; } }(i) } return fns;}var fs = fn2();for (var i = 0; i &lt; fs.length; i++) { // 每一个 fs 都是在不同作用域链中，num 也是保存在不同的作用域中，所以输出 0 ~ 9 console.log(fs[i]());} 闭包中的 this 的指向浏览器中的顶级域，其实就是 window 对象，所谓的闭包中的 this 指向，通俗点说就是，谁调用这个函数（即 xx.fn() 中的 xx），谁就是这个函数（fn）的 this JavaScript 中的 this 指向函数调用时的上下文，可以想像成每个函数在被调用时，动态注入了一个 this 对象 所以在非严格模式下内部的 this 指向 window 对象，严格模式下应为 undefined，其实，引入 this 的初衷就是想在原型继承的情况下，得到函数的调用者，如下实例 12345678910111213var obj = { method: function () { return this; }};console.log(obj.method() === obj);var F = function () { };F.prototype = obj;var instance = new F;console.log(instance.method() === instance); 如果函数没有指明调用者呢，那就让 this 指向全局对象吧 12345var global = this;console.log(global === window);var g = obj.method();console.log(g() === global); 再看一个实例 12345678910111213var name = 'window';var person = { name: '张三', age: 20, say: function () { return function () { return this.name; } }}console.log(person.say()()); // window 当完成 person.say() 之后，这个函数就调用结束了，在这个函数调用结束之前 this 是指向 preson，但是在调用匿名函数的时候，this 就指向了 window，所以得到的结果是 window 我们可以把函数中的 this 用一个临时变量保存起来，就可以得到我们想要的结果 12345678910111213141516var name = 'window';var person = { name: '张三', age: 20, say: function () { // that 就指向 person（把 this 保存起来） var that = this; return function () { return that.name; } }}console.log(person.say()()); 此时 that 就是指向 person 的，所以调用 that.name 就是 person 中的 name 扩展闭包当中的对象如下示例 1234567891011121314151617var a, b;+function () { function A(arg1, arg2) { this.a = 1; this.b = 2; } A.prototype.log = function () { console.log(this.a); } a = new A(); b = new A();}()a.log(); // 1b.log(); // 1 函数外层通过一个 IIFE（立即调用函数表达式） 包裹，内部的构造函数 A 处于闭包当中，所以现在我们是不能直接访问 A 的 如果我们想给类 A 增加新方法，便可以通过访问 constructor 来达到目的 1234567// a.constructor.prototype 在 chrome，firefox 中可以通过 a.__proto__ 直接访问a.constructor.prototype.log2 = function () { console.log(this.b)}a.log2(); // 2b.log2(); // 2","link":"/2017/05/12/JavaScript/16/"},{"title":"闭包的实例","text":"前面我们大致了解了 JavaScript 中的闭包是什么，闭包在 JavaScript 是怎么实现的，详情见 闭包与作用域链 下面我们来看一些例子来更加深入的理解闭包 先来看 5 个摘自 JavaScript Closures for Dummies 的案例 实例一：闭包中局部变量是引用而非拷贝123456789101112function say667() { // 局部变量 var num = 666; var sayAlert = function () { alert(num); } num++; return sayAlert;}var sayAlert = say667();sayAlert() 因此执行结果应该弹出的 667 而非 666 实例二：多个函数绑定同一个闭包，因为他们定义在同一个函数内12345678910111213141516function setupSomeGlobals() { var num = 666; // 存储一些函数作为全局变量的引用 gAlertNumber = function () { alert(num); } gIncreaseNumber = function () { num++; } gSetNumber = function (x) { num = x; }}setupSomeGlobals(); // 为三个全局变量赋值gAlertNumber(); // 666gIncreaseNumber();gAlertNumber(); // 667gSetNumber(12);gAlertNumber(); // 12 实例三：当在一个循环中赋值函数时，这些函数将绑定同样的闭包1234567891011121314151617181920function buildList(list) { var result = []; for (var i = 0; i &lt; list.length; i++) { var item = 'item' + list[i]; result.push(function () { alert(item + ' ' + list[i]) }); } return result;}function testList() { var fnlist = buildList([1, 2, 3]); // 只使用 j 防止混乱 for (var j = 0; j &lt; fnlist.length; j++) { fnlist[j](); }}testList() // 弹出三次 item3 undefined 因为这三个函数绑定了同一个闭包，而且 item 的值为最后计算的结果，但是当 i 跳出循环时 i 值为 4，所以 list[4] 的结果为 undefined 实例四：外部函数所有局部变量都在闭包内，即使这个变量声明在内部函数定义之后1234567891011function sayAlice() { var sayAlert = function () { alert(alice); } // 但是如果把 return 语句放到 var 上面，结果就是 undefined var alice = 'Hello Alice'; return sayAlert;}var helloAlice = sayAlice();helloAlice(); 执行结果是弹出 'Hello Alice' 的窗口，即使局部变量声明在函数 sayAlert 之后，局部变量仍然可以被访问到 实例五：每次函数调用的时候创建一个新的闭包123456789101112131415161718function newClosure(someNum, someRef) { var num = someNum; var anArray = [1, 2, 3]; var ref = someRef; return function (x) { num += x; anArray.push(num); alert('num: ' + num + ' anArray ' + anArray.toString() + ' ref.someVar ' + ref.someVar); }}closure1 = newClosure(40, { someVar: 'closure 1' });closure2 = newClosure(1000, { someVar: 'closure 2' });closure1(5); // num: 45 anArray[1, 2, 3, 45] ref: 'someVar closure1'closure2(-10); // num: 990 anArray[1, 2, 3, 990] ref: 'someVar closure2' 下面是一些平常遇到过的坑： 实例六：闭包引用的局部变量，不会自动清除123456789101112function f1() { var n = 999; nAdd = function () { n += 1 }; function f2() { alert(n); } return f2;}var result = f1();result(); // 999nAdd();result(); // 1000 在上述代码中，result 实际上就是闭包 f2 函数，它一共运行了两次，第一次的值是 999，第二次的值是 1000 这证明了，函数 f1 中的局部变量 n 一直保存在内存中，并没有在 f1 调用后被自动清除 原因在于 f1 是 f2 的父函数，而 f2 被赋给了一个全局变量，这导致 f2 始终在内存中，而 f2 的存在依赖于 f1 ，因此 f1 也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage-collection）回收 这段代码中另一个值得注意的地方，就是 nAdd = function () { n += 1 } 这一行，首先在 nAdd 前面没有使用 var 关键字，因此 nAdd 是一个全局变量，而不是局部变量 其次，nAdd 的值是一个匿名函数（anonymous-function），而这个匿名函数本身也是一个闭包，所以 nAdd 相当于是一个 setter，可以在函数外部对函数内部的局部变量进行操作 实例七：闭包中的 this12345678910111213141516171819202122232425262728// 1var name = 'The Window';var object = { name: 'My Object', getNameFunc: function () { return function () { return this.name; }; }};alert(object.getNameFunc()());// 2var name = 'The Window';var object = { name: 'My Object', getNameFunc: function () { var that = this; return function () { return that.name; }; }};alert(object.getNameFunc()()); 第一个 打印结果为 The window 第二个 打印结果为 My Object 第一个 this 为全局对象，所以 alert 处理的 name 为 The window 第二个 that 为 object 对象，所以 alert 处理的 name 为 My object 第二个好理解，因为在调用前用 that 保存了 object 自己的 this，所以在闭包内可以调用 实例八：闭包中的作用域12345678910111213141516171819202122// 1function foo(x) { var tmp = 3; function bar(y) { alert(x + y + (++tmp)); } bar(10);}foo(2);// 2function foo(x) { var tmp = 3; return function (y) { alert(x + y + (++tmp)); }}var bar = foo(2); // bar 现在是一个闭包bar(10); // 16bar(10); // 17 1 中不管执行多少次，都会 alert 16，因为 bar 能访问 foo 的参数 x，也能访问 foo 的变量 tmp，但这还不是闭包 只有当你 return 的是内部 function 时，就是一个闭包（即这时才会产生一个闭包） 内部 function 会 close-over 外部 function 的变量直到内部 function 结束 2 中的脚本也会 alert 16，因为虽然 bar 不直接处于 foo 的内部作用域，但 bar 还是能访问 x 和 tmp，但是，由于 tmp 仍存在于 bar 闭包的内部，所以它还是会自加 1，而且你每次调用 bar 时它都会自加 1 上面的 x 是一个字面值（值传递），和 JavaScript 里其他的字面值一样，当调用 foo 时，实参 x 的值被复制了一份，复制的那一份作为了 foo 的参数 x 那么问题来了，JavaScript 里处理 object 时是用到引用传递的，那么，你调用 foo 时传递一个 object，foo 函数 return 的闭包也会引用最初那个 object，也就有了下面的 3 1234567891011121314// 3function foo(x) { var tmp = 3; return function (y) { alert(x + y + tmp); x.memb = x.memb ? x.memb + 1 : 1; alert(x.memb); }}var age = new Number(2);var bar = foo(age); // bar 现在是一个引用了 age 的闭包bar(10); 不出我们意料，每次运行 bar(10)，x.memb 都会自加 1，但需要注意的是 x 每次都指向同一个 object，运行两次 bar(10) 后，age.memb 会变成 2 这里还有一个不用 return 关键字的闭包例子 1234567function closureExample(objID, text, timedelay) { setTimeout(function () { document.getElementById(objID).innerHTML = text; }, timedelay);}closureExample('myDiv', 'Closure is created', 500); 注意，外部函数不是必需的 通过访问外部变量，一个闭包可以维持（keep alive）这些变量，在内部函数和外部函数的例子中，外部函数可以创建局部变量，并且最终退出，但是，如果任何一个或多个内部函数在它退出后却没有退出，那么内部函数就维持了外部函数的局部数据 闭包经常用于创建含有隐藏数据的函数（但并不总是这样），看下面这段代码 12345678910111213141516171819202122232425var db = (function () { // 创建一个隐藏的 object, 这个 object 持有一些数据 // 从外部是不能访问这个 object 的 var data = {}; // 创建一个函数, 这个函数提供一些访问 data 的数据的方法 return function (key, val) { if (val === undefined) { // get return data[key] } else { // set return data[key] = val } }; // 我们可以调用这个匿名方法 // 返回这个内部函数，它是一个闭包})();db('x'); // 返回 undefineddb('x', 1); // 设置 data['x'] 为 1db('x'); // 返回 1// 我们不可能访问 data 这个 object 本身// 但是我们可以设置它的成员 闭包的应用：Singleton 单件123456789101112131415var singleton = function () { var privateVariable; function privateFunction(x) { //...privateVariable... } return { firstMethod: function (a, b) { //...privateVariable... }, secondMethod: function (c) { //...privateFunction()... } };}(); 这个单件通过闭包来实现，通过闭包完成了私有的成员和方法的封装，匿名主函数返回一个对象，对象包含了两个方法，方法 1 可以方法私有变量，方法 2 访问内部私有函数 需要注意的地方是匿名主函数结束的地方的 ()，如果没有这个 () 就不能产生单件，因为匿名函数只能返回了唯一的对象，而且不能被其他地方调用，这个就是利用闭包产生单件的方法","link":"/2017/05/13/JavaScript/17/"},{"title":"原型和闭包","text":"最近又复习了一次 深入理解 JavaScript 原型和闭包 算是一个小小的总结吧 对象 - 若干属性的集合1234567891011121314// 简单的值类型，不是对象console.log(typeof x); // undefinedconsole.log(typeof 10); // numberconsole.log(typeof 'abc'); // stringconsole.log(typeof true); // boolean// 函数其实也是对象，也是可以做为参数传递的console.log(typeof function () { }); //function// 引用类型console.log(typeof [1, 'a', true]); //objectconsole.log(typeof { a: 10, b: 20 }); //objectconsole.log(typeof null); //objectconsole.log(typeof new Number(10)); //object 判断一个变量是不是对象，值类型的类型判断用 typeof，引用类型的类型判断用 instanceof 函数和对象的关系对象是可以通过函数来创建 1234567891011//var obj = { a: 10, b: 20 };//var arr = [5, 'x', true];var obj = new Object();obj.a = 10;obj.b = 20;var arr = new Array();arr[0] = 5;arr[1] = 'x';arr[2] = true; prototype每个函数都有一个属性叫做 prorotype，这个 prototype 的属性值是一个对象（属性的集合），默认的还有一个叫做 constructor 的属性，指向这个函数本身 例如 Object 的 prototype 上就挂载了一系列方法 我们也可以在自己自定义的方法的 prototype 中新增自己的属性 123456789function Foo () {...}Foo.prototype.name = ..Foo.prototype.getName = function () {..}var bar = new Foo();console.log(bar.name);console.log(bar.getName()); Foo 是一个函数，bar 对象是通过 Foo 函数 new 出来的，这样一来，bar 对象就可以调用 Foo.prototype 上的属性和方法 因为每个对象都有一个隐藏的属性 __proto__（一般称为 隐式原型），这个属性引用了创建这个对象的函数的 prototype，即 1bar.__proto__ === Foo.prototype // true instanceof对于值类型可以使用 typeof 判断，但是对于引用类型的时候，返回值只有 object/function，这个时候就可以使用 instanceof 比如判断 f1 instanceof Object，按照上图来说就是： 沿着 f1 的 __proto__ 这条线来找，同时沿着 Object 的 prototype 这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回 true，如果找到终点还未重合，则返回 false 这也解释了为何一下结果均返回 true 12345Object instanceof Function; // trueFunction instanceof Object; // trueFunction instanceof Function; // true 完整原型图如下所示： instanceof 表示的就是一种继承关系，或者原型链的结构 一个小小的练习题： 12345678910111213141516171819202122232425262728var a = { x: 1, y: { z: 2 }};var b = {};b.__proto__ = a;// a 和 b 都是对象（通过new Object() 生成，这里是简写）// 所以 a.__proto__ === b.__proto__ 是相等的（都是指向 Object.prototype）// 所以在查找 b.x 的时候先去 b 查看，发现是空对象（{}），原则上应该去 Object.prototype 上查找 // 但是现在把 b.__proto__ 从新指回了 a，所以应该就去 a 上查找// 所以 b.x 为 1，b.y 为 { z: 2 }console.log(a.x);console.log(b.x);// 然后把 b.x 重新赋值为 22// 因为是基本类型，所以 a.x 是不变的b.x = 22;console.log(a.x);console.log(b.x);// 这个同上面那个类似// 但是由于是引用类型，所以 a.y 和 b.y 指向的都是同一个地址// 其中一个变化的话自然会引起另外一个变化b.y.z = 33;console.log(a.y.z);console.log(b.y.z); 继承访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着 __proto__ 这条链往上找，这就是原型链 可以利用 hasOwnProperty 来区分一个属性是不是从原型上继承得到的（特别是在 for..in 循环中） hasOwnProperty 这个方法存在与 Object.prototype 上，对象的原型链是沿着 __proto__ 这条线走的，因此在查找对象的 hasOwnProperty 属性的时候，就会顺着原型链一直查找到 Object.prototype 由于所有的对象的原型链都会找到 Object.prototype，因此所有的对象都会有 Object.prototype 的方法，这就是所谓的继承 同样的，每个函数都有 call，apply 方法，这也是”继承”而来的，函数由 Function 函数构建，因此继承的 Function.prototype 中的方法 至于为什么 Function.prototype 上也会有 hasOwnProperty 方法，这是因为 Function.prototype 同样继承自 Object.prorotype 执行上下文环境简单来说，函数每被调用一次，都会产生一个新的执行上下文环境，因为不同的调用可能就会有不同的参数 需要注意一点：函数体内部自由变量在函数在定义的时候（不是调用的时候）就已经确定了 JavaScript 在执行一个代码段之前，都会进行这些 “准备工作” 来生成执行上下文，其实分三种情况 – 全局代码，函数体，eval 代码（不推荐这个） 全局执行上下文环境在产生执行全局上下文时，浏览器通常会做以下三个准备工作： 提取 var 声明的变量，并赋值（默认）为 undefined（变量提升） 提取声明式函数（function foo () {..}） 给 this 赋值（指向 window 或当前对象） 函数体上下文环境（也就是所谓的局部）会在以上三个的基础上增加以下三条： 给函数参数赋值 给 arguments 赋值（是一个实参副本，与实参保持一致） 自由变量的取值作用域，查找并赋值 所以总结来说就是，在执行代码之前，把将要用到的所有的变量都事先拿出来，有的直接赋值了，有的先用 undefined 占个空 而在执行 JavaScript 代码时，会有数不清的函数调用次数，会产生许多个上下文环境，这么多上下文环境该如何管理，以及如何销毁而释放内存就主要依靠下面的执行上下文栈 执行上下文栈执行全局代码时，会产生一个执行上下文环境，每次调用函数都又会产生执行上下文环境，当函数调用完成时，这个上下文环境以及其中的数据都会被消除，再重新回到全局上下文环境 处于活动状态的执行上下文环境只有一个 其实这是一个 压栈 ==&gt; 出栈 的过程，如下图所示： 压栈：函数未调用时只有全局上下文在执行，每次调用函数时会产生局部上下文，这就是压栈，也就是进栈 出栈：函数调用完成后，就会出栈，会销毁本次调用的局部上下文环境 注意：若函数里面是多层函数嵌套，也会出现多层执行上下文的嵌套（压栈和出栈也是嵌套产生的） 上面这种只是较为理想的情况，有一种情况无法做到这样干净利落的说销毁就销毁，这个就是 – 闭包 thisthis 是 JavaScript 语言的一个关键字它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用 随着函数使用场合的不同，this 的值会发生变化，但是有一个总的原则，那就是 this 指的是，调用函数的那个对象 JavaScript 中函数的调用有以下几种方式： 为对象方法调用 作为函数调用 作为构造函数调用 使用 apply 或 call 调用 一般比较常见的用法我们经常会遇到，下面来看一个特殊的案例，在 jQuery 中，有下面这样一段代码： 12345678jQuery.extend = jQuery.fn.extend = function () { // ... if (i === length) { target = this; i--; } // ...} jQuery.extend 和 jQuery.fn.extend 都指向了同一个函数，但是当执行时，函数中的 this 是不一样的 执行 jQuery.extend( .. ) 时，this 指向 jQuery 执行 jQuery.fn.extend( .. ) 时，this 指向 jQuery.fn 这样就巧妙的将一段代码同时共享给两个功能使用，更加符合设计原则 作用域JavaScript 中没有块级作用域（ES6 之前），除了全局作用域以外，只有函数可以创建作用域 我们在声明变量时，全局代码要在代码前端声明，函数中要在函数体一开始就声明好（先声明，在使用），除了这两个地方，其他地方都不要出现变量声明 作用域有上下级的关系，上下级关系的确定就看函数是在哪个作用域下创建的 作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突 除了全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了，而不是在函数调用时确定 抽象来看待的话，作用域只是一个 “地盘”，其中没有变量，要通过作用域对应的执行上下文环境来获取变量的值 同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值，所以，作用域中变量的值是在执行过程中产生的确定的，而作用域却是在函数创建时就确定了 所以，如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中寻找变量的值","link":"/2017/05/14/JavaScript/18/"},{"title":"JSON.parse() && JSON.stringify()","text":"对于这两个方法，以前只是使用，但是并没有去深入研究，只是简单的知道一个是将对象或者数组转为 JSON 字符串，另外一个就是反过来转换 JSON 的 但是深入了解以后却发现东西还是有点多的，特别是还支持第二个参数配置，于是便查阅资料深入了解一下，在这里记录记录 JSON.parse()JSON.parse() 用来解析 JSON 字符串，构造由字符串描述的 JavaScript 值或对象，提供可选的 reviver 函数用以在返回之前对所得到的对象执行变换 1234var json = '{\"result\":true, \"count\":42}';// {result: true, count: 42}JSON.parse(json); 语法如下 1JSON.parse(text[, reviver]) 如果被解析的 JSON 字符串是非法的（text），则会抛出一个语法错误异常（需要注意，JSON.parse() 不允许最后一个键值对后面存在逗号） 如果指定了 reviver 函数，则解析出的 JavaScript 值（解析值）会经过一次转换后才将被最终返回（返回值） 意思就是，解析值本身以及它所包含的所有属性，会按照一定的顺序（从最最里层的属性开始，一级级往外，最终到达顶层，也就是解析值本身）分别的去调用 reviver 函数 在调用过程中，当前属性所属的对象会作为 this 值，当前属性名和属性值会分别作为第一个和第二个参数传入 reviver 中 如果 reviver 返回 undefined，则当前属性会从所属对象中删除，如果返回了其他值，则返回的值会成为当前属性新的属性值 需要注意的是 当遍历到最顶层的值（解析值）时，传入 reviver 函数的参数会是空字符串 &quot;&quot;（因为此时已经没有真正的属性）和当前的解析值（有可能已经被修改过了） 当前的 this 值会是 {&quot;&quot;: 修改过的解析值}，在编写 reviver 函数时，要注意到这个特例（这个函数的遍历顺序依照：从最内层开始，按照层级顺序，依次向外遍历） 下面是两个示例 12345678910111213141516171819202122232425// 如果到了最顶层，则直接返回属性值// 否则将属性值变为原来的 2 倍JSON.parse('{\"p\": 5}', function (k, v) { if(k === '') return v; return v * 2; }); // { p: 10 }JSON.parse(' {\"1\": 1, \"2\": 2, \"3\": {\"4\": 4, \"5\": {\"6\": 6}}} ', function (k, v) { // 输出当前的属性名，从而得知遍历顺序是从内向外的 console.log(k); // 最后一个属性名会是个空字符串 // 返回原始属性值，相当于没有传递 reviver 参数 return v; });// 1// 2// 4// 6// 5// 3 // \"\" JSON.stringify()方法是将一个 JavaScript 值（对象或者数组）转换为一个 JSON 字符串，如果指定了 replacer 是一个函数，则可以替换值，或者如果指定了 replacer 是一个数组，可选的仅包括指定的属性 语法如下 1JSON.stringify(value[, replacer [, space]]) 关于可选参数 replacer 如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理 如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中 如果该参数为 null 或者未提供，则对象所有的属性都会被序列化 关于可选参数 space 指定缩进用的空白字符串，用于美化输出（pretty-print） 如果参数是个数字，它代表有多少的空格（上限为 10），该值若小于 1，则意味着没有空格 如果该参数为字符串（字符串的前十个字母），该字符串将被作为空格 如果该参数没有提供（或者为 null）将没有空格 关于序列化，有下面五点注意事项： 非数组对象的属性不能保证以特定的顺序出现在序列化后的字符串中 布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值 undefined、任意的函数以及 symbol 值，如果出现在非数组对象的属性值中时，在序列化过程中会被忽略，如果出现在数组中时将被转换成 null 对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误 所有以 symbol 为属性键的属性都会被完全忽略掉，即便 replacer 参数中强制指定包含了它们 不可枚举的属性会被忽略 123456789101112131415161718192021222324252627282930313233343536373839404142434445JSON.stringify({}); // '{}'JSON.stringify(true); // 'true'JSON.stringify(\"foo\"); // '\"foo\"'JSON.stringify([1, \"false\", false]); // '[1, \"false\", false]'JSON.stringify({ x: 5 }); // '{\"x\": 5}'JSON.stringify({ x: 5, y: 6 });// \"{\"x\": 5, \"y\": 6}\"JSON.stringify([new Number(1), new String(\"false\"), new Boolean(false)]);// '[1, \"false\", false]'JSON.stringify({ x: undefined, y: Object, z: Symbol(\"\") });// '{}'JSON.stringify([undefined, Object, Symbol(\"\")]);// '[null, null, null]' JSON.stringify({ [Symbol(\"foo\")]: \"foo\" });// '{}'JSON.stringify({ [Symbol.for(\"foo\")]: \"foo\" }, [Symbol.for(\"foo\")]);// '{}'JSON.stringify( { [Symbol.for(\"foo\")]: \"foo\" }, function (k, v) { if (typeof k === \"symbol\") { return \"a symbol\"; } });// undefined JSON.stringify( Object.create( null, { x: { value: 'x', enumerable: false }, y: { value: 'y', enumerable: true } } ));// 不可枚举的属性默认会被忽略// \"{\"y\": \"y\"}\" JSON.stringify() 的 replacer 参数replacer 参数可以是一个函数或者一个数组，作为函数，它有两个参数，键值都会被序列化 如果返回一个 Number，转换成相应的字符串被添加入 JSON 字符串 如果返回一个 String，该字符串作为属性值被添加入 JSON 如果返回一个 Boolean，&quot;true&quot; 或者 &quot;false&quot; 被作为属性值被添加入 JSON 字符串 如果返回任何其他对象，该对象递归地序列化成 JSON 字符串，对每个属性调用 replacer 方法（除非该对象是一个函数，这种情况将不会被序列化成 JSON 字符串） 如果返回 undefined，该属性值不会在 JSON 字符串中输出 需要注意的是，不能用 replacer 方法，从数组中移除值（values），如若返回 undefined 或者一个函数，将会被 null 取代 123456789var foo = { foundation: \"Mozilla\", model: \"box\", week: 45, transport: \"car\", month: 7 };var jsonString = JSON.stringify(foo, (key, value) =&gt; { if (typeof value === \"string\") { return undefined; } return value;});console.log(jsonString); // {\"week\": 45, \"month\": 7} 如果 replacer 是一个数组，数组的值代表将被序列化成 JSON 字符串的属性名（即只有包含在这个数组中的属性名才会被序列化） 12var foo = { foundation: \"Mozilla\", model: \"box\", week: 45, transport: \"car\", month: 7 };console.log(JSON.stringify(foo, ['week', 'month'])); // 只保留 week 和 month 属性值 关于 toJSON 方法需要注意的是，如果一个被序列化的对象拥有 toJSON 方法，那么该 toJSON 方法就会覆盖该对象默认的序列化行为（即为调用 toJSON 方法后的返回值会被序列化） 123456789var obj = { foo: 'foo', toJSON: function () { return 'bar'; }};JSON.stringify(obj); // '\"bar\"'JSON.stringify({ x: obj }); // '{\"x\":\"bar\"}' 使用 JSON.stringify 来格式化对象在平常的开发过程中，经常会遇到一些十分复杂的对象，往往是对象当中嵌套对象，看上去十分的不直观 我们可以利用 replacer 和 space 参数来对其进行格式化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 因为函数如果出现在非数组对象的属性值中时，在序列化过程中会被忽略，所以需要特殊处理var foo = function (key, value) { if (typeof (value) === 'function' || typeof(value) === 'symbol') { return value.toString() } else if (typeof (value) === 'undefined') { return 'undefined' } else { return value; }}var json = { bar: 'aaa', foo: { age: Symbol('23') }, baz: undefined, o: { name: 'zhangsan', userInfo: { sex: 0, getSex: function () { return this.sex; }, address: null } }};JSON.stringify(json, foo, 2);// {// \"bar\": \"aaa\",// \"foo\": {// \"age\": \"Symbol(23)\"// },// \"baz\": \"undefined\",// \"o\": {// \"name\": \"zhangsan\",// \"userInfo\": {// \"sex\": 0,// \"getSex\": \"function () { return this.sex; }\",// \"address\": null// }// }// }","link":"/2017/07/06/JavaScript/23/"},{"title":"JavaScript 中的函数","text":"一般来说，一个函数是可以通过外部代码调用的一个子程序（或在递归的情况下由内部函数调用） 像程序本身一样，一个函数由称为函数体的一系列语句组成，值可以传递给一个函数，函数将返回一个值 在 JavaScript 中，函数是头等（first-class）对象，因为它们可以像任何其他对象一样具有属性和方法 它们与其他对象的区别在于函数可以被调用，简而言之，它们是 Function 对象 下面是一个简单的函数定义方式 123456// 第一种定义方式function fn1() { alert('fn1');}typeof fn1; // function 在 JavaScript 中函数就是对象，只不过函数是一个非常特殊的对象，是一个 Function 类的实例，其实在内存中存储的操作是通过一个键值对来存储的（如下图所示） 函数的名称仅仅是一个键，它的值是指向了内存中的一个对象，这个对象就是 Function 的一个对象 由于函数是一个对象，所以可以通过如下方式定义 以下是通过函数的拷贝来完成赋值的，两个引用并没有指向同一个对象 123456789101112var fn2 = fn1;// fn1 两个的值是虽然相等，但是指向不同的空间fn2();// fn1 的值改变了以后，不会影响 fn2 的值fn1 = function () { alert('fnn1');}fn2(); // 这里修改了 fn1 的内容，fn2 未做修改，故还是 fn1fn1(); // fnn1 函数虽然是一个对象，但是却和对象有一些区别，对象是通过引用的指向完成对象的赋值的，而函数确实通过对象的拷贝来完成的，所以 fn1 虽然改变了，但是并不会影响 fn2 对于对象而言，是通过引用的指向来完成赋值的，此时修改 o1 或者 o2 会将两个值都完成修改 123456// o1 和 o2 其实指向了同一块空间，当修改 o2 的值的时候，o1 的也会改变var o1 = new Object();var o2 = o1;o2.name = 'abc';alert(o1.name); // abc 函数对象简单来说，对象就是键值对的集合并拥有一个连到原型对象的隐藏连接 对象字面量产生的对象连接到 Object.prototype， 函数对象连接到 Function.prototype（该原型对象本身连接到 Object.prototype） 1Function.prototype.__proto__ === Object.prototype // true 每个函数在创建的时候会有两个附加属性：函数上下文 和 实现函数行为的代码 每个函数对象在创建的时候也会带有一个 constructor 属性，它的值是一个拥有 constructor 属性且值即为该函数的对象 函数的与众不同之处在于 它们可以被调用 函数调用调用一个函数将暂停当前函数的执行，传递控制权和参数给新函数，除了声明的时候定义的形式参数，每个函数接收两个附加的参数 this 和 arguments 参数 this 的值取决于调用的模式，在 JavaScript 中一共有四种调用模式： 方法调用模式 函数调用模式 构造调用模式 apply/call 调用模式 当实际参数（arguments）的个数与形式参数（parameters）的个数不匹配的时候不会导致程序错误 如果实际参数过多，超出的参数值将会被忽略 如果实际参数过少，缺失的部分将会被替换为 undefined 对参数的值不会进行类型检查，即 任何类型的值都可以被传递给参数 函数没有重载12345678910function sum(num1, num2) { return num1 + num2;}function sum(num1) { return num1 + 100;}sum(10); // 110sum(10, 20); // 110 换一种写法，可以看的更清楚些 12345678910var sum = function (num1, num2) { return num1 + num2;}var sum = function (num1) { return num1 + 100;}sum(10); // 110sum(10, 20); // 110 此时 sum 所指向的空间已经从有两个参数的函数变化到只有 num1 的函数中 在调用的时候就只会调用 num1 的函数 特别指出：函数的参数和调用没用关系，如果函数只有一个参数，但是却传入了两个参数，仅仅只会匹配一个 函数是对象，不存在重载，只会存在覆盖，后面定义的会覆盖前面所定义的 123456789101112/** * 如下定义方式等于定义了一个 * function fn(num1, num2) { * alert(num1 + num2); * } * * 所以通过以下的例子，充分说明了函数就是一个对象 */var fn = new Function('num1', 'num2', 'alert(num1 + num2)');fn(12, 22); // 34 函数的值传递由于函数是对象，所以可以直接把函数通过参数传递进来 123456789101112131415161718function callFun(fun, arg) { // 第一个参数就是函数对象 return fun(arg);}function sum(num) { return num + 100;}function say(str) { alert(str);}// 调用了 say 函数callFun(say, 'abc');// 调用了 sum 函数callFun(sum, 20); 作为返回值来传递（也就是所谓的闭包） 1234567891011121314function fn1(arg) { var rel = function (num) { return arg + num; } return rel;}// 此时 f 是一个函数对象，可以完成调用// 在外部调用的时候，更改函数内部的值var f = fn1(20);f(20); //40f(11); //31 实例下面是一些实际操作的例子 实例一12345678910function sortByNum(a, b) { return a - b;}var arr = [1, 2, 11, 33, 12, 190];// 对于 JavaScript 而言，默认是按照字符串来进行排序的arr.sort(); // 1, 11, 12, 190, 2, 33arr.sort(sortByNum); // 1, 2, 11, 12, 33, 190 实例二123456789101112131415161718192021222324252627function Person(name, age) { this.name = name; this.age = age;}var p1 = new Person('zhangsan', 12);var p2 = new Person('lisi', 15);var p3 = new Person('wangwu', 18);var ps = [p1, p2, p3];function sortByName(obj1, obj2) { if (obj1.name &gt; obj2.name) { return 1; } else if (obj1.name == obj2.name) { return 0; } else { return -1; }}function sortByAge(obj1, obj2) { return obj1.age - obj2.age;}ps.sort(sortByName);ps.sort(sortByAge); 使用如上的方式来处理排序，带来的问题是需要为每一个属性都设置一个函数，显得不是很灵活，所以可以通过函数的返回值来调用,实现函数排序功能 1234567891011121314function sortByProperty(propertyName) { var sortFun = function (obj1, obj2) { if (obj1[propertyName] &gt; obj2[propertyName]) { return 1; } else if (obj1[propertyName] == obj2[propertyName]) { return 0; } else { return -1; } }}ps.sort(sortByProperty('name'));ps.sort(sortByProperty('age')); 函数中的 arguments在函数对象中有一个属性叫做 arguments，通过这个属性可以获取相应的参数值，这个属性是一个类数组对象，其实就是传递进来的参数的一个集合 123456function say(num) { alert(num); // 1 alert(arguments.length); // 3}say(1, 2, 3); arguments.callee()在 arguments 这对象中有一个 callee 的方法，arguments.callee(arg) 可以实现反向的调用（已经不再推荐使用） 12345678910function factorial(num) { if (num &lt;= 1) { return 1; } else { // 此时和函数名耦合在一起 return num * factorial(num - 1); }}factorial(5); // 120 以上是一个求阶乘的函数，递归调用的函数名称和原有函数名耦合在一起，如果将这个函数名称更改以后，递归就会失效 12345678var fn = factorial;// 此时不会报错fn(5); // 120factorial = null;fn(5); // 报错 此时由于 fn 函数依然使用 factorial 这个名称来调用，但是 factorial 已经指向 null 了，所以会报错，如上情况就需要使用 arguments.callee 方法来调用 1234567891011function factorial(num) { if (num &lt;= 1) { return 1; } else { // 以下就实现了函数名的解耦，在 JavaScript 中通常都是使用这种方式来做递归 return num * arguments.callee(num - 1); }}// 120fn(5); 函数中的 this当需要创建一个函数对象的时候，设置函数对象的属性和方法需要通过 this 关键字来引用 但是特别注意 this 关键字在调用的时候会根据不同的调用对象而变得不同 123456789101112131415var color = 'red';function showColor() { alert(this.color);}function Circle(color) { this.color = color; this.showColor = showColor;}var c = new Circle('yellow');c.showColor(); // yellowshowColor(); // red 使用 c 来调用 showColor 方法，等于调用了 showColor 方法，此时的 this 是 c，所以是 yellow 直接调用 showColor，此时调用的对象等于是 window，showColor 的 this 就是 window，所以就会在 window 中寻找 color 返回值当一个函数被调用的时候，它从第一个语句开始执行，并在遇到关闭函数体的 } 时结束，从而是的函数把控制权交还给调用该函数的程序部分 return 语句可用来使函数提前返回，当 return 被执行的时候，函数立即返回而不再执行余下的语句 一个函数总是有一个返回值，如果没有指定返回值，则返回 unfefined 如果函数在前面加上 new 前缀的方式来调用，且返回值不是一个对象，则返回 this（该新对象） 简单的总结就是，如果一个构造函数不写 return 语句，则系统会自动帮你返回一个对象，但是如果写了 return 语句，则 如果 return 的是一个基本类型的值（比如 string，number），则会忽略这个 return，该返回什么还是返回什么，但是会阻止构造函数接下来的执行 如果 return 了一个引用类型，则原有的 return 会被覆盖","link":"/2017/10/08/JavaScript/26/"},{"title":"原型继承和类式继承","text":"在一些基于类的语言（比如 Java）当中，继承（inheritance/extends）提供了两个有用的服务，如果一个新的类与一个已存在的类大部分相似，那么你只需说明其不同点即可 JavaScript 是一门弱类型语言，从不需要类型转换，它可以模拟那些基于类的模式，同时它也支持其他更具表现力的模式 在基于类的语言中，对象是类的实例，并且类可以用另一个类继承，JavaScript 是一门基于原型的语言，这意味着对象直接从其他对象继承 在 JavaScript 当中比较常见的继承方法有类式继承和原型继承 类式继承（构造函数）JavaScript 在 ES5 当中其实是没有类的概念的，所谓的类也是模拟出来的，特别是当我们是用 new 关键字的时候，就使得类的概念就越像其他语言中的类了 类式继承是在函数对象内调用父类的构造函数，使得自身获得父类的方法和属性（call 和 apply 方法为类式继承提供了支持） 通过改变 this 的作用环境，使得子类本身具有父类的各种属性 1234567891011121314var father = function () { this.age = 20; this.say = function () { alert(this.name + this.age); }}var child = function () { this.name = 'zhangsan'; father.call(this);}var man = new child();man.say(); 原型继承我们先来看一张珍藏多年的图 原型继承有别于类继承，因为继承不在对象本身，而在对象的原型上（prototype） 每一个对象都有原型，在浏览器中它体现在一个隐藏的 __proto__ 属性上，在一些现代浏览器中你可以更改它们（不过不太建议这样操作） 比如在 zepto 中，就是通过添加 zepto 的 fn 对象到一个空的数组的 __proto__ 属性上去，从而使得该数组成为一个 zepto 对象并且拥有所有的方法 当一个对象需要调用某个方法时，它会去最近的原型上查找该方法，如果没有找到，它会再次往下继续查找 这样逐级查找，一直找到了要找的方法，这些查找的原型构成了该对象的原型链条（最后指向 Object.prototype.__proto__ 也就是 null），类似于下面这样 1234567891011function Foo() {}var f1 = new Foo()// f1 的 __proto__ 是指向 Foo.prototype 的f1.__proto__ === Foo.prototype// 而 Foo.prototype.__proto__ 又是指向 Object.prototypeFoo.prototype.__proto__ === Object.prototype// 而 Object.prototype.__proto__ 则是指向 null 的Object.prototype.__proto__ === null 下面我们再来看看原型继承的例子，如下 12345678var father = function () { }father.prototype.a = function () { }var child = function () { }child.prototype = new father();var man = new child();man.a(); 这里面比较重要的一句就是 1child.prototype = new father(); 可以发现，child 是通过中间层继承了 father 的原型上的东西的，但是这里有一个问题，为什么不直接使用 child.prototype = father.prototype 如果这样做 child 和 father 就没有区别了，通过上面的图可以发现，在 prototype 中有个 constructor 属性，是指向的是构造函数的 按照正常的情况我们要把 constructor 的值改回来指向 child 的构造函数，但如果直接把 father.prototype 赋值给 child.prototype 那么 constructor 应该指向谁呢？所以很显然只能通过中间层才能使得 child 和 father 保持为独立的对象 对比和原型对比起来，构造函数（类）式继承有什么不一样呢？首先，构造函数继承的方法都会存在父对象之中，每一次实例，都会将 funciton 保存在内存中，这样的做法毫无疑问会带来性能上的问题 其次类式继承是不可变的，在运行时，无法修改或者添加新的方法，这种方式是一种固步自封的死方法 而原型继承是可以通过改变原型链接而对子类进行修改的（重写方法即可） 另外就是类式继承不支持多重继承，而对于原型继承来说，可以使用类似 extend 等方法对对象进行扩展 组合模式另外的一种模式，是结合类继承和原型继承的各自优点来进行对父类的继承，用类式继承属性，而原型继承方法 这种模式避免了属性的公用，因为一般来说，每一个子类的属性都是私有的，而方法得到了统一 这种模式称为组合模式，也是继承类式常用到的一种方法 12345678910111213function father() { this.a = 'father'}father.prototype.b = function () { alert(this.a)}var child = function () { father.call(this)}child.prototype = new father(); new 关键字和 Obeject.create 方法引用 why-prototypal-inheritance-matters 这篇文章当中的一句话 new 关键字掩盖了 JavaScript 中真正的原型继承，使得它更像是基于类的继承 其实 new 关键字只是 Javascript 在为了获得流行度而加入与 Java 类似的语法时期留下来的一个残留物 作者推荐我们使用 Object.create() 方法创建或者实例化对象，我们可以对比一下使用类式继承和 Object.create 方法两者之间的区别 12345678910111213141516171819// 类式继承 var father = function () { this.a = 'father'}father.prototype.b = function () { alert(this.a) }var obj = new father();// 使用 Object.create()var father = { a: 'father', b: function () { alert(this.a); }}var obj = Object.create(father);console.dir(obj) 通过在控制台查看结果，我们可以发现 用 create 的方法构造出来的对象，a 属性和 b 方法都是在对象的原型上，也就是说我们可以通过更改 father 的属性动态改变 obj 的原型上的方法和属性 而上面通过 new 关键字用构造函数生成的实例，a 属性是无法改变的 下面我们就来看看 Object.create() 方法到底是个什么东西 这里只是简单介绍，更多详细的可以查看 Object.create( … ) 这篇文章 使用 Object.create(…)Object.create() 的作用是 创建一个空对象，并且这个对象的原型指向这个参数 典型的原型风格 12345678910111213141516171819202122232425262728function Foo(name) { this.name = name;}Foo.prototype.myName = function () { return this.name;};function Bar(name, label) { Foo.call(this, name); this.label = label;}// 我们创建了一个新的 Bar.prototype 对象并关联到 Foo.prototypeBar.prototype = Object.create(Foo.prototype);// 注意！现在没有 Bar.prototype.constructor 了// 如果你需要这个属性的话可能需要手动修复一下它// Bar.prototype.constructor = Bar;Bar.prototype.myLabel = function () { return this.label;};var a = new Bar('a', 'obj a');a.myName(); // 'a'a.myLabel(); // 'obj a' 关于 constructor代码如下： 12345var father = function () {}var child = function () { }child.prototype = new father();var man = new child(); 任何一个 prototype 对象都有一个 constructor 属性，指向它的构造函数，在执行比如下面步骤之前 1child.prototype = new father(); child.prototype.constructor 是指向 child 的，但是在执行以后，child.prototype.constructor 便指向了 father 更重要的是，每一个实例也有一个 constructor 属性，默认调用 prototype 对象的 constructor 属性 12345// 运行前man.constructor === child.prototype.constructor // true// 运行后man.constructor === father // true 这显然会导致继承链的紊乱（man 明明是用构造函数 child 生成的），因此我们必须手动纠正，将 child.prototype 对象的 constructor 值改为 child 这是很重要的一点，即如果替换了 prototype 对象 1o.prototype = {}; 那么，下一步必然是为新的 prototype 对象加上 constructor 属性，并将这个属性指回原来的构造函数 1o.prototype.constructor = o; 总结其实还有另外一种方式，用如上例子表示就是： 1child.prototype = father.prototype; 这样一来，在改变 child 的同时，也将同时改变 father 即 child.prototype 和 father.prototype 现在指向了同一个对象 那么任何对 child.prototype 的修改，都会反映到 father.prototype，强烈不推荐 而之前的： 1child.prototype = new father(); 说起来也会存在一些小问题，这样一来相当于直接运行了一遍 father（new 的作用），如果在 father 里做了一些其他事情（比如改变全局变量等）就会造成一些副作用 所以如果要实现继承的话，推荐使用 Object.create(...) 综合实例1234567891011121314151617181920212223242526// Person 类function Person (name, age) { this.name = name; this.age = age;}Person.prototype.hi = function () { console.log(this.name + this.age);}Person.prototype.LEGS_NUM = 2;Person.prototype.ARMS_NUM = 2;Person.prototype.walk = function () { console.log('walk');}// Student 类function Student (age, name, className) { Person.call(this, age, name); this.className = className;}// 使用 Object.create 来得到以 Person.prototype 做为原型的一个空对象Student.prototype = Object.create(Person.prototype);Student.prototype.constructor = Student; 添加自己新的方法来覆盖 Person 上的方法1234567891011121314151617Student.prototype.hi = function () { console.log(this.name + this.age + this.className);}// 添加自己新的方法Student.prototype.learn = function (subject) { console.log(this.name + subject + this.className);}// testvar man = new Student('name',20,'Class 3 , Grade 2');man.hi(); // name 20 Class 3 , Grade 2man.LEGS_NUM; // 2man.walk(); // walkman.learn('math') // man math Class 3 , Grade 2 原型链原理图 改变 prototype123456789101112131415Student.prototype.x = 101;man.x; // 101// 修改的 man 的原型的指向对象Student.prototype = {y: 2};// 当我们去修改 Student.prototype 的值的时候，不能修改已经实例化的一些对象，已经实例化的对象// 是指向当时的 Student.prototype，不会影响已经创建的实例man.y; // undefinedman.x; // 101var abc = new Student('aaa',3,'bbb');abc.x; // undefinedabc.y; // 2 所以，当我们动态的修改 prototype 属性的时候，是会影响所有已经创建和新创建的实例的 但是如果修改整个 prototype 赋值为新的对象的话，新的实例是不会修改的，但是会影响后续的实例 几种实现继承方式的优缺点123456789101112131415161718192021function Person () {}function Student () {}Student.prototype = Person.prototype; // 1 在改变 Student 的同时，也改变了 Person，不推荐Student.prototype = new Person(); // 2 也可以实现继承，但是 Student 只是一个类，还没有实例化，只是为了继承，而调用构造函数Student.prototype = Object.create(Person.prototype);// 3 相对来说比较妥当的，自己的修改不会影响到原型链，ES5 之后才实现// ES5之前的话，可以判断一下if (!Object.create) { Object.create = function (proto) { function F() {} F.prototype = proto; return new F; };} 调用子类方法 1234567891011121314151617181920function Person (name) { this.name = name;}function Student (name, className) { this.className = className; Person.call(this, name); }// testvar man = new Student('man','abc');man; // Student{className: 'abc', name: 'man'}// 若子类的方法覆盖了基类的方法Person.prototype.init = function () {};Student.prototype.init = function () { // do something... Person.prototype.init.apply(this, arguments);}","link":"/2018/01/10/JavaScript/28/"},{"title":"变量的赋值与深浅拷贝","text":"在 JavaScript 中，变量的赋值分为 「传值」 与 「传址」 给变量赋予基本数据类型的值，也就是「传值」，而给变量赋予引用数据类型的值，实际上是「传址」 基本数据类型变量的赋值、比较，只是值的赋值与比较，即栈内存中的数据的拷贝和比较 12345678910var num1 = 123;var num2 = 123;var num3 = num1;num1 === num2; // truenum1 === num3; // truenum1 = 456;num1 === num2; // falsenum1 === num3; // false 引用数据类型变量的赋值、比较，只是存于栈内存中的堆内存地址的拷贝、比较 12345678910var arr1 = [1, 2, 3];var arr2 = [1, 2, 3];var arr3 = arr1;arr1 === arr2; // falsearr1 === arr3; // truearr3 = [1, 2, 3];arr1 === arr3; // falsearr2 === arr3; // false 在 JavaScript 当中，拷贝分为浅拷贝和深拷贝，一般我们操作也只针对像 Object，Array 这样的复杂对象 简单来说，浅复制只复制一层对象的属性，而深复制则递归复制了所有层级 浅拷贝浅拷贝只会将对象的各个属性进行依次复制，并不会进行递归复制，也就是说只会赋值目标对象的第一层属性 对于目标对象第一层为基本类型的数据，就是直接赋值，即「传值」 而对于目标对象第一层为引用数据类型的数据，就是直接赋与内存中的堆内存地址，即「传址」 实现的方法有很多种，第一种比较简单的对象复制的方法，就是使用 JSON.stringify() 方法，如下 1var newObject = JSON.parse(JSON.stringify(oldObject)) 但是这种写法会存在一些问题，可能不是一种很好的方法，但能适用于部分场景，具体存在的问题可以参考 JSON.parse() &amp;&amp; JSON.stringify() 另外还可以使用 ES6 内置的 Object.assign(target, source1, source2, ...) 方法 第一个参数是目标参数，后面是需要合并的源对象可以有多个，后合并的属性（方法）会覆盖之前的同名属性（方法） 需要注意 Object.assign() 进行的拷贝是浅拷贝 1234567891011const obj1 = { a: { b: 1 } }const obj2 = Object.assign({}, obj1)obj2.a.b = 3obj2.aa = 'aa'console.log(obj1.a.b) // 3console.log(obj2.a.b) // 3console.log(obj1.aa) // undefinedconsole.log(obj2.aa) // aa 下面是一个比较通用的简单浅复制的实现 123456789101112var obj = { a: 1, arr: [2, 3] };var shallowObj = shallowCopy(obj);function shallowCopy(src) { var dst = {}; for (var prop in src) { if (src.hasOwnProperty(prop)) { dst[prop] = src[prop]; } } return dst;} 因为浅复制只会将对象的各个属性进行依次复制，并不会进行递归复制，而 JavaScript 存储对象都是存地址的 所以浅复制会导致 obj.arr 和 shallowObj.arr 指向同一块内存地址 所以 123shallowObj.arr[1] = 5;obj.arr[1] // = 5 深拷贝深拷贝不同于浅拷贝，它不只拷贝目标对象的第一层属性，而是递归拷贝目标对象的所有属性 一般来说，在 JavaScript 中考虑复合类型的深层复制的时候，往往就是指对于 Date，Object 和 Array 三个复合类型的处 一般简单的处理方式是建立一个新的空对象，然后递归遍历旧的的对象，直到发现基础类型的子节点才赋予到新对象对应的位置 不过这个方法存在一个问题，就是 JavaScript 中存在着神奇的原型机制，并且这个原型会在遍历的时候出现，然后需要考虑原型应不应该被赋予给新对象 一般在使用过程中，我们通常会使用 hasOwnProperty 方法来进行判断是否过滤掉那些继承自原型链上的属性 先来看看一个简单的实现 对于一个复杂的数组对象，要做到深度拷贝（采用递归的方式），在每次遍历之前创建一个新的对象或者数组，从而开辟一个新的存储地址，这样就切断了引用对象的指针联系 123456789101112function deepCopy(o) { // 根据传入的元素判断是数组还是对象 let c = o instanceof Array ? [] : {}; for (let i in o) { // 注意数组也是对象类型，如果遍历的元素是对象，进行深度拷贝 c[i] = typeof o[i] === 'object' ? deepCopy(o[i]) : o[i]; } return c;} 下面这个则是较为完善的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657function _isPlainObject(target) { return (typeof target === 'object' &amp;&amp; !!target &amp;&amp; !Array.isArray(target));}function shallowExtend() { var args = Array.prototype.slice.call(arguments); // 第一个参数作为 target var target = args[0]; var src; target = _isPlainObject(target) ? target : {}; // 从 1 开始循环 for (var i = 1; i &lt; args.length; i++) { src = args[i]; if (!_isPlainObject(src)) { continue; } for (var key in src) { if (src.hasOwnProperty(key)) { if (src[key] != undefined) { target[key] = src[key]; } } } } return target;}var target = { key: 'value', num: 1, bool: false, arr: [1, 2, 3], obj: { objKey: 'objValue' },};var result = shallowExtend({}, target, { key: 'changeValue', num: 2})// 对原引用类型数据做修改target.arr.push(4);console.log(target.arr === result.arr) // trueconsole.log(result)// {// key: 'changeValue',// num: 2,// bool: false,// arr: [1, 2, 3, 4],// obj: {// objKey: 'objValue'// },// } JavaScript 中的 mixinJavaScript 语言的设计是单一继承，即子类只能继承一个父类，不允许继承多个父类，毕竟一个对象只有一个原型，如果想实现多继承，可以使用 mixin mixin 简单通俗的讲就是把一个对象的方法和属性拷贝到另一个对象上（和继承有区别） mixin 就是一个正常的类，不仅定义了接口，还定义了接口的实现 子类通过在 this 对象上面绑定方法，达到多重继承的目的 一个简单的 mixin 123456789101112131415161718192021function extend(destClass, srcClass) { var destProto = destClass.prototype; var srcProto = srcClass.prototype; for (var method in srcProto) { if (!destProto[method]) { destProto[method] = srcProto[method]; } }}function Book() { }Book.prototype.printName = function () { console.log('I am a book, named hello');};function JS() { }extend(JS, Book);var js = new JS();js.printName() mixin 实现多继承 1234567891011121314151617181920212223242526function extend(destClass) { var classes = Array.prototype.slice.call(arguments, 1); for (var i = 0; i &lt; classes.length; i++) { var srcClass = classes[i]; var srcProto = srcClass.prototype; var destProto = destClass.prototype; for (var method in srcProto) { if (!destProto[method]) { destProto[method] = srcProto[method]; } } }}function Book() { }Book.prototype.getName = function () { };Book.prototype.setName = function () { };function Tech() { }Tech.prototype.showTech = function () { };function JS() { }extend(JS, Book, Tech);var js = new JS();console.log(js.__proto__); 很多前端库里都有 mixin 方法，比如 jQuery 的 extend，Underscore 中的 _.extend 下面我们就来看看 jQuery 中的 extend 的实现 jQuery 中的 extend 的实现先来看看怎么使用 1234$.extend( target [, object1 ] [, objectN ] )// 可以添加参数来指示是否深度合并$.extend( [deep ], target, object1 [, objectN ] ) 需要注意的是，第一个参数不支持传递 false 取值 释义 deep 可选，Boolean 类型，指示是否深度合并对象，默认为 false，如果该值为 true，且多个对象的某个同名属性也都是对象，则该对象的属性也将进行合并 target Object 类型，目标对象，其他对象的成员属性将被附加到该对象上 object1 可选，Object 类型，第一个被合并的对象 objectN 可选，Object 类型，第 N 个被合并的对象 简单来说，该方法的作用是用一个或多个其他对象来扩展一个对象，返回扩展后的对象 如果不指定 target，则是给 jQuery 命名空间本身进行扩展（有利于为 jQuery 增加新方法） 如果第一个参数设置为 true，则 jQuery 返回一个深层次的副本，递归的复制找到的任何对象，否则的话副本会与原对象共享结构 未定义的属性不会被复制，然而从对象的原型继承的属性将会被复制 源码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// 版本为 3.31jQuery.extend = jQuery.fn.extend = function () { var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false; // 如果第一个参数是布尔值，则为判断是否深拷贝的标志变量 if (typeof target === \"boolean\") { deep = target; // 跳过 deep 标志变量，留意上面 i 的初始值为1 target = arguments[i] || {}; // i 自增1 i++; } // 判断 target 是否为 object / array / function 以外的类型变量 if (typeof target !== \"object\" &amp;&amp; !isFunction(target)) { // 如果是其它类型变量，则强制重新赋值为新的空对象 target = {}; } // 如果只传入 1 个参数，或者是传入 2 个参数，第一个参数为 deep 变量，第二个为 target // 所以 length 的值可能为 1 或 2，但无论是 1 或 2，下段 for 循环只会运行一次 if (i === length) { // 将 jQuery 本身赋值给 target target = this; // i 自减1，可能的值为 0 或 1 i--; } for (; i &lt; length; i++) { // 以下拷贝操作，只针对非 null 或 undefined 的 arguments[i] 进行 if ((options = arguments[i]) != null) { // Extend the base object for (name in options) { src = target[name]; copy = options[name]; // 避免死循环的情况 if (target === copy) { continue; } // 如果是深拷贝，且 copy 值有效，且 copy 值为纯 object 或纯 array if (deep &amp;&amp; copy &amp;&amp; (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) { if (copyIsArray) { // 数组情况 copyIsArray = false; clone = src &amp;&amp; Array.isArray(src) ? src : []; } else { // 对象情况 clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : {}; } // 克隆 copy 对象到原对象并赋值回原属性，而不是重新赋值 // 递归调用 target[name] = jQuery.extend(deep, clone, copy); // Don't bring in undefined values } else if (copy !== undefined) { target[name] = copy; } } } } // Return the modified object return target;};","link":"/2018/01/14/JavaScript/29/"},{"title":"promise 和 setTimeout","text":"首先，我们要知道为什么要使用 promise 来看下面这个示例，读取一个文件，在控制台输出这个文件内容 12345var fs = require('fs');fs.readFile('1.txt', 'utf8', function (err, data) { console.log(data);}); 看起来很简单，再进一步: 读取两个文件，在控制台输出这两个文件内容 12345678var fs = require('fs');fs.readFile('1.txt', 'utf8', function (err, data) { console.log(data); fs.readFile('2.txt', 'utf8', function (err, data) { console.log(data); });}); 要是读取更多的文件呢? 12345678910var fs = require('fs');fs.readFile('1.txt', 'utf8', function (err, data) { fs.readFile('2.txt', 'utf8', function (err, data) { fs.readFile('3.txt', 'utf8', function (err, data) { fs.readFile('4.txt', 'utf8', function (err, data) { // ... }); }); });}); 这就是传说中的 callback hell 基本概念首先它是一个对象，它和 JavaScript 普通的对象没什么区别，同时，它也是一种规范，跟异步操作约定了统一的接口 表示一个异步操作的最终结果，以同步的方式来写代码，执行的操作是异步的，但又保证程序执行的顺序是同步的 只有三种状态，未完成，完成（fulfilled）和失败（rejected） 状态可以由未完成转换成完成，或者未完成转换成失败 状态转换只发生一次 状态转换完成后就是外部不可变的值，我们可以安全地把这个值传递给第三方，并确信它不会被有意无意的修改（特别是对于多方查看同一个 promise 状态转换的情况） promise 有一个 then 方法，then 方法可以接受 3 个函数作为参数 前两个函数对应 promise 的两种状态 fulfilled，rejected 的回调函数，第三个函数用于处理进度信息（.then() 总是返回一个新的 promise） 一个简单的读取文件示例： 12345678910111213141516171819var fs = require('fs');function readFile() { return new Promise(function (resolve, reject) { fs.readFile('1.txt', 'utf-8', function (err, data) { if (err) { reject(err) } else { resolve(data) } }) })}readFile().then(function (data) { console.log(data)}).catch(function (err) { console.log(err)}) setTimeout一般用于在指定的毫秒数后调用函数或计算表达式，语法为 1setTimeout(code, millisec) code 必需，要调用的函数后要执行的 JavaScript 代码串 millisec 必需，在执行代码前需等待的毫秒数 需要注意的是，setTimeout() 只执行 code 一次，如果要多次调用，请使用 setInterval() 或者让 code 自身再次调用 setTimeout() 下面来看看两者的区别 promise 和 setTimeout一个简单的示例 1234567891011setTimeout(function () { console.log(1)}, 0);new Promise(function (resolve) { resolve();}).then(function () { console.log(2);});// 2, 1 简单来说，promise 的任务会在当前事件循环末尾中执行，而 setTimeout 中的任务是在下一次事件循环执行 在 ES6 中，有一个新的概念建立在事件循环队列之上，叫做 任务队列 简单的理解就是，它是挂在事件循环队列的每个 tick 之后的一个队列，在事件循环的每个 tick 中，可能出现的异步动作不会导致一个完整的新事件添加到事件循环队列中 而会在当前 tick 的任务队列末尾添加一个项目（任务） 一个任务可能引起更多任务被添加到同一个队列末尾，所以，理论上说，任务循环可能无限循环（一个任务总是添加另一个任务，以此类推） 进而导致程序的无限循环，无法转移到下一个事件循环 tick，从概念上看，这和代码中的无限循环（类似 while(true)）的体验几乎是一样的 再来看一个实例 12345678910111213141516setTimeout(function () { console.log(1)}, 0);new Promise(function executor(resolve) { console.log(2); for (var i = 0; i &lt; 10000; i++) { i == 9999 &amp;&amp; resolve(); } console.log(3);}).then(function () { console.log(4);});console.log(5);// 结果为 2 3 5 4 1 首先是一个 setTimeout，于是会先设置一个定时，在定时结束后将传递这个函数放到任务队列里面，因此开始肯定不会输出 1 然后是一个 promise，里面的函数是会立即执行的，所以首先输出 2 和 3 这里需要注意的是，promise 的 then 应当会放到当前 tick 的最后，但是还是在当前 tick 中，所以会先输出 5 然后才会输出 4，最后轮到下一个 tick 之后才会输出 1 扩展：promise 的队列与 setTimeout 的队列有何关联？ 经典案例下面几个的输出值为多少 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// 一for (var i = 0; i &lt; 5; i++) { console.log(i);}// 二for (var i = 0; i &lt; 5; i++) { setTimeout(function () { console.log(i); }, 1000 * i);}// 三for (var i = 0; i &lt; 5; i++) { (function (i) { setTimeout(function () { console.log(i); }, 1000 * i); })(i)}// 四for (let i = 0; i &lt; 5; i++) { setTimeout(function () { console.log(i); }, 1000 * i);}// 五for (var i = 0; i &lt; 5; i++) { (function () { setTimeout(function () { console.log(i); }, 1000 * i); })(i)}// 六for (var i = 0; i &lt; 5; i++) { setTimeout((function (i) { console.log(i); })(i), i * 1000);}// 七setTimeout(function () { console.log(1)}, 0);new Promise(function executor(resolve) { console.log(2); for (var i = 0; i &lt; 10000; i++) { i == 9999 &amp;&amp; resolve(); } console.log(3);}).then(function () { console.log(4);});console.log(5);// 八setTimeout(function () { console.log(1)}, 0);new Promise(function executor(resolve) { console.log(2); for (var i = 0; i &lt; 10000; i++) { i == 9999 &amp;&amp; resolve(); } setTimeout(function() { console.log(6) }, 0) console.log(3);}).then(function () { console.log(4);});console.log(5); 最基本的，输出 0 - 4 setTimeout 会延迟执行，那么执行到 console.log 的时候，其实 i 已经变成 5 了，所以结果为 5 个 5（每一秒输出一个 5） 将 var 变成了 let，结果同样是 0 到 4，可以使用三和四两种方式 去掉 function() 中的 i，内部就没有对 i 保持引用，结果还是 5 个 5 如果修改成六这样，立即执行函数会立即执行，所以会立即输出 0 - 4 而不会延迟 最后两个有些复杂，但是原理是类似的 都被改写成了 promise，但是首先需要明确的是，promise 的任务会在当前事件循环末尾中执行，而 setTimeout 中的任务是在下一次事件循环执行 首先是一个 setTimeout，所以其中的任务是会在下一次事件循环中才会执行，因此开始肯定不会输出 1 然后是一个 promise，里面的函数是会立即执行的，所以首先输出 2 和 3 这里需要注意的是，promise 的 then 应当会放到当前 tick 的最后，但是还是在当前 tick 中（而不是下一次事件循环），所以会先输出 5 然后才会输出 4，最后轮到下一个 tick 才会输出 1 所以结果为 2 3 5 4 1 至于最后一个，和第七个是一样的，结果为 2 3 5 4 1 6 Promises/A+ 规范promise 代表一个异步操作的最终结果，主要通过 promise 的 then 方法订阅其最终结果的处理回调函数，和订阅因某原因无法成功获取最终结果的处理回调函数 更对详细见：Promises/A+ A 与 A+ 的不同点 A+ 规范通过术语 thenable 来区分 promise 对象 A+ 定义 onFulfilled/onRejectd 必须是作为函数来调用，而且调用过程必须是异步的 A+ 严格定义了 then 方法链式调用时，onFulfilled/onRejectd 的调用顺序 promise 当中的 finally今天看到了一个问题，说是怎么让一个函数无论 promise 对象成功和失败都能被调用？在这种情况下，就要用到 finally() 这个方法了 finally() 方法返回一个 Promise，在 promise 执行结束时，无论结果是 fulfilled 或者是 rejected，在执行 then() 和 catch() 后，都会执行 finally 指定的回调函数 这为指定执行完 promise 后，无论结果是 fulfilled 还是 rejected 都需要执行的代码提供了一种方式，避免同样的语句需要在 then() 和 catch() 中各写一次的情况 123456789101112131415Promise.resolve('success').then(result =&gt; { console.log('then: ', result) return Promise.resolve(result);}).catch(err =&gt; { console.error('catch: ', err); return Promise.reject(err);}).finally(result =&gt; { console.info('finally: ', result);})// then: success// finally: undefined// Promise {&lt;resolved&gt;: 'success'}","link":"/2018/03/19/JavaScript/31/"},{"title":"JavaScript 中的类型判断","text":"JavaScript 由于各种各样的原因，在判断一个变量的数据类型方面一直存在着一些问题，其中最典型的问题恐怕就是 typeof null 会返回 object 因此在这里简单的总结一下判断数据类型时常见的陷阱，以及正确的处理姿势 原始值在 JavaScript 中有 5 种原始类型：字符串，数字，布尔值，null 和 undefined，如果你希望检测一个值是否为原始类型，最佳选择是使用 typeof 运算符 对于数字类型的值，typeof 会返回 number（NaN 也是一个数字类型，因为它在 JavaScript 中代表的是特殊非数字值） 对于字符串类型的值，typeof 会返回 string 对于布尔类型的值，typeof 会返回 boolean 对于函数类型而言，typeof 返回 function 如果运算数没有定义（不存在或未赋值），将会返回 undefined typeof 运算符的独特之处在于，将其用于一个未声明的变量也不会报错，未定义的变量和值为 undefined 的变量通过 typeof 都将返回 'undefined' 最后一个原始值 null，一般不用于检测语句，但有一个例外，如果所期望的值真的是 null，则可以直接和 null 进行比较 这时应当使用 '===' 或者 '!==' 来和 null 进行比较 12345var element = document.getElementById('myDiv');if (element !== null) { element.classList.add('found');} 如果 DOM 元素不存在，则通过 document.getElementById() 得到的值为 null，这个方法要么返回一个节点，要么返回 null 由于这时 null 是可预见的一种输出，则可以使用 !== 来检测返回结果 这里还有一个特殊的值需要单独处理一下，那就是 NaN，如果使用 typeof 的话，返回的结果将是 number 1typeof NaN // number 也许你会想到 isNaN 这个方法，如下 12345isNaN(NaN) // true 不能转换isNaN('123') // false 可以转换isNaN('abc') // true 不能转换isNaN('123ab') // true 不能转换isNaN('123.45abc') // true 不能转换 可以看出，isNaN() 没有办法判断某个值本身是否为 NaN，如果想判断某个值是否为 NaN，可以采用 NaN 不等于自身这一特性来判断 123function valueIsNaN(value){ return value !== value} 引用值引用值也称对象（object），在 JavaScript 中除了原始值之外的值都是引用，有这几种内置的引用的类型：Object，Array，Error，Date typeof 运算符在判断这些引用类型的时候就显得力不从心，因为所有的对象都会返回 'object' 1234567console.log(typeof {}); // 'object'console.log(typeof []); // 'object'console.log(typeof new Date()); // 'object'console.log(typeof new RegExp()); // 'object' typeof 另外一种不推荐的用法是检测 null 的类型的时候，将会返回 'object' 1console.log(typeof null); // 'object' 所以，在检测某个引用值的类型的最好的方法是使用 instanceof 运算符： 12345678910111213141516// 检测日期if (value instanceof Date) { console.log(value.getFullYear());} // 检测正则表达式if (value instanceof RegExp) { if (value.test(anotherValue)) { console.log('Matches'); }} // 检测 Errorif (value instanceof Error) { throw value;} instanceof 的一个有意思的特征是它不仅检测构造这个对象的构造器，还检测原型链，原型链包含了很多信息，包括定义对象所采用的继承模式 比如，默认情况下，每个对象都继承自 Object，因此每个对象的 value instanceof Object 都会返回 true 1234var now = new Date();console.log(now instanceof Date); // trueconsole.log(now instanceof Object); // true 正因为这个原因，使用 value instanceof Object 来判断对象是否属于某个特定类型的做法并非最佳 instanceof 运算符也可以检测自定义的类型 12345678function Person(name) { this.name = name;}var me = new Person('zhangsan');console.log(me instanceof Person); // trueconsole.log(me instanceof Object); // true 变量 me 是 Person 的实例，因此 me instanceof Person 返回的是 true，之前也提到过，所有对象都被认为是 Object 的实例，故也返回 true 在 JavaScript 中检测自定义类型的时候，最好的做法就是使用 instanceof 运算符，这也是唯一的方法，但是也有例外 假设在一 frameA 中的一个对象被传入到了 frameB 中，两个 frame 中都定义了构造函数 Person，如果来自 A 的对象是 A 的 Person 的实例，则如下规则成立 12345// trueframeAPersonInstance instanceof frameAPersonInstance// falseframeAPersonInstance instanceof frameBPersonInstance 因为每个 frame 内都有用 Person 的一份 copy，它被认为是该 frame 中的 Person 拷贝的实例，尽管两个定义可能完全不一样 这个问题不仅出现在自定义类型身上，其他两个非常重要的内置类型也有这个问题：函数和数组，对于这两个类型来说，一般不使用 instanceof 另外还有有个比较取巧的方式，如下 12345Object.prototype.toString.call({}) // '[object Object]'Object.prototype.toString.call([]) // '[object Array]'Object.prototype.toString.call(null) // '[object Null]'Object.prototype.toString.call({ a: '123' }) // '[object Object]'Object.prototype.toString.call(/\\s/g) // '[object RegExp]' 空对象检测一般有下面这几种方式 但是有一点需要注意，for...in，JSON.stringify()，Object.keys()，isEmptyObject() 无法检测非枚举属性 for…in返回所有可枚举属性，包括原型中的属性，不含 Symbol 属性 最常见的思路，for...in 遍历属性，为真则为非空数组，否则为空数组 1234567// 如果不为空，则会执行到这一步，返回 truefor (var i in obj) { return true}// 如果为空，返回 falsereturn false 另外有一个可以混淆的 for...of 方法，不过需要注意的是，对象没有部署可迭代接口，所以不适用 JSON.stringify()通过 JSON 自带的 stringify() 方法来判断 JSON.stringify() 方法用于将 JavaScript 值转换为 JSON 字符串 这里需要注意一点：undefined、任意的函数以及 symbol 值，如果出现在非数组对象的属性值中时，在序列化过程中会被忽略，如果出现在数组中时将被转换成 null 即 1JSON.stringify({a: undefined}); // { } 所以一般可以直接与 {} 来进行比较 1234567if (JSON.stringify(data) === '{}') { // 如果为空，返回 false return false}// 如果不为空，则会执行到这一步，返回 truereturn true 这里需要注意为什么不用 toString()，因为它返回的不是我们需要的 12var a = {}a.toString() // \"[object Object]\" Object.keys()ES6 新增的 Object.keys() 方法会返回所有可枚举属性，不包括原型中属性，不含 Symbol 属性 如果我们的对象为空，他会返回一个空数组，如下 12var a = {}Object.keys(a) // [] 我们可以依靠 Object.keys() 这个方法通过判断它的长度来知道它是否为空 1234567if (Object.keys(object).length === 0) { // 如果为空，返回 false return false}// 如果不为空，则会执行到这一步，返回 truereturn true isEmptyObject()jQuery 当中提供了 isEmptyObject() 方法用来判断空对象 但是其本质也是通过 for...in 循环来进行判断的，源码如下 1234567isEmptyObject: function(obj) { var name; for (name in obj) { return false; } return true;} 下面是一些使用示例 123456789101112131415161718192021$.isEmptyObject({ }) // true$.isEmptyObject(new Object()) // true$.isEmptyObject([0]) // false$.isEmptyObject({ name: 'zhangsan' }) // false$.isEmptyObject({ sayHi: function () { } }) // false// 自定义的原型对象上的属性也是可枚举的function Foo() { }Foo.prototype.word = 'hello';$.isEmptyObject(User()) // false// 尽管在没有为空数组、Function、Number 等内置对象添加自定义属性的情况下，它们也是不可枚举的，但是不推荐这么做// 因为 isEmptyObject() 的参数应该始终是一个纯粹的 Object，比如如下示例，数组中没有元素，也无法通过 for...in 迭代出属性$.isEmptyObject([]) // true// Function、Number、String 等内置对象也无法通过 for...in 迭代出属性$.isEmptyObject(function () { alert('xxx') }) // false 这里有个需要注意的地方，上面这几个方法均不能检测出非枚举属性，即严格意义上的不完美方法，比如如下示例 12345678910111213141516171819var obj = {}Object.defineProperty(obj, 'key', { enumerable: false, configurable: false, writable: false, value: '123'});for (var i in obj) { console.log(i)}JSON.stringify(obj) === '{}' // trueObject.keys(obj) // []$.isEmptyObject(obj) // true Object.getOwnPropertyNames()该方法会返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括 Symbol 值作为名称的属性）组成的数组 需要注意的是，该方法不支持 IE8 及以下，并且在 ES5 版本当中，如果参数不是一个原始对象类型会抛出一个错误 123456789// 判断空对象let obj = {}Object.getOwnPropertyNames(obj) // []// ES5 版本当中参数不是原始对象类型会引起错误Object.getOwnPropertyNames('foo'); // TypeError: 'foo' is not an object// ES6 版本当中非对象参数会被强制转换为对象Object.getOwnPropertyNames('foo'); // ['length', '0', '1', '2'] 利用这个方法可以检测出非枚举属性 12345678910var obj = {}Object.defineProperty(obj, 'key', { enumerable: false, configurable: false, writable: false, value: '123'});Object.getOwnPropertyNames(obj) // ['key'] Reflect.ownKeys(obj)这个是个无敌的方法，返回所有的自身属性，不管是否可枚举，不管是不是 Symbol，一律返回 123456789101112131415var test = Symbol()var obj = { [test]: 123}Object.defineProperty(obj, 'key', { enumerable: false, configurable: false, writable: false, value: '123'});Object.getOwnPropertyNames(obj) // ['key']Object.keys(obj) // []Reflect.ownKeys(obj) // ['key', Symbol()] 所以简单的总结一下，判断一个变量是不是空对象的比较完善的方法 12345678910111213obj !== null&amp;&amp; typeof obj === 'object'&amp;&amp; !Array.isArray(obj)&amp;&amp; (Object.getOwnPropertyNames(obj).length === 0)&amp;&amp; (Object.getOwnPropertySymbols(obj).length === 0)// or(Object.prototype.toString.call(obj) === '[object Object]')&amp;&amp; (Object.getOwnPropertyNames(obj).length === 0)&amp;&amp; (Object.getOwnPropertySymbols(obj).length === 0)// or(String(obj) === '[object Object]') &amp;&amp; (Reflect.ownKeys(obj).length === 0) 函数检测从技术上讲，JavaScript 中的函数是引用类型，同样存在 Function 构造函数，每个函数都是其实例，比如： 1234function myFunc () {}// 不推荐console.log( myFunc instanceof Function ); // true 然而，这个方法并不能跨 frame 使用，因为每个 frame 中都有各自的 Function 构造函数，好在 typeof 运算符也可以用于函数 1234function myFunc () {}// 推荐，返回的是 functionconsole.log( typeof myFunc === 'function' ); // true 检测函数最好的方法是使用 typeof ，因为它可以跨 frame 使用 数组检测在没有 isArray 方法之前，一般会采用如下方式来进行判断 123var isArray = function (value) { return value &amp;&amp; typeof value === 'object' &amp;&amp; value.constructor === 'Array';} 上面这个方法在 从不同的窗口（window/frame）里构造的数组的时候会失败，所以我们不得不考虑更多 123456var isArray = function (value) { return value &amp;&amp; typeof value === 'object' &amp;&amp; typeof value.length === 'number' &amp;&amp; typeof value.slice === 'function' &amp;&amp; !(value.propertyIsEnumerable('length'));} 首先，我们要判断这个值是否为真，不接受 null 和其他为假的值 其次判断 typeof 运算的结果是否为 object，对于对象，数组和 null 来说，返回的是 true（但是对于对象来说并非如此） 然后判断这个值是否包含一个 splice 的方法，对于数组来说，又将会得到 true 最后判断 length 属性是否是可枚举的，对于数组来说，将得到 false 但是在 ES5 之后，将 Array.isArray() 正式的引入，唯一的目的就是检测一个值是否为数组 1234567function isArray (value) { if (typeof Array.isArray === 'function') { return Array.isArray(value); } else { return Object.prototype.toString.call(value) === '[object Array]'; }} 关于使用 Object.prototype.toString.call() 有一些需要注意的地方 这种方法在识别内置对象的时候往往十分有用，但是对于自定义对象请不要使用这种方法，比如内置的 JSON 对象将返回 '[object JSON]' 属性检测另外一种用到 null（和 undefined）的场景是当检测一个属性是否在对象中存在的时候，比如 1234567891011121314// 不推荐的写法，检测假值if (object[prototype]) { // ...}// 不推荐的写法，与 null 比较if (object[propertyName] !== null) { // ...}// 不推荐的写法，与 undefined 比较if (object[propertyName] !== undefined) { // ...} 以上代码的每个判断，实际上是通过给定的名字来检查属性的值，而非判断给定的名字的所指的属性是否存在，因为当这些属性值为假值（false value）的时候，结果会出错，比如 0， null， undefined， false， ''（空字符串） 判断属性是否存在的最好的方法是使用 in 运算符，in 运算符仅仅会简单的判断属性是否存在，而不会去读属性的值 如果实例对象的属性存在，或者继承自对象的原型，in 运算符都会返回 true 1234567891011121314var object = { count: 0, related: null}; // 推荐if ('count' in object) { // ...} // 不推荐if (object['count']) { // ...} 如果你只想检查实例对象的某个属性是否存在，则使用 hasOwnProperty() 方法，所有继承自 Object 的对象都有这个方法，如果实例中存在这个属性则返回 true 需要注意的是：如果这个属性只存在原型里，则会返回 false 但是在 IE8 以及更早的版本中，DOM 对象并非继承自 Object，因此也不包含这个方法，也就是说，你在调用 DOM 对象的 hasOwnProperty() 方法之前应当先检测其是否存在（如果你已经知道对象不是DOM，则可以省略这一步） 123456789// 对于所有非 DOM 对象来说，这是好的写法if (object.hasOwnProperty('count')) { // ...}// 如果你不确定是否为 DOM 对象，则可以这样写if ('hasOwnProperty' in object &amp;&amp; object.hasOwnProperty('count')) { // ...} 在判断实例对象是否存在的时候，推荐使用 in 运算符，只有在需要判断实例属性的时候才会用到 hasOwnProperty() 不管你什么时候需要检测属性的存在性，请使用 in 运算符或者 hasOwnProperty()，这样可以避免很多错误 hasOwnProperty是用来判断一个对象是否有你给出名称的属性或对象（需要注意的是，此方法无法检查该对象的原型链中是否具有该属性） 该属性必须是对象本身的一个成员，在跨浏览器的设计中，我们不能依赖于 for in 来获取对象的成员名称，一般使用 hasOwnProperty 来判断 1234567891011var buz = { fog: '123'};for (var name in buz) { if (buz.hasOwnProperty(name)) { alert(\"this is fog (\" + name + \") for sure. Value: \" + buz[name]); } else { alert(name); // toString or something else }} 在 Object.prototype 中调用 hasOwnProperty() 1234567891011121314151617181920// 对象var man = { hands: 2, legs: 2, heads: 1};// 将一个方法添加到对象上if (typeof Object.prototype.clone === \"undefined\") { Object.prototype.clone = function () { // ... }}// 使用 hasOwnProperty()for (var i in man) { if (Object.prototype.hasOwnProperty.call(man, i)) { // 过滤 console.log(i, \":\", man[i]); }} 在使用 hasOwnProperty() 对 man 对象进行精炼后，可有效的避免命名冲突，也可以使用一个本地变量来缓存比较长的属性名 12345678var i, hasOwn = Object.prototype.hasOwnProperty;for (var i in man) { // 过滤 if (hasOwn.call(man, i)) { console.log(i, \":\", man[i]); }} 严格来讲，不使用 hasOwnProperty() 并没有错，依赖具体任务和对代码的自信，可以忽略过该方法并略微加快循环的执行速度 但是当确认不了对象的内容（和原型链）的时候，最好还是加上 hasOwnProperty() 这样安全的检查 isPrototypeOf是用来判断要检查其原型链的对象是否存在于指定对象实例中，是则返回 true，否则返回 false 12345678910111213141516171819202122232425262728293031323334353637function Fee() { // . . .}function Fi() { // . . .}Fi.prototype = new Fee();function Fo() { // . . .}Fo.prototype = new Fi();function Fum() { // . . .}Fum.prototype = new Fo();// ---------------------------var fum = new Fum();// ...if (Fi.prototype.isPrototypeOf(fum)) { // do something safe} instanceof用来测试一个对象在其原型链构造函数上是否具有 prototype 属性，直白的说就是，用来检测 constructor.prototype 是否存在于参数 object 的原型链上 1234567891011121314151617181920212223242526// 定义构造函数function C() { }function D() { }var o = new C();// true，因为 Object.getPrototypeOf(o) === C.prototypeo instanceof C;// false，因为 D.prototype 不在 o 的原型链上o instanceof D;o instanceof Object; // true，因为 Object.prototype.isPrototypeOf(o) 返回 trueC.prototype instanceof Object // true，同上C.prototype = {};var o2 = new C();o2 instanceof C; // trueo instanceof C; // false，C.prototype 指向了一个空对象，这个空对象不在 o 的原型链上D.prototype = new C(); // 继承var o3 = new D();o3 instanceof D; // trueo3 instanceof C; // true 需要注意的是，如果表达式 obj instanceof Foo 返回 true，则并不意味着该表达式会永远返回 ture，因为 Foo.prototype 属性的值有可能会改变 改变之后的值很有可能不存在于 obj 的原型链上，这时原表达式的值就会成为 false 另外一种情况下，原表达式的值也会改变，就是改变对象 obj 的原型链的情况，虽然在目前的 ES 规范中，我们只能读取对象的原型而不能改变它，但借助于非标准的 __proto__ 魔法属性，是可以实现的 比如执行 obj.__proto__ = {} 之后，obj instanceof Foo 就会返回 false 了 更多详细见： MDN - instanceof 所以，在判断一个变量是不是对象的情况下，值类型的类型判断用 typeof，引用类型的类型判断用 instanceof 123var fn = function () { };console.log(fn instanceof Object); // true 总结 原始值（字符串，数字，布尔值，undefined） – typeof 引用值（Date，RegExp，Error） – instanceof 函数 – typeof 数组 – isArray 属性检测（是否存在） – in/hasOwnProperty()","link":"/2018/03/17/JavaScript/30/"},{"title":"FileReader 接口","text":"FileReader 接口主要是将文件读入内存，并提供相应的方法，来读取文件中的数据 比如比较常见的上传预览就可以使用这个 API 来实现 一个简单的示例如下： 123456789101112131415161718192021222324252627282930var result = document.getElementById('result');var file = document.getElementById('file');// 判断浏览器是否支持 FileReader 接口if (typeof FileReader == 'undefined') { result.InnerHTML = '&lt;p&gt;你的浏览器不支持 FileReader 接口！&lt;/p&gt;'; // 使选择控件不可操作 file.setAttribute('disabled', 'disabled');}function readAsDataURL() { var file = document.getElementById('file').files[0]; // 检验是否为图像文件 if (!/image\\/\\w+/.test(file.type)) { alert('格式不正确！'); return false; } // 将文件以 Data URL 形式读入页面 var reader = new FileReader(); reader.readAsDataURL(file); // 在 onload 函数当中进行逻辑操作 reader.onload = function (e) { var result = document.getElementById('result'); // 显示文件 result.innerHTML = '&lt;img src= ' + e.target.result + ' &gt;' }} 123456&lt;p&gt; &lt;input type='file' id='file' /&gt; &lt;input type='button' value=\"读取图像\" onclick=\"readAsDataURL()\" /&gt;&lt;/p&gt;&lt;div id='result' name='result'&gt;&lt;/div&gt; 预览完成后就可以上传到服务器了： 123456789101112131415161718$('#submitBtn').submit(function () { if ($('#upload_file').val()) { $('#upload_btn').attr('disabled', true); $('.tip').html('正在上传中，请稍候...'); $(this).ajaxSubmit({ type: 'post', url: url, success: function (data) { // ... $('#upload_btn').attr('disabled', false); $('.tip').html(''); } }); } // 不刷新页面 return false;}); 方法和事件12345678910111213141516171819202122// 方法abort // 中断读取readAsText(file, [encoding]) // 将文件读取为文本该方法有两个参数，其中第二个参数是文本的编码方式，默认值为 UTF-8 // 这个方法非常容易理解，将文件以文本方式读取，读取的结果即是这个文本文件中的内容readAsBinaryString(file) // 将文件读取二进制码通常我们将它传送到后端，后端可以通过这段字符串存储文件readAsDataURL(file) // 将文件读取为 DataURL 将文件读取为一串Data URL字符串， // 将小文件以一种特殊格式的URL地址直接读入页面，小文件指图像与html等格式的文件// 事件onabort // 数据读取中断时触发onerror // 数据读取出错时触发onloadstart // 数据读取开始时触发onload // 数据读取成功完成时触发onloadend // 数据读取完成时触发，无论成功失败 分段读取文本信息（slice）有的时候，一次性将一个大文件读入内存，并不是一个很好的选择（如果文件太大，可能直接导致浏览器崩溃），更稳健的方法是分段读取 HTML5 File Api 提供了一个 slice 方法，允许分片读取文件内容 文件一旦开始读取，无论成功或失败，实例的 result 属性都会被填充，如果读取失败，则 result 的值为 null ，否则即是读取的结果，绝大多数的程序都会在成功读取文件的时候，抓取这个值 12345678910111213141516171819202122232425262728293031323334353637383940function readBlob(start, end) { var files = document.getElementById('file').files; if (!files.length) { alert('请选择文件'); return false; } var file = files[0], start = parseInt(start, 10) || 0, end = parseInt(end, 10) || (file.size - 1); var r = document.getElementById('range'), c = document.getElementById('content'); var reader = new FileReader(); reader.onloadend = function (e) { if (this.readyState == FileReader.DONE) { c.textContent = this.result; r.textContent = 'Read bytes: ' + (start + 1) + ' - ' + (end + 1) + ' of ' + file.size + ' bytes'; } }; // 兼容 var blob; if (file.webkitSlice) { blob = file.webkitSlice(start, end + 1); } else if (file.mozSlice) { blob = file.mozSlice(start, end + 1); } else if (file.slice) { blob = file.slice(start, end + 1); } reader.readAsBinaryString(blob);};document.getElementById('file').onchange = function () { readBlob(10, 100);} 使用了 FileReader 的 onloadend 事件来检测读取成功与否，如果用 onloadend 则必须检测一下 FileReader 的 readyState 因为 read abort 时也会触发 onloadend 事件，如果我们采用 onload，则可以不用检测 readyState 另一个分段读取的示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465var bar = document.getElementById('progress-bar');var progress = document.getElementById('progress');var input = document.getElementById('file');var block = 1 * 1024 * 1024; // 每次读取 1M// 当前文件对象var file;// 当前已读取大小var fileLoaded;// 文件总大小var fileSize;// 每次读取一个 blockfunction readBlob() { var blob; if (file.webkitSlice) { blob = file.webkitSlice(fileLoaded, fileLoaded + block + 1); } else if (file.mozSlice) { blob = file.mozSlice(fileLoaded, fileLoaded + block + 1); } else if (file.slice) { blob = file.slice(fileLoaded, fileLoaded + block + 1); } else { alert('不支持分段读取！'); return false; } reader.readAsBinaryString(blob);}// 每个 blob 读取完毕时调用function loadHandler(e) { fileLoaded += e.total; var percent = fileLoaded / fileSize; if (percent &lt; 1) { // 继续读取下一块 readBlob2(); } else { // 结束 percent = 1; } percent = Math.ceil(percent * 100) + '%'; progress.innerHTML = percent; progress.style.width = percent;}function fileSelect(e) { file = this.files[0]; if (!file) { alert('文件不能为空！'); return false; } fileLoaded = 0; fileSize = file.size; bar.style.display = 'block'; // 开始读取 readBlob2();}var reader = new FileReader();// 只需监听 onload 事件reader.onload = loadHandler;input.onchange = fileSelect FileReader 进度条既然 FileReader 是异步读取文件内容，那么就应该可以监听它的读取进度 事实上，FileReader 的 onloadstart 以及 onprogress 等事件可以用来监听 FileReader 的读取进度 在 onprogress 的事件处理器中，提供了一个 ProgressEvent 对象，这个事件对象实际上继承了 Event 对象 提供了三个只读属性：lengthComputable、loaded、total，通过以上几个属性，即可实时显示读取进度 12345interface ProgressEvent : Event { readonly attribute boolean lengthComputable; readonly attribute unsigned long long loaded; readonly attribute unsigned long long total;}; Ajax 上传并显示进度条： 1234567891011121314151617181920212223242526272829function upLoad() { var myPic = document.querySelector('myPic').files[0]; var fd = new FormData(); fd.append('myPic', myPic); var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function () { if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) { alert(xhr.responseText); } } // 监听附件上传情况 xhr.upload.onprogress = function () { // evt.loaded -- 已经上传大小 // evt.total -- 附件总大小 var loaded = evt.loaded; var tot = evt.total; var per = Math.floor(100 * loaded / tot); var son = document.getElementById('flag'); flag.innerHTML = per + '%'; flag.style.width = per + '%'; } var url = ''; xhr.open('POST', url); xhr.send(fd);} FormData 对象FormData 对象，可以把 form 中所有表单元素的 name 与 value 组成一个 queryString，提交到后台 用 jQuery 的方法来说，就是 serialize 了，但是在使用 Ajax 提交时，这过程就变成人工的了，因此，使用 FormData 对象可以减少拼接 queryString 的工作量 可以先创建一个空的 FormData 对象，然后利用 append 方法向该对象添加字段（key/value） 12345var myForm = new FormData();myForm.append('name', 'zhangsan');myForm.append('name', 'lisi');myForm.append('num', 222333); // 数字会被转换成字符串 或者可以取得 form 元素对象，然后将其作为参数传入 FormData 对象中 12var myForm = document.querySelector('#myForm');var formdata = new FormData(myForm); 利用 getFormData 生成 12var myForm = document.querySelector('#myForm');var formdata = myForm.getFormData(); 使用 FormData 提交表单： 123456789101112131415function fsubmit() { var data = new FormData($('#myForm')[0]); $.ajax({ url: 'upLoad.html', type: 'POST', data: data, dataType: 'JSON', cahce: false, processData: false, contentType: false, success: function () { // ... } })} window.URL.createObjectURLwindow.URL.createObjectURL 的作用是创建一个新的对象 URL，该对象 URL 可以代表某一个指定的 File 对象或 Blob 对象 关于 Bold 对象，见 MDN -Bold 大体的意思就是 File 对象，就是一个文件，比如使用 &lt;input type=&quot;file&quot; /&gt; 标签来上传文件，那么里面的每个文件都是一个 File 对象 Blob 对象，就是二进制数据，比如通过 new Blob() 创建的对象就是 Blob 对象.又比如，在 XMLHttpRequest 里，如果指定 responseType 为 blob，那么得到的返回值也是一个 blob 对象 123objectURL = window.URL.createObjectURL(blob);// blob 参数是一个 File 对象或者 Blob 对象// objectURL 是生成的对象 URL 通过这个 URL，可以获取到所指定文件的完整内容 每次调用 createObjectURL 的时候，一个新的 URL 对象就被创建了，即使你已经为同一个文件创建过一个 URL 如果你不再需要这个对象，要释放它，需要使用 URL.revokeObjectURL() 方法 当页面被关闭，浏览器会自动释放它，但是为了最佳性能和内存使用，当确保不再用得到它的时候，就应该释放它 利用 window.URL.createObjectURL 显示图片： 1234567&lt;input type= \"file\" id= \"fileElem\" multiple accept= \"image/*\" style= \"display:none\" onchange= \"handleFiles(this.files)\"&gt;&lt;a href=\"#\" id=\"fileSelect\"&gt;Select some files&lt;/a&gt;&lt;div id=\"fileList\"&gt; &lt;p&gt;No files selected!&lt;/p&gt;&lt;/div&gt; 使用过程如下 12345678910111213141516171819202122232425262728293031323334353637window.URL = window.URL || window.webkitURL;var fileSelect = document.getElementById('fileSelect'), fileElem = document.getElementById('fileElem'), fileList = document.getElementById('fileList');fileSelect.addEventListener('click', function (e) { if (fileElem) { fileElem.click(); } e.preventDefault(); // prevent navigation to '#'}, false);function handleFiles(files) { if (!files.length) { fileList.innerHTML = '&lt;p&gt;No files selected!&lt;/p&gt;'; } else { fileList.innerHTML = ''; var list = document.createElement('ul'); fileList.appendChild(list); for (var i = 0; i &lt; files.length; i++) { var li = document.createElement('li'); list.appendChild(li); var img = document.createElement('img'); img.src = window.URL.createObjectURL(files[i]); img.height = 60; img.onload = function () { window.URL.revokeObjectURL(this.src); } li.appendChild(img); var info = document.createElement('span'); info.innerHTML = files[i].name + ': ' + files[i].size + ' bytes'; li.appendChild(info); } }} 如果有现成的 'img' 标签 1234function upLoadImg() { var myPic = document.getElementById('myPic').files[0]; document.getElementsByTagName('img')[0].src = window.URL.createObjectURL(myPic);} 参考： leejersey HTML5 之 FileReader 的使用 JavaScript File API","link":"/2018/08/04/JavaScript/35/"},{"title":"JavaScript 中的数据双向绑定","text":"关于数据双向绑定，绑定的基础就是监听属性的变化事件（propertyChange），现在主流的框架当中的解决方法一般有以下几种 Knockout / Backbone（发布/订阅模式），简单来说就是另外开发一套 API，但使用起来却不得不使用这套 API 来操作 viewModel，导致上手复杂、代码繁琐 Angular（脏检查机制），特点是直接使用原生 JavaScript 来操作 viewModel，但脏检查机制随之带来的就是性能问题 Vue（数据劫持，也就是 Object.defineProperty），会把定义的 viewModel 对象（即 data 函数返回的对象）中所有的（除某些前缀开头的）成员替换为属性，这样既可以使用原生 JavaScript 操作对象，又可以主动触发 propertyChange 事件，效率虽高，但也有一些限制，见后文 另外的几种方式 Object.observe，谷歌对于简化双向绑定机制的尝试，在 Chrome 49 中引入，然而由于性能等问题，并没有被其他各大浏览器及 ES 标准所接受，所以在后续版本当中移除了该方法的实现 Proxy，是 ES6 加入的新特性，用于对某些基本操作定义其自定义行为，类似于其他语言中的面向切面编程（它的其中一个作用就是用于（部分）替代 Object.observe 以实现双向绑定） 基于数据劫持实现的双向绑定什么是数据劫持数据劫持比较好理解，通常我们利用 Object.defineProperty 劫持对象的访问器，在属性值发生变化时我们可以获取变化，从而进行进一步操作 12345678910111213141516171819202122// 这是将要被劫持的对象const data = { name: '',};// 遍历对象,对其属性值进行劫持Object.keys(data).forEach(function (key) { Object.defineProperty(data, key, { enumerable: true, configurable: true, get: function () { console.log(`get`); }, set: function (newValue) { // 当属性值发生变化时我们可以进行额外操作 console.log(`set`); console.log(newValue); }, });});data.name = 'new name'; 数据劫持的优势以及实现思路目前业界分为两个大的流派，一个是以 React 为首的单向数据绑定，另一个是以 Angular、Vue 为主的双向数据绑定 两者主要有两点区别 无需显示调用，例如 Vue 运用数据劫持加上发布订阅，直接可以通知变化并驱动视图，而比如 Angular 的脏检测或是 react 需要显示调用 setState 可精确得知变化数据：例如上面的例子，我们劫持了属性的 setter，当属性值改变，我们可以精确获知变化的内容，因此在这部分不需要额外的 diff 操作，否则我们只知道数据发生了变化而不知道具体哪些数据变化了，这个时候需要大量 diff 来找出变化值，这是额外性能损耗 本质上，基于数据劫持的双向绑定离不开 Proxy 与 Object.defineProperty 等方法对对象或者对象属性的劫持，我们要实现一个完整的双向绑定需要以下几个要点 利用 Proxy 或 Object.defineProperty 生成的 Observer 针对对象或者对象的属性进行劫持，在属性发生变化后通知订阅者 解析器 Compile 解析模板中的 Directive（指令），收集指令所依赖的方法和数据，等待数据变化然后进行渲染 Watcher 属于 Observer 和 Compile 桥梁，它将接收到的 Observer 产生的数据变化，并根据 Compile 提供的指令进行视图渲染，使得数据变化促使视图变化 基于 Object.defineProperty 双向绑定完整的实现可以见 剖析 Vue 原理 &amp;&amp; 实现双向绑定 MVVM，比如上面的示例，就是一个简单的实现 但是很快就会发现，里面存在着一堆问题，比如我们只监听了一个属性，一个对象不可能只有一个属性，我们需要对对象的每个属性进行监听等等 我们可以参考 Vue 的实现方式，Vue 是采用数据劫持结合发布者订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调 简单来说，主要有下面几个步骤 需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter 这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化 compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图 Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是: 在自身实例化时往属性订阅器（dep）里面添加自己 自身必须有一个 update() 方法 待属性变动 dep.notice() 通知时，能调用自身的 update() 方法，并触发 Compile 中绑定的回调，则功成身退 MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，所以最终便可以达到达到 数据变化 ==&gt; 视图更新 和 视图交互变化（input） ==&gt; 数据 model 变更 的双向绑定效果 下面是一个完成的例子 12345&lt;main&gt; &lt;p&gt;请输入:&lt;/p&gt; &lt;input type=\"text\" id=\"input\"&gt; &lt;p id=\"p\"&gt;&lt;/p&gt;&lt;/main&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192// 首先实现一个订阅发布中心，即消息管理员（Dep），它负责储存订阅者和消息的分发，不管是订阅者还是发布者都需要依赖于它const Vue = (function() { let uid = 0; // 用于储存订阅者并发布消息 class Dep { constructor() { // 设置 id 用于区分新 Watcher 和只改变属性值后新产生的 Watcher this.id = uid++; // 储存订阅者的数组 this.subs = []; } // 触发 target 上的 Watcher 中的 addDep 方法，参数为 dep 的实例本身 depend() { Dep.target.addDep(this); } // 添加订阅者 addSub(sub) { this.subs.push(sub); } notify() { // 通知所有的订阅者（Watcher）触发订阅者的相应逻辑处理 this.subs.forEach(sub =&gt; sub.update()); } } // 为 Dep 类设置一个静态属性，默认为 null，工作时指向当前的 Watcher Dep.target = null; // 现在我们需要实现监听者（Observer），用于监听属性值的变化 // 监听者，监听对象属性值的变化 class Observer { constructor(value) { this.value = value; this.walk(value); } // 遍历属性值并监听 walk(value) { Object.keys(value).forEach(key =&gt; this.convert(key, value[key])); } // 执行监听的具体方法 convert(key, val) { defineReactive(this.value, key, val); } } function defineReactive(obj, key, val) { const dep = new Dep(); // 给当前属性的值添加监听 let chlidOb = observe(val); Object.defineProperty(obj, key, { enumerable: true, configurable: true, get: () =&gt; { // 如果 Dep 类存在 target 属性，将其添加到 dep 实例的 subs 数组中 // target 指向一个 Watcher 实例，每个 Watcher 都是一个订阅者 // Watcher 实例在实例化过程中，会读取 data 中的某个属性，从而触发当前 get 方法 if (Dep.target) { dep.depend(); } return val; }, set: newVal =&gt; { if (val === newVal) return; val = newVal; // 对新值进行监听 chlidOb = observe(newVal); // 通知所有订阅者，数值被改变了 dep.notify(); }, }); } function observe(value) { // 当值不存在，或者不是复杂数据类型时，不再需要继续深入监听 if (!value || typeof value !== 'object') { return; } return new Observer(value); } // 我们还需要实现一个订阅者（Watcher） class Watcher { constructor(vm, expOrFn, cb) { this.depIds = {}; // hash 储存订阅者的 id，避免重复的订阅者 this.vm = vm; // 被订阅的数据一定来自于当前 Vue 实例 this.cb = cb; // 当数据更新时想要做的事情 this.expOrFn = expOrFn; // 被订阅的数据 this.val = this.get(); // 维护更新之前的数据 } // 对外暴露的接口，用于在订阅的数据被更新时，由订阅者管理员（Dep）调用 update() { this.run(); } addDep(dep) { // 如果在 depIds 的 hash 中没有当前的 id，可以判断是新 Watcher，因此可以添加到 dep 的数组中储存 // 此判断是避免同 id 的 Watcher 被多次储存 if (!this.depIds.hasOwnProperty(dep.id)) { dep.addSub(this); this.depIds[dep.id] = dep; } } run() { const val = this.get(); console.log(val); if (val !== this.val) { this.val = val; this.cb.call(this.vm, val); } } get() { // 当前订阅者（Watcher）读取被订阅数据的最新更新后的值时，通知订阅者管理员收集当前订阅者 Dep.target = this; const val = this.vm._data[this.expOrFn]; // 置空，用于下一个 Watcher 使用 Dep.target = null; console.log(Dep.target, 2); return val; } } // 将上述方法挂载在 Vue 上 class Vue { constructor(options = {}) { // 简化了 $options 的处理 this.$options = options; // 简化了对 data 的处理 let data = (this._data = this.$options.data); // 将所有 data 最外层属性代理到 Vue 实例上 Object.keys(data).forEach(key =&gt; this._proxy(key)); // 监听数据 observe(data); } // 对外暴露调用订阅者的接口，内部主要在指令中使用订阅者 $watch(expOrFn, cb) { new Watcher(this, expOrFn, cb); } _proxy(key) { Object.defineProperty(this, key, { configurable: true, enumerable: true, get: () =&gt; this._data[key], set: val =&gt; { this._data[key] = val; }, }); } } return Vue;})();// 使用let demo = new Vue({ data: { text: '', },});const p = document.getElementById('p');const input = document.getElementById('input');input.addEventListener('keyup', function(e) { demo.text = e.target.value;});demo.$watch('text', str =&gt; p.innerHTML = str); Object.defineProperty 的缺陷其实我们升级版的双向绑定依然存在漏洞，比如我们将属性值改为数组 1234567891011121314151617181920212223242526272829303132let demo = new Vue({ data: { list: [1], },});const list = document.getElementById('list');const btn = document.getElementById('btn');btn.addEventListener('click', function () { demo.list.push(1);});const render = arr =&gt; { const fragment = document.createDocumentFragment(); for (let i = 0; i &lt; arr.length; i++) { const li = document.createElement('li'); li.textContent = arr[i]; fragment.appendChild(li); } list.appendChild(fragment);};// 监听数组，每次数组变化则触发渲染函数，然而却无法监听demo.$watch('list', list =&gt; render(list));setTimeout( function () { alert(demo.list); }, 5000,); 是的，Object.defineProperty 的第一个缺陷，无法监听数组变化，然而 Vue 的文档提到了 Vue 是可以检测到数组变化的 其实简单来说，这里就是重写了原来的方法 123456789101112131415161718192021// 首先获取 Array 原型const oldMethod = Object.create(Array.prototype);const newMethod = [];['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(method =&gt; { // 在 newMethod 上进行方法的重写 // 这里需要注意的是重写的方法是定义在 newMethod 的属性上而不是其原型属性（newMethod.__proto__ 没有改变） newMethod[method] = function () { console.log(`监听到数组的变化`) return oldMethod[method].apply(this, arguments) }})let list = [1, 2]// 将需要监听的数组的原型指针指向我们重新定义的新对象list.__proto__ = newMethodlist.push(3)// 如果不设定指向，则默认使用原生的方法let list2 = [1, 2]list2.push(3) 由于只针对了特定几种方法进行了 hack，所以其他数组的属性也是检测不到的 我们应该注意到在上文中的实现里，我们多次用遍历方法遍历对象的属性，这就引出了 Object.defineProperty 的第二个缺陷，只能劫持对象的属性 因此我们需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历，显然能劫持一个完整的对象是更好的选择 1Object.keys(value).forEach(key =&gt; this.convert(key, value[key])); Proxy 实现的双向绑定Proxy 在 ES2015 规范中被正式发布，它在目标对象之前架设一层拦截，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写 我们可以这样认为 Proxy 是 Object.defineProperty 的全方位加强版 Proxy 直接可以劫持整个对象，并返回一个新对象，不管是操作便利程度还是底层功能上都远强于 Object.defineProperty Proxy 可以直接监听数组的变化当我们对数组进行操作（push、shift、splice 等）时，会触发对应的方法名称和 length 的变化 下面是一个实例 12345&lt;main&gt; &lt;ul id=\"list\"&gt; &lt;/ul&gt; &lt;button type=\"button\" name=\"button\" id=\"btn\"&gt;添加列表项&lt;/button&gt;&lt;/main&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const list = document.getElementById('list');const btn = document.getElementById('btn');// 渲染列表const Render = { // 初始化 init: function(arr) { const fragment = document.createDocumentFragment(); for (let i = 0; i &lt; arr.length; i++) { const li = document.createElement('li'); li.textContent = arr[i]; fragment.appendChild(li); } list.appendChild(fragment); }, // 我们只考虑了增加的情况，仅作为示例 change: function(val) { const li = document.createElement('li'); li.textContent = val; list.appendChild(li); },};// 初始数组const arr = [1, 2, 3, 4];// 监听数组const newArr = new Proxy(arr, { get: function(target, key, receiver) { console.log(key); return Reflect.get(target, key, receiver); }, set: function(target, key, value, receiver) { console.log(target, key, value, receiver); if (key !== 'length') { Render.change(value); } return Reflect.set(target, key, value, receiver); },});// 初始化window.onload = function() { Render.init(arr);}// push 数字btn.addEventListener('click', function() { newArr.push(6);}); Proxy的优势Proxy 有多种拦截方法，不限于 apply、ownKeys、deleteProperty、has 等等，是 Object.defineProperty 不具备的 Proxy 返回的是一个新对象，我们可以只操作新的对象达到目的，而 Object.defineProperty 只能遍历对象属性直接修改","link":"/2018/07/10/JavaScript/34/"},{"title":"为什么 Object.keys 的返回值会自动排序","text":"我们先来看一个实例，如下所示 1234567var arr = ['a', 'b', 'c'];console.log(Object.keys(arr)); // ['0', '1', '2']// -------------------------------var an_obj = { 100: 'a', 2: 'b', 7: 'c' };console.log(Object.keys(an_obj)); // ['2', '7', '100'] 至于为什么会发生这样的情况，我们需要来看看在 Object.keys() 的调用过程中到底发生了些什么 查看 规范 可知，总共有三步流程 调用 ToObject(O) 将结果赋值给变量 obj 调用 EnumerableOwnPropertyNames(obj, 'key') 将结果赋值给变量 nameList 调用 CreateArrayFromList(nameList) 得到最终的结果 ToObject(O)首先第一步是将参数转换成 Object()，根据参数的不同结果有所不同，如下所示 参数类型 结果 Undefined 抛出 TypeError Null 抛出 TypeError Boolean 返回一个新的 Boolean 对象 Number 返回一个新的 Number 对象 String 返回一个新的 String 对象 Symbol 返回一个新的 Symbol 对象 Object 直接将 Object 返回 几个示例 12345Object.keys(null) // TypeErrorObject.keys(true) // []Object.keys('abc') // ['0', '1', '2'] EnumerableOwnPropertyNames(obj, ‘key’)接下来就是获得属性列表 过程有很多，比较重要的一个是调用对象的内部方法 OwnPropertyKeys 获得对象的 ownKeys，也正是该方法决定了属性的顺序 声明变量 keys 值为一个空列表（List 类型） 把每个 Number 类型的属性，按数值大小升序排序，并依次添加到 keys 中 把每个 String 类型的属性，按创建时间升序排序，并依次添加到 keys 中 把每个 Symbol 类型的属性，按创建时间升序排序，并依次添加到 keys 中 将 keys 返回（return keys） 除此之外，还有一点需要补充，如果对象的属性类型是数字，字符与 Symbol 混合的，那么返回顺序永远是数字在前，然后是字符串，最后是 Symbol 不过虽然规定了 Symbol，最终会将 Symbol 类型的属性过滤出去 12345678910111213let s = Symbol()const obj = { [s]: 'd', 7: 'a', a: '7', 10: 'b', b: '10', 44: 'c', c: '44'}Object.keys(obj) // ['7', '10', '44', 'a', 'b', 'c'] CreateArrayFromList(nameList)最后一步就是调用 CreateArrayFromList(nameList) 来得到最终的结果 现在已经得到了一个对象的属性列表，最后一步是将 List 类型的属性列表转换成 Array 类型 先声明一个变量 array，值是一个空数组 循环属性列表，将每个元素添加到 array 中 将 array 返回 一些其他的 API上面介绍的排序规则同样适用于下列 API Object.entries Object.values for...in Object.getOwnPropertyNames Reflect.ownKeys 不过需要注意的是，以上 API 除了 Reflect.ownKeys 之外，其他 API 均会将 Symbol 类型的属性过滤掉 如果想要保证对象遍历的输出顺序，可以将对象转换为数组来进行操作","link":"/2019/03/16/JavaScript/38/"},{"title":"使用 Underscore","text":"underscore 提供了一套完善的函数式编程的接口，让我们更方便地在 JavaScript 中实现函数式编程 123'use strict'_.map([1, 2, 3], (x) =&gt; x * x); // [1, 4, 9] 重要的一点，是 underscore 的 map() 还可以作用于 Object 123'use strict'_.map( { a: 1, b: 2, c: 3 }, (v, k) =&gt; k + ' = ' + v); // ['a = 1', 'b = 2', 'c = 3'] map / filter和 Array 的 map() 与 filter() 类似，但是可以作用于 Object，当作用于 Object 时，传入的函数为 function (value, key)，第一个参数接收 value，第二个参数接收 key 需要注意的是，对 Object 作 map() 操作的返回结果是 Array（若是需要返回 Object，请使用 _.mapObject()） every / some当集合的所有元素都满足条件的时候，_.every() 函数返回 true 当集合的至少一个元素满足条件的时候，_.some() 函数返回 true 123_.every([1, 4, 5, 6, 8, -2], (x) =&gt; x &gt; 0); // false_some([1, 4, 5, 6, 8, -2], (x) =&gt; x &gt; 0); // true 123456789101112131415161718'use strict';var obj = { name: 'bob', school: 'No.1 middle school', address: 'xueyuan road'};// 判断 key 和 value 是否全部是小写var r1 = _.every(obj, function (value, key) { return (value + key) === (value + key).toLowerCase();});var r2 = _.some(obj, function (value, key) { return (value + key) === (value + key).toLowerCase();});alert('every key-value are lowercase: ' + r1 + '\\nsome key-value are lowercase: ' + r2); max / min返回集合中最大和最小的数 123456789101112var arr = [3, 5, 7, 9];_.max(arr); // 9_.min(arr); // 3// 需要注意的是，空集合会返回 -Infinity 和 Infinity，所以要先判断集合不为空_.max([]); // -Infinity_.min([]); // Infinity 如果集合是 Object，max() 和 min() 只作用于 value，会忽略掉 key： 1_.max({ a: 1, b: 2, c: 3 }); // 3 groupBygroupBy() 会把集合的元素按照 key 归类，key 由传入的函数返回，一般用于数组分组 1234567891011121314151617181920'use strict'var scores = [20, 81, 75, 40, 91, 59, 77, 66, 72, 88, 99];var groups = _.groupBy(scores, function (x) { if (x &lt; 60) { return 'C'; } else if (x &lt; 80) { return 'B'; } else { return 'A'; }})// 结果:// {// A: [81, 91, 88, 99],// B: [75, 77, 66, 72],// C: [20, 40, 59]// } shuffle / sampleshuffle() 用于洗牌算法随机打乱一个集合： 123'use strict'_.shuffle([1, 2, 3, 4, 5, 6]); // [3, 5, 4, 6, 2, 1] sample() 则是随机选择一个或多个元素： 1234567'use strict'// 随机选取 1 个_.sample([1, 2, 3, 4, 5, 6]); // 2// 随机选取 3 个_.sample([1, 2, 3, 4, 5, 6], 3); // [6, 1, 4] Arraysfirst / last12345var arr = [2, 4, 6, 8];_.first(arr); // 2_.last(arr); // 8 flattenflatten() 接收一个 Array，无论这个 Array 里面嵌套了多少个 Array，flatten() 最后都会把他们变成一个一维数组 1_.flatten([1, [2], [3, [[4], [5]]]]); // [1, 2, 3, 4, 5] zip / unzipzip() 把两个或多个数组的所有元素按索引对齐，然后按索引合并成新数组，例如，你有一个 Array 保存了名字，另一个 Array 保存了分数，现在，要把名字和分数给对上，用 zip() 轻松实现 1234var names = ['Adam', 'Lisa', 'Bart'];var scores = [85, 92, 59];_.zip(names, scores); // [['Adam', 85], ['Lisa', 92], ['Bart', 59]] unzip() 则是反过来 123var namesAndScores = [['Adam', 85], ['Lisa', 92], ['Bart', 59]];_.unzip(namesAndScores); // [['Adam', 'Lisa', 'Bart'], [85, 92, 59]] object与 zip() 类似，不过是把名字和分数直接对应为 Object 12345var names = ['Adam', 'Lisa', 'Bart'];var scores = [85, 92, 59];_.object(names, scores); // {Adam: 85, Lisa: 92, Bart: 59} rangerange() 可以快速生成一个序列，不再需要使用 for 循环实现，如果只传入一个参数，默认是从 0 开始 1234567891011// 从 0 开始小于 10:_.range(10); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]// 从 1 开始小于 11：_.range(1, 11); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]// 从 0 开始小于 30，步长 5:_.range(0, 30, 5); // [0, 5, 10, 15, 20, 25]// 从 0 开始大于 -10，步长 -1:_.range(0, -10, -1); // [0, -1, -2, -3, -4, -5, -6, -7, -8, -9] functionsbind同 ES5 中的 bind() 方法类似 12345// 不使用 bind 的话，需要这样，直接使用的话会报错，因为直接调用 log() 传入的 this 指针是 undefinedvar log = console.log();// 调用 call 并传入 console 对象作为 this:log.call(console, 'Hello, world!'); bind() 可以帮我们把 console 对象直接绑定在 log() 的 this 指针上，以后调用 log() 就可以直接正常调用了 123var log = _.bind(condole.log, console);log('Hello, world!'); memoize如果一个函数调用开销很大，我们就希望把结果缓存下来，以便后续调用的时候直接获得结果 1234567891011121314function factorial(n) { console.log('start calculate ' + n + '!...'); var s = 1, i = n; while (i &gt; 1) { s = s * i; i--; } console.log(n + '! = ' + s); return s;}factorial(10); // 3628800// start calculate 10!...// 10! = 3628800 使用 memoize() 就可以自动缓存函数计算的结果： 1234567891011121314151617181920var factorial = _.memoize(function (n) { console.log('start calculate ' + n + '!...'); var s = 1, i = n; while (i &gt; 1) { s = s * i; i--; } console.log(n + '! = ' + s); return s;})// 第一次调用:factorial(10); // 3628800// 注意控制台输出:// start calculate 10!...// 10! = 3628800// 第二次调用:factorial(10); // 3628800// 控制台没有输出 对于相同的调用，比如连续两次调用 factorial(10)，第二次调用并没有计算，而是直接返回上次计算后缓存的结果，不过，当你计算 factorial(9) 的时候，仍然会重新计算，这个时候可以对 factorial() 进行改进，让其递归调用： 123456789101112131415161718192021222324var factorial = _.memoize(function (n) { console.log('start calculate ' + n + '!...'); if (n &lt; 2) { return 1; } return n * factorial(n - 1);})factorial(10); // 3628800// 输出结果说明 factorial(1)~factorial(10) 都已经缓存了:// start calculate 10!...// start calculate 9!...// start calculate 8!...// start calculate 7!...// start calculate 6!...// start calculate 5!...// start calculate 4!...// start calculate 3!...// start calculate 2!...// start calculate 1!...factorial(9); // 362880// console 无输出 onceonce() 保证某个函数执行且仅执行一次，与 jQuery 中的 one() 方法类似 delaydelay() 可以让一个函数延迟执行，效果和 serTimeout() 是一样的（与 jQuery 中的 delay() 方法类似） 12// 2 秒后调用 alert_.delay(alert, 2000); 如果要延迟调用的函数有参数，把参数也传进去 123var log = _.bind(console.log, conole);_.delay(log, 200, 'Hello, world!'); // 2 秒后输出 Hello, world! Objectskeys / allkeyskeys() 可以方便地返回一个 object 自身所有的 key，但不包含从原型链继承下来的 1234567function Student (name, age) { this.name = name; this.age = age;}var xiaoming = new Student('小明', 20);_.keys(xiaoming); // ['name', 'age'] allkeys() 除了 object 自身的 key，还包含从原型链继承下来的 123456789function Student (name, age) { this.name = name; this.age = age;}Student.prototype.school = 'NO.1 Middle School';var xiaoming = new Student('小明', 20);_.allkeys(xiaoming); // ['name', 'age', 'school'] values和 keys() 类似，values() 返回 object 自身但不包含原型链继承的所有值（注意：没有 allvalues()） 123456var obj = { name: '小明', age: 20}_.values(obj); // ['小明', 20] mapObject()是针对 object 的 map 版本： 1234var obj = { a: 1, b: 2, c: 3 };// 需要注意的是，传入的函数名，value 在前，key 在后_.mapObject(obj, (v, k) =&gt; 100 + v); // { a: 101, b: 102, c: 103 } invertinvert() 把 object 的每个 key-value 互相交换，key =&gt; value，value =&gt; key 1234567var obj = { Adam: 90, Lisa: 85, Bart: 59}_.invert(obj); // { '59': 'Bart', '85': 'Lisa', '90': 'Adam' } extend / extendOwn可以把多个 object 的 key-value 合并到第一个 object 并返回（可以参考 jQuery 的 extend() 方法） 12345var a = {name: 'Bob', age: 20};_.extend(a, {age: 15}, {age: 88, city: 'WuHan'}); // {name: 'Bob', age: 88, city: 'WuHan'}// 变量 a 的内容也改变了a; // {name: 'Bob', age: 88, city: 'WuHan'} 需要注意的是：如果有相同的 key，后面的 object 的 value 将覆盖前面的 object 的 value extendOwn() 和 extend() 类似，但是获取属性的时候会忽略掉从原型链继承下来的属性 clone如果我们要复制一个 object 对象，可以使用 clone() 方法，它会把原有对象的所有属性都赋值到新的对象中 但是需要需要的是，clone() 是 ‘浅复制’，即两个对象相同的 key 所引用的 value 其实是同一对象 也就是说，修改其中一个的话，会影响到另外一个 注意区分修改和重新赋值 clone() 方法是浅拷贝，对象的引用是不同的，但是对象属性值的引用与原对象是一致的 修改是改变原对象值的引用所指向的内存地址存储的值，此时原对象和复制得到的新对象的属性值引用还是原来的，并没有变化，所以这种修改两个对象的属性值都会变化 重新赋值是开辟一个新的内存空间存新的值，这时候原对象属性值的引用已经不是之前的引用了，换句话说，这已经不是当时要复制的对象了，对之前复制得到的对象没有影响 简单来说 Array 可变，所以是修改，string 不可变，所以是重新赋值 可参考： 123456789101112131415var a = 1;var b = a;a === b; // truevar a = 1;var b = a;a = 2;var c = a;b === 1; // truec === 2; // truevar a = {};var b = {};a === b // false isEqualisEqual() 是对两个 object 进行深度比较，如果内容完全相同，则返回 true 12345var o1 = { name: 'Bob', skills: { AA: 90, BB: 99 }};var o2 = { name: 'Bob', skills: { BB: 99, AA: 90 }};o1 === o2; // false_.isEqual(o1, o2); // true 其实也可以对 Array 进行比较： 12345var o1 = ['Bob', { skills: ['AA', 'BB'] }];var o2 = ['Bob', { skills: ['AA', 'BB'] }];o1 === o2; // false_.isEqual(o1, o2); // true Chaining我们有一组操作，用 underscore 提供的函数，如下 1_.filter(_.map([1, 3, 9, 16, 25], Math.sqrt), x =&gt; x % 2 === 1); 使用 chain() 函数，就可以实现链式调用的方式： 1_.chain([1, 4, 9, 16, 25]).map(Math.sqrt).filter(x =&gt; x % 2 === 1).value(); 因为每一步返回的都是包装对象，所以最后一步的结果需要调用 value() 获取最终的结果","link":"/2018/06/22/JavaScript/40/"},{"title":"Zepto 架构设计","text":"最近看了 zepto 设计和源码分析 ，耳目一新，作者没有老套的去讲各个方法怎么实现的，能做些什么 而是讲了许多为什么源码要这样去设计，这样设计有什么好处，也分享了一些自己的看源码心得 一口气看完，收货良多，不光了解了 Zepto 的设计理念，同时也重温了 JavaScript 原型链的一些相关知识，在此记录一些笔记和涉及到的一些知识点 同时也感谢作者分享了加注版本的 zepto 源码，这样读起来也轻松不少，地址见：zepto-core-1.1.6 源码注视 大体结构看了以后会发现，这一类库的最外层的设计都是大同小异的 123456789101112131415161718192021222324252627282930313233343536var Zepto = (function () { var $, zepto = {} // ... // 一些判断方法，初始化操作 zepto.init = function (selector, context) { // ... return zepto.Z(dom, selector) } $ = function (selector, context) { return zepto.init(selector, context) } // ... // 一些挂载在 $ 上的方法，比如 $.each，$.map 等 // 这里是一些挂载在 $.fn 上的方法 $.fn = { ... } zepto.Z.prototype = $.fn // ... return $})()window.Zepto = Zeptowindow.$ === undefined &amp;&amp; (window.$ = Zepto) 首先，Zepto 是一个自执行的匿名函数（IIFE），最后挂载在 window 对象身上，window.Zepto 和 window.$ 都赋值给了 Zepto 这个变量 当我们平时在使用的时候，比如 $('div')，依次会按照以下顺序来执行 123456789101112131415161718192021$ = function(selector, context){ return zepto.init(selector, context)}==&gt;zepto.init = function(selector, context) { // ... return zepto.Z(dom, selector)}==&gt;zepto.Z = function(dom, selector) { dom = dom || [] dom.__proto__ = $.fn dom.selector = selector || '' return dom} 接下来，我们分步来看 zepto.init查看源码可以发现，其实 $ 也是一个函数（同理也可得知 Zepto 也是一个函数） 123$ = function(selector, context){ return zepto.init(selector, context)} 它本身并没没有做什么具体的操作，而是直接返回了一个函数 zepto.init(selector, context) 查看源码可知，init 函数中添加了一系列判断来梳理 selector 参数的各种可能，然后根据不同条件下对 DOM 变量进行赋值，最终，它将通过 selector 一起传递给 zepto.Z 函数并返回值 我们一条一条的来看 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768zepto.init = function (selector, context) { var dom // 如果 selector 为空（null，undefined...），即 $() 那么就直接返回一个空的 Zepto 对象 if (!selector) return zepto.Z() // 参数是 String 的情况（$('p')，$('&lt;div&gt;')） else if (typeof selector == 'string') { // 字符串的情况，一般有两种： // 第一，一段 html 代码，旨在通过 zepto 生成 dom 对象 // 第二，一段查询字符串，旨在通过 zepto 查找 dom 对象 // 将查询结果存储到 dom 变量中 // 先剔除掉两边的空格 selector = selector.trim() // fragmentRE = /^\\s*&lt;(\\w+|!)[^&gt;]*&gt;/ // 取出 html 代码中第一个 html 标签（或注释），如取出 &lt;p&gt;123&lt;/p&gt;&lt;h1&gt;345&lt;/h1&gt; 中的 &lt;p&gt; if (selector[0] == '&lt;' &amp;&amp; fragmentRE.test(selector)) // 第一，RegExp.$1 取出来的就是第一个标签名称，即正则中 (\\w+|!) 对应的内容 // 第二，此时的 context 应该传入的是 css 属性对象（这里会产生歧义，老版的不会传入 context） dom = zepto.fragment(selector, RegExp.$1, context), selector = null // 如果 selector 不是 html 字符串标签，并且 context 有值，则从 context 中查找 else if (context !== undefined) return $(context).find(selector) // 除了以上情况，就从整个 document 执行 qsa 的查找 // qsa 就是 document.querySelectAll else dom = zepto.qsa(document, selector) } // 如果是函数，则放在 dom ready 时执行 // 即 $(document).ready(function(){ ... }) else if (isFunction(selector)) return $(document).ready(selector) // 如果传入的参数本身就已经是 zepto 对象，则直接返回 else if (zepto.isZ(selector)) return selector else { // compact 函数，剔除数组中 == null（undefined） 的元素 if (isArray(selector)) dom = compact(selector) // 如果传入的是 object，直接强制塞进一个数组 else if (isObject(selector)) dom = [selector], selector = null // 从此往下，和上文 selector 是字符串的情况处理相同 // fragmentRE.test 即判断字符串是否是 html 标签开头（即是否是 html fragement） else if (fragmentRE.test(selector)) // 此时，context 也是属性集合，不是容器（这里会产生歧义，老版的不会传入 context） // 然后清空 selector 不妨碍下面的判断 dom = zepto.fragment(selector.trim(), RegExp.$1, context), selector = null else if (context !== undefined) return $(context).find(selector) else dom = zepto.qsa(document, selector) } // 最后通过 zepto.Z 创建了对象 // 这里的 dom 其实就是一个数组 return zepto.Z(dom, selector)} 最后 init 函数的结构梳理如下： 1234567891011121314zepto.init = function (selector, context) { var dom // 分情况对 dom 赋值： // 1. selector 为空 // 2. selector 是字符串，其中又分好几种情况 // 3. selector 是函数 // 4. 其他情况，例如 selector 是数组、对象等 // 最后返回 return zepto.Z(dom, selector)} zepto.Z先来看看之前的 zepto.Z 的实现： 12345678910111213zepto.Z = function (dom, selector) { // 首先，dom 是一个数组 dom = dom || [] // 然后把它的隐式原型（__proto__）赋值给 $.fn dom.__proto__ = $.fn dom.selector = selector || '' return dom} 首先需要明确，每一个函数，都有一个 prototype 的属性，同时又有一个 constructor 属性，指向该函数自身，如下图所示： 所有通过函数 new 出来的对象，都有一个 __proto__（隐式原型）指向这个函数的 prototype（显式原型） 12var arr = []; // 相当于 new Array()arr.__proto__ === Array.prototype; // true 所以当你想要使用一个对象（或者一个数组）的某个功能时： 如果该对象本身具有这个功能，则直接使用 如果该对象本身没有这个功能，则去 __proto__ 中找（即构造函数的原型链上） 这就是为何数组会有 concat、push 等方法，因为这些方法都存在于 Array.prototype 中 这也就解释了为什么 Zepto 取得的元素数组（$('p') 返回的是一个元素数组）上会有类似 addClass 等方法了，原因就是 __proto__ 肯定是被修改过的，而不仅仅是 Array.prototype 这样再去看上面的 zepto.Z 函数就很明了了 新版的 zepto.Z 函数如下： 12345678910111213141516function Z(dom, selector) { var i, len = dom ? dom.length : 0 for (i = 0; i &lt; len; i++) this[i] = dom[i] this.length = len this.selector = selector || ''}zepto.Z = function (dom, selector) { return new Z(dom, selector)}$.fn = { // ...}zepto.Z.prototype = Z.prototype = $.fn 相较于老版，新版的 zepto.Z 函数直接将构造函数的原型修改了，即 Z.prototype = $.fn 经过这样一改，构造函数再 new 出来的对象的隐式原型 __proto__ 自然就指向了 $.fn，而这时返回的是一个对象数组，相对于之前的单纯数组，本质上更灵活一些 区别如下之前的 zepto.Z 函数 现在的 zepto.Z 函数 Zepto 整体的设计就是以上这些了，明白了 __proto__（隐式原型）和 prototype（显式原型）再来看的话就会清晰不少 其他各个函数，方法的实现，就慢慢去读源码来摸索认识了","link":"/2019/05/28/JavaScript/41/"},{"title":"Node.js 中的 co 模块","text":"Node.js 中的 co 模块主要用于 Generator 函数的自动执行，可以使我们以同步的形式编写异步代码 实例一先来看两个对比实例，传统方式下，sayhello 是一个异步函数，执行 helloworld 会先输出 'world' 再输出 'hello'： 1234567891011121314151617181920setTimeout(() =&gt; { console.log('!')}, 0);function sayhello() { return Promise.resolve('hello').then(function (hello) { console.log(hello); });}function helloworld() { sayhello(); console.log('world');}helloworld();// 'world'// 'hello'// ! 这是因为 promise 是基于任务队列机制（Microtasks）的，即当前代码执行完的时候才会触发，但是会在下一个 Event Loop 之前执行（相较于 setTimeout） 实例二而使用 co 的方式，会先输出 'hello' 再输出 'world'： 123456789101112131415161718192021function co(gen) { var it = gen(); var ret = it.next(); ret.value.then(function (res) { it.next(res); });}function sayhello() { return Promise.resolve('hello').then(function (hello) { console.log(hello); });}co(function* helloworld() { yield sayhello(); console.log('world');});// 'hello'// 'world' 从上面示例可以看出，generator 函数体可以挂载在 yield 语句处，直到下一次执行 next() co 模块的思路就是利用 generator 的这个特性，将异步操作跟在 yield 后面，当异步操作完成并返回结果后，再触发下一次 next() ，当然，跟在 yield 后面的异步操作需要遵循一定的规范 thunks 和 promises 而我们模拟实现的 co 函数，首先生成一个迭代器，然后执行一遍 next()，得到的 value 是一个 promise 对象，promise.then() 里面再执行 next() 简单来说，co 的主要功能分为 异步流程控制，依次执行 generator 函数内的每个位于 yield 后的 promise 对象，并在 promise 的状态改变后，把其将要传递给 reslove 函数的结果或传递给 reject 函数的错误返回出来，可供外部来进行传递值等操作，这些 promise 是串行执行的 若 yield 后是 promise 对象的数组或属性值是 promise 对象的对象，则返回出结构相同的 promise 执行结果数组（对象），并且这些 promise 是并行执行的 co 自身的返回值也是一个 promise 对象，可供继续使用 源码剖析下面就来看看 co 源码中具体是怎样实现的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// co 的核心代码如下function co(gen) { // 保持当前函数的上下文 var ctx = this; // 截取 co 输入的参数，剔除 arguments 中的第一个参数，即 gen 对象，剩余参数作为 gen 的入参 var args = slice.call(arguments, 1) // co 函数整个的返回值是一个 promise 实例，包装了传递的 generator 函数内所有 promise 的执行 // 这也是它为什么可以使用 then 和 catch 的根源 return new Promise(function (resolve, reject) { // 判断传入的 gen 是否为函数，如果是则执行，将结果赋值给 gen 对象 if (typeof gen === 'function') gen = gen.apply(ctx, args); // 根据 generator 函数执行结果是否存在 next 字段，判断 gen 是否为 generator 迭代器对象 // 若不是，则调用 resolve 返回最外层的 promise 对象状态 if (!gen || typeof gen.next !== 'function') return resolve(gen); // 如果是 generator 迭代器对象，开始控制 gen.next() 方法的调用 // 调用入口函数，成功方法 onFulfilled(); // 入口函数，将传递进来的 generator 函数执行到第一个 yield 处来开启第一次的异步调用 // 另外也用作内部使用，作为 resolve 方法，处理异步结果，并继续调用下一个 promise function onFulfilled(res) { var ret; try { // res 为此次调用的 Peomise 结果 // 利用 generator 函数的特性，调用 next() 方法的参数，会作为 yield 的返回值 // 并将异步操作的结果返回给 ret.value ret = gen.next(res); } catch (e) { // 如果发生错误，则把 Peomise 状态指为 rejected，并且把错误结果返回出去 return reject(e); } // 将 generator 函数执行 next() 后的结果再次传入 next() 方法，实现串行调用 next(ret); } // 上面的 onFulfilled 函数作为内部的成功方法，下面这个则作为失败方法 // 实现和上面类似 function onRejected(err) { var ret; try { ret = gen.throw(err); } catch (e) { return reject(e); } next(ret); } // 首先需要明确，generator 函数在执行完毕后会返回 { done: true, value: undefined } function next(ret) { // 如果执行完成，直接调用 resolve 把 promise 置为成功状态 if (ret.done) return resolve(ret.value); // 然后把 yield 的值（ret.value）转换成 promise（ctx 为上面保存的 this） // 支持 promise，generator，generatorFunction，array，object var value = toPromise.call(ctx, ret.value); // 成功转换就可以直接给新的 promise 添加 onFulfilled, onRejected // 当新的 promise 状态变成结束态（成功或失败），就会调用对应的回调，整个 next 链路就执行下去了 // 之所以可以一直 next() 下去，这是因为上面的 ret.value 是一个 Peomise 对象 // 当 return value.then(onFulfilled, onRejected) 以后，意味着又要去执行上面的 onFulfilled 了 // 然后会在 onFulfilled 里面再次去调用 next(ret) // 这样就会一直循环下去，直到完成整个链的操作 if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected); // 如果以上情况都没发生，则参数为非 thunk 函数和 promise 对象 // 那么就将 promise 对象的状态改为 rejected，从而终止执行 return onRejected(new TypeError('You may only yield a function, promise, generator, array, or object, ' + 'but the following object was passed: \"' + String(ret.value) + '\"')); } });} 核心代码入口是 onFulfilled，无论如何第一次的 next(ret) 是一定要执行的，因为 generator 必须要 next() 一下的 但是 co 实际上有两种调用方式，分为有参数和无参数的，很明显以上是无参数的 generator 执行器，那么有参数的 wrap 呢？co 为我们提供了简单的包装 123456789// 为有参数的 generator 调用，提供简单包装co.wrap = function (fn) { createPromise.__generatorFunction__ = fn; return createPromise; function createPromise() { // 把 arguments 给 fn 当参数 return co.call(this, fn.apply(this, arguments)); }}; 通过 call 和 apply 的组合使用来传递 arguments 辅助函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// 将传入的参数对象转换为 Promise 对象function toPromise(obj) { if (!obj) return obj; // 如果 obj 已经是 Promise 对象，则直接返回 if (isPromise(obj)) return obj; // 如果 generator 是函数或对象，则直接把 obj 作为参数传入 co 函数，并返回 if (isGeneratorFunction(obj) || isGenerator(obj)) return co.call(this, obj); // 如果 obj 是函数，则直接视为符合 thunk 规范的函数直接转换为 Promise // 关于 thunk 函数可以参考 阮一峰老师的 Thunk 函数的含义和用法 if ('function' == typeof obj) return thunkToPromise.call(this, obj); // 如果是数组，把数组中每个元素转化为内部 Promise，然后使用 Promise.all 并行计算 if (Array.isArray(obj)) return arrayToPromise.call(this, obj); // 如果是对象，则遍历对象中的每个 key 对应的 value，然后使用 Promise.all 并行计算 if (isObject(obj)) return objectToPromise.call(this, obj); // 最后返回 return obj;}// 这里的 obj 为数组// 所以使用 Array.map 方法，分别对数组中的每一个元素递归执行 toPromise 方法// 再利用 Promise.all 方法，在所有给定的可迭代完成时执行 resolve（或者第一个代码失败）并返回结果function arrayToPromise(obj) { return Promise.all(obj.map(toPromise, this));}// thunk 转为 promisefunction thunkToPromise(fn) { var ctx = this; return new Promise(function (resolve, reject) { fn.call(ctx, function (err, res) { if (err) return reject(err); if (arguments.length &gt; 2) res = slice.call(arguments, 1); resolve(res); }); });}// 这里的 obj 为对象function objectToPromise(obj) { // results 是将用于返回的对象，使用和 obj 相同的构造函数 var results = new obj.constructor(); // Object.keys 方法用于返回对象的所有的属性名 var keys = Object.keys(obj); // 用于保存所有对象属性的 Promise 的数组 var promises = []; // 利用 for 循环来实现并行的异步调用 for (var i = 0; i &lt; keys.length; i++) { var key = keys[i]; // 转换为 Promise 对象 var promise = toPromise.call(this, obj[key]); // 如果是 promise 对象，直接调用 defer 函数，添加到 promises 数组中，否则直接将结果返回给 result[key] if (promise &amp;&amp; isPromise(promise)) defer(promise, key); else results[key] = obj[key]; } // 将 Promise 数组传入 Promise.all，待 defer 函数中 results 对象的属性都赋值完毕后，返回最终的 results 对象 // 使得后续调用的 then() 可以获得此处的 results return Promise.all(promises).then(function () { return results; }); // key 对应的元素成功转化为 Promise 对象后，调用 Promise 的 resovle 方法 // 以便在 results 中获取每个 Promise 对象成功执行后的结果 function defer(promise, key) { results[key] = undefined; promises.push(promise.then(function (res) { results[key] = res; })); }} 经过上面这些步骤，我们可以得到 yield 后面只能是函数、Promise 对象、Generator 函数、Generator 迭代器对象、数组（元素仅限之前的 4 类）和 Object（对应 value 仅限定之前的 4 类） 现在可以把 co 串行调用 generator 函数中 yield 的过程总结如下： 首先进入最外层的 promise 通过入口 onFilfilled() 方法，将 generator 函数运行至第一个 yield 处，执行该 yield 后边的异步操作，并将结果传入 next 方法 如果 next 中传入结果的 done 为 true（已经完成），则返回最外层 promise 的 resolve 如果 next 中传入结果的 done 为 fasle（表示还没执行完），则返回 value（即 yield 后边的对象）然后查看是否可以转化为内部 promise 对象。如无法转化则抛出错误，返回最外层 promise 的 reject 若能转化为 promise 对象，则通过 then(onFilfilled, onRejected) 开始执行 在 onFilfilled() 或者 onRejected() 内部调用再次调用 next() 方法，实现串行执行 yield，并将 yield 后边的对象传递给 next()，依次重复（实现链式调用） 所有 yield 执行返回，将最后的 return 值返回给最外层 promise 的 resovle 方法，结束 co 对 generator 函数的调用 run 函数一个类似的方法函数，目的也是为了 Generator 函数的自动执行 1234567891011121314151617181920212223242526272829function run(gen) { var args = [].slice(arguments, 1), it; // 在当前上下文中初始化生成器 it = gen.apply(this, args) // 返回一个 promise 用于生成器完成 return Promise.resolve().then(function handleNext(value) { // 对下一个 yield 出的值运行 var next = it.next(value) return (function handleResult(next) { // 生成器运行完毕了吗 if (next.done) { return next.value // 否则继续运行 } else { // 成功就恢复异步循环，把决议的值发回生成器 // 如果 value 是被拒绝的 promise // 就把错误传回生成器进行错误处理 return Promise.resolve(next.value).then(handleNext, function handleErr(err) { return Promise.resolve(it.throw(err)).then(handleResult) }) } })(next) })} 参考： co co 4.6源码解析 Thunk 函数的含义和用法 co 和 koa 异步流程控制：7 行代码学会 co 模块","link":"/2019/01/02/Node/02/"},{"title":"SuperAgent 模块","text":"SuperAgent 是 Node.js 里一个非常方便的客户端请求代理模块，当你想处理 get，post，put，delete，head 请求时，你就应该想起该用它了 123456789101112request .post('/api/age') .send({ name: 'Manny', species: 'cat' }) .set('X-API-Key', 'foobar') .set('Accept', 'application/json') .end(function (err, res) { if (err || !res.ok) { alert('Oh no! error'); } else { alert('yay got ' + JSON.stringify(res.body)); } }); 基本请求初始化一个请求可以通过调用 request 模块中适当的方法，然后使用 .end() 来发送请求，例如一个简单的 GET 请求 1234request .get('/search') .end(function (err, res) { }); 请求方法也可以通过参数传递: 1request('GET', '/search').end(callback); 同时也支持 ES6，可以使用 .then() 来代替 .end() 1request('GET', '/search').then(success, failure); Node.js 客户端也允许提供绝对路径: 1234request .get('http://example.com/search') .end(function (err, res) { }); delete，head，post，put 和别的 http 请求都可以使用，只需要简单的改变方法名称 不过需要注意的是，delete 是一个特列，因为它是系统保留的关键字，所以应该用 .del() 这个名字 1234request .del('/user/1') .end(function (err, res) { }); http 请求默认的方法为 get，所以就像你看到的，下面的这个例子也是可用的 1request('/search', function (err, res) { }); 设置头字段设置头字段非常简单，只需调用 .set() 方法，传递一个名称和值就行 12345request .get('/search') .set('API-Key', 'foobar') .set('Accept', 'application/json') .end(callback) 也可以直接传递一个对象，这样一次就可以修改多个头字段 1234request .get('/search') .set({ 'API-Key': 'foobar', Accept: 'application/json' }) .end(callback) GET 请求当使用 get 请求传递查询字符串的时候，用 .query() 方法，传递一个对象就可以，下面的代码将产生一个 /search?query=Manny&amp;range=1..5&amp;order=desc 请求 12345678request .get('/search') .query({ query: 'Manny' }) .query({ range: '1..5' }) .query({ order: 'desc' }) .end(function (err, res) { // ... }) 或者传递一个对象： 123456request .get('/search') .query({ query: 'Manny', range: '1..5', order: 'desc' }) .end(function (err, res) { // ... }); .query() 方法也可以传递字符串: 123456request .get('/queryString') .query('search=Manny&amp;range=1..5') .end(function (err, res) { // ... }); POST/PUT 请求一个典型的 json post 请求看起来就像下面的那样，设置一个合适的 Content-type 头字段，然后写入一些数据，在这个例子里只是 json 字符串 12345request .post('/user') .set('Content-Type', 'application/json') .send('{\"name\": \"zhangsan\", \"age\": \"20\"}') .end(callback) 因为 json 非常通用，所以就作为默认的 Content-type，下面的例子跟上面的一样 123request.post('/user') .send({ name: 'zhangsan', age: '20' }) .end(callback) 或者调用多次 .send() 方法 1234request.post('/user') .send({ name: 'zhangsan' }) .send({ age: '20' }) .end(callback) 默认发送字符串将设置 Content-Type 为 application/x-www-form-urlencoded，多个请求将使用 &amp; 连接，这里结果是 name=zhangsan&amp;age=20 1234request.post('/user') .send('name=zhangsan') .send('age=20') .end(callback); superagent 的请求数据格式化是可以扩展的，不过默认支持 form 和 json 两种格式 想发送数据以 application/x-www-form-urlencoded 类型的话，则可以简单的调用 .type() 方法传递 form 参数就行 这里默认是 json，下面的请求将会 postname=zhangsan&amp;age=20 内容 12345request.post('/user') .type('form') .send({ name: 'zhangsan' }) .send({ age: '20' }) .end(callback) 注意：form 是 form-data 和 urlencoded 的别名，为了向后兼容 设置 Content-Type常见的方案是使用 .set() 方法： 12request.post('/user') .set('Content-Type', 'application/json') 一个简便的方法是调用 .type() 方法，传递一个规范的 MIME 名称，包括 type/subtype，或者一个简单的后缀就像 xml，json，png 这样，例如 12345678request.post('/user') .type('application/json')request.post('/user') .type('json')request.post('/user') .type('png') 设置接受类型跟 .type() 简便方法一样，这里也可以调用 .accept() 方法来设置接受类型，这个值将会被 request.types 所引用 支持传递一个规范的 MIME 名称，包括 type/subtype，或者一个简单的后缀就像 xml，json，png 例如 12345678request.get('/user') .accept('application/json')request.get('/user') .accept('json')request.post('/user') .accept('png') 查询字符串当用 .send(obj) 方法来发送一个 post 请求，并且希望传递一些查询字符串，可以调用 .query() 方法,比如向 ?format=json&amp;dest=/login 发送 post 请求 123456request .post('/') .query({ format: 'json' }) .query({ dest: '/login' }) .send({ post: 'data', here: 'wahoo' }) .end(callback); 解析响应内容superagent 会解析一些常用的格式给请求者，当前支持 application/x-www-form-urlencoded，application/json，multipart/form-data JSON/Urlencodedres.body 是解析后的内容对象，比如一个请求响应 '{'user': {'name': '20'}}' 字符串，res.body.user.name 将会返回 20，同样的，x-www-form-urlencoded 格式的 user[name] = 20 解析完的值，也是一样的 MultipartNode.js 客户端通过 Formidable 模块支持 multipart/form-data，当解析 multipart 返回时，对象 res.files 对你也是可用的，假设例如一个请求响应如下 multipart 结构 1234567891011--whoopContent - Disposition: attachment; name = 'image'; filename = '20.png'Content - Type: image / png ... data here ...--whoopContent - Disposition: form - data; name = 'name'Content - Type: text / plainTobi--whoop-- res.body.name 将为 'Tobi'，res.files.image 作为一个 File 对象包含磁盘地址、文件名、和其他属性 响应属性res.text 包含未解析前的响应内容，一般只在 mime 类型能够匹配 text/，json，x-www-form-urlencoding 的情况下，默认为 nodejs 客户端提供，这是为了节省内存，因为当响应以文件或者图片大内容的情况下影响性能 res.body 跟请求数据自动序列化一样，响应数据也会自动的解析，当为一个 Content-Type 定义一个解析器后，就能自动解析，默认解析包含 application/json 和 application/x-www-form-urlencoded，可以通过访问 res.body 来访问解析对象 res.header 包含解析之后的响应头数据，键值都是 Node.js 处理成小写字母形式，比如 res.header['content-length'] res.type Content-Type 响应头字段是一个特列，服务器提供 res.type 来访问它，默认 res.charset 是空的,如果有的话，则自动填充，例如 Content-Type 值为 text/html; charset = utf8，则 res.type 为 text/html，res.charst 为 utf8 利用 SuperAgent 完成一个简单的爬虫123456789101112131415161718192021222324252627282930313233343536var express = require('express');var superagent = require('superagent');var cheerio = require('cheerio');var app = express();app.get('/', function (req, res, next) { // 用 superagent 去抓取 https://cnodejs.org 的内容 superagent.get('https://cnodejs.org') .end(function (err, sres) { if (err) { return next(err); } // sres.text 里面存储着网页的 html 内容，将它传给 cheerio.load 之后 // 就可以得到一个实现了 jQuery 接口的变量，我们习惯性的将它命名为 '$' var $ = cheerio.load(sres.text); var items = []; $('#topic_list .topic_title').each(function (index, element) { var $element = $(element); var $author = $('.user_avatar img'); items.push({ title: $element.attr('title'), href: $element.attr('href'), author: $author.attr('title') }) }) res.send(items) })})app.listen('3000', function (req, res) { console.log('app is running at port 3000')}) 完善一下上面的例子，使用 eventproxy 控制并发 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859var eventproxy = require('eventproxy');var superagent = require('superagent');var cheerio = require('cheerio');var url = require('url');var cnodeUrl = 'https://cnodejs.org/';superagent.get(cnodeUrl).end(function (err, res) { if (err) { return console.error(err); } var topicUrls = []; var $ = cheerio.load(res.text); // 获取首页所有链接 $('#topic_list .topic_title').each(function (index, element) { var $element = $(element); // href 原本是 /topic/542acd7d5d28233425538b04 // 利用 url.resolve(from, to) 拼接成完整的 'https://cnodejs.org/topic/581b0c4ebb9452c9052e7acb' var href = url.resolve(cnodeUrl, $element.attr('href')); topicUrls.push(href); }) // 得到 topicUrls 之后 // 创建一个 eventproxy 的实例 var ep = new eventproxy(); // 命令 ep 重复监听 topicUrls.length 次（在这里也就是 40 次） `topic_html` 事件再行动 ep.after('topic_html', topicUrls.length, function (topics) { // topics 是个数组，包含了 40 次 ep.emit('topic_html', pair) 中的那 40 个 pair topics = topics.map(function (topicPair) { var topicUrl = topicPair[0]; var topicHtml = topicPair[1]; var $ = cheerio.load(topicHtml); return ({ title: $('.topic_full_title').text().trim(), href: topicUrl, comment1: $('.reply_content').eq(0).text().trim(), }); }); console.log('final:'); console.log(topics); }); topicUrls.forEach(function (topicUrl) { superagent.get(topicUrl) .end(function (err, res) { console.log('fetch ' + topicUrl + ' successful'); ep.emit('topic_html', [topicUrl, res.text]); }); });})","link":"/2018/07/22/Node/03/"},{"title":"Stream（流）","text":"这篇是早期初学 Node.js 时期整理的文章，最近又在温习相关内容，所以翻出来重新更新一下 什么是 StreamStream 的概念最早来源于 Unix 系统，其可以将一个大型系统拆分成一些小的组件，然后将这些小的组件可以很好地运行 TCP/IP 协议中的 TCP 协议也用到了 Stream 的思想，进而可以进行流量控制、差错控制 在 unix 中通过 | 来表示流，在 Node.js 中通过 pipe() 方法 Stream 可以认为数据就像管道一样，多次不断地被传递下去，而不是一次性全部传递给下游 Node.js 中的流在 Node.js API 文档 中可以看到下面一段话 123A stream is an abstract interface implemented by various objects in Node. For example a request to an HTTP server is a stream, as is stdout. Streams are readable, writable, or both. All streams are instances of EventEmitter 简单来说 Stream 是 Node.js 中一个非常重要的概念，被大量对象实现，尤其是 Node.js 中的 I/O 操作 Stream 是一个抽像的接口，一般不会直接使用，需要实现内部的某些抽象方法(例如 _read、_write、_transform) Stream 是 EventEmitter 的子类，实际上 Stream 的数据传递内部依然是通过事件（data）来实现的 流的分类在 Node.js 中有四种类型的流：readable、writeable、Duplex 和 transform readable – 可读流，表示数据能够被消费，例如可以通过 fs.createReadStream() 方法创建可读流 writeable – 可写流，表示数据能被写，例如可以通过 fs.createWriteStream() 方法创建可写流 duplex – 即表示既是 Readable 流也是 Writable 流，如 TCP Socket transform – 它也是 Duplex 流，能够用来修改或转换数据，例如 zlib.createGzip 方法用来使用 gzip 压缩数据 你可以认为 transform 流是一个函数，它的输入是 Writable 流，输出是 Readable 流 使用情景 类 需要重写的方法 只读 Readable _read 只写 Writable _write 双工 Duplex _read，_write 操作被写入数据，然后读出结果 Transform _transform，_flush 此外所有的流都是 EventEmitter 的实例，它们能够监听或触发事件，用于控制读取和写入数据，Readable 与 Writable 流支持的常见的事件和方法如下图所示： 下面我们就一个一个来分类介绍 Readable可读流（Readable streams）是对提供数据的源头（source）的抽象 可读流事实上工作在下面两种模式之一：flowing 和 paused 在 flowing 模式下，可读流自动从系统底层读取数据，并通过 EventEmitter 接口的事件尽快将数据提供给应用 在 paused 模式下，必须显式调用 stream.read() 方法来从流中读取数据片段 那如何触发这两种模式呢： paused mode – 调用 pause 方法（没有 pipe 方法）、移除 data 事件和释放所有 pipe flowing mode – 注册事件 data、调用 resume 方法、调用 pipe 方法 如下所示： 12345678910111213141516171819202122232425262728// data 事件触发 flowing modeReadable.prototype.on = function (ev, fn) { // ... if (ev === 'data' &amp;&amp; false !== this._readableState.flowing) { this.resume(); } // ...}// resume 触发 flowing modeReadable.prototype.resume = function () { var state = this._readableState; if (!state.flowing) { debug('resume'); state.flowing = true; resume(this, state); } return this;}// pipe 方法触发 flowing 模式Readable.prototype.resume = function () { if (!state.flowing) { this.resume() }} 简单来说，两种模式取决于一个 flowing 字段： 123true ==&gt; flowing modefalse ==&gt; paused mode 上面三种方式最后均是通过 resume 方法，将 state.flowing = true 可读流的两种操作模式是一种简单抽象，它抽象了在可读流实现（Readable stream implementation）内部发生的复杂的状态管理过程 在任意时刻，任意可读流应确切处于下面三种状态之一： 12345readable._readableState.flowing = nullreadable._readableState.flowing = falsereadable._readableState.flowing = true 若 readable._readableState.flowing 为 null，由于不存在数据消费者，可读流将不会产生数据 如果监听 data 事件，调用 readable.pipe() 方法，或者调用 readable.resume() 方法，readable._readableState.flowing 的值将会变为 true，这时，随着数据生成，可读流开始频繁触发事件 调用 readable.pause() 方法，readable.unpipe() 方法， 或者接收背压（back pressure），将导致 readable._readableState.flowing 值变为 false，这将暂停事件流，但不会暂停数据生成 当 readable._readableState.flowing 值为 false 时， 数据可能堆积到流的内部缓存中 需要注意的是：应该选择其中一种来消费数据，而不应该在单个流使用多种方法来消费数据 对于大多数用户，建议使用 readable.pipe() 方法来消费流数据，因为它是最简单的一种实现 如果要精细地控制数据传递和产生的过程，可以使用 EventEmitter 和 readable.pause() / readable.resume() 提供的 API paused mode在 paused mode 下，需要手动地读取数据，并且可以直接指定读取数据的长度: 123456789var Read = require('stream').Readable;var r = new Read();r.push('hello');r.push('world');r.push(null);console.log(r.read(1).toString()) // hconsole.log(r.read(3).toString()) // ell 还可以通过监听事件 readable，触发时手工读取 chunk 数据: 12345678910111213var Read = require('stream').Readablevar r = new Read()r.push('hello')r.push('world')r.push(null)r.on('readable', function() { var chunk = r.read() console.log(chunk.toString())})// helloworld 需要注意的是，一旦注册了 readable 事件，必须手工读取 read 数据，否则数据就会流失，看看内部实现： 123456789101112131415161718192021222324252627function emitReadable_(stream) { debug('emit readable'); stream.emit('readable'); flow(stream);}function flow(stream) { var state = stream._readableState; debug('flow', state.flowing); if (state.flowing) { do { var chunk = stream.read(); } while (null !== chunk &amp;&amp; state.flowing); }}Readable.prototype.read = function (n) { // ... var res = fromList(n, state); if (!util.isNull(ret)) { this.emit('data', ret); } // ...} flow 方法直接 read 数据，将得到的数据通过事件 data 交付出去，然而此处没有注册 data 事件监控 因此，得到的 chunk 数据并没有交付给任何对象，这样数据就白白流失了，所以在触发 emit('readable') 时，需要提前 read 数据 flowing mode通过注册 data、pipe、resume 可以自动获取所需要的数据，比如通过事件 data 的方式 12345678910111213var Read = require('stream').Readable;var r = new Read();r.push('hello');r.push('world');r.push(null)r.on('data', function (chunk) { console.log(chunk.toString())})// hello // world 或者通过 pipe 的方式 12345678910var Read = require('stream').Readablevar r = new Read()r.push('hello')r.push('world')r.push(null)r.pipe(process.stdout)// helloworld 以上两种 mode 总体如下： readable 与 data 事件read() 是 Readable 流的基石，无论流处于什么模式，只要是涉及读取数据最终都会转到 read() 上面来，它的主要功能是 读取缓冲区数据并返回给消费者，并按需发射各种事件 按需调用 _read()，_read() 会从底层汲取数据，并填充缓冲区 它的流程大致如下： 务必记住 read() 是同步的，因此它并不是直接从底层数据那里读取数据，而是从缓冲区读取数据，而缓冲区的数据则是由 _read() 负责补充 _read() 可以是同步或者异步，Node.js 内部的实现经常会调用 read(0)，因为参数是 0 所以不会破坏缓冲区中的数据和状态，但可以触发 _read() 来从底层汲取数据并填充缓冲区 _read() 是流实现者需要重写的函数，它从底层汲取数据并填充缓冲区（flowing 模式不会填充而是直接发送给消费者），它的大致流程如下 注意在 addChunk() 后会根据情况发射 readable 或者 data 事件，然后依次调用 1read() ==&gt; _read(0) ==&gt; ... ==&gt; addChunk() 从而形成一个循环，因为一旦调用了 _read() 之后，流就会默默在底层读取数据，直到数据都消耗完为止 readable 事件文档上关于 readable 事件的描述如下 事实上，readable 事件表明流有了新的动态：要么是有了新的数据，要么是到了流的尾部， 对于前者 stream.read() 将返回可用的数据，而对于后者 stream.read() 将返回 null 由此我们可以知道 readable 事件意味着 流有了新的数据（注意，这里只说明有了新数据，至于新数据如何读取是调用者自己的事情） 流到达了尾部 来看下面这个示例 1234567// 可以将 size 设为 1 或 undefined 来进行测试const size = 1;const rs = require('fs').createReadStream('./test.js');rs.on('readable', () =&gt; { console.log(rs.read(size));}); 总之，readable 只是负责通知用户流有了新的动态，事件发生的时候是否读取数据，如何读取数据则是调用者的事情（如果一直不读取事件，则数据会存在于缓冲区中） 例如可以给 readable 注册一个回调函数，该回调函数调用无参的 read()，它会读取并清空缓冲区的全部数据，这样就使得每次 readable 发生的时候都可以读取到最新的数据 readable 的触发时机readable 在以下几种情况会被触发： 在 onEofChunk 中，且 _read() 从底层汲取的数据为空，这个场景意味着流中的数据已经全部消耗完 在 addChunk() 中，且 _read() 从底层汲取的数据不为空且处于 pause 模式，这个场景意味着流中有新数据 在 read(n) 中，且 n 为 0 是的某些情况下 通过 on() 为 readable 添加监听器，如果此时缓冲区有数据则会触发，这个场景意味着流中已经有数据可供 read() 直接调用 data 事件data 事件的意义则明确很多，文档上关于 data 事件的描述如下 The ‘data’ event is emitted whenever the stream is relinquishing ownership of a chunk of data to a consumer. 与 readable 不同的是，data 事件代表的意义清晰单一：流将数据交付给消费者时触发，并且会将对应的数据通过回调传递给用户 data 的触发时机从源码来看，有两个地方会触发 data 事件 在 read() 中，如果缓冲区此时有数据可以返回给调用者，这种情况只会在调用 pipe() 时候发生，如果 readable() 被暂停过并重新启动，此时缓冲区内残留的数据会通过 read() 读出然后借助 data 事件传递出去 在 addChunk() 中，此时 _read() 从底层汲取的数据不为空，且满足以下条件 处于 flowing 模式 缓冲区为空 处于异步调用模式 在这种情况下，数据直接就交付给消费者了，并没有在缓冲区缓存 而文档中的说法是： 当流转换到 flowing 模式时会触发该事件，调用 readable.pipe()， readable.resume() 方法，或为 data 事件添加回调可以将流转换到 flowing 模式， data 事件也会在调用 readable.read() 方法并有数据返回时触发 似乎两者不太一致？其实本质上调用 readable.pipe()、readable.resume() 或为 data 事件添加回调，最终都会依次调用 1read() ==&gt; _read() ==&gt; addChunk() 然后最终才进行发射 data 事件，结合 _read() 的流程图，可以发现，通过 on() 为 readable 和 data 事件添加监听器后，程序就开始循环汲取底层数据直至消耗完为止 如果同时监听 readable 和 data 事件如下示例 1234const rs = require('fs').createReadStream('./test.js');rs.on('readable', () =&gt; console.log('readable 触发'));rs.on('data', console.log); 运行结果如下 12&lt;Buffer 63 6f 6e 73 74 20 72 73 20 3d 20 72 65 71 75 69 72 65 28 27 66 73 27 29 2e 63 72 65 61 74 65 52 65 61 64 53 74 72 65 61 6d 28 27 2e 2f 74 65 73 74 2e ... &gt;readable 触发 从上面的流程图我们知道，在 addChunk() 中当有新数据到来的时候，redable 和 data 都有可能触发，那究竟触发哪个？让我们来看看 addChunk() 的源码 123456789101112131415161718192021function addChunk(stream, state, chunk, addToFront) { // 如果处于 flowing 模式，且缓冲区为空，且为异步调用时候，触发 data 事件 if (state.flowing &amp;&amp; state.length === 0 &amp;&amp; !state.sync) { state.awaitDrain = 0; stream.emit('data', chunk); } else { // 更新缓冲区已有数据数量 state.length += state.objectMode ? 1 : chunk.length; if (addToFront) // 插入缓冲区头部 state.buffer.unshift(chunk); else // 插入缓冲区尾部 state.buffer.push(chunk); if (state.needReadable) // 触发 readable 事件 emitReadable(stream); } maybeReadMore(stream, state);} 由于为 data 事件添加回调会使得流进入 flowing 模式，因此我们的例子中，有新数据时只会发射 data 事件，而 readable 事件则流结束的时候发射一次 Writable所有 Writable 流都实现了 stream.Writable 类定义的接口 尽管特定的 Writable 流的实现可能略有差别， 所有的 Writable streams 都可以按一种基本模式进行使用，如下 1234567const myStream = getWritableStreamSomehow();myStream.write('some data');myStream.write('some more data');myStream.end('done writing data'); 本质上 只是需要实现的是 _write(data, enc, next) 方法 1234567891011121314151617181920212223const Writable = require('stream').Writableconst writable = Writable()// 实现 _write 方法// 这是将数据写入底层的逻辑writable._write = function (data, enc, next) { // 将流中的数据写入底层 process.stdout.write(data.toString().toUpperCase()) // 写入完成时，调用 next() 方法通知流传入下一个数据 process.nextTick(next)}// 所有数据均已写入底层writable.on('finish', () =&gt; process.stdout.write('DONE'))// 将一个数据写入流中writable.write('a' + '\\n')writable.write('b' + '\\n')writable.write('c' + '\\n')// 再无数据写入流时，需要调用 end() 方法writable.end() 上游通过调用 writable.write(data) 将数据写入可写流中，write() 方法会调用 _write() 将 data 写入底层 在 _write 方法中，当数据成功写入底层后，必须调用 next([err]) 告诉流开始处理下一个数据 next 的调用既可以是同步的，也可以是异步的 上游必须调用 writable.end(data) 来结束可写流，data 是可选的，此后，不能再调用 write 新增数据 在 end 方法调用后，当所有底层的写操作均完成时，会触发 finish 事件 Readable Stream 与 Writeable Stream二者的关系 Readable Stream 是提供数据的 Stream，外部来源的数据均会存储到内部的 buffer 数组内缓存起来 writeable Stream 是消费数据的 Stream，从 readable stream 中获取数据，然后对得到的 chunk 块数据进行处理，至于如何处理，就依赖于具体实现（也就是 _write 的实现） 首先看看 Readdable Stream 与 writeable stream 二者之间的流动关系 pipe 的流程stream 内部是从 readable stream 流到 writeable stream，有两种处理方法 pipe 连接两个 stream123456789101112131415161718var Read = require('stream').Readablevar Write = require('stream').Writablevar r = new Read()var w = new Write()r.push('hello')r.push('world')r.push(null)w._write = function(chunk, ev, cb) { console.log(chunk.toString()) cb()}r.pipe(w)// hello// world pipe 是一种最简单直接的方法连接两个 stream，内部实现了数据传递的整个过程，在开发的时候不需要关注内部数据的流动： 1234567891011121314151617181920Readable.prototype.pipe = function (dest, pipeOpts) { var src = this; // ... src.on('data', ondata); function ondata(chunk) { var ret = dest.write(chunk); if (false === ret) { debug('false write response, pause', src._readableState.awaitDrain); src._readableState.awaitDrain++; src.pause(); } } // ...} 附一张 pipe() 的流程图 事件 data + 事件 drain 联合实现1234567891011121314151617181920212223242526var Read = require('stream').Readablevar Write = require('stream').Writablevar r = new Read()var w = new Write()r.push('hello')r.push('world')r.push(null)w._write = function(chunk, ev, cb) { console.log(chunk.toString()) cb()}r.on('data', function(chunk) { if (!w.write(chunk)) { r.pause() }})w.on('drain', function() { r.resume()})// hello// world DuplexDuplex 实际上就是继承了 Readable 和 Writable 的一类流 所以，一个 Duplex 对象既可当成可读流来使用（需要实现 _read 方法），也可当成可写流来使用（需要实现 _write 方法） 12345678910111213141516171819202122232425262728var Duplex = require('stream').Duplexvar duplex = Duplex()// 可读端底层读取逻辑duplex._read = function () { this._readNum = this._readNum || 0 if (this._readNum &gt; 1) { this.push(null) } else { this.push(' ' + (this._readNum++)) }}// 可写端底层写逻辑duplex._write = function (buf, enc, next) { // a, b process.stdout.write('_write ' + buf.toString() + '\\n') next()}// 0, 1duplex.on('data', data =&gt; console.log('ondata', data.toString()))duplex.write('a')duplex.write('b')duplex.end() 上面的代码中实现了 _read 方法，所以可以监听 data 事件来消耗 Duplex 产生的数据 同时，又实现了 _write 方法，可作为下游去消耗数据 因为它既可读又可写，所以它有两端：可写端和可读端 可写端的接口与 Writable 一致，作为下游来使用，可读端的接口与 Readable 一致，作为上游来使用 下面是另外一个示例，读取从 A 到 Z 的字母 123456789101112131415161718192021const { Duplex } = require('stream');const inoutStream = new Duplex({ write(chunk, encoding, callback) { console.log(chunk.toString()); callback(); }, read() { this.push(String.fromCharCode(this.currentCharCode++)); if (this.currentCharCode &gt; 90) { this.push(null); } }});inoutStream.currentCharCode = 65;process.stdin.pipe(inoutStream).pipe(process.stdout);inoutStream.end() 我们将可读的 stdin 流传输到 duplex stream 当中以使用 callback()，然后将 duplex stream 本身传输到可写的 stdout 流以查看我们的输出结果 TransformTranform 继承自 Duplex，并已经实现了 _read 和 _write 方法 我们只需要实现将两者结合起来的 transform 方法即可，它具有 write 方法，我们可以使用它来推送数据 下面是一个简单的 transform stream 示例，它会将你的输入结果转换为大写 12345678910const { Transform } = require('stream');const upperCaseTr = new Transform({ transform(chunk, encoding, callback) { this.push(chunk.toString().toUpperCase()); callback(); }});process.stdin.pipe(upperCaseTr).pipe(process.stdout); 内置的 transform streamNode.js 有一些内置的 transform stream，比如 zlib 和 crypto 下面是一个使用 zlib.createGzip() 方法结合 fs 的 readable/writable 流实现的一个文件压缩示例 1234567const fs = require('fs');const zlib = require('zlib');const file = process.argv[2];fs.createReadStream(file) .pipe(zlib.createGzip()) .pipe(fs.createWriteStream(file + '.gz')); 上述示例可以将传递进来的文件进行 gzip 压缩，下面我们来稍微扩展一下 比如我们希望用户在运行时可以看到进度结果，并且在完成的时侯看到已经完成的提示 123456789const fs = require('fs');const zlib = require('zlib');const file = process.argv[2];fs.createReadStream(file) .pipe(zlib.createGzip()) .on('data', () =&gt; process.stdout.write('.')) .pipe(fs.createWriteStream(file + '.zz')) .on('finish', () =&gt; console.log('Done')); 在上面示例当中，我们也可以不使用 on 去监听其中的数据事件，而只需创建一个 transform stream 来追踪进度，然后将 .on() 方法替换为另一个 .pipe() 即可 123456789101112131415161718const fs = require('fs');const zlib = require('zlib');const file = process.argv[2];const { Transform } = require('stream');const reportProgress = new Transform({ transform(chunk, encoding, callback) { process.stdout.write('.'); callback(null, chunk); }});fs.createReadStream(file) .pipe(zlib.createGzip()) .pipe(reportProgress) .pipe(fs.createWriteStream(file + '.zz')) .on('finish', () =&gt; console.log('Done')); 注意上面示例当中的 callback() 方法的第二个参数，这样写是为了优先推送数据 在或者，我们需要在 gzip 压缩之前或之后对文件进行加密，和上面的示例一样，我们只需要按照我们想要的顺序添加另外一个 transform stream 即可 1234567891011121314151617181920const crypto = require('crypto');const fs = require('fs');const zlib = require('zlib');const file = process.argv[2];const { Transform } = require('stream');const reportProgress = new Transform({ transform(chunk, encoding, callback) { process.stdout.write('.'); callback(null, chunk); }});fs.createReadStream(file) .pipe(zlib.createGzip()) .pipe(crypto.createCipher('aes192', 'a_secret')) .pipe(reportProgress) .pipe(fs.createWriteStream(file + '.zz')) .on('finish', () =&gt; console.log('Done')); 当然，为了解压上面我们压缩过的内容，我们只需要以相反的顺序执行 crypto 和 zlib 即可 123456fs.createReadStream(file) .pipe(crypto.createDecipher('aes192', 'a_secret')) .pipe(zlib.createGunzip()) .pipe(reportProgress) .pipe(fs.createWriteStream(file.slice(0, -3))) .on('finish', () =&gt; console.log('Done')); 自定义 stream自定义 stream 很简单，只要实现相应的内部待实现方法就可以了，具体来说： readable stream：实现 _read 方法来解决数据的获取问题 writeable stream：实现 _write 方法来解决数据的去向问题 tranform stream：实现 _tranform 方法来解决数据存放在 buffer 前的转换工作 代码如下： 1234567891011121314151617181920212223242526// 自定义 readable stream 的实现var Stream = require('stream');var Read = Stream.Readable;var util = require('util');util.inherits(MyReadStream, Read);function MyReadStream(data, opt) { Read.call(this, opt); this.data = data || [];}MyReadStream.prototype._read = function () { var _this = this; this.data.forEach(function (d) { _this.push(d); }) this.push(null);}var data = ['aa', 'bb', 'cc'];var r = new MyReadStream(data);r.on('data', function (chunk) { console.log(chunk.toString());}) 总结在 Node.js 中有四种类型的流：readable、writeable、duplex 和 transform readable – 可读流，表示数据能够被消费，是对提供数据的源头（source）的抽象，工作在下面两种模式之一 在 flowing 模式下，可读流自动从系统底层读取数据，并通过 EventEmitter 接口的事件尽快将数据提供给应用 通过注册 data、pipe、resume 可以自动获取所需要的数据，比如通过事件 data 的方式 在 paused 模式下，必须显式调用 stream.read() 方法来从流中读取数据片段 在 paused mode 下，需要手动地读取数据，并且可以直接指定读取数据的长度 还可以通过监听事件 readable，触发时手工读取 chunk 数据 一旦注册了 readable 事件，必须手工读取 read 数据，否则数据就会流失 如何触发： paused mode – 调用 pause 方法（没有 pipe 方法）、移除 data 事件和释放所有 pipe flowing mode – 注册事件 data、调用 resume 方法、调用 pipe 方法 writeable – 可写流，表示数据能被写，所有 Writable 流都实现了 stream.Writable 类定义的接口 本质上 只是需要实现的是 _write(data, enc, next) 方法 在 _write 方法中，当数据成功写入底层后，必须调用 next([err]) 告诉流开始处理下一个数据 next 的调用既可以是同步的，也可以是异步的 上游必须调用 writable.end(data) 来结束可写流，data 是可选的，此后，不能再调用 write 新增数据 在 end 方法调用后，当所有底层的写操作均完成时，会触发 finish 事件 duplex – 实际上就是继承了 Readable 和 Writable 的一类流 一个 duplex 对象既可当成可读流来使用（需要实现 _read 方法），也可当成可写流来使用（需要实现 _write 方法） transform – 它也是 duplex 流，能够用来修改或转换数据，例如 zlib.createGzip 方法用来使用 gzip 压缩数据（内置的 transform stream） 你可以认为 transform 流是一个函数，它的输入是 Writable 流，输出是 Readable 流 Tranform 继承自 duplex，并已经实现了 _read 和 _write 方法 只需要实现将两者结合起来的 transform 方法即可，它具有 write 方法，我们可以使用它来推送数据 推荐一下这篇文章，整理的很齐全 streamify-your-node-program 参考： stream-handbook Node.js Stream - 基础篇 Node.js Stream - 进阶篇 Node.js Stream - 实战篇 streamify-your-node-program Node.js 中文网 Node.js Streams: Everything you need to know stream-handbook streamify-your-node-program","link":"/2019/10/14/Node/01/"},{"title":"组件 API","text":"下面我们来看一下在 React 当中，提供了哪些组件相关的 API 状态设置（setState）1setState(object nextState[, function callback]) nextState，将要设置的新状态，该状态会和当前的 state 合并 callback，可选参数，回调函数，该函数会在 setState 设置成功，且组件重新渲染后调用 合并 nextState 和当前 state，并重新渲染组件，setState 是 React 事件处理函数中和请求回调函数中触发 UI 更新的主要方法 一些需要注意的地方 不能在组件内部通过 this.state 修改状态，因为该状态会在调用 setState() 后被替换 setState() 并不会立即改变 this.state，而是创建一个即将处理的 state，setState() 并不一定是同步的，为了提升性能 React 会批量执行 state 和 DOM 渲染 setState() 总是会触发一次组件重绘，除非在 shouldComponentUpdate() 中实现了一些条件渲染逻辑 1234567891011121314151617181920var Hello = React.createClass({ getInitialState() { return { count: 0 }; }, handleClick() { this.setState(function (state) { return { count: state.count + 1 }; }) }, render() { return ( &lt;h2 onClick={this.handleClick}&gt;当前点击次数为 ===&gt; {this.state.count}&lt;/h2&gt; ) }})ReactDOM.render( &lt;Hello /&gt;, document.getElementById('box')) replaceState（状态替换）1replaceState(object nextState[, function callback]) nextState，将要设置的新状态，该状态会替换当前的 state callback，可选参数，回调函数，该函数会在 replaceState 设置成功，且组件重新渲染后调用 replaceState() 方法与 setState() 类似，但是方法只会保留 nextState 中状态，原 state 不在 nextState 中的状态都会被删除 setProps（属性设置）1setProps(object nextProps[, function callback]) nextProps，将要设置的新属性，该状态会和当前的 props 合并 callback，可选参数，回调函数，该函数会在 setProps 设置成功，且组件重新渲染后调用 setProps 一般用来设置组件属性，并重新渲染组件，下面是几个需要注意的地方 props 相当于组件的数据流，它总是会从父组件向下传递至所有的子组件中，当和一个外部的 JavaScript 应用集成时，我们可能会需要向组件传递数据或通知 React.render() 组件需要重新渲染，可以使用 setProps() 更新组件，可以在节点上再次调用 React.render() 方法，也可以通过 setProps() 方法来改变组件属性从而触发组件重新渲染 replaceProps（替换属性）1replaceProps(object nextProps[, function callback]) nextProps，将要设置的新属性，该属性会替换当前的 props callback，可选参数，回调函数，该函数会在 replaceProps 设置成功，且组件重新渲染后调用 replaceProps() 方法与 setProps 类似，但它会删除原有的 props forceUpdate（强制更新）1forceUpdate([function callback]) callback，可选参数，回调函数，该函数会在组件 render() 方法调用后调用 forceUpdate() 方法会使组件调用自身的 render() 方法重新渲染组件，组件的子组件也会调用自己的 render()，但是组件重新渲染时，依然会读取 this.props 和 this.state，如果状态没有改变，那么 React 只会更新 DOM forceUpdate() 方法适用于 this.props 和 this.state 之外的组件重绘（如：修改了 this.state 后），通过该方法通知 React 需要调用 render() 应该尽量避免使用 forceUpdate()（而仅从 this.props 和 this.state 中读取状态并由 React 触发 render() 调用） 简单来说 forceUpdate() 就是重新 render()，而有些变量不在 state 上，但是又想达到这个变量更新的时候，刷新 render，或者 state 里的某个变量层次太深，更新的时候没有自动触发 render，这些时候都可以手动调用 forceUpdate() 自动触发 render 所以建议使用 immutable 来操作 state，redux 等 flux 架构来管理 state findDOMNode（获取 DOM 节点）12// 返回 DOMElementDOMElement findDOMNode() 如果组件已经挂载到 DOM 中，该方法返回对应的本地浏览器 DOM 元素，当 render 返回 null 或 false 时，this.findDOMNode() 也会返回 null 从 DOM 中读取值的时候，该方法很有用，如：获取表单字段的值和做一些 DOM 操作 isMounted（判断组件的挂载状态）12// 返回布尔值，表示是否挂载bool isMounted() isMounted() 方法用于判断组件是否已挂载到 DOM 中，可以使用该方法保证了 setState() 和 forceUpdate() 在异步场景下的调用不会出错 组件的生命周期这里只做简单介绍，详细可参考 官方文档 React 组件的生命周期大致可分成三个状态： Mounting，已插入真实 DOM Updating，正在被重新渲染 Unmounting，已移出真实 DOM 生命周期的方法有： componentWillMount，在渲染前调用（在客户端也在服务端） componentDidMount，在第一次渲染后调用，只在客户端，之后组件已经生成了对应的 DOM 结构，可以通过 this.getDOMNode() 来进行访问，如果你想和其他 JavaScript 框架一起使用，可以在这个方法中调用 setTimeout，setInterval 或者发送 Ajax 请求等操作（防止异部操作阻塞 UI） componentWillReceiveProps，在组件接收到一个新的 prop 时被调用，这个方法在初始化 render 时不会被调用 shouldComponentUpdate，返回一个布尔值，在组件接收到新的 props 或者 state 时被调用，在初始化时或者使用 forceUpdate() 时不被调用， 可以在你确认不需要更新组件时使用 componentWillUpdate，在组件接收到新的 props 或者 state 但还没有 render 时被调用，在初始化时不会被调用 componentDidUpdate，在组件完成更新后立即调用，在初始化时不会被调用 componentWillUnmount，在组件从 DOM 中移除的时候立刻被调用 两个个简单的示例 示例一，在 Hello 组件加载以后，通过 componentDidMount 方法设置一个定时器，每隔 100 毫秒重新设置该组件的透明度，并重新渲染： 12345678910111213141516171819202122232425262728293031var Hello = React.createClass({ getInitialState() { return { opacity: 1.0 }; }, componentDidMount() { this.timer = setInterval(() =&gt; { var opacity = this.state.opacity; opacity -= .05; if (opacity &lt; 0.1) { opacity = 1.0; } this.setState({ opacity: opacity }); }, 100); }, render() { return ( &lt;div style={{ opacity: this.state.opacity }}&gt;Hello&lt;/div&gt; ); }});ReactDOM.render( &lt;Hello name='world' /&gt;, document.getElementById('box')); 示例二，初始化 state，setNewnumber 用于更新 state，所有生命周期在 Content 组件中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657var Button = React.createClass({ getInitialState() { return { data: 0 }; }, setNewNumber() { this.setState({ data: this.state.data + 1 }) }, render() { return ( &lt;div&gt; &lt;button onClick={this.setNewNumber}&gt;Button&lt;/button&gt; &lt;Content myNumber={this.state.data}&gt;&lt;/Content&gt; &lt;/div&gt; ); }})var Content = React.createClass({ componentWillMount() { console.log('Component WILL MOUNT!') }, componentDidMount() { console.log('Component DID MOUNT!') }, componentWillReceiveProps(newProps) { console.log('Component WILL RECEIVE PROPS!') }, shouldComponentUpdate(newProps, newState) { return true; }, componentWillUpdate(nextProps, nextState) { console.log('Component WILL UPDATE!'); }, componentDidUpdate(prevProps, prevState) { console.log('Component DID UPDATE!') }, componentWillUnmount() { console.log('Component WILL UNMOUNT!') }, render() { return ( &lt;div&gt; &lt;h3&gt;{this.props.myNumber}&lt;/h3&gt; &lt;/div&gt; ); }});ReactDOM.render( &lt;div&gt; &lt;Button /&gt; &lt;/div&gt;, document.getElementById('box')); ajaxReact 组件的数据可以通过 componentDidMount 方法中的 Ajax 来获取，当从服务端获取数据库可以将数据存储在 state 中，再用 this.setState 方法重新渲染 UI 当使用异步加载数据时，在组件卸载前使用 componentWillUnmount 来取消未完成的请求 下面是一个利用 jQuery 实现的数据请求的简单示例 1234567891011121314151617181920212223242526272829303132333435var UserGist = React.createClass({ getInitialState: function () { return { username: '', lastGistUrl: '' }; }, componentDidMount: function () { this.serverRequest = $.get(this.props.source, function (result) { var lastGist = result[0]; this.setState({ username: lastGist.owner.login, lastGistUrl: lastGist.html_url }); }.bind(this)); }, componentWillUnmount: function () { this.serverRequest.abort(); }, render: function () { return ( &lt;div&gt; {this.state.username} 用户最新的 Gist 共享地址为：&lt;a href={this.state.lastGistUrl}&gt;{this.state.lastGistUrl}&lt;/a&gt; &lt;/div&gt; ); }});ReactDOM.render( &lt;UserGist source='https://api.github.com/users/octocat/gists' /&gt;, document.getElementById('example')); 表单事件（数据双向绑定）首先设置输入框 input 的默认值为 value = {this.state.data}，然后使用 onChange 事件来监听 input 的变化，在输入框值发生变化时可以动态更新 state 12345678910111213141516171819202122var HelloMessage = React.createClass({ getInitialState() { return { value: 'hello world' }; }, handleChange(event) { this.setState({ value: event.target.value }); }, render() { var value = this.state.value; return ( &lt;div&gt; &lt;input type='text' value={value} onChange={this.handleChange} /&gt; &lt;h4&gt;{value}&lt;/h4&gt; &lt;/div&gt; ) }});ReactDOM.render( &lt;HelloMessage /&gt;, document.getElementById('box')); 子组件上数据绑定在父组件通过创建事件句柄（handleChange） ，作为 prop（updateStateProp） 传递到子组件上，onChange 方法将触发 state 的更新并将更新的值传递到子组件的输入框的 value 上来重新渲染界面 1234567891011121314151617181920212223242526272829303132var Content = React.createClass({ render() { return ( &lt;div&gt; &lt;input type='text' value={this.props.myDataProp} onChange={this.props.updateStateProp} /&gt; &lt;h4&gt;{this.props.myDataProp}&lt;/h4&gt; &lt;/div&gt; ) }})var HelloMessage = React.createClass({ getInitialState() { return { value: 'hello world' } }, handleChange(event) { this.setState({ value: event.target.value }) }, render() { var value = this.state.value; return ( &lt;div&gt; &lt;Content myDataProp={value} updateStateProp={this.handleChange} /&gt; &lt;/div&gt; ) }})ReactDOM.render( &lt;HelloMessage /&gt;, document.getElementById('example')) 事件一个简单的示例，通过 onClick 事件来修改数据 12345678910111213141516171819202122var HelloMessage = React.createClass({ getInitialState() { return { value: 'hello world' } }, handleChange() { this.setState({ value: 'world hello' }) }, render() { var value = this.state.value; return ( &lt;div&gt; &lt;button onClick={this.handleChange}&gt;点我&lt;/button&gt; &lt;h2&gt;{value}&lt;/h2&gt; &lt;/div&gt; ) }})ReactDOM.render( &lt;HelloMessage /&gt;, document.getElementById('example')) 当需要从子组件中更新父组件的 state 时，需要在父组件通过创建事件句柄（handleChange） ，并作为 prop（updateStateProp） 传递到你的子组件上，如下所示： 1234567891011121314151617181920212223242526272829303132var Content = React.createClass({ render() { return ( &lt;div&gt; &lt;button onClick={this.props.updateStateProp}&gt;点我&lt;/button&gt; &lt;h2&gt;{this.props.myDataProp}&lt;/h2&gt; &lt;/div&gt; ) }})var HelloMessage = React.createClass({ getInitialState() { return { value: 'hello world' } }, handleChange() { this.setState({ value: 'world hello' }) }, render() { var value = this.state.value; return ( &lt;div&gt; &lt;Content myDataProp={value} updateStateProp={this.handleChange} /&gt; &lt;/div&gt; ) }})ReactDOM.render( &lt;HelloMessage /&gt;, document.getElementById('example')) RefsReact 支持一种非常特殊的属性 Ref ，你可以用来绑定到 render() 输出的任何组件上 这个特殊的属性允许你引用 render() 返回的相应的支撑实例（backing instance），这样就可以确保在任何时间总是拿到正确的实例 比如绑定一个 ref 属性到 render 的返回值上 1&lt;input ref='myInput' /&gt; 而在其它的代码中，可以通过 this.refs 来获取支撑实例: 12345var input = this.refs.myInput;var inputValue = input.value;var inputRect = input.getBoundingClientRect(); 一个完整的示例，通过使用 this 来获取当前 React 组件，或使用 ref 来获取组件的引用 123456789101112131415161718var MyComponent = React.createClass({ handleClick() { this.refs.myInput.focus(); }, render() { return ( &lt;div&gt; &lt;input type='text' ref='myInput' /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;input type='button' value='点击获取焦点' onClick={this.handleClick} /&gt; &lt;/div&gt; ) }})ReactDOM.render( &lt;MyComponent /&gt;, document.getElementById('example'))","link":"/2017/06/19/React/02/"},{"title":"jsx","text":"在 jsx 中，html 属性是受限制的 在 html 标签中使用非原始 html 支持的属性（但是可以添加 data- 前缀），是会被 react 所忽略的 class 关键字需要换成 className，事件绑定需要使用 camelCase 形式（比如 onClick） 12345var Info = React.createClass({ render: function () { return &lt;p className=\"user\" me=\"me\" name=\"myName\"&gt;{this.props.name}&lt;/p&gt; }}); setState 调用之后的异步setState 实际上是一个异步方法，可带两个参数 12345678this.setState( { age: this.state.age + 1 }, function () { }) 但是更好的做法是直接在第一个参数使用函数，如此便可以保证函数内部能取到正确的值 12345this.setState(function (prevState, next) { return { age: this.state.age + 1 }}) 组件的定义方式和绑定方式定义方式常见的有三种 函数式定义使用函数的方式定义，特点是无状态，实际上它并没有被实例化，所以无法访问 this 对象，不能管理生命周期，一般用于纯展示组件 123456// 函数组件接受一个属性参数，可直接获取function Info(props) { return &lt;p&gt;{props.name}&lt;/p&gt;}ReactDOM.render(&lt;Info name=\"zhangsan\" /&gt;, document.getElementById('box')); React.createClass之前比较流行的一种方式 1234567891011var Info = React.createClass({ // 初始化 state getInitialState: function () { return { name: 'myName' }; }, render: function () { return &lt;p&gt;{this.state.name}&lt;/p&gt; }}); extends React.ComponentES6 的类形式 1234567891011121314151617181920212223class Info extends React.Component { constructor(props) { super(props); this.state = { name: this.props.name || 'myName' }; } showYear(e) { console.log(this) let elem = ReactDOM.findDOMNode(e.target); } render() { return &lt;p onClick={this.showYear} data-year={this.props.year}&gt;{this.state.name}&lt;/p&gt; }}Info.defaultProps = { year: new Date().getFullYear()};ReactDOM.render(&lt;Info /&gt;, document.getElementById('box')); 可以发现，初始化 props 与 state 的方式不一样 在 React.createClass 形式中是直接在函数中 return 的方式，而 ES6 形式的 state 是在构造函数中直接初始化 this.state，而 props 初始化则需要在外部进行 至于点击事件，在 ES6 的类形式中，可以发现上述中输出的 this 为 null，这时因为 React 并不会自动绑定函数方法的 this 对象，需要自行绑定（绑定方式见下面） 绑定方式常用的也有三种 直接在构造函数中统一绑定12345678constructor(props) { super(props); this.state = { name: this.props.name || 'myName' }; this.showYear = this.showYear.bind(this);} 直接在 onClick 中绑定123render() { return &lt;p onClick={this.showYear.bind(this)} data-year={this.props.year}&gt;{this.state.name}&lt;/p&gt;} 在 onClick 绑定中使用回调函数调用1234// 这种方式需要手动传入 event 参数，而上述两种不需要render() { return &lt;p onClick={(e) =&gt; this.showYear(e)} data-year={this.props.year}&gt;{this.state.name}&lt;/p&gt;} 组件的生命周期如下： 12345678910111213141516// 实例化期（Mounting）componentWillMount // 组件挂载之前执行，只执行一次componentDidMount // 组件渲染完成，只执行一次// 存在期间（Updating）componentWillRecevieProps // 组件将要接收新的 props 执行shouldComponentUpdate // 判断组件是否应该重新渲染，默认是 true（门神）componentWillUpdate // 组件将要重新渲染componentDidUpdate // 组件重新渲染完成// 销毁期（Unmounting）componentWillUnmount // 卸载组件 需要注意的是：Ajax 请求一般放到 componentDidMount 函数中执行 受控组件与非受控组件非受控组件非受控，即表单项的 value 不受 React 的控制，不设初始 value 值，我们可以随意更改 但不便于统一使用 React 进行管理，也不便于设置初始值 受控组件受控组件，是为了更好地管理表单项的值，但要注意的是，一旦设置了 value，将不能通过直接在表单项输入就能改变 value 值 因为 value 已经被 React 控制，要更新 value 值，就得更新相应的 state 状态值 对于受控组件，又有初始值和值两种之分 初始值（defaultValue） – 注：其实 defaultValue 应该是属于非受控组件的 defaultValue 指的是 input，select，textarea 等，相应的 checkbox，radio 是 defaultChecked 初始值只是初始的一个值，在第一次设置定义之后就不可改变 在实际开发中，数据的获取经常是异步的，大部分情况下会先初始设置 input 表单值为空，获取到数据后再放到 input 中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class InputItem extends React.Component { constructor(props) { super(props); this.state = { inputValue: this.props.inputValue || '' }; } componentWillReceiveProps(nextProps) { this.setState({ inputValue: nextProps.inputValue }); } inputChange(e) { let inputValue = e.target.value; console.log(inputValue); // this.setState({ // inputValue // }); } render() { return &lt;p&gt;&lt;input type=\"input\" onChange={this.inputChange.bind(this)} defaultValue={this.state.inputValue} /&gt;&lt;/p&gt; }}class Page extends React.Component { constructor(props) { super(props); this.state = { inputValue: '' }; } componentDidMount() { setTimeout(() =&gt; { this.setState({ inputValue: 'myValue' }); }, 1000); } render() { return &lt;InputItem inputValue={this.state.inputValue} /&gt; }}ReactDOM.render(&lt;Page /&gt;, document.getElementById('box')); 初始在 InputItem 中设置了 defaultValue 为空，一段时间后获取到父 Page 传来的新值 inputValue，然而 InputItem 中的 defaultValue 并不会更新 这种情况，就不适用与 defaultValue 了，换成用状态控制的 value 即可 值（value） 123render() { return &lt;p&gt;&lt;input type=\"input\" onChange={this.inputChange.bind(this)} value={this.state.inputValue} /&gt;&lt;/p&gt;} 获取到异步的数据后，通过 componentWillReceiveProps 中更新状态值，加入 onChange 事件，在输入的时候更新状态值 补充 对于 onChange 事件的调用更新 state，假如 input 项目太多，为每个 input 定义一个 change 回调并不实际 这时可以在 bind 中指定参数，指定是某个 input 项，或者直接在 input 项中添加属性区分，调用的时候再获取 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class InputItem extends React.Component { constructor(props) { super(props); this.state = { userName: this.props.userName || '', age: this.props.age || '' }; } componentWillReceiveProps(nextProps) { this.setState({ userName: nextProps.userName, age: nextProps.age }); } inputChange(name, e) { this.setState({ [name]: e.target.value }); } // inputChange(e) { // this.setState({ // [e.target.getAttribute('name')]: e.target.value // }); // } render() { return ( &lt;div&gt; &lt;p&gt;&lt;input type=\"input\" name=\"userName\" onChange={this.inputChange.bind(this, 'userName')} value={this.state.userName} /&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"input\" name=\"age\" onChange={this.inputChange.bind(this, 'age')} value={this.state.age} /&gt;&lt;/p&gt;&lt;/div&gt; ) }}class Page extends React.Component { constructor(props) { super(props); this.state = { userName: '', age: '' }; } componentDidMount() { setTimeout(() =&gt; { this.setState({ userName: 'zhangsan', age: 10 }); }, 1000); } render() { return &lt;InputItem userName={this.state.userName} age={this.state.age} /&gt; }}ReactDOM.render(&lt;Page /&gt;, document.getElementById('box')); 默认情况下，如果 bind 中不填第二个参数，在回调中第一个参数就是触发的 event 对象 如果有第二个参数，回调中的第一个参数就是该参数，后续的参数才是触发的 event 对象 上述两个 inputChange 方法调用之后结果一样，这里也利用了 ES6 支持对象属性名为变量的新特性","link":"/2017/07/02/React/03/"},{"title":"React 基础","text":"react 是一个用于构建用户界面的 JavaScript 库，主要用于构建 ui，可以简单的认为 react 是 MVC 中的 V（视图） react 的一些特点如下： 声明式设计 − react 采用声明范式，可以轻松描述应用 高效 − react 通过对 DOM 的模拟，最大限度地减少与 DOM 的交互 灵活 − react 可以与已知的库或框架很好地配合 JSX − JSX 是 JavaScript 语法的扩展，建议使用它 组件 − 通过 react 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中 单向响应的数据流 − react 实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单 一个简单的示例 1234567891011121314151617181920// ...&lt;script src='./react.min.js'&gt;&lt;/script&gt;&lt;script src='./react-dom.min.js'&gt;&lt;/script&gt;&lt;script src='./babel.min.js'&gt;&lt;/script&gt;// ...&lt;div id='box'&gt;&lt;/div&gt;&lt;script type='text/babel'&gt; ReactDOM.render( &lt;h1&gt;hello world!&lt;/h1&gt;, document.getElementById('box') )&lt;/script&gt;// ... 几个需要注意的地方： 需要引入三个 JavaScript 文件 react.min.js - react 的核心库 react-dom.min.js - 提供与 DOM 相关的功能 babel.min.js - 将 ES6 代码转为 ES5 代码（babel 内嵌了对 jsx 的支持） 内嵌的 script 标签注意 type 格式为 text/babel jsxjsx 的一些特点： react 使用 jsx 来替代常规的 JavaScript jsx 执行更快，因为它在编译为 JavaScript 代码后进行了优化 它是类型安全的，在编译过程中就能发现错误 使用 jsx 编写模板更加简单快速 1234567ReactDOM.render( &lt;div&gt; &lt;h2&gt;hello&lt;/h2&gt; &lt;h2&gt;world&lt;/h2&gt; &lt;/div&gt;, document.getElementById('box')) 但是需要注意的是，jsx 当中可以嵌套多个 html 标签，但是最外层只能是一个标签，即需要包裹的元素（同 vue 类似） 123456789101112131415// 错误的例子ReactDOM.render( &lt;h2&gt;hello&lt;/h2&gt;, &lt;h2&gt;world&lt;/h2&gt;, document.getElementById('box'));// 正确的例子ReactDOM.render( &lt;div&gt; &lt;h2&gt;hello&lt;/h2&gt; &lt;h2&gt;world&lt;/h2&gt; &lt;/div&gt;, document.getElementById('box')); 其他一些需要注意的地方： 可以在 jsx 中使用 JavaScript 表达式，需要写在 {} 当中，比如 123456ReactDOM.render( &lt;div&gt; &lt;h2&gt;{1 + 2}&lt;/h2&gt; &lt;/div&gt;, document.getElementById('box')) jsx 中不能使用 if...else 语句，但是可以使用三元运算符来替代，比如 123456ReactDOM.render( &lt;div&gt; &lt;h2&gt;{x == 1 ? 'true' : 'false'}&lt;/h2&gt; &lt;/div&gt;, document.getElementById('box')) react 推荐使用内联样式，react 会在指定的元素数字后面自动加上 px，命名时使用驼峰命名法 123456789var style = { fontSize: 12, color: red}ReactDOM.render( &lt;div style={style}&gt;&lt;/div&gt;, document.getElementById('box')) jsx 也允许在模版中插入数组，数组会自动展开所有成员 123456789var arr = [ &lt;h2&gt;hello&lt;/h2&gt;, &lt;h2&gt;world&lt;/h2&gt;]ReactDOM.render( &lt;div&gt;{arr}&lt;/div&gt;, document.getElementById('box')) jsx 当作也允许添加注释，但是需要注意区别两点 在标签内部的注释需要放在 {} 当中 在标签外部的注释不能使用 {} 12345ReactDOM.render( /* 这里也是注释 */ &lt;div&gt;{/* 这里是注释 */}&lt;/div&gt;, document.getElementById('box')) jsx 不仅可以渲染 html 标签，同时还可以渲染 react 组件，在 jsx 当中使用大小写来区分（注意标签最后需要闭合，即 /） 12345678// 渲染 html 标签var divElement = &lt;div className='foo' /&gt;;ReactDOM.render(divElement, document.getElementById('box'));// 渲染 react 组件var Component = React.createClass({ /**/ })var divElement = &lt;Component flag={true} /&gt;;ReactDOM.render(divElement, document.getElementById('box')); 组件一个最基本的组件 12345678910var HelloWorld = React.createClass({ render: function () { return &lt;h1&gt;hello world!&lt;/h1&gt; }})ReactDOM.render( &lt;HelloWorld /&gt;, document.getElementById('box')) 上例中的 React.createClass 方法用于生成一个组件类 HelloWorld，有几个需要注意的地方 原生 html 元素以小写字母开头，而自定义的 React 类名以大写字母 组件类只能包含一个顶层标签，否则也会报错 在渲染组件的时候，组件名称需要关闭，即 &lt; ... /&gt; 中的 / 参数传递如果需要向组件传递参数，可以使用 this.props 对象 12345678910var HelloWorld = React.createClass({ render: function () { return &lt;h1&gt;{this.props.name}&lt;/h1&gt; }})ReactDOM.render( &lt;HelloWorld name='hello' /&gt;, document.getElementById('box')) 复合组件也可以通过创建多个组件来合并成一个大组件 12345678910111213141516171819202122232425262728293031var User = React.createClass({ render() { return ( &lt;div&gt; &lt;Name name={this.props.name} /&gt; &lt;Age age={this.props.age} /&gt; &lt;/div&gt; ) }})var Name = React.createClass({ render() { return ( &lt;h1&gt;{this.props.name}&lt;/h1&gt; ) }})var Age = React.createClass({ render() { return ( &lt;h1&gt;{this.props.age}&lt;/h1&gt; ) }})ReactDOM.render( &lt;User name='zhangsan' age='20' /&gt;, document.getElementById('box')) 状态react 把组件看成是一个状态机（State Machines），通过与用户的交互，实现不同状态，然后渲染 UI，让用户界面和数据保持一致 在 react 中，只需要更新组件的 state，然后就可以在不刷新 DOM 的前提下根据新的 state 重新渲染用户界面 12345678910111213141516var LikeButton = React.createClass({ getInitialState() { return { liked: false }; }, handleClick(event) { this.setState({ liked: !this.state.liked }); }, render() { var text = this.state.liked ? '是' : '否'; return ( &lt;p onClick={this.handleClick}&gt; 点击切换状态 ==&gt; ## {text} &lt;/p&gt; ); }}); State 和 Props 的区别两者其实都是用于描述 component 状态的，并且这个状态应该是与显示相关的 两者的主要区别在于 props 是不可变的，而 state 可以根据与用户交互来改变，这就是为什么有些容器组件需要定义 state 来更新和修改数据，而子组件只能通过 props 来传递数据 props 是一个父组件传递给子组件的数据流，这个数据流可以一直传递到子孙组件，而 state 代表的是一个组件内部自身的状态（可以是父组件、子孙组件） State改变一个组件自身状态，从语义上来说，就是这个组件内部已经发生变化，有可能需要对此组件以及组件所包含的子孙组件进行重渲染 如果 component 的某些状态需要被改变，并且会影响到 component 的 render，那么这些状态就应该用 state 表示 例如：一个购物车的 component，会根据用户在购物车中添加的产品和产品数量，显示不同的价格，那么’总价’这个状态，就应该用 state 表示 Propsprops 是父组件传递的参数，可以被用于显示内容，或者用于此组件自身状态的设置（部分 props 可以用来设置组件的 state），不仅仅是组件内部 state 改变才会导致重渲染，父组件传递的 props 发生变化，也会执行 如果 component 的某些状态由外部所决定，并且会影响到 component 的 render，那么这些状态就应该用 props 表示 例如：一个下拉菜单的 component，有哪些菜单项，是由这个 component 的使用者和使用场景决定的，那么’菜单项’这个状态，就应该用 props 表示，并且由外部传入 1234567891011// name 属性通过 this.props.name 来获取var HelloWorld = React.createClass({ render() { return &lt;h1&gt;Hello {this.props.name}&lt;/h1&gt;; }})ReactDOM.render( &lt;HelloWorld name='zhangsan' /&gt;, document.getElementById('box')) 默认的 props你可以通过 getDefaultProps() 方法为 props 设置默认值 123456789101112131415var HelloWorld = React.createClass({ getDefaultProps() { return { name: 'zhangsan' } }, render() { return &lt;h1&gt;Hello {this.props.name}&lt;/h1&gt;; }})ReactDOM.render( &lt;HelloWorld /&gt;, document.getElementById('box')) State 和 Props 结合我们可以在父组件中设置默认的 state，在子组件的 render 函数中通过 props 来接收父组件通过 state 传递过来的数据，然后来设置 name 和 site 的值 123456789101112131415161718192021222324252627282930313233343536373839var HelloWorld = React.createClass({ getInitialState() { return { name: 'zhangsan', link: 'www.baidu.com' } }, render() { return ( &lt;div&gt; &lt;User name={this.state.name} /&gt; &lt;Link link={this.state.link} /&gt; &lt;/div&gt; ) }})var Name = React.createClass({ render: function () { return ( &lt;h1&gt;{this.props.name}&lt;/h1&gt; ); }});var Link = React.createClass({ render: function () { return ( &lt;a href={this.props.site}&gt; {this.props.site} &lt;/a&gt; ); }});ReactDOM.render( &lt;HelloWorld /&gt;, document.getElementById('box')) Props 验证Props 可以使用 propTypes 来进行验证，它可以保证我们的应用组件被正确使用，React.PropTypes 提供很多验证器（validator）来验证传入数据是否有效 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657React.createClass({ propTypes: { // 可以声明 prop 为指定的 javaScript 基本数据类型，默认情况，这些数据是可选的 optionalArray: React.PropTypes.array, optionalBool: React.PropTypes.bool, optionalFunc: React.PropTypes.func, optionalNumber: React.PropTypes.number, optionalObject: React.PropTypes.object, optionalString: React.PropTypes.string, // 可以被渲染的对象 numbers, strings, elements 或 array optionalNode: React.PropTypes.node, // React 元素 optionalElement: React.PropTypes.element, // 用 javaScript 的 instanceof 操作符声明 prop 为类的实例 optionalMessage: React.PropTypes.instanceOf(Message), // 用 enum 来限制 prop 只接受指定的值 optionalEnum: React.PropTypes.oneOf(['News', 'Photos']), // 可以是多个对象类型中的一个 optionalUnion: React.PropTypes.oneOfType([ React.PropTypes.string, React.PropTypes.number, React.PropTypes.instanceOf(Message) ]), // 指定类型组成的数组 optionalArrayOf: React.PropTypes.arrayOf(React.PropTypes.number), // 指定类型的属性构成的对象 optionalObjectOf: React.PropTypes.objectOf(React.PropTypes.number), // 特定 shape 参数的对象 optionalObjectWithShape: React.PropTypes.shape({ color: React.PropTypes.string, fontSize: React.PropTypes.number }), // 任意类型加上 `isRequired` 来使 prop 不可空 requiredFunc: React.PropTypes.func.isRequired, // 不可空的任意类型 requiredAny: React.PropTypes.any.isRequired, // 自定义验证器，如果验证失败需要返回一个 Error 对象，不要直接使用 `console.warn` 或抛异常，因为这样 `oneOfType` 会失效 customProp: function (props, propName, componentName) { if (!/matchme/.test(props[propName])) { return new Error('Validation failed!'); } } }, // ...});","link":"/2017/06/11/React/01/"},{"title":"Redux","text":"简单来说，redux 就是 flux 思想在 react 当中的实现，所谓的 redux 可以简单的理解为一个可以预测状态的 JavaScript 的 app 容器 app 中的全部 state 都被存储在一个单独的 store 中，形式是 object-tree（JSON） 唯一更改 state 的途径就是 emit 一个 action，这个 action 描述了发生了什么 为了指定这些 actions 如何改变 state tree，必须书写简单的、纯净的 reducers 所谓的纯净的 reducers 就是类似下面这样伪代码，不继承任何东西，并且无论何时返回的值都是固定的 1234function reducers(state, action) { // 返回一个新的 state return newState;} 上面就是一个 reducer，是一个纯函数，接收 state 和 action 两个参数，返回新的 state 表达式 如果使用过 flux，这里有一个重要的区别 redux 中没有 dispatcher 的概念（store 自己负责 dispatch 某个 action 到自己身上），也不允许有多个 store 所以一般来说，redux 比较适合用于有强的全局数据概念的 web 应用（比如商城，购物车等） redux 中只有一个唯一的 store，使用唯一的 reducing function 随着项目增长的时候也不要去增加 store，而是应该切割当前的 store 为一个个小的 store 即 store 应该只有一个，类似于 react 当中只允许使用一个根节点，但是根节点是由众多的节点组成 下面将会分别进行讨论 为什么要用 Redux当然除了 redux 还有 flux、reflux、mobx 等状态管理库可供选择 一个实际场景，比如在控制台上记录用户的每个动作 12345678910111213141516171819// 后端，比如使用 Express 中实现一个简单的 Logger var loggerMiddleware = function (req, res, next) { console.log('[Logger]', req.method, req.originalUrl) next()}...app.use(loggerMiddleware)// 前端，jQuery$('#loginBtn').on('click', function (e) { console.log('[Logger] 用户登录') ...})$('#logoutBtn').on('click', function () { console.log('[Logger] 用户退出登录') ...}) 然后现在又需要在上述需求的基础上，记录用户的操作时间 12345678910111213141516171819// 后端，只需要稍微修改一下原来的中间件即可var loggerMiddleware = function (req, res, next) { console.log('[Logger]', new Date(), req.method, req.originalUrl) next()}...app.use(loggerMiddleware)// 前端，需要一个一个去改$('#loginBtn').on('click', function (e) { console.log('[Logger] 用户登录', new Date()) ...})$('#logoutBtn').on('click', function () { console.log('[Logger] 用户退出登录', new Date()) ...}) 又比如说，在正式上线的时候，把控制台中有关 Logger 的输出全部去掉，亦或是自动收集 bug 很明显的可以看出前后端对于这类需求的处理竟然大相径庭 原因在于，后端具有统一的入口与统一的状态管理（数据库），因此可以引入中间件机制来统一实现某些功能 而前端也可以使用 MVC 的开发思维，将应用中所有的动作与状态都统一管理，让一切有据可循 Store首先要区分 store 和 state state 是应用的状态，一般本质上是一个普通对象，例如，我们有一个 Web APP，包含 计数器 和 待办事项 两大功能 那么我们可以为该应用设计出对应的存储数据结构（应用初始状态） 12345/** 应用初始 state **/{ counter: 0, todos: []} 而 store 则是应用状态 state 的管理者，包含下列四个函数 getState() 获取整个 state dispatch(action) 触发 state 改变的【唯一途径】 subscribe(listener) 可以理解成是 DOM 中的 addEventListener replaceReducer(nextReducer) 一般在 Webpack Code-Splitting 按需加载的时候用（使用较少） 二者的关系是 state = store.getState() redux 规定，一个应用只应有一个单一的 store，其管理着唯一的应用状态 state redux 还规定，不能直接修改应用的状态 state，也就是说，下面的行为是不允许的 1234var state = store.getState()// 禁止在业务逻辑中直接修改 statestate.counter = state.counter + 1 若要改变 state，必须 dispatch 一个 action，这是修改应用状态的不二法门 暂时只需要记住，action 就是一个包含 type 属性的普通对象，例如 { type: 'INCREMENT' } 而 store，我们需要调用 redux 提供的的 createStore() 方法 123456import { createStore } from 'redux'...// 只需记住 store 是靠传入 reducer 来生成的const store = createStore(reducer, initialState) 暂时只需要记住，reducer 是一个 函数，负责更新并返回一个新的 state 即可 而第二个参数 initialState 主要用于前后端同构的数据同步（详情请关注 React 服务端渲染）（可暂时不用管） Actionaction（动作）实质上是包含 type 属性的普通对象，这个 type 是我们实现用户行为追踪的关键 例如，增加一个待办事项 的 action 可能是像下面一样： 12345678{ type: 'ADD_TODO', payload: { id: 1, content: '待办事项1', completed: false }} action 的形式是多种多样的，唯一的约束仅仅就是包含一个 type 属性 12345678910111213141516// 下面这些 action 都是合法的，但就是不够规范{ type: 'ADD_TODO', id: 1, content: '待办事项1', completed: false}{ type: 'ADD_TODO', abc: { id: 1, content: '待办事项1', completed: false }} 规范可见 flux-standard-action Action CreatorAction Creator 是 action 的创造者，本质上就是一个函数，返回值是一个 action（对象）（可以是同步的，也可以是异步的） 例如下面就是一个 ‘新增一个待办事项’ 的 Action Creator 1234567891011var id = 1function addTodo(content) { return { type: 'ADD_TODO', payload: { id: id++, content: content, // 待办事项内容 completed: false // 是否完成的标识 } }} 简单来说，Action Creator 就是用于绑定到用户的操作（比如点击按钮等），其返回值 action 用于之后的 dispatch(action) Reducer需要注意的是，reducer 必须是同步的纯函数 简单来说分为一下三步 用户每次 dispatch(action) 后，都会触发 reducer 的执行 reducer 的实质是一个函数，根据 action.type 来更新 state 并返回 nextState 最后会用 reducer 的返回值 nextState 完全替换掉原来的 state 几个需要注意的地方： ‘更新’ 并不是指 reducer 可以直接对 state 进行修改 redux 规定，须先复制一份 state，在副本 nextState 上进行修改操作 例如，可以使用 lodash 的 cloneDeep，也可以使用 Object.assign / map / filter/ ... 等返回副本的函数 例如下面这个示例 123456789101112131415161718192021var initState = { counter: 0, todos: []}function reducer(state, action) { // 应用的初始状态是在第一次执行 reducer 时设置的 if (!state) state = initState switch (action.type) { case 'ADD_TODO': var nextState = _.cloneDeep(state) // 用到了 lodash 的深克隆 nextState.todos.push(action.payload) return nextState default: // 由于 nextState 会把原 state 整个替换掉 // 若无修改，必须返回原 state（否则就是 undefined） return state }} 简单的理解就是，reducer 返回什么，state 就被替换成什么 总结 store 由 redux 的 createStore(reducer) 生成 state 通过 store.getState() 获取，本质上一般是一个存储着整个应用状态的对象 action 本质上是一个包含 type 属性的普通对象，由 Action Creator（函数） 产生 改变 state 必须 dispatch 一个 action reducer 本质上是根据 action.type 来更新 state 并返回 nextState 的函数 reducer 必须返回值，否则 nextState 即为 undefined 实际上，state 就是所有 reducer 返回值的汇总 大致流程如下所示： 123456789101112131415161718192021Action Creator ==&gt; action ==&gt; store.dispatch(action) ==&gt; reducer(state, action) ==&gt; state(`原`) ==&gt; nextState(`新`)","link":"/2019/03/13/React/06/"},{"title":"axios","text":"先来看看一些 axios 的特点 浏览器端发起 XMLHttpRequest 请求 Node.js 发起 http 请求 支持 Promise API 拦截请求和返回 转化请求和返回（data） 取消请求 自动转化 json 数据 客户端支持抵御 XSRF 基本语法一个简单的 GET 请求 123456789101112131415161718axios.get('/user?id=1234') .then(function (response) { console.log(response); }) .catch(function (err) { console.log(err); })// 等同于axios.get('/user', { params: { id: 1234 }}).then(function (response) { console.log(response)}).catch(function (err) { console.log(err)}) 一个简单的 POST 请求 12345678axios.post('/user', { firstName: 'firstName', lastName: 'lastName'}).then(function (response) { console.log(response)}).catch(function (err) { console.log(err)}) 一个多重并发请求 123456axios.all([ axios.get('/user/123'), axios.get('/user/456')]).then(axios.spread(function (acc, pers) { // 两个请求均已经完成})) API123456789101112131415161718// POST 请求axios({ method: 'post', url: '/user/123', data: { firstName: 'firstName', lastName: 'lastName' }});// 获取远程图片axios({ method: 'get', url: 'http://imgurl/1234', responseType: 'stream'}).then(function (response) { response.data.pipe(fs.createWriteStream('123.jpg'))}) Request Config请求时的设置只有 url 是必须的，如果没有指明 method 的话，默认的请求方式是 GET 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114{ // url 是服务器链接，用来请求 url: '/user', // method 是发起请求时的请求方法，默认是 GET method: 'get', // baseURL 如果 url 不是绝对地址，那么将会加在其前面（当 axios 使用相对地址时这个设置非常方便） baseURL: 'http://some-domain.com/api/', // transformRequest 允许请求的数据在传到服务器之前进行转化 // 这个只适用于 PUT，GET，PATCH 方法 // 数组中的最后一个函数必须返回一个字符串或者一个 ArrayBuffer/Stream/Buffer/ArrayBuffer/FormData transformRequest: [function (data) { return data; }], // transformResponse 允许返回的数据传入 then/catch 之前进行处理 transformResponse: [function (data) { return data; }], // headers 是自定义的要被发送的头信息 headers: { 'X-Requested-with': 'XMLHttpRequest' }, // params 是请求连接中的请求参数，必须是一个纯对象，或者 URLSearchParams 对象 params: { id: 123 }, // paramsSerializer 是一个可选的函数，是用来序列化参数 // https://ww.npmjs.com/package/qs || http://api.jQuery.com/jQuery.param/ paramsSerializer: function(params) { return Qs.stringify(params, { arrayFormat: 'brackets' }) }, // data 是请求提需要设置的数据 // 只适用于应用的 'PUT' || 'POST' || 'PATCH' // 当没有设置 transformRequest 时，必须是以下其中之一的类型（不可重复？）： // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - Browser only: FormData, File, Blob // - Node only: Stream, Buffer data: { firstName: 'firstName' }, // timeout 定义请求的时间，单位是毫秒 timeout: 1000, // withCredentials 表明是否跨网站访问协议（cross-site Access-Control requests） // 应该使用证书 withCredentials: false // adapter 适配器，允许自定义处理请求，这会使测试更简单 // 返回一个 promise，并且提供验证返回（https://github.com/axios/axios/tree/master/lib/adapters） adapter: function(config) { /*...*/ }, // auth 表明 http 基础的认证应该被使用，并且提供证书 // 这个会设置一个 authorization 头（header），并且覆盖你在 header 设置的 Authorization 头信息 auth: { username: 'janedoe', password: 's00pers3cret' }, // responsetype 表明服务器返回的数据类型，这些类型的设置应该是 // 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream' responsetype: 'json', // xsrfHeaderName 是 http 头（header）的名字，并且该头携带 xsrf 的值 xrsfHeadername: 'X-XSRF-TOKEN', // onUploadProgress 允许处理上传过程的事件 onUploadProgress: function(progressEvent) { /*...*/ }, // onDownloadProgress 允许处理下载过程的事件 onDownloadProgress: function(progressEvent) { /*...*/ }, // maxContentLength 定义 http 返回内容的最大容量 maxContentLength: 2000, // validateStatus 定义 promise 的 resolve 和 reject // http 返回状态码，如果 validateStatus 返回 true（或者设置成 null/undefined），promise 将会接受，其他的 promise 将会拒绝 validateStatus: function(status) { return status &gt;= 200 &amp;&amp; stauts &lt; 300; }, // 在 nodejs 中 httpAgent 和 httpsAgent 当产生一个 http 或者 https 请求时分别定义一个自定义的代理 // 像是 keepAlive -- 这个在默认中是没有开启的 httpAgent: new http.Agent({ keepAlive: treu }), httpsAgent: new https.Agent({ keepAlive: true }), // proxy 定义服务器的主机名字和端口号 // auth 表明 http 基本认证应该跟 proxy 相连接，并且提供证书 // 这个将设置一个 'Proxy-Authorization' 头（header），覆盖原先自定义的 proxy: { host: 127.0.0.1, port: 9000, auth: { username: 'abc', password: '123' } }, // cancelTaken 定义一个取消，能够用来取消请求 cancelToken: new CancelToken(function (cancel) { /*...*/ })} Response Schema123456789101112131415161718192021222324252627{ // 服务器返回的消息 data: {}, // htpp status status: 200, // 返回的 http 状态信息 statusText: 'ok', // 返回中携带的 headers headers: {}, // axios 的设置，目的是为了请求（request） config: {}}// --------------------------axios.get('/user/12345') .then(function (response) { console.log(response.data); console.log(response.status); console.log(response.statusText); console.log(response.headers); console.log(response.config); }); 当使用 catch 时，或者传入一个 reject callback 作为 then 的第二个参数，那么返回的错误信息将能够被使用 添加拦截器可以在请求或者返回被 then 或者 catch 处理之前对它们进行拦截 1234567891011121314151617// 添加一个请求拦截器axios.interceptors.request.use(function (config) { // code here return config;}, function (err) { // code here return Promise.reject(err);})// 添加一个返回拦截器axios.interceptors.response.use(function (response) { // code here return response;}, function (err) { // code here return Promise.reject(err);}) 移除拦截器12var myInterceptor = axios.interceptors.request.use(function() { /*...*/ })axios.interceptors.request.eject(myInterceptor) 可以在一个 axios 实例中使用拦截器 12var instance = axios.create();instance.interceptors.request.use(function() { /*...*/ }); 实例在项目中经常会遇到请求的时候需要携带 token，所以我们可以将其封装，使其每个请求都可以携带自定义 token 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import axios from 'axios'import { Message } from 'element-ui'import store from './store'// 创建 axios 实例const service = axios.cerate({ baseURL: process.env.BASE_URL, // API 的 bade_url，读取 config 配置文件 timeout: 5000 // 请求超时时间})// request 拦截器service.interceptors.request.use(config =&gt; { if (store.getters.token) { // 让每个请求携带自定义的 token config.headers['X-Token'] = store.getters.token; } return config;}, error =&gt; { console.log(error); Promise.reject(error);})// response 拦截器service.interceptors.response.use(response =&gt; { const res = response.data; // 根据 res.code 进行判断 if (res.code !== 10000) { Message({ message: res.code, type: 'error', duration: 3000 }) return Promise.reject(error) } else { return response.data; }}, error =&gt; { console.log(`err${error}`) Message({ message: error.message, type: 'error', duration: 3000 }) return Promise.reject(error)})export default service; 由于 axios 每一个都是一个实例里，每一请求都是基于这个实例而来的，所以配置的参数属性都会被继承下来 123456789101112131415161718192021// apiimport fetch from '@/utils/fetch'export function getInfo(token) { return fetch({ url: '/user/info', methods: 'get', params: { token } })}// 可以直接使用，之前的配置都是可以生效的，会自动有一个之前所配置的 baseURL// 如果想要手动修改请求路径，只需要覆盖 baseURL 即可export function getInfo(token) { return fetch({ baseURL: 'http://123.com', url: '/user/info', methods: 'get', params: { token } })}","link":"/2018/05/10/Vue/04/"},{"title":"installModule，resetStoreVM，plugins","text":"installModule初始化组件树根组件，注册所有子组件，并将其中所有的 getters 存储到 this._wrappedGetters 属性中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111// 接收五个参数// store 当前 Store 的实例// rootState 根 state// path 当前嵌套模块的路径数组// module 当前安装的模块// hot 当动态改变 modules 或者热更新的时候为 truefunction installModule(store, rootState, path, module, hot) { // 判断是否为根 const isRoot = !path.length /** * 我们在构造函数中调用的时候为 installModule(this, state, [], options) * 所以这里的 path.length 为空，所以 isRoot 为 true * 而 module 自然就是传递进来的 options * 即 state，actions，mutations，getters 和嵌套的 modules */ // 新增的模块命名空间 const namespace = store._modules.getNamespace(path) // register in namespace map // 是否设置了命名空间，若存在则在 namespace 中进行 module 的存储 if (module.namespaced) { store._modulesNamespaceMap[namespace] = module } // set state // 非根组件设置 state 方法 if (!isRoot &amp;&amp; !hot) { // 在不是根组件且不是 hot 条件的情况下 // 通过 getNestedState 方法拿到该 module 父级的 state /** // 根据 path 查找 state 上的嵌套 state function getNestedState (state, path) { return path.length ? path.reduce((state, key) =&gt; state[key], state) : state } */ const parentState = getNestedState(rootState, path.slice(0, -1)) // 由于模块的 path 是根据模块的名称 concat 连接的 // 所以 path 的最后一个元素就是当前模块的模块名 // 然后拿到其所在的 moduleName const moduleName = path[path.length - 1] /** _withCommit (fn) { // 保存之前的提交状态 const committing = this._committing // 进行本次提交，若不设置为 true，直接修改 state // 在 strict 模式下，Vuex 将会产生非法修改 state 的警告 this._committing = true // 执行 state 的修改操作 fn() // 修改完成后还原本次修改之前的状态 this._committing = committing } */ // 一个代理方法，Vuex 中所有触发 mutation 的进行 state 的修改操作都会经过它 // 保证同步修改 state 的过程中 this._committing 的值始终为 true // 可以统一管理监控 state 状态的修改 // 这样当我们观测 state 的变化的时候，如果 this._committing 不为 true，则说明这个状态的修改是有问题的 // 拿到 parentState 和 moduleName // 然后利用 Vue.set 方法将 state 设置到父级 state 对象的 moduleName 属性中 // 由此实现该模块的 state 注册 // 注：如果是首次执行，因为是根目录注册，所以并不会执行该条件中的方法 store._withCommit(() =&gt; { Vue.set(parentState, moduleName, module.state) }) } // module 上下文环境设置 // 命名空间和根目录条件判断完毕后，接下来定义 local 变量和 module.context 的值 // makeLocalContext 方法会为该 module 设置局部的 dispatch，commit 方法以及 getters 和 state（namespace 的存在需要做兼容处理） const local = module.context = makeLocalContext(store, namespace, path) // 分别对 mutations，actions，getters 进行注册，见下 // 注册对应模块的 mutation，供 state 修改使用 module.forEachMutation((mutation, key) =&gt; { const namespacedType = namespace + key registerMutation(store, namespacedType, mutation, local) }) // 注册对应模块的 action，供数据操作、提交 mutation 等异步操作使用 module.forEachAction((action, key) =&gt; { const type = action.root ? key : namespace + key const handler = action.handler || action registerAction(store, type, handler, local) }) // 注册对应模块的 getters，供 state 读取使用 module.forEachGetter((getter, key) =&gt; { const namespacedType = namespace + key registerGetter(store, namespacedType, getter, local) }) // 这个是 Store 中的 Module // 需要注意这里传入的 path 参数是不为空的 // 注册完了根组件的 actions、mutations 以及 getters 后，递归调用自身 // 为子组件注册其 state，actions、mutations 以及 getters 等 module.forEachChild((child, key) =&gt; { installModule(store, rootState, path.concat(key), child, hot) })} mutations、actions 以及 getters 注册定义 local 环境后，循环注册我们在 options 中配置的 action 以及 mutation 等，逻辑关系见下图： registerMutation简单来说，就是获取 store 中的对应的 mutation type 的处理函数集合，将新的处理函数 push 进去 这里对设置在 mutation type 上对应的 handler 进行封装，给原函数传入 state 所以在执行比如 commit('xxx', payload) 的时候，type 为 xxx 的 mutation 的所有 handler 都会接收到 state 以及 payload 这就是在 handler 里面拿到 state 的原因 1234567891011121314151617// 接收四个参数// store 为当前 Store 实例// type 为 mutation 的 type// handler 为 mutation 执行的回调函数，作用就是同步修改当前模块的 state// local 为当前模块的路径function registerMutation(store, type, handler, local) { // 通过 type 拿到对应的 mutation 对象数组 const entry = store._mutations[type] || (store._mutations[type] = []) // 将 mutation 包装成函数 push 到数组当中，同时添加载荷 payload 参数 // 所以 commit 实际调用的不是我们传入的 handler，而是经过封装的 entry.push(function wrappedMutationHandler(payload) { // 调用 handler 并将 state 传入 handler.call(store, local.state, payload) })} registerAction 和 registerGetteraction 和 getter 的注册也是同理 唯一区别就是 action handler 比 mutation handler 以及 getter wrapper 多拿到 dispatch 和 commit 操作方法 因此 action 可以进行 dispatch action 和 commit mutation 操作 registerAction 函数是对 store 的 action 的初始化，它和 registerMutation 的参数一致 不同的地方在于，mutation 是同步修改当前模块的 state，而 action 是可以异步的通过提交一个 mutation 去修改 state 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364function registerAction(store, type, handler, local) { // 通过 type 拿到对应的 actions 对象数组 const entry = store._actions[type] || (store._actions[type] = []) // 存储新的封装过的 action handler entry.push(function wrappedActionHandler(payload, cb) { // 传入 state 等对象供我们之前的 action handler 使用 let res = handler.call(store, { dispatch: local.dispatch, commit: local.commit, getters: local.getters, state: local.state, rootGetters: store.getters, rootState: store.state }, payload, cb) /* export function isPromise (val) { return val &amp;&amp; typeof val.then === 'function' } */ // 兼容 Promise if (!isPromise(res)) { res = Promise.resolve(res) } // 判断 store._devtoolHook，只有当用到 Vuex devtools 开启的时候，才能捕获 Promise 过程 if (store._devtoolHook) { return res.catch(err =&gt; { store._devtoolHook.emit('vuex:error', err) throw err }) } else { return res } })}function registerGetter(store, type, rawGetter, local) { // getters 只允许存在一个处理函数，若重复需要报错 if (store._wrappedGetters[type]) { if (process.env.NODE_ENV !== 'production') { console.error(`[vuex] duplicate getter key: ${type}`) } return } // 存储新的封装过的 getters 处理函数 store._wrappedGetters[type] = function wrappedGetter(store) { // 为之前的 getters 传入对应的状态 return rawGetter( local.state, // local state local.getters, // local getters store.state, // root state store.getters // root getters ) }} resetStoreVM执行完各 module 的 install 之后，执行 resetVM 方法，进行 store 组件的初始化 本质上，Vuex 其实构建的就是一个名为 store 的 vm 组件，所有配置的 state，actions，mutations 以及 getters 都是其组件的属性，所有的操作都是对这个 vm 组件进行的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172function resetStoreVM(store, state, hot) { // 缓存前 vm 组件，保留 state 树 const oldVm = store._vm // bind store public getters store.getters = {} const wrappedGetters = store._wrappedGetters const computed = {} // 循环所有处理过的 getters，并新建 computed 对象进行存储 // 通过 Object.defineProperty 方法为 getters 对象建立属性 // 使得我们可以通过 this.$store.getters.xxxgetter 能够访问到该 getters // store._vm[xxxgetter] ==&gt; computed[xxxgetter] ==&gt; xxxgetter 对应的回调函数 forEachValue(wrappedGetters, (fn, key) =&gt; { // use computed to leverage its lazy-caching mechanism computed[key] = () =&gt; fn(store) Object.defineProperty(store.getters, key, { get: () =&gt; store._vm[key], enumerable: true // for local getters }) }) // use a Vue instance to store the state tree // suppress warnings just in case the user has added // some funky global mixins const silent = Vue.config.silent // 暂时设置为静默模式，避免因而加载某些插件触发的警告 Vue.config.silent = true // 设置新的 storeVm，将当前初始化的 state 以及 getters 作为 computed 属性（刚刚遍历生成的） store._vm = new Vue({ data: { $$state: state }, computed }) // 恢复 Vue 的模式 Vue.config.silent = silent // enable strict mode for new vm if (store.strict) { // 该方法对 state 执行 $watch 以禁止从 mutation 外部修改 state enableStrictMode(store) } // 若不是初始化过程执行的该方法，将旧的组件 state 设置为 null // 强制更新所有监听者（watchers），待更新生效 // DOM 更新完成后，执行 vm 组件的 destroy 方法进行销毁，减少内存的占用 if (oldVm) { if (hot) { // dispatch changes in all subscribed watchers // to force getter re-evaluation for hot reloading. store._withCommit(() =&gt; { oldVm._data.$$state = null }) } Vue.nextTick(() =&gt; oldVm.$destroy()) }}// 监视 state 的变化，如果没有通过 this._withCommit() 方法进行 state 修改，则报错function enableStrictMode(store) { store._vm.$watch(function () { return this._data.$$state }, () =&gt; { if (process.env.NODE_ENV !== 'production') { assert(store._committing, `Do not mutate vuex store state outside mutation handlers.`) } }, { deep: true, sync: true })} plugin 注入最后就是 plugin 的注入 12// apply pluginsplugins.forEach(plugin =&gt; plugin(this))","link":"/2018/09/04/Vue/10/"},{"title":"使用 webpack 来构建 vue 项目","text":"这里不使用 vue-cli，而是从头开始搭建，一步一步实现一个简易脚手架 理解 vue-cli 到底是怎么实现的（顺路了解一下 webpack 在 vue 项目中的使用） 源码可以见 基于 vue-cli 整合的一个个人脚手架 注：webpack 和 vue 的版本均在 2.0 以上 创建目录大致目录结构如下 12345├── index.html 根本件，最后用于展示 App.vue 组件├── main.js 入口文件├── App.vue vue 组件├── pacjage.json 工程配置文件（依赖，配置）└── webpack.config.js webpack 配置文件 首先新建一个 html 文件，添加一个 id 为 box 的容器 12// html&lt;div id='box'&gt;&lt;/div&gt; 然后在 main.js 文件中添加一点内容，用于最后的渲染 123456789// main.jsimport Vue from 'vue'import App from './App.vue'new Vue({ el: '#box', // 关于 h =&gt; h(App) 见最下方 render: h =&gt; h(App)}) 接下来来安装 webpack 和 webpack-dev-server，再配置一下 webpack，先简单的指定一下入口和出口文件 123456789101112// webpack.config.jsmodule.exports = { // 入口文件 entry: './main.js', // 出口文件 output: { filename: 'bundle.js', // 当前路径 path: __dirname }}; 然后就可以在我们的 index.html 中引入出口文件中指定的 JavaScript 这里是 bundle.js，但是目录中不使用 webpack -p 的话是不存在这个文件的 webpack 会在编译执行的时候为我们自动生成该文件 12// index.html&lt;script src='./bundle.js'&gt;&lt;/script&gt; 关于出口文件，如果想指定输出的目录，可以按照下面这样来设置 123456789101112output: { // 如果目录，如果不存在则会去新建 path: path.resolve(__dirname, './src'), // 设置静态目录（可以从这个目录下直接进行读取） publicPath: '/src/', // 文件名称 filename: 'bundle.js'}, 配置 vue-loader如果需要解析像 App.vue 这样的文件，使其变成正常可以访问的代码，我们需要引入 vue-loader 来处理 这个时候我们就可以在 webpack 中配置我们的相关 loader 了（这也是 webpack 最核心的东西） 在 webpack.config.js 中添加 1234567891011module: { // 所有的 loader 都配置在这里 rules: [ // 下面这句的意思是 使用 vue-loader 来解析处理以 .vue 结尾的文件 // 如果多个 loader 的话，中间可以使用 ! 来连接，比如 style!css { test: /\\.vue$/, loader: 'vue-loader' } ]} 配置完 webpack 以后就可以来安装 vue-loader 以及其相关的一些组件了 单单使用 vue-loader 编译写入 .vue 文件是不够的，因为在 .vue 文件当中主要分为三大块，如下所示 1234567891011&lt;template&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 每一部分都需要相对应的 loader 来进行处理，这时就需要同时安装以下 loader 123456789101112// 处理模版vue-template-compiler ==&gt; 编译 vue 的 template 部分，（之前使用的是 vue-html-loader） // 处理 css，因为 css 分为 .css 文件和行内样式，需要同时加载css-loader ==&gt; 编译写入 cssvue-style-loader ==&gt; 编译 vue 的样式部分// 处理 js，关于 babel 部分见下方vue-hot-reload-api ==&gt; 使 webpack 对 vue 实现热替换 可以使用以下命令来进行安装 1npm install vue-template-compiler css-loader vue-style-loader vue-hot-reload-api --save-dev 配置 babel众所周知，现在浏览器对 ES6 语法的支持还不是很完善，这个时候也就需要使用 babel 来解析 ES6 语法，先来配置 webpack 12345678910111213141516171819202122module: { rules: [ // 规则和上面类似，需要注意的就是多了一个 exclude // 意思是 匹配除了 /node_modules/ 和 bower_components 之外的所有 .js 文件 // 关于 options 选项，如果在根目录下的 .babelrc 配置了，这里就不需要了，两者是一样的 // 关于 .babelrc 见最后 { test: /\\.js$/, exclude: /(node_modules|bower_components)/, use: { loader: 'babel-loader', options: { // 先配置一个前置 presets: ['es2015'], // 还需要一个插件来使每次改变的时候，实时编译 plugins: ['transform-runtime'] } } } ]} babel 需要的相关组件如下： 123456789babel-loader ==&gt; 主程序babel-core ==&gt; 编译核心（语法层面）babel-plugin-transform-runtime ==&gt; 实时编译插件babel-perset-es2015 ==&gt; es6 语法babel-runtime ==&gt; 上面几个程序需要这个组件来运行（babel 执行环境） 最后来汇总一下所有涉及到的依赖： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647vue-loader ==&gt; 编译写入 .vue 文件// 处理 .vue 中的模版vue-template-compiler ==&gt; 编译 vue 的 template 部分，（之前使用的是 vue-html-loader） // 处理 css，因为 css 分为 .css 文件和行内样式，需要同时加载css-loader ==&gt; 编译写入 cssvue-style-loader ==&gt; 编译 vue 的样式部分// 处理 jsvue-hot-reload-api ===&gt; 使 webpack 对 vue 实现热替换// 使用 babel 来处理 es6 语法babel-loader ==&gt; 主程序babel-core ==&gt; 编译核心（语法层面）babel-plugin-transform-runtime ==&gt; 实时编译插件babel-perset-es2015 ==&gt; es6 语法babel-runtime ==&gt; 上面几个 babel 程序需要这个组件来运行（babel 执行环境）// 处理文件和图片file-loader ==&gt; 用于打包文件和图片，默认情况下生成文件的文件名是文件名与 md5 哈希值的组合// webpackwebpack ==&gt; webpack 主程序webpack-dev-server ==&gt; webpack 执行环境// vuevue ==&gt; 这个就不用多说了// 可选url-loader ==&gt; 实际上是对 file-loader 的封装（见最后）webpack-merge ==&gt; 开发环境和生产环节的 webpaak 配置文件的配置合并 启动安装和配置完成以后，这个时候就可以来启动程序了 但是如果想在命令行直接使用类似 npm run dev 命令的话，就需要配置一下 package.json 文件 在 scripts 标签下设置： 1234567// 设置 scripts 即可// --inline 自动刷新// --hot 热载// --port 设定端口（在端口被占用的情况下可以利用这个参数来指定，默认的为 8080）'scripts': { 'dev': 'webpack-dev-server --inline --hot'} 然后就可以使用 npm run dev 命令来启动服务了，如果在控制台中看到： 1Project is running at http://localhost:8080/ 这个时候就表明启动成功了，可以访问 http://localhost:8080/ 来查看效果了 如果配置全部正确的话，就可以在浏览器中看到对应的内容了，修改内容直接保存，浏览器也会自动跟着刷新 如果在最后运行的时候发现控制台出现如下内容： 123[Vue warn]: You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build.// ... 这个就主要涉及到了 vue 的运行时构建和独立构建的区别 简单来说，就是在独立构建的时候可以使用用 template 选项，而在运行时构建则不行，只能通过模板来编译转成 render 函数 两者区别如下： 独立构建包含模板编译器，运行时构建不包含模板编译器 模板编译器的作用就是将 template 选项编译成 render 函数，render 函数是渲染的关键 鉴于以上两点，使用运行时构建时，不能出现 template 选项 因为此时没有模板编译器，但是有一种情况除外：即 webpack + vue-loader 情况下单文件组件中出现 template 是可以的 使用 vue-cli 生成项目时，会提醒使用哪种构建方式，npm 包默认导出的是运行时构建 如果需要使用独立构建，需要在 webpack 中配置 alias 目前暂时发现的两者的应用场景上的区别有： 需要注意 Vue 实例化时的方式，运行时构建方式下实例化 Vue 时，不要出现 template 属性 index.html 中不要出现 template 或者是通过 vue-router 渲染的 route-view 以上区别讨论的场景均为使用 webpack + vue-loader 单文件组件下 解决办法也很简单，只需在 webpack 配置中设置一下 vue 的别名即可 12345resolve: { alias: { 'vue': 'vue/dist/vue.js' }} h =&gt; h(App)在 vuejs 中，可以把 h 函数仅是作为 createElement 函数的缩写，所以上述代码可以理解为 123render: function (createElement){ return createElement(app);} render 方法： 12345678render: function (createElement) { return createElement( // tag name 标签名称 'h' + this.level, // 子组件中的阵列 this.$slots.default )} 也是 2.0 新增的函数，可以直接给绑定节点渲染一个 vue 组件，如果在 1.x 的版本下，就应该使用 123456789new Vue({ el: '#app', components: { App }});// html&lt;div id='app'&gt; &lt;app&gt;&lt;/app&gt;&lt;/div&gt; .babelrc和 .bowerrc 是一样的原理，都是用来配置文件，只需要在根目录新建一个名为 .babelrc 文件，然后添加 1234{ 'presets': ['es2015', 'stage-0'], 'plugins': ['transform-runtime']} 就可以达到和上面一样的效果 url-loaderurl-loader 是对 file-loader 的上层封装，比如可以在 webpack 中对图片的加载器进行配置 1234{ test: /\\.(png|jpg)$/, loader: 'url-loader?limit=8192'} 这样一来，在小于 8K 的图片将直接以 base64 的形式内联在代码中，可以减少一次 http 请求 所以在处理一般小图片的时候就可以使用 url-loader 来转为 base64，其他情况照常使用 file-loader","link":"/2018/09/12/Vue/12/"},{"title":"Angular 中的依赖注入","text":"前文（为什么要使用依赖注入）只是简单的介绍了依赖注入的基本概念和 Angular 当中的一个简单的依赖注入实例 下面我们就来深入的了解一下 Angular 当中的依赖注入到底是什么东西 依赖注入（DI）是一种设计模式，也是 Angular 的核心，在 Angular 中我们使用 Provider 来描述与 Token 关联的依赖对象的创建方式 创建方式有四种，它们分别是 useClass，useValue，useExisting 和 useFactory useClass123456@NgModule({ providers: [ // 两者名称一样的时候可以使用简洁语法，直接使用 ApiService { provide: ApiService, useClass: ApiService } ],}) ClassProvider 接口定义12345678export interface ClassProvider { // 用于设置与依赖对象关联的 Token 值 // Token 值可能是 Type、InjectionToken、OpaqueToken 的实例或字符串 provide: any; useClass: Type&lt;any&gt;; // 用于标识是否 multiple providers，若是 multiple 类型，则返回与 Token 关联的依赖对象列表 multi?: boolean; } Type&lt;any&gt; 类型在 Angular 中分为 Type 类型和非 Type 类似，两者的区别在于注入方式的不同 即：非 Type 类型的参数只能用 @Inject(Something) 的方式注入 接口定义如下 12345export interface Type&lt;T&gt; extends Function { new (...args: any[]): T; }export function isType(v: any): v is Type&lt;any&gt; { return typeof v === 'function';} useValue123providers: [ { provide: 'SEARCH_URL', useValue: 'http://api.xxx.com'}] ValueProvider 接口如下 123456789export interface ValueProvider { // 用于设置与依赖对象关联的 Token 值 // Token 值可能是 Type、InjectionToken、OpaqueToken 的实例或字符串 provide: any; // 设置注入的对象 useValue: any; // 用于标识是否 multiple providers，若是 multiple 类型，则返回与 Token 关联的依赖对象列表 multi?: boolean;} 如果需要使用的话，直接在当前组件的构造函数当中进行注入即可，需要注意使用 @Inject() 123constructor( @Inject('SEARCH_URL') private searchUrl) { } 还会遇到一种问题，如果在开发中引入第三方库以后，可能会引起比如上面的字符串 Token（SEARCH_URL）的冲突问题 这里可以使用 InjectionToken 来解决 useExistinguseExisting 的意思是使用已经注册的类型注入到这里（别名），比如下面示例意思是将 ApiService 起个叫 OtherApiService 的别名 123providers: [ { provide: 'OtherApiService', useExisting: ApiService }] useFactory1234567891011121314@NgModule({ ... providers: [ { provide: APP_INITIALIZER, useFactory: (config: AppConfig) =&gt; { return () =&gt; config.load(); }, deps: [AppConfig], // 关于这个属性，见下方 multi: true } ]}) 一般用于告诉 Injector（注入器），通过调用 useFactory 对应的函数，返回 Token 对应的依赖对象 接口定义如下，详细示例可见上方 1234567891011export interface FactoryProvider { // 用于设置与依赖对象关联的 Token 值 // Token 值可能是 Type、InjectionToken、OpaqueToken 的实例或字符串 provide: any; // 设置用于创建对象的工厂函数 useFactory: Function; // 依赖对象列表 deps?: any[]; // 用于标识是否 multiple providers，若是 multiple 类型，则返回与 Token 关联的依赖对象列表 multi?: boolean;} MultiMulti providers 让我们可以使用相同的 Token 去注册多个 Provider 123456789const SOME_TOKEN: OpaqueToken = new OpaqueToken('SomeToken');var injector = ReflectiveInjector.resolveAndCreate([ provide(SOME_TOKEN, { useValue: 'dependency one', multi: true }), provide(SOME_TOKEN, { useValue: 'dependency two', multi: true })]);// dependencies == ['dependency one', 'dependency two']var dependencies = injector.get(SOME_TOKEN); 我们使用 multi: true 来告诉 Angular 的依赖注入系统，我们设置的 provider 是 multi provider 我们可以使用相同的 token 值来注册不同的 provider，当我们使用对应的 token 去获取依赖项的时候，我们获取的是已注册的依赖对象列表 使用 multi provider 的原因因为如果使用同一个 token 去注册 provider，后面注册的 provider 将会覆盖前面已经注册的 probider 此外，Angular 使用 multi provider 这种机制，为我们提供了可插拔的钩子（pluggable hooks） 另外需要注意：multi provider 是不能和普通的 provider 混用的 使用 Provider步骤如下所示： 创建 Token 根据实际需求来选择依赖对象的创建方式，如 useClass，useValue，useExisting，useFactory 在 NgModule 或 Component 中注册 providers 使用构造注入的方式，注入与 Token 关联的依赖对象 下面是一个示例，封装 http 服务，比如在每个 Http 的请求头中添加 token（类似拦截器） 123456789101112131415161718192021222324252627282930// 封装 http 为一个服务@Injectable()export class ApiService { constructor( public http: Http ) {} ...}// 然后在使用的 Module 当中进行注入@NgModule({ providers: [ { provide: ApiService, usdClass: ApiService } ],})// 然后在组件当中进行注入后使用export class HomePage { constructor( public apiService: ApiService ) {} ngOnInit(): void { this.apiService.get(url) .map(res =&gt; res.json()) .subscribe(v =&gt; { console.log(v) }) }} 一些需要注意的地方： 创建 Token 的时候为了避免命名冲突，尽量避免使用字符串作为 Token 若要创建模块内通用的依赖对象，需要在 NgModule 中注册相关的 provider 若在每个组件中都有唯一的依赖对象，就需要在 Component 中注册相关的 provider 当 DI 解析 Providers 时，都会对提供的每个 provider 进行规范化处理，即转换成标准的形式 12345678910111213141516function _normalizeProviders(providers: Provider[], res: Provider[]): Provider[] { providers.forEach(b =&gt; { // 支持简洁的语法，转换为标准格式 if (b instanceof Type) { res.push({ provide: b, useClass: b }); } else if (b &amp;&amp; typeof b == 'object' &amp;&amp; (b as any).provide !== undefined) { res.push(b as NormalizedProvider); } else if (b instanceof Array) { // 如果是数组，进行递归处理 _normalizeProviders(b, res); } else { throw invalidProviderError(b); } }); return res;} Forward ReferenceAngular 通过引入 forwardRef 让我们可以在使用构造注入的时候，使用尚未定义的依赖对象类型 如果不使用 forwardRef 就会遇到类似下面的问题 1234567891011121314151617@Injectable()class Socket { constructor(private buffer: Buffer) { }}console.log(Buffer); // undefined@Injectable()class Buffer { constructor(@Inject(BUFFER_SIZE) private size: Number) { }}console.log(Buffer); // [Function: Buffer]// 运行后报错// Error: Cannot resolve all parameters for Socket(undefined).// Make sure they all have valid type or annotations 因为我们编写的代码最终都会被转义为 ES5 来运行，所以在编译阶段变量声明和函数声明会自动提升，而函数表达式不会自动提升 如果要解决上面的问题，最简单的处理方式是交换类定义的顺序，或者还可以使用 Angular 提供的 forward reference 特性 12345678910111213import { forwardRef } from '@angular2/core';@Injectable()class Socket { constructor( @Inject(forwardRef(() =&gt; Buffer)) private buffer ) { }}class Buffer { constructor(@Inject(BUFFER_SIZE) private size: Number) { }} forwardRef 原理分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// @angular/core/src/di/forward_ref.ts/** * Allows to refer to references which are not yet defined. */export function forwardRef(forwardRefFn: ForwardRefFn): Type&lt;any&gt; { // forwardRefFn: () =&gt; Buffer // 当调用 forwardRef 方法时，我们只是在 forwardRefFn 函数对象上，增加了一个私有属性__forward_ref__ (&lt;any&gt;forwardRefFn).__forward_ref__ = forwardRef; // 然后覆写了函数的 toString 方法 (&lt;any&gt;forwardRefFn).toString = function () { return stringify(this()); }; return (&lt;Type&lt;any&gt;&gt;&lt;any&gt;forwardRefFn);}/** * Lazily retrieves the reference value from a forwardRef. */// 用来解析通过 forwardRef 包装过的引用值// 由依赖注入系统调用，当解析 Provider 和创建依赖对象的时候，会自动调用该函数// 如下export function resolveForwardRef(type: any): any { if (typeof type === 'function' &amp;&amp; type.hasOwnProperty('__forward_ref__') &amp;&amp; type.__forward_ref__ === forwardRef) { return (&lt;ForwardRefFn&gt;type)(); // Call forwardRefFn get Buffer } else { return type; }}/********************************************************************/// @angular/core/src/di/reflective_provider.ts/** * 解析Provider */function resolveReflectiveFactory(provider: NormalizedProvider): ResolvedReflectiveFactory { let factoryFn: Function; let resolvedDeps: ReflectiveDependency[]; ... if (provider.useClass) { const useClass = resolveForwardRef(provider.useClass); factoryFn = reflector.factory(useClass); resolvedDeps = _dependenciesFor(useClass); }}/********************************************************************//** * 构造依赖对象 */export function constructDependencies( typeOrFunc: any, dependencies: any[]): ReflectiveDependency[] { if (!dependencies) { return _dependenciesFor(typeOrFunc); } else { const params: any[][] = dependencies.map(t =&gt; [t]); return dependencies.map(t =&gt; _extractToken(typeOrFunc, t, params)); }}/** * 抽取Token */function _extractToken( typeOrFunc: any, metadata: any[] | any, params: any[][]): ReflectiveDependency { token = resolveForwardRef(token); if (token != null) { return _createDependency(token, optional, visibility); } else { throw noAnnotationError(typeOrFunc, params); }} inject 装饰器在 Angular 中，Inject 是 参数装饰器，主要用来在类的构造函数中描述 非 Type 类型的参数对象 在 Angular 中的 Type 类型如下所示 12345678// Type类型 - @angular/core/src/type.tsexport const Type = Function;export function isType(v: any): v is Type&lt;any&gt; { return typeof v === 'function';}export interface Type&lt;T&gt; extends Function { new (...args: any[]): T; } Angular 中常用的非 Type 类型 Token 有：字符串（常量）、OpaqueToken 对象、InjectionToken 对象等 OpaqueToken 对象、InjectionToken 对象的构造如下 12345678910111213141516171819/** 用于创建 OpaqueToken 实例* export const CONFIG = new OpaqueToken('config');*/export class OpaqueToken { constructor(protected _desc: string) {} toString(): string { return `Token ${this._desc}`; }}/** 用于创建 InjectionToken 实例，使用泛型描述该 Token 所关联的依赖对象的类型* const API_URL = new InjectionToken&lt;string&gt;('apiUrl'); */export class InjectionToken&lt;T&gt; extends OpaqueToken { private _differentiate_from_OpaqueToken_structurally: any; constructor(desc: string) { super(desc); } toString(): string { return `InjectionToken ${this._desc}`; }} 一个简单的示例 123456789101112131415161718192021// 公共模块，主要作用是导入 providers// 定义一个常量，用来保存一个地址@NgModule({ providers: [ { provide: 'BASE_CONFIG', useValue: { uri: 'http://localhost:3002' } } ]})// 然后在需要使用的地方使用 @Inject 导入进来即可// 而对于 Http 这种 Type 类型则不需要使用 @Injectconstructor( @Inject('BASE_CONFIG') private config, private http: Http) { // ...} 那么这里就会涉及到几个问题 为什么在构造函数中，非 Type 类型的参数只能用 @Inject(Something) 的方式注入因为只有是 Type 类型的对象，才会被 TypeScript 编译器编译 即我们通过 class 关键字声明的服务，最终都会编译成 ES5 的函数对象 AppService（服务） 中的 @Injectable() 是必须的么如果 AppService 不依赖于其他对象，是可以不用使用 Injectable 类装饰器 当 AppService 需要在构造函数中注入依赖对象，就需要使用 Injectable 类装饰器 所以推荐的做法不管是否有依赖对象，service 中都使用 Injectable 类装饰器 在构造函数中，Type 类型的参数是否可以使用 @Inject(Type) 的方式注入Type 类型的参数也能使用 @Inject(Type) 的方式注入，具体如下： 123456// 虽然可以正常使用，但是编辑器会有提示// [ts] Parameter 'http' implicitly has an 'any' type.constructor(@Inject(Http) private http) { }// 也可以这样使用，但是有些冗余constructor(@Inject(Http) private http: Http) { } 如果是 Type 类型的参数，还是推荐使用下面这样的注入方式 1constructor(private http: Http) { } 注入器和提供器使用的时候定义一个变量用来接收对应的服务 ProductServicr 123constructor( private productServicr: ProductServicr) { } 而在定义的时候，需要在提供器的 providers 属性当中指明 1234567891011121314providers: [ProjectDirective]// 等价于下面这种写法，因为 provide 和 useClass 两者的属性皆为 ProductServicr// 所以可以简写成上面那种形式providers: [{ // provide 属性指定了提供器的 token（key） // 就是根据这个属性来匹配注入的对象和提供器 // 然后才会根据提供器的 useClass 属性再去具体实例化某个类 provide: ProductServicr, // 指明实例化的方式为 new 操作（因为定义的为 useClass） // 比如上方在 constructor 当中注入的 ProductServicr 就是经过 new 操作之后的 // 如果这里定义为 useClass: AnotherProductServicr 的话就不能使用简写的方式 useClass: ProductServicr}] 还可以使用如下方式 1234567providers: [{ provide: ProductServicr, // 在这种情况下就不再是直接去执行 new 一个类的操作了 // 而是通过一个工厂方法返回一个实例，再将这个实例注入到 providers 当中 // 比如做一些初始化的工作 useFactory: () =&gt; { ... }}] 提供器的作用域规则 当一个提供器声明在模块当中时（Module），对于该模块下的所有组件是可见的，所有组件都是可以注入的，即在当前模块的 @NgModule 当中的 providers 当中进行注入之后，当前模块下所有组件可用 当一个提供器声明在组件当中时（Component），只对声明它的组件及其子组件可见，其他组件不可注入 当在模块（Module）和组件（Component）当中声明的提供器具有相同的 token（key）的时候，那么组件当中的提供器会覆盖声明在模块当中的提供器（就近原则） 一般情况下优先将服务提供器声明在模块当中 只有在服务只针对某个组件使用，并且对其他组件不可见的时候，才会声明在组件当中 这种情况十分少见，所以一般推荐声明在模块当中 因为服务最终能不能注入到其他地方，是由它在没有在当前模块的 providers 当中声明来决定的 @Injectable 装饰器如下，一个简单的示例 12345678// 封装 http 为一个服务@Injectable()export class ApiService { constructor( public http: Http ) {} ...} 如果所创建的服务不依赖于其他对象，是可以不用使用 @Injectable() 类装饰器 但当该服务需要在构造函数中注入依赖对象，就需要使用 @Injectable() 装饰器，因为只有声明了 @Injectable() 这个装饰器的服务才可以注入其他服务 推荐的做法不管是否有依赖对象，在创建服务时都使用 @Injectable() 类装饰器，这样所有服务都遵循同样的规则，一致性 如果所依赖的服务是动态加载的一个简单的示例，随机生成的随机数动态加载对应服务 1234567891011121314151617181920212223242526272829// app.module.ts@NgModule({ // ... providers: [{ provide: ProductService, useFactory: () =&gt; { let logger = new LoggerService(); let dev = Math.random() &gt; 0.5 if (dev) { return new ProductService(logger) } else { return new AnotherProductService(logger) } } }, LoggerService]})// logger.service.ts// 一个简单的打印日志的服务import {} from '@angular/core'@Injectable()export class LoggerService { constructor() { } log (messgae: string) { console.log(messgae) }} 需要注意，如果多个组件共用这个服务，那么生成的实例都是相同的，因为工厂方法创建的对象是一个单例对象 工厂方法只会在创建第一个对象的时候被调用一次，然后在整个应用当中所有被注入的服务的实例都是同一个对象 上面的实例中存在两个问题 第一个问题在方法内部，手动实例化了一个 new LoggerService()，意味着工厂方法与这个类是一种强耦合的关系 而我们又声明了 LoggerService 的提供器，所以可以采用下面这种方式来解耦 利用第三个参数 deps 来声明工厂方法所依赖的参数 12345678910111213141516@NgModule({ // ... providers: [{ provide: ProductService, useFactory: (logger： LoggerService) =&gt; { let dev = Math.random() &gt; 0.5 if (dev) { return new ProductService(logger) } else { return new AnotherProductService(logger) } }, deps: [LoggerService] }, LoggerService]}) 这时 Angular 将会使用 LoggerService 这个提供器来实例化一个 LoggerService 的实例 并将其注入到 ProductService 的工厂方法的参数当中 第二个问题我们是根据一个随机数来决定实例化哪个对象，这样测试是可以的，但是在发布的时候就不适用了 在这种情况下就可以使用一个变量来决定调用哪个方法 然后同样的在 deps 当中进行依赖声明，然后在当作参数的时候传递进去 12345678910111213141516171819202122@NgModule({ // ... providers: [ { provide: ProductService, useFactory: (logger： LoggerService, isDev) =&gt; { if (isDev) { return new ProductService(logger) } else { return new AnotherProductService(logger) } }, deps: [LoggerService, 'IS_DEV_ENV'] }, LoggerService, { provide: 'IS_DEV_ENV', useValue: false } ]}) 同样的，可以不单一的注入一个固定的值，也是可以注入一个对象，方便维护 123456789101112131415161718192021222324@NgModule({ // ... providers: [ { provide: ProductService, useFactory: (logger： LoggerService, appConfig) =&gt; { if (appConfig.isDev) { return new ProductService(logger) } else { return new AnotherProductService(logger) } }, deps: [LoggerService, 'APP_CONFIG'] }, LoggerService, { provide: 'APP_CONFIG', useValue: { isDev: false } } ]}) 注入器的层级关系前面的提供器只负责实例化所需的依赖对象，将实例化好的对象注入所需组件的工作则是由注入器来完成的 在程序启动的时候， Angular 首先会创建一个应用级注入器，然后将模块中声明的提供器，都注册到这个注入器当中 被注册的提供器除了应用的主模块声明的以外，还包括所有被引用的模块中声明的提供器 比如 123456789101112// app.module.ts@NgModule({ // ... imports: [ BrowserModule, FormsModule, HttpModule ], providers: [ // ... ]}) 在应用级的注入器里面，除了 AppModule 本身声明的一些提供器（providers）会被注册以外 它引入的部分（imports）所有其他的模块，这些模块当中声明的提供器都会被注册到应用级注入器当中 然后 Angular 会创建启动模块指定的主组件（bootstrap 指定的模块），同时应用级别的注入器会为这个主组件创建一个组件级的注入器，并将组件中声明的提供器注册到这个组件级的注入器上 当子组件被创建的时候，它的父组件的注入器会为这个子组件也创建一个注入器，然后将子组件声明的提供器注册上去 以此类推，应用中会形成一组注入器，这些注入器会形成一个与组件的上下级关系一样的层级关系 不过在一般情况下 Angular 可以通过构造函数的参数自动注入所需的依赖 1constructor(private http: Http) { } 同时也需要注意，Angular 的依赖注入点只有一个，就是它的构造函数 如果一个组件的构造函数为空，那么就可以断定，这个函数没有被注入任何东西 简单来说，分为 1应用级的注入器 ==&gt; 主组件注入器 ==&gt; 子组件注入器 手动添加注入器（避免此类操作）但是需要注意，在实际的使用当中避免使用这种方式 12345678910import { Component, OnInit, Injector } from '@angular/core'import { ProductService } from './product.service'export class ProductComponent implements OnInit { private productService: ProductService; constructor(private injector: Injector) { this.productService = injector.get(this.productService) }}","link":"/2018/12/26/Angular/03/"},{"title":"rxjs","text":"rxjs 是一种针对异步数据流编程工具，或者叫响应式扩展程序，rxjs 的目标就是异步编程，Angular 引入 rxjs 为了就是让异步可控，更为简单 大部分 rxjs 操作符都不包括在 Angular 的 Observable 基本实现中，基本实现只包括 Angular 本身所需的功能 如果需要更多的 rxjs 功能，必须导入其所定义的库来扩展 Observable 对象 rxjs 是基于观察者模式和迭代器模式以函数式编程思维来实现的，含有两个基本概念 Observables 作为被观察者，是一个值或事件的流集合 Observer 则作为观察者，根据 Observables 进行处理 两者关系如下 订阅：Observer 通过 Observable 提供的 subscribe() 方法订阅 Observable 发布：Observable 通过回调 next 方法向 Observer 发布事件 ObservableObservable 就是一个拥有以下特性的函数 它接收一个 observer 对象作为参数，该对象中包含 next、error 和 complete 方法 它返回一个函数，用于在销毁 Observable 时，执行清理操作，返回的是 Subcription 对象，该对象中包含一个 unsubscribe 方法 有几个特殊的状态，如下所示 永不结束，它没有 complete 状态，比如计时器 Never 完全不发射，流中没有任何元素，但是也不结束，就是一个空的，没有状态，一般用于测试 Empty 一般也是用于测试，与 Never 类似，也是空的，但是会直接进入 complete 状态，所以是有结束状态的 Throw 直接进入 error 状态，也是不会发射任何元素 emptyempty 操作符返回一个空的 Observable 对象，如果我们订阅该对象，它会立即返回 Complete 信息 12345Rx.Observable.empty().subscribe( null, null, () =&gt; { console.log('Completed') }); nevernever 操作符会返回一个无穷的 Observable 当我们订阅它后，什么事情都不会发生，它是一个一直存在却什么都不做的 Observable 对象 123456Rx.Observable.never() .subscribe( v =&gt; { console.log( v) }, e =&gt; { console.log( e ) }, () =&gt; { console.log('complete') } ); throw只做一件事，抛出错误 123456Rx.Observable.throw('err') .subscribe( v =&gt; { console.log( v) }, e =&gt; { console.log( e ) }, () =&gt; { console.log('complete') } ); Observer Observer (观察者) 是一个普通的对象，该对象会作为 subscribe() 方法的参数 当 Observable 对象产生新值的时候，我们可以通过调用 next() 方法来通知对应的观察者 若出现异常，则会调用观察者的 error() 方法，当我们订阅 Observable 对象后，只要有新的值，都会通知对应的观察者 在下面两种情况中，新的值不会再通知对应的观察者 已调用 observer 对象的 complete() 方法 执行取消订阅操作 1234567interface Observer&lt;T&gt; { closed?: boolean; // 标识是否已经取消对 Observable 对象的订阅 next: (value: T) =&gt; void; // 每当 Observable 发送新值的时候，next 方法会被调用 error: (err: any) =&gt; void; // 当 Observable 内发生错误时，error 方法就会被调用 complete: () =&gt; void; // 当 Observable 数据终止后，complete 方法会被调用 // 需要注意：在调用 complete 方法之后，next 方法不会再被调用} 下面是一些 rxjs 常用的操作符 创建类操作符 from，fromEvent，fromEventPattern，Interval，Timer 工具类操作符 do 变换类操作符 scan 数学类操作符 reduce 过滤类操作符 filter，take，first，last，skip 过滤类操作符 debounce，debounceTime 过滤类操作符 distinct，distinctUntilChanged 合并类操作符 merge，concat，startWith 合并类操作符 combineLatest，withLatestFrom，zip fromfrom 可以支持从数组、类似数组的对象、promise、iterable 对象或类似 Observable 的对象（ES5 当中的 Observable）来创建一个 Observable 它几乎可以把任何对象转换成 Observable 1234var array = [10, 20, 30];var result$ = Rx.Observable.from(array);result$.subscribe(x =&gt; console.log(x)); fromEvent这个操作符是专门为事件转换成 Observable 而制作的，用于处理各种 DOM 中的事件 12var click$ = Rx.Observable.fromEvent(document, 'click');click$.subscribe(x =&gt; console.log(x)); fromEventPattern我们经常会遇到一些已有的代码，这些代码和类库往往不受我们的控制，无法重构或代价太大 在 rxjs 中也提供了对应的方法可以转换 1234567891011121314function addClickHandler(handler) { document.addEventListener('click', handler);}function removeClickHandler(handler) { document.removeEventListener('click', handler);}var click$ = Rx.Observable.fromEventPattern( addClickHandler, removeClickHandler);click$.subscribe(x =&gt; console.log(x)); IntervalRx 提供内建的可以创建和计时器相关的 Observable 方法，第一个是 Interval，它可以在指定时间间隔发送整数的自增长序列 12345678910111213141516171819202122232425262728// 没有条件的情况下 interval 会一直执行下去// 所以触发不了剩余的两种情况（err 和 complete）Rx.Observable.interval(1000).subscribe( v =&gt; { console.log('Value', v) }, e =&gt; { console.log('Error', e) }, () =&gt; { console.log('Completed') });// 稍作修改，添加上条件，便可以看到 Completed// take() 表示取前几个Rx.Observable.interval(1000).take(4) .subscribe( v =&gt; { console.log('Value', v) }, e =&gt; { console.log('Error', e) }, () =&gt; { console.log('Completed') } ); Timer一共有两种形式的 Timer，一种是指定时间后返回一个序列中只有一个元素（值为 0）的 Observable 1234567891011Rx.Observable.timer(1000).subscribe( v =&gt; { console.log('Value', v) }, e =&gt; { console.log('Error', e) }, () =&gt; { console.log('Completed') }); 另外一种很类似于 Interval，接收两个参数，第一个参数表示延迟多长时间，第二个参数表示之后要以什么样的频率来进行发送 也就是说，在一开始的延迟时间后，每隔一段时间就会返回一个整数序列 1234567891011Rx.Observable.timer(1000, 1000).subscribe( v =&gt; { console.log('Value', v) }, e =&gt; { console.log('Error', e) }, () =&gt; { console.log('Completed') }); do一般用来调试，有时也会用来作为外部条件的设置，可以作为一个可以与外部交互的桥梁 因为当 subscribe() 之后，这个流中的东西就已经固定了，就没有办法在对流继续做一些链接的操作 简单来说，do 可以起到一个临时 subscribe() 的作用，但是并没有中断流 123456789101112131415161718192021// 即取得了这个值，也可以改变这个值let logLabel = '当前值为：'Rx.Observable.interval(1000) .map(val =&gt; val * 2) .do(v =&gt; { console.log(logLabel + v) logLabel = '修改后，当前值为：' }) .take(3) .subscribe( v =&gt; { console.log('Value', v) }, e =&gt; { console.log('Error', e) }, () =&gt; { console.log('Completed') } ); scan接收一个函数作为参数，而函数又接收两个参数 123scan((x, y) =&gt; { return x + y;}) x 为累加器，将函数返回的值（比如上面的 x + y）作为下一次累加的 x 值传入进来，与递归很类似 y 为上一个序列过来所接收的值 12345678910111213141516171819202122Rx.Observable.interval(1000) .filter(val =&gt; val % 2 === 0) .scan((x, y) =&gt; { return x + y }) .take(4) .subscribe( v =&gt; { console.log('Value', v) }, e =&gt; { console.log('Error', e) }, () =&gt; { console.log('Completed') } );// 输出结果为// Value 0// Value 2// Value 6// Value 12// Completed 流程图如下所示 123456789101112原始序列： 0------1------2------3------4------5------6------ filter(val =&gt; val % 2 === 0)filter： 0-------------2-------------4-------------6------ scan((x, y) =&gt; { return x + y }) x = 0, y = 0 x = 0, y = 2 x = 2, y = 4 x = 6, y = 6 \\ \\ \\ \\ \\ \\ \\ \\scan： 0-------------2------------6-------------12----- 在有些情况下，需要记住之前的操作结果，这时候用 scan 就是很好的选择 reduce把上面的例子改为 reduce 123456789101112131415Rx.Observable.interval(1000) .filter(val =&gt; val % 2 === 0) .reduce((x, y) =&gt; { return x + y }) .take(4) .subscribe( v =&gt; { console.log('Value', v) }, e =&gt; { console.log('Error', e) }, () =&gt; { console.log('Completed') } ); 与 scan 有一点不同，每次做叠加之后都会发射出一个值 reduce 会把序列当中所有的东西做最后的一个累加值，只会发射出一个值 而又由于上面是一个无限的序列，所以会是一个 Never 调换一下 take() 的位置 123456789101112131415Rx.Observable.interval(1000) .filter(val =&gt; val % 2 === 0) .take(4) .reduce((x, y) =&gt; { return x + y }) .subscribe( v =&gt; { console.log('Value', v) }, e =&gt; { console.log('Error', e) }, () =&gt; { console.log('Completed') } ); 可以看到结果为 12，其实本质上与 scan 的运算是一致的，只不过 reduce 要算出一个最终值，而且只发射最终值 reduce 不仅仅可以用于数学运算，还有一些高级的用法 12345678910111213141516Rx.Observable.interval(100) .filter(val =&gt; val % 2 === 0) .take(4) .reduce((x, y) =&gt; { return [...x, y] }, []) .subscribe( v =&gt; { console.log('Value', v) }, e =&gt; { console.log('Error', e) }, () =&gt; { console.log('Completed') } );// [0, 2, 4, 6] filter123456789101112131415161718192021222324let logLabel = '当前值为：'// 利用 filter 过滤奇数// 需要注意这里的 take(3)，原本应该是 0，1，2 就结束了// 但是之前使用了 filter() 使得偶数放行// 所以这里表示需要等待三个偶数经过后才会结束Rx.Observable.interval(1000) .filter(val =&gt; val % 2 === 0) .do(v =&gt; { console.log(logLabel + v) logLabel = '修改后，当前值为：' }) .take(3) .subscribe( v =&gt; { console.log('Value', v) }, e =&gt; { console.log('Error', e) }, () =&gt; { console.log('Completed') } ); first123456789101112131415161718192021222324252627282930Rx.Observable.interval(1000) .filter(val =&gt; val % 2 === 0) .first() .subscribe( v =&gt; { console.log('Value', v) }, e =&gt; { console.log('Error', e) }, () =&gt; { console.log('Completed') } );// ==&gt; 等同于 take(1)Rx.Observable.interval(1000) .filter(val =&gt; val % 2 === 0) .take(1) .subscribe( v =&gt; { console.log('Value', v) }, e =&gt; { console.log('Error', e) }, () =&gt; { console.log('Completed') } ); last12345678910111213141516// 如果替换成 last() 则会变为一个 Never 状态// 因为序列永远无法到达Rx.Observable.interval(1000) .filter(val =&gt; val % 2 === 0) .last() .subscribe( v =&gt; { console.log('Value', v) }, e =&gt; { console.log('Error', e) }, () =&gt; { console.log('Completed') } ); skip123456789101112131415// 过滤，这里是过滤掉了前三个，即 0，2，4Rx.Observable.interval(1000) .filter(val =&gt; val % 2 === 0) .skip(3) .subscribe( v =&gt; { console.log('Value', v) }, e =&gt; { console.log('Error', e) }, () =&gt; { console.log('Completed') } ); debounce, debounceTime两个操作符的作用都是节流器，限制一定时间内的输出，但是在使用上会有一些不同 debounceTime直接使用，后面传入指定的时间即可，即可达到在规定的时间内节流的作用 12345678Rx.Observable.fromEvent(number, 'keyup').pluck('target', 'value').debounceTime(300).subscribe( v =&gt; { console.log(v) }, e =&gt; { console.log(e) }, () =&gt; { console.log('complete') }); debounce就像是 debounceTime, 但是静默时间段由第二个 Observable 决定 所以可以操作的空间就比较广泛 12345678910Rx.Observable.fromEvent(number, 'keyup').pluck('target', 'value')// 需要注意，如果写成 debounce(() =&gt; { return Rx.Observable.interval(300) })// 这样带有 {} 的形式，需要加上 return.debounce(() =&gt; Rx.Observable.interval(300)).subscribe( v =&gt; { console.log(v) }, e =&gt; { console.log(e) }, () =&gt; { console.log('complete') }); distinct, distinctUntilChangeddistinct将整个序列的流中不一样的保留下来，一样的重复的则过滤掉 比如下面这个示例，如果将输入框中的元素选定或者删除，然后从新输入相同的内容，是不会触发 keyup 事件的 12345678Rx.Observable.fromEvent(number, 'keyup').pluck('target', 'value').distinct().subscribe( v =&gt; { console.log(v) }, e =&gt; { console.log(e) }, () =&gt; { console.log('complete') }); 使用的时候需要小心，尤其是应用在无尽序列当中，因为会极大的消耗内存 distinctUntilChanged只和前一个元素进行对比，前一个元素如果跟其一样，那就抛弃掉 12345678Rx.Observable.fromEvent(number, 'keyup').pluck('target', 'value').distinctUntilChanged().subscribe( v =&gt; { console.log(v) }, e =&gt; { console.log(e) }, () =&gt; { console.log('complete') }); merge, concat, startWith针对多个流，两个或者两个以上的流进行合并 merge两个流，按各自的事件顺序进行合并，严格有时间交叉 一种简单的合并，不回去更改两条流的任何东西 123456789101112const a = document.querySelector('#a');const b = document.querySelector('#b');const a$ = Rx.Observable.fromEvent(a, 'keyup').pluck('target', 'value');const b$ = Rx.Observable.fromEvent(b, 'keyup').pluck('target', 'value'); Rx.Observable.merge(a$, b$) .subscribe( (v) =&gt; { console.log(v) } ) 在两个输入框内分别输入值，则会交替的输出每个输入框内的值 concat严格来说不属于合并，应该属于对接，等待前一个流完成了之后，才会进行下一个流 尽管后面的流的序列很快的执行，也会等待前一个流完成之后才会进行输出 123456Rx.Observable.concat(a$, b$) .subscribe( (v) =&gt; { console.log(v) } ) 从运行结果可以看出，第一个输入框可以正常的输出内容，但是触发第二个输入框的时候是没有反应的 原因是因为第一个输入框是一个无尽序列，理论上只有第一个序列完成后才会输出后面的值，稍作修改 123456789const a$ = Rx.Observable.fromEvent(a, 'keyup').pluck('target', 'value');const c$ = Rx.Observable.from([1, 2, 3, 4]); Rx.Observable.concat(c$, a$) .subscribe( (v) =&gt; { console.log(v) } ) 这样就可以看到输入的值了，因为只有等待第一个序列完成后后续序列输入的值才会输出 startWith如果希望这个流在一开始的时候就有一个值可以发射出来的话，就可以使用 startWith 设置一个默认值，类似初始值 类似于在序列前 concat 一个值 12Rx.Observable.from([1, 2, 3, 4]).startWith(0).subscribe(v =&gt; console.log(v))// 输出 0 1 2 3 4 一般都是用来赋予初始值，避免在一开始的时候流是空的 combineLatest, withLatestFrom, zipcombineLatest组成它的任何一个流当中有新元素出现的话，那么它就会产生一个新流当中对应的一个数据 和 withLatestFrom 相比的话，无论哪个流有改变均会有输出 zip一对一的输出，和 combineLatest 类似，但是严格要求必须配对，即全都需要新的数据 combineLatest 和 zip 的示例可以参考文章开头部分 withLatestFrom以一个流为主，然后这个流产生的数据的时候会去获取另一个流的最新值，注意输出的结果为数组 123456789const a$ = Rx.Observable.fromEvent(a, 'keyup').pluck('target', 'value');const b$ = Rx.Observable.fromEvent(b, 'keyup').pluck('target', 'value'); a$.withLatestFrom(b$) .subscribe( (v) =&gt; { console.log(v) } ) 简单来说，只有当第一个输入框内的值发生变化的时候，才会去取第二个输入框内的值组合成一个数组发送出来 所以改变第二个输入框内的值是不会引起变化的","link":"/2019/06/04/Angular/11/"},{"title":"http 与 tcp","text":"http 协议http 协议即超文本传送协议(Hypertext Transfer Protocol)，定义了浏览器怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器 从层次的角度看，http 是面向（transaction-oriented）应用层协议，它是万维网上能够可靠地交换文件（包括文本，声音，图像等各种多媒体文件）的重要基础，也是 Web 联网的基础，也是手机联网常用的协议之一，http 协议是建立在 tcp 协议之上的一种应用 tcp（Transmission Control Protocol）手机等一些移动设备，能够使用联网功能是因为手机底层实现了 tcp/IP 协议，可以使手机终端通过无线网络建立 tcp 连接 tcp 协议可以对上层网络提供接口，使上层网络数据的传输建立在”无差别”的网络之上 在具体介绍之前，先来弄清一些基本概念 SYN（synchronous）是 tcp/IP 建立连接时使用的握手信号，表示建立连接 FIN 表示关闭连接 ACK（Acknowledgement）既确认字符，在数据通信中，接收站发给发送站的一种传输类控制字符，表示发来的数据已确认接收无误，表示响应 LISTEN 表示服务器端的某个 SOCKET 处于监听状态，可以接受连接了 MIME 类型 在把输出结果传送到浏览器上的时候，浏览器必须启动适当的应用程序来处理这个输出文档 这可以通过多种类型 MIME（多功能网际邮件扩充协议）来完成，在 http 中，MIME 类型被定义在 Content-Type header 中 tcp 传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通信协议 通讯双方建立一次 tcp 连接，需要经过三次步骤，可以见下方的三次握手 URL（Uniform Resource Locator）统一资源定位符URL 统一资源定位符（URL）也被称为网页地址，是因特网上标准的资源的地址，现在几乎所有的 URI 都是 URL，如下所示 12345 协议 ip 地址 资源的具体位置 | | | | | |----- ---------------- -------http://192.168.1.1:8888/index.html 第一部分是协议（或称为服务方式） 第二部分是存有该资源的主机 IP 地址（有时也包括端口号） 第三部分是主机资源的具体位置（如目录和文件名等） 第一部分和第三部分之间用 '：//' 符号隔开，第二部分和第三部分用 '/' 符号分隔，第一部分和第二部分是不可缺少的，第三部分有时也可以省略 tcp 三次握手我们要和服务端连接 tcp 连接，需要通过三次连接，包括：请求，确认，建立连接，即传说中的三次握手协议 第一次握手：客户端发送 syn 包（syn = j）到服务器，并进入 SYN_SEND 状态，等待服务器确认 第二次握手：服务器收到 syn 包，必须确认客户的 SYN（ack = j + 1），同时自己也发送一个 SYN 包（syn = k），即 SYN + ACK 包，此时服务器进入 SYN_RECV 状态 第三次握手：客户端收到服务器的 SYN ＋ ACK 包，向服务器发送确认包 ACK（ack = k + 1），此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据 理想状态下，tcp 连接一旦建立，在通信双方中的任何一方主动关闭连接之前，tcp 连接都将被一直保持下去 但是由于 tcp 连接是全双工的，所以每个方向都必须单独进行关闭，这原则是当一方完成它的数据发送任务后就能发送一个 FIN 来终止这个方向的连接 收到一个 FIN 只意味着这一方向上没有数据流动，一个 tcp 连接在收到一个 FIN 后仍能发送数据，首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭 tcp 四次挥手断开连接时服务器和客户端均可以主动发起断开 tcp 连接的请求，断开过程需要经过”四次挥手” 第一次挥手：tcp 客户端发送一个 FIN，用来关闭客户到服务器的数据传送 第二次挥手：服务器收到这个 FIN，它发回一个 ACK，确认序号为收到的序号加 1，和 SYN 一样，一个 FIN 将占用一个序号 第三次挥手：服务器关闭客户端的连接，发送一个 FIN 给客户端 第四次挥手：客户端发回 ACK 报文确认，并将确认序号设置为收到序号加 1 那么这里就会有一个问题了，为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？ 这是因为服务端的 LISTEN 状态下的 SOCKET 当收到 SYN 报文的建连请求后，它可以把 ACK 和 SYN（ACK 起应答作用，而 SYN 起同步作用）放在一个报文里来发送 但关闭连接时，当收到对方的 FIN 报文通知时，它仅仅表示对方没有数据发送给你了，但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭 SOCKET 也即你可能还需要发送一些数据给对方之后，再发送 FIN 报文给对方来表示你同意现在可以关闭连接了，所以它这里的 ACK 报文和 FIN 报文多数情况下都是分开发送的 总结 http 是要基于 tcp 连接基础上的，简单的说，tcp 就是单纯建立连接，不涉及任何我们需要请求的实际数据，简单的传输，http 是用来收发数据，即实际应用上来的 tcp 是底层通讯协议，定义的是 数据传输和连接方式的规范 http 是应用层协议，定义的是 传输数据的内容的规范 http 协议中的数据是利用 tcp 协议传输的，所以支持 http 也就一定支持 tcp http 支持的是 www 服务，而 tcp/IP 是协议，它是 Internet 国际互联网络的基础，tcp/IP 是网络中使用的基本的通信协议 tcp/IP 实际上是一组协议，它包括上百个各种功能的协议，如：远程登录、文件传输和电子邮件等，而 tcp 协议和 IP 协议是保证数据完整传输的两个基本的重要协议，通常说 tcp/IP 是 Internet 协议族，而不单单是 tcp 和 IP","link":"/2018/05/05/HTTP/05/"},{"title":"JavaScript 中的对象","text":"JavaScript 中的所有事物都是对象：字符串、数值、数组、函数…，对象只是带有属性和方法的特殊数据类型，可以使用 typeof 来进行判断 typeof 函数输出的一共有几种类型，在此列出： 123456789101112131415console.log(typeof x); // undefinedconsole.log(typeof 10); // numberconsole.log(typeof 'abc'); // stringconsole.log(typeof true); // booleanconsole.log(typeof (function () { })); // functionconsole.log(typeof [1, 'a', true]); // objectconsole.log(typeof { a: 10, b: 20 }); // objectconsole.log(typeof null); // objectconsole.log(typeof new Number(10)); // objectconsole.log(typeof Symbol()); // symbol 其中上面的四种（undefined，number，string，boolean）属于简单的值类型，不是对象 剩下的几种情况 — 函数、数组、对象、null、new Number(10) 都是对象，他们都是引用类型 另外 ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值，它是 JavaScript 语言的第七种数据类型 判断一个变量是不是对象非常简单，只需要记住：值类型的类型判断用 typeof，引用类型的类型判断用 instanceof 12var fn = function () { };console.log(fn instanceof Object); // true 下面来看看创建 JavaScript 对象的几种方式 使用 new object() 来创建对象在 JavaScript 中并不存在类，所以可以直接通过 Objeact 来创建对象 12345678var person = new object();person.name = 'abc';person.age = '20';person.say = function () { alert(this.name + ',' + this.age);} 使用如上方式创建，带来的最大问题是，由于没有类的约束，无法实现对象的重复利用，并且没有一种约定，在操作的时候可能会带来问题 使用 JSON 来创建对象JSON 格式就是 JavaScript 的对象，但是它神略去了 xml 中的标签，而是通过 { } 来完成对象的说明 12345678910var person = { // 通过 '属性名：属性值' 来表示，不同的属性通过 ',' 来间隔，最后一个属性后不能有 ',' name: '张三', age: 20, say: function () { alert(this.name + ',' + this.age); }}person.say(); 通过 JSON 依然可以创建对象数组，创建的方式和 JavaScript 的数组一样 12345678var arr = [ {name : '张三', age : 20}, {name : '李四', age : 30}];for (var i = 0; i &lt; arr.length; i++) { alert(arr[i].name);} 使用工厂模式来创建对象通过工厂的方式来创建 person 对象，在 createPerson 中创建一个对象，然后为这个对象设置相应的属性和方法，之后在返回这个对象 123456789101112131415161718function createPerson(name, age) { var o = new Object(); o.name = name; o.age = age; o.say = function () { alert(this.name + ',' + this.age); } return o;}var p1 = createPerson('张三', 20);var p2 = createPerson('李四', 20);p1.say();p2.say(); 使用工厂的方式，虽然有效的解决了类的问题，但是依然存在一个问题，没有办法检测 p1 和 p2 的数据类型 通过 typeof 仅仅只能检测出 object 类型，如果希望使用 instanceof 来检测的话，无法确定检测的类型 使用构造函数来创建对象通过构造函数的方式创建，和基于工厂的创建类似，最大的区别就是函数的名称，约定成俗，第一个字母大写，使用构造函数创建的时候，在函数内部是通过 this 关键字来完成属性的定义 1234567891011121314151617function Person(name, age) { this.name = name; this.age = age; this.say = function () { alert(this.name + ',' + this.age); }}// 通过 new Person 来创建对象var p1 = new Person('张三', 20);var p2 = new Person('李四', 30);p1.say();p2.say();// 使用构造函数的方式可以通过以下的方式来检测对象的类型alert(p1 instanceof Person); 使用构造函数创建所带来的第一个问题就是每一个对象中都会存在一个方法的拷贝，如果对象行为很多的话，空间的占用率会大大的增加 如果在 Person 内部来创建方法 p1.say() 和 p2.say() 是不一样的 解决方法是可以将函数放到全局变量中去定义，这样可以让类中的行为指向同一个函数 123456789function Person(name, age) { this.name = name; this.age = age; this.say = say;}function say() { alert(this.name + ',' + this.age);} 若是将其设置为全局方法，如果将所有的方法都设为全局函数的时候，这个函数就可以被 window 调用 此时就破坏了对象的封装性，而且如果某个对象有大量的方法，就会导致代码中充斥着大量的全局函数，而不利于维护 原型的内存原型是 JavaScript 中非常特殊的一个对象，当一个函数创建之后，就会随之产生一个原型对象，当通过这个函数的构造函数创建了一个具体的对象之后，在这个具体的对象中就会有一个属性指向原型 123456789101112131415161718192021222324252627// 第一种状态function Person() { }//第二种状态Person.prototype.name = 'Leon';Person.prototype.age = 23;Person.prototype.say = function () { alert(this.name + ',' + this.age);}// 第三种状态// 创建了一个对象之后会有一个 _prop_ 的属性指向原型// 在使用的时候如果在对象内部没有找到属性就会去原型中找，_prop_ 属性是隐藏的var p1 = new Person();p1.say();// 以下方法可以检测出 p1 是否有 _prop_ 指向 Person 的原型alert(Person.prototype.isPrototypeOf(p1));// 第四种状态var p2 = new Person();p2.name = 'lisi';p2.say();p1.say(); 然后依次图解函数中的四种状态，如下所示 第一种状态 以上是第一种状态：function Person() { } Person 函数中有一个 prototype 的属性指向 Person 的原型对象，在原型对象中有一个 constructor 的属性指向了 person 函数，所以可以通过 new Person() 创建对象 第二种状态 以上是第二种状态，通过 Person.prototype.name 为原型设置值以后，这些属性和方法都是设置在 Person 的原型中的 第三种状态 第三种状态是，当使用 Person 创建了对象之后，会在对象中有一个 _prop_ 属性（这个属性是不能被访问的）指向了原型 当使用对象调用原型的时候，首先会在对象的内部找是否有这个属性，如果没有会通过 _prop_ 去原型中找属性，所以当调用 p1.say() 在自己的空间中不存在这个方法，就会去原型中寻找，找到了之后完成 say 的调用 第四种状态 第四种状态，当创建了一个新的 p2 之后，依然会有一个 _prop_ 属性指向 Person 的原型 此时如果通过 p2.name 设置了属性之后，会在对象自己的内存空间中存储 name 的值，当调用 say 方法的时候，在寻找 name 的时候，在自己的空间中找到以后，就不会去原型中查找了 特别注意：原型中的值不会被替换，仅仅只是在查找的时候会被覆盖 原型的重写使用如下方式来编写代码，当属性和方法特别多的时候，编写起来不是很方便，可以通过 JSON 的格式来编写 123456Person.prototype.name = 'Leon';Person.prototype.age = 23;Person.prototype.say = function () { alert(this.name + ',' + this.age);} 以下方式将会重写原型，由于原型重写，而且没有通过 Person.prototype 来指定，此时 constructor 不会在指向 Person 而是指向 Object 如果 constructor 真的比较重要，可以在 JSON 中说明原型的指向 1234567891011Person.prototype = { constructor: Person, // 手动指定 constructor name: 'Leon', age: 23, say: function () { alert(this.name + ',' + this.age); }}var p1 = new Person();p1.say(); 测试123456789101112131415161718192021222324function Person() { };var p1 = new Person();Person.prototype.sayHi = function () { alert(this.name + ' :hi');}p1.sayHi();// 注意 是把重写放置在 new Person 之后Person.prototype = { constructor: Person, // 手动指定 constructor name: 'Leon', age: 23, say: function () { alert(this.name + ',' + this.age); }}p1.sayHi(); // 不会报错，但是没有 this.namep2.sayHi() // 此时 p2 没有 sayHi 所以会报错p2.say(); // Leon 23 运行如下图所示： 基于组合和动态原型创建为了解决原型所带来的问题，此外需要通过组合构造函数和原型来实现对象的创建，将属性在构造函数中定义，将方法在原型中定义，这种有效集合了两者的优点，是目前最为常用的一种方式 1234567891011121314151617181920212223242526function Person(name, age, friends) { // 属性在构造函数中定义 this.name = name; this.age = age; this.friends = friends;}Person.prototype = { constructor: Person, // 方法在原型中定义 say: function () { alert(this.name + '[' + this.friends + ']'); }}// 此时所有的属性都是保存在自己的空间中的var p1 = new Person('Leon', 23, ['Aid', 'Cilr']);p1.name = 'Jim';p1.friends.push('Milk'); //为 p1 增加一个朋友p1.say();var p2 = new Person('Aid', 33, ['Leon']);// 此时原型中就多了一个 Milkp2.say(); // Leon adi cilr milk 基于原型的一个实例12345678910111213141516function obj(name) { if (name) { this.name = name; } return this;}obj.prototype.name = 'name2';var a = obj('name1');var b = new obj;console.log(a.name); // name1console.log(window.name); // name1console.log(b.name); // name2 一般函数直接调用，默认 this 指向全局 window/global 通过 obj('name1') 调用，返回 this 引用，并传递给 a，此时 a 等于 window 对象，即可输出 name 值 new 操作，new obj 等价于 new obj() ，实例化一个对象，这时 this 指向 obj，要拿到 b.name 的值，需要保证 name 属性存在 属性查找原则是先查找当前实例有没有属性，如果有就直接使用，如果没有，就到原型上去找，在没有就接着原型链一步一步往上 这里为了和 a.name 作属性区别，使用了 if (name) 有条件的构建 this 的属性 name 所以，现在 name 属性提供给 a 使用，原型上的 name 提供给 b 使用 实例变体一123456789101112131415161718192021// 去掉 if 判断function obj(name) { // if(name) { this.name = name; // } return this;}obj.prototype.name = 'name2';var a = obj('name1');var b = new obj;console.log(a.name); // name1console.log(window.name); // name1console.log(b.name); // undefined// 这时，b 实例已经有属性 name，但是参数 name 是为 undefined 的// 所以这时可以把 this.name 属性删掉，这样就能去原型找 name 了delete b.name;console.log(b.name); // name2 实例变体二 试试传个参数12345678910111213function obj(name) { this.name = name; return this;}obj.prototype.name = 'name2';var a = obj('name1');var b = new obj('myname');console.log(a.name); // name1console.log(window.name); // name1console.log(b.name); // myname this 指向问题12345678/* new Constructor*/function new (f) { var n = { '__prop__': f.prototype; } /* step1 */ return function () { f.apply(n, arguments); /* step2 */ return n; /* step3 */ };} 笼统的说，都是指向了构造函数，但实际上是指向了实例化的对象 其实 new 一个构造函数的过程是：先创建一个空对象，然后该对象自然有了 this，然后产生一个继承的过程（为该函数添加一个 __peoto__ 属性，指向构造函数的原型） 这样一来，自然而然空对象就具有了构造函数的所有属性，最后在通过 apply 之类的方式调用构造函数，把环境指向原先的空对象，达到模拟调用构造函数产生一个新对象的目的 几种面向对象的书写方式第一类123456789101112131415+function () { function Circle(nRadius) { this.nR = nRadius; } Circle.prototype = { PI: 3.14, fnGetArea: function () { return this.PI * this.nR * this.nR; } } var c1 = new Circle(5); alert(c1.fnGetArea()); // 78.5}(); 上面这种可以说是很标准的面向对象 JavaScript 书写方式了我们又称之为工厂模式，优点就是简单容易上手，以上代码略微改动，会有如下这个变种： 12345678910111213141516171819+function () { function Circle(nRadius, sMessage) { this.init.apply(this, arguments); } Circle.prototype = { init: function (nRadius, sMessage) { this.nR = nRadius; this.sMessage = sMessage; }, PI: 3.14, fnGetArea: function () { return this.sMessage + ': ' + this.PI * this.nR * this.nR; } } var c = new Circle(5, '构造初始化 面积'); alert(c.fnGetArea()); // 构造初始化 面积: 78.5}(); this.init.apply(this, arguments) 这行代码把初始化的任务交接给了 init() 方法，这么做的好处就是可以把所有初始化的东西都放在一个地方进行，增加可阅读性 第二类1234567891011121314151617181920+function () { function Circle() { } Circle.prototype = { init: function (nRadius, sMessage) { this.nR = nRadius; this.sMessage = sMessage; }, PI: 3.14, fnGetArea: function () { return this.sMessage + ': ' + this.PI * this.nR * this.nR; } } var c = new Circle(); c.init(5, '手动构造初始化 面积'); alert(c.fnGetArea()); // 手动构造初始化 面积: 78.5}(); 这类写法从书写角度来看省去了构造函数初始化属性，改用其 init() 中初始化 改为手动型初始化更易于代码排查修改，当然这种写法还有一个原因就是他可以很好的转换成一般前端接受的封装型代码，我们把上面的代码也略微改动一下 123456789101112131415+function () { var Circle = { init: function (nRadius, sMessage) { this.nR = nRadius; this.sMessage = sMessage; }, PI: 3.14, fnGetArea: function () { return this.sMessage + ': ' + this.PI * this.nR * this.nR; } } Circle.init(5, '封装型 面积'); alert(Circle.fnGetArea()); // 封装型 面积: 78.5}(); 上面这类代码优点是代码的封装性良好，可以有效的重用，多用于页面功能性效果实现，封装一个 Tab 控件、封装一个跑马灯效果等等 缺点就是不能很好的用作继承，这是和上面三种格式最大区别，可话又说回来一般 JavaScript 代码很少会用到继承的地方，除非是写一个大型库（类似 YUI）会用到继承外，一般写一个功能模块用到封装型代码就够用了 上面介绍了两类 4 种面向对象的写法，一般面向对象书写格式基本都在上面了，熟悉面向对象书写可以有效的增加你对 JavaScript 的理解 熟练使用上面 4 中写法也能够很好的在工作中给代码维护修改带来便利，最后我们再来谈一个技巧，让你的 JavaScript 代码在技巧上进化 用对象字面量构造对象一个对象字面量就是包含在一对花括号中的 0 个或多个 名/值 对，上文在面向对象书写格式的时候我们就大量的使用了对象字面量的书写格式 对象字面量书写 JavaScript 可以很好的简化代码，又能极大的增加代码可读性，尤其作为参数使用可以有化腐朽为神奇的表现，我们看下面代码 123456789101112131415+function () { function Person(sName, nAge, nWeight, bSingle) { this.sName = sName; this.nAge = nAge; this.nWeight = nWeight; this.bSingle = bSingle; } Person.prototype.showInfo = function () { return this.sName + ' ' + this.nAge + ' ' + this.nWeight + ' ' + this.bSingle; } var p = new Person('张三', 25, 75, true); alert(p.showInfo()); // 张三 25 75 true}(); 上面是一个很标准的工厂模式，一般而言这类写法属于那种规规矩矩没有大错也没有亮点的代码，而且参数不少，一个不小心还会传入错误的参数，而应用对象字面量技巧可以很好的规避此类问题，我们来看改动过后的代码 12345678910111213141516171819202122232425(function () { function Person() { } Person.prototype = { init: function (option) { if (typeof option == 'undefined') { option = {}; } this.sName = option.sName || '张三'; this.nAge = option.nAge || 25; this.nWeight = option.nWeight || 75; this.bSingle = (typeof option.bSingle != 'undefined') ? option.bSingle : true; }, showInfo: function () { return this.sName + ' ' + this.nAge + ' ' + this.nWeight + ' ' + this.bSingle; } } var p = new Person(); p.init({ nWeight: 80, sName: '李四' }) alert(p.showInfo()); // 李四 25 80 true})(); 这里使用第三种面向对象写法，传入参数改成了一个对象字面量，而且传入参数可以是随意设置，位置颠倒也不会有任何问题 这里充分利用对象字面量优点，利用键值对代替原始的传参方式大大提升了可读性和容错性 还有一个改进就是默认值的处理，如果没有传入任何参数，此代码也能很好的运行下去，不会有任何问题 参考： JavaScript 面向对象 全面理解面向对象的 JavaScript","link":"/2017/10/07/JavaScript/25/"},{"title":"移动端图片上传的那些坑","text":"之前的代码逻辑存在一些问题，现在从新调整优化了代码，更换了部分方法，可以下拉至下方看 2017-03-06 更新 之前做了一个关于移动端图片裁剪上传的功能，主要嵌套在 app 中作为 WebView 使用，踩过一堆坑，总结一下 大体的思路如下 利用 input(file) 选择上传文件，使用 FileReader 读取 file 文件，获取到图片的 base64 格式 利用 canvas，在页面上新建一个画布，利用 canvas 提供的 API，将图片添加至 canvas 调用裁剪插件（这里采用的是 cropper），进行裁剪，获取到裁剪后的新图片 图片上传 然后下面来逐条分析其中的坑 上传的文件当中的坑1&lt;input type=\"file\" id=\"upload\" name=\"file\" accept=\"image/*\"&gt; 1var file = document.getElementById('upload').files[0]; 这里会有两个问题 一个是 input 的 change 事件只会触发一次，可以使用在上传后重新替换掉原先的 input 然后在重新绑定事件 12345$('#input').replaceWith('&lt;input type=\"file\" id=\"upload\" name=\"file\" accept=\"image/*\"&gt;');$('#input').on('change', function() { // ...}) 另外一个是如果连续上传多次，最后保存的数据还会是第一次拍照（或是相册选取）的图片，这里只需要在次重新上传的时候清空一下前一次的上传结果即可 然后利用 canvas 进行绘图，并进行裁剪，这里会遇到部分机型下，拍照的照片会出现旋转的问题，这里采用 exif.js 来解决 修正图片旋转问题123456789101112131415161718192021// 配合下面的 getImgData() 函数修正图片旋转问题var orientation;EXIF.getData(file, function () { orientation = EXIF.getTag(this, \"Orientation\");});var reader = new FileReader();reader.readAsDataURL(file);reader.onloadstart = function () { // 读取前的一些操作，比如可以增加遮罩一类的}reader.onload = function (e) { // 利用 exif 获取 图片源信息（修正角度） getImgData(this.result, orientation, function (data) { console.log(data) });} getImgData()方法具体如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * 修正 IOS 拍照上传图片裁剪时角度偏移（旋转）问题 * * img 图片的 base64 * dir exif 获取的方向信息 * next 回调方法，返回校正方向后的 base64 * **/function getImgData(img, dir, next) { var image = new Image(); image.onload = function () { var degree = 0, drawWidth, drawHeight, width, height; drawWidth = this.naturalWidth; drawHeight = this.naturalHeight; // 改变一下图片大小 var maxSide = Math.max(drawWidth, drawHeight); if (maxSide &gt; 1024) { var minSide = Math.min(drawWidth, drawHeight); minSide = minSide / maxSide * 1024; maxSide = 1024; if (drawWidth &gt; drawHeight) { drawWidth = maxSide; drawHeight = minSide; } else { drawWidth = minSide; drawHeight = maxSide; } } // 创建画布 var canvas = document.createElement('canvas'); canvas.width = width = drawWidth; canvas.height = height = drawHeight; var context = canvas.getContext('2d'); // 判断图片方向，重置 canvas 大小，确定旋转角度，iphone 默认的是 home 键在右方的横屏拍摄方式 switch (dir) { // iphone 横屏拍摄，此时 home 键在左侧 case 3: degree = 180; drawWidth = -width; drawHeight = -height; break; // iphone 竖屏拍摄，此时 home 键在下方(正常拿手机的方向) case 6: canvas.width = height; canvas.height = width; degree = 90; drawWidth = width; drawHeight = -height; break; // iphone 竖屏拍摄，此时 home 键在上方 case 8: canvas.width = height; canvas.height = width; degree = 270; drawWidth = -width; drawHeight = height; break; } // 使用 canvas 旋转校正 context.rotate(degree * Math.PI / 180); context.drawImage(this, 0, 0, drawWidth, drawHeight); // 返回校正图片 next(canvas.toDataURL('image/jpeg', .8)); } image.src = img;} 将校正方向后的图片添加至画布中，然后调用 cropper 进行裁剪 12345678910111213141516171819202122232425262728293031323334353637383940414243// 图片裁剪var $image = $('img');// 图片加载完成后在进行裁剪$image.on('load', function () { // 裁剪框容器位置居中，如果图片过大，加上限定范围 if ($image.height() &gt; $(window).height()) { $('imgWrap').height($(window).height()) } else { $('imgWrap').css({ left: 0, top: $(window).height() / 2 - $('imgWrap').height() / 2 }) } // 裁剪，获取裁剪参数 x，y，width，height $image.cropper({ aspectRatio: 16 / 9, // 裁剪比例 guides: false, autoCropArea: 1, zoomable: false, crop: function (data) { var coord = 'x_' + data.x.toFixed(0) + ',y_' + (data.y.toFixed(0)) + ',w_' + (data.width).toFixed(0) + ',h_' + (data.height).toFixed(0); } });})// 点击后获取到裁剪信息$('#btn').on('click', function () { // 获取参数 var src = $image.eq(0).attr('src'); var canvasdata = $image.cropper('getCanvasData'); var cropBoxData = $image.cropper('getCropBoxData'); // 调用 convertToData() 方法，获取裁剪后的 base64 即为最终裁剪后的数据 convertToData(src, canvasdata, cropBoxData, function (basechar) { $('#newImg').attr('src', basechar).show(); });}) convertToData()方法具体如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 图片裁剪函数 * * url 图片的 url 地址 * canvasdata 利用 cropper 获取 var canvasdata = $image.cropper('getCanvasData'); * cropBoxData 利用 cropper 获取 var cropBoxData = $image.cropper('getCropBoxData'); * callback 回调函数 * **/function convertToData(url, canvasdata, cropdata, callback) { var cropw = cropdata.width; // 剪切的长 var croph = cropdata.height; // 剪切的宽 var imgw = canvasdata.width; // 图片缩放或则放大后的高 var imgh = canvasdata.height; // 图片缩放或则放大后的高 var poleft = canvasdata.left - cropdata.left; // canvas 定位图片的左边位置 var potop = canvasdata.top - cropdata.top; // canvas 定位图片的上边位置 var canvas = document.createElement('canvas'); var ctx = canvas.getContext('2d'); canvas.width = cropw; canvas.height = croph; var img = new Image(); img.src = url; img.onload = function () { this.width = imgw; this.height = imgh; // canvas 与图片的裁剪之间的关系位置 ctx.drawImage(this, poleft, potop, this.width, this.height); // 这里的 1 是处理图片的清晰度（0-1）之间,当然越小图片越模糊,处理后的图片大小也就越小 var base64 = canvas.toDataURL('image/jpg', 1); // 回调 base64 字符串 callback &amp;&amp; callback(base64) }} 最后就是图片上传了，可以根据后台图片处理的方式不同而采取不同的方法，这里就说说两种用过的方式 图片处理一种就是阿里云的图片处理 这个时候就需要 coord 这个变量的值了，因为在阿里云预览的话需要对应的裁剪坐标参数来得到裁剪后的图片 需要注意的是，阿里云的图片处理的坐标不能有小数点，否则会报错 还有一点就是，如果移动端上传的图片过大，会导致裁剪坐标错位，这个时候可以采用阿里云自带的图片压缩参数，压缩至屏幕大小宽高度即可 最后的结果类似 1(这里是服务器地址)?x-oss-process=image/resize,m_fixed,h_22,w_22(这里是缩放坐标)/crop,x_0,y_22,w_222,h_222(这里是裁剪坐标) 二就是直接把校正裁剪后生成的 base64 发送到服务器，由服务器来进行处理 2017-03-06 更新最近新做的的一个项目，也有一个类似的上传裁剪的功能，理了一下之前做过的，发现逻辑上存在很多问题，也不够清晰明了，也就没打算复用，所以就在之前的基础上做了部分调整，理顺各个步骤，使得代码逻辑更加清晰 备注：仅适用于图片 CND，如果后台可以处理 base64 格式图片，根本就不需要上面那么多麻烦事 如果不想看各个步骤的话，可直接拖至最下方看整合后的完整代码 基本的逻辑如下： 利用 input(file) 选择上传文件，使用 exif 读取/保存信息 使用 FileReader 读取文件后，修正旋转角度，转换为 blob 格式文件使用 FormData 上传，拿到上传成功后服务器返回的原图地址 使用 cropper 裁剪，生成裁剪参数 拼接 原图地址 + 裁剪参数 = 裁剪后图片 下面来逐条分析其中的逻辑： 首先使用 input(file) 选择上传文件，触发 change 事件，然后使用 exif 来 读取/保存 图片的信息，看图片是否需要做旋转处理 1234567891011121314151617181920212223$('#input').on('change', function () { uploadImg()})function uploadImg() { // 获取 file var file = document.getElementById('input').files[0]; if (!/image\\/\\w+/.test(file.type)) { alert('上传文件格式不正确！'); return false; } // 利用 exif 读取/保存 图片信息 var orientation; EXIF.getData(file, function () { orientation = EXIF.getTag(this, 'Orientation'); }); // ...} 然后使用 HTML5 的 FileReader 接口来读取文件，在 onload 以后，根据 exif 读取的信息，来修正对应的旋转角度，并得到旋转后的 base64 图片地址 至于为什么需要使用 exif 来读取图片信息，是因为在部分 IOS/Android 机型下，拍照上传的图片会发生旋转，这里就统一处理了 12345678910var reader = new FileReader();reader.readAsDataURL(file);reader.onload = function (e) { // 利用 getImgData 来旋转图片（方法在上方有详细展示） getImgData(e.target.result, orientation, function (data) { // ... })} 因为修正旋转角度需要用到 readAsDataURL() 处理后的地址（base64 地址），然而 base64 格式文件并不能直接上传（如果后台可以处理 base64 的话，那你就不需要这么多复杂的操作了） 我们还需要对其进行处理，将其转换为二进制的 blob 文件格式后再来上传，这里使用的是 FormData 上传，当然使用其他上传方式也是可以的 这里可以预留一个旋转后的图片缓存地址（base64 格式）用于后面来裁剪 然后处理多次上传失效可以使用 form 表单的 reset() 方法，比之之前替换 input 以后再重新绑定 change 事件的处理上面更优雅一些 12345678910111213141516171819202122232425262728293031323334getImgData(e.target.result, orientation, function (data) { // 缓存个地址，用于后面裁剪 var cacheImg = data; // 转换为 bolb var blob = dataURItoBlob(data); var canvas = document.createElement('canvas'); var dataURL = canvas.toDataURL('image/jpeg', 0.5); // 利用 formdata 上传 var fd = new FormData(document.forms[0]); // file 等效于 input 中的 name // image.png 则是文件名，由于 base64 的图片信息是不带文件名的，可以手动指定一个 fd.append('file', blob, 'image.png'); // 上传 $.ajax({ url: '', method: 'POST', processData: false, contentType: false, dataType: 'json', data: fd, success(data) { // ... // 重置 form 表单后可以多次重复上传 $('#input').get(0).reset(); } })}) base64 转换为 bold 的具体方法如下 12345678910111213141516171819function dataURItoBlob(base64Data) { var byteString; if (base64Data.split(',')[0].indexOf('base64') &gt;= 0) { byteString = atob(base64Data.split(',')[1]); } else { byteString = unescape(base64Data.split(',')[1]); } var mimeString = base64Data.split(',')[0].split(':')[1].split(';')[0]; var ia = new Uint8Array(byteString.length); for (var i = 0; i &lt; byteString.length; i++) { ia[i] = byteString.charCodeAt(i); } return new Blob([ia], { type: mimeString });} 利用 CDN（例如阿里云图片等）上传成功之后，就得到了服务器返回的旋转后的图片的线上地址，然后利用之前缓存的旋转后的 base64 格式的图片 cacheImg 来进行裁剪，这样我们就可以得到裁剪坐标，然后拼在一起，也就得到了我们裁剪后的图片地址，具体实现如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 用于存储裁剪坐标var coordinate = '';// 这里使用 layer 的裁剪遮罩（确定/取消 按钮 和一个 图片 容器）var open = layer.open({ content: '&lt;div&gt;&lt;div&gt;取消&lt;/div&gt;&lt;div&gt;确定&lt;/div&gt;&lt;/div&gt;&lt;div class=\"imgBox\"&gt;&lt;img src=\"\"&gt;&lt;/div&gt;'});// 将之前缓存的 旋转后的图片 添加到裁剪层上$('.imgBox img').attr('src', cacheImg);var $image = $('.imgBox img');// 图片加载完成后在进行裁剪$image.on('load', function () { // 确定裁剪框和图片位置 if ($image.height() &gt; $(window).height()) { // ... } else { // ... } // 裁剪框居中，如果放置于其他位置的话可自行调整 $('.imgBox').css({ left: 0, top: $(window).height() / 2 - ($('.imgBox').height() / 2) }) // 裁剪，获取裁剪参数 x，y，width，height $image.cropper({ aspectRatio: 1 / 1, // 比例根据需求自行调整 guides: false, autoCropArea: 1, zoomable: false, crop: function (data) { // 裁剪坐标也根据需求自行调整 coordinate = data.x + data.y + data.width + data.height; } });})// 裁剪确定事件$('确定').on('click', function () { // 拿到上传成功服务器返回的原图地址 + 裁剪坐标 = 裁剪后的图片，然后可以添加到需要展示的位置 $('#newImg').attr('src', data.result + coordinate) // 关闭裁剪层 layer.close(open);})// 裁剪取消事件$('取消').on('click', function () { // 关闭裁剪层 layer.close(open);}) 以上就是全部的流程，下面是整合后的完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122// 绑定 change 事件$('#input').on('change', function () { uploadImg()})// 裁剪上传函数function uploadImg() { // 获取 file var file = document.getElementById('input').files[0]; // 判断格式 if (!/image\\/\\w+/.test(file.type)) { alert('上传文件格式不正确！'); return false; } // 利用 exif 读取/ 保存 图片信息 var orientation; EXIF.getData(file, function () { orientation = EXIF.getTag(this, 'Orientation'); }); // 调用 FileReader 接口，生成 base64 图片格式 var reader = new FileReader(); reader.readAsDataURL(file); reader.onload = function (e) { // 利用 getImgData 来旋转图片（方法在上方有详细展示） getImgData(e.target.result, orientation, function (data) { // 缓存一个旋转后的图片地址，用于后面裁剪 var cacheImg = data; // 转换为 bolb var blob = dataURItoBlob(data); // 利用 formdata 上传 var fd = new FormData(document.forms[0]); // file 等效于 input 中的 name // image.png 则是文件名，由于 base64 的图片信息是不带文件名的，可以手动指定一个 fd.append('file', blob, 'image.png'); // 上传 $.ajax({ url: '', method: 'POST', processData: false, contentType: false, dataType: 'json', data: fd, success(data) { // 重置 form 表单后可以多次重复上传 $('#input').get(0).reset(); // 用于存储裁剪坐标 var coordinate = ''; // 这里使用 layer 的裁剪遮罩（确定/取消 按钮 和一个 图片 容器） var open = layer.open({ content: '&lt;div&gt; &lt;div&gt;取消&lt;/div&gt; &lt;div&gt;确定&lt;/div&gt; &lt;/div&gt; &lt;div class=\"imgBox\"&gt;&lt;img src=\"\"&gt;&lt;/div&gt;' }); // 将之前缓存的 旋转后的图片 添加到裁剪层上 $('.imgBox img').attr('src', cacheImg); var $image = $('.imgBox img'); // 图片加载完成后在进行裁剪 $image.on('load', function () { // 确定裁剪框和图片位置 if ($image.height() &gt; $(window).height()) { // ... } else { // ... } // 裁剪框居中，如果放置于其他位置的话可自行调整 $('.imgBox').css({ left: 0, top: $(window).height() / 2 - ($('.imgBox').height() / 2) }) // 裁剪，获取裁剪参数 x，y，width，height $image.cropper({ aspectRatio: 1 / 1, // 比例根据需求自行调整 guides: false, autoCropArea: 1, zoomable: false, crop: function (data) { // 裁剪坐标也根据需求自行调整 coordinate = data.x + data.y + data.width + data.height; } }); }) // 裁剪确定事件 $('确定的按钮').on('click', function () { // 拿到上传成功服务器返回的原图地址（data.result） + 裁剪坐标（coordinate） = 裁剪后的图片 // 然后可以添加到需要展示的位置 $('#newImg').attr('src', data.result + coordinate) // 关闭裁剪层 layer.close(open); }) // 裁剪取消事件 $('取消的按钮').on('click', function () { // 关闭裁剪层 layer.close(open); }) } }) }) }}","link":"/2017/03/02/JavaScript/43/"},{"title":"Vuex 源码整体汇总","text":"整体如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762// store.js// 定义局部变量 Vue，用于判断是否已经装载和减少全局作用域查找let Vue // bind on installexport class Store { constructor(options = {}) { // Auto install if it is not done yet and `window` has `Vue`. // To allow users to avoid auto-installation in some cases, // this code should be placed here. See #731 // 源码中所涉及到的方法 /* // store.js 最后导出部分 export function install(_Vue) { if (Vue &amp;&amp; _Vue === Vue) { if (process.env.NODE_ENV !== 'production') { console.error( '[vuex] already installed. Vue.use(Vuex) should be called only once.' ) } return } Vue = _Vue applyMixin(Vue) } // mixin.js export default function (Vue) { const version = Number(Vue.version.split('.')[0]) if (version &gt;= 2) { Vue.mixin({ beforeCreate: vuexInit }) } else { // override init and inject vuex init procedure // for 1.x backwards compatibility. const _init = Vue.prototype._init Vue.prototype._init = function (options = {}) { options.init = options.init ? [vuexInit].concat(options.init) : vuexInit _init.call(this, options) } } function vuexInit() { const options = this.$options // 将初始化 Vue 根组件时传入的 store 设置到 this 对象的 $store 属性上 // 子组件从其父组件引用 $store 属性，层层嵌套进行设置 if (options.store) { this.$store = typeof options.store === 'function' ? options.store() : options.store } else if (options.parent &amp;&amp; options.parent.$store) { this.$store = options.parent.$store } } } */ // 判断若处于浏览器环境下且加载过 Vue，则执行 install 方法 // 见上方 install ==&gt; applyMixin ==&gt; mixin.js 中的 vuexInit if (!Vue &amp;&amp; typeof window !== 'undefined' &amp;&amp; window.Vue) { install(window.Vue) } // 使用断言函数， // 确保 Vue 的存在，也就是在实例化 Store 之前，必须要保证之前的 install 方法已经执行过 // 另外一点就是需要支持 Promise 语法，因为 Vuex 是依赖 Promise 的 if (process.env.NODE_ENV !== 'production') { assert(Vue, `must call Vue.use(Vuex) before creating a store instance.`) assert(typeof Promise !== 'undefined', `vuex requires a Promise polyfill in this browser.`) assert(this instanceof Store, `Store must be called with the new operator.`) } // 利用解构赋值，拿到 options 里面的 plugins 和 strict // plugins 表示应用的插件 // strict 表示是否开启严格模式 const { plugins = [], strict = false } = options // store internal state // 是否在进行提交状态标识，作用是保证对 Vuex 中 state 的修改只能在 mutation 的回调函数中 // 而不能在外部随意修改 state this._committing = false // 存储用户定义的所有的 actions this._actions = Object.create(null) this._actionSubscribers = [] // mutations this._mutations = Object.create(null) // 封装后的 getters 集合对象 this._wrappedGetters = Object.create(null) /* // module/module-collection.js class ModuleCollection { constructor(rawRootModule) { // 将传入的 options 对象整个构造为一个 module 对象 // 并循环调用 register() 方法为其中的 modules 属性进行模块注册，使其都成为 module 对象 // 最后 options 对象被构造成一个完整的组件树 // register root module (Vuex.Store options) this.register([], rawRootModule, false) } // ... register(path, rawModule, runtime = true) { // ... // 分割模块的情况 const newModule = new Module(rawModule, runtime) if (path.length === 0) { this.root = newModule // &lt;=== 这里是 ① } else { const parent = this.get(path.slice(0, -1)) parent.addChild(path[path.length - 1], newModule) } // register nested modules // util.js export function forEachValue (obj, fn) { Object.keys(obj).forEach(key =&gt; fn(obj[key], key)) } if (rawModule.modules) { forEachValue(rawModule.modules, (rawChildModule, key) =&gt; { this.register(path.concat(key), rawChildModule, runtime) }) } } } */ // 用于支持 store 分模块传入，存储分析后的 modules // ModuleCollection 见上方 this._modules = new ModuleCollection(options) // 模块命名空间 map this._modulesNamespaceMap = Object.create(null) // 订阅函数集合，Vuex 提供了 substcribe 功能，用来存储所有对 mutation 变化的订阅者 this._subscribers = [] // 一个 Vue 对象的实例，主要是利用 Vue 实例方法 $watch 来观测变化 this._watcherVM = new Vue() // bind commit and dispatch to self // 把 Store 类的 dispatch 和 commit 方法的 this 指针指向当前 store 的实例上 const store = this const { dispatch, commit } = this // 封装替换原型中的 dispatch 和 commit 方法，详细解释见下方 this.dispatch = function boundDispatch(type, payload) { return dispatch.call(store, type, payload) } this.commit = function boundCommit(type, payload, options) { return commit.call(store, type, payload, options) } // strict mode // 是否开启严格模式 this.strict = strict // state 没有放在上面 options 对象中初始化了，改为在 module/module.js 下初始化，见上面 ① // 详细可见 module/module.js const state = this._modules.root.state /* 下面这三个方法就是 Store 的三个核心方法 */ // init root module. // this also recursively registers all sub-modules // and collects all module getters inside this._wrappedGetters // 见下方 installModule(this, state, [], this._modules.root) // initialize the store vm, which is responsible for the reactivity // (also registers _wrappedGetters as computed properties) resetStoreVM(this, state) // apply plugins plugins.forEach(plugin =&gt; plugin(this)) if (Vue.config.devtools) { devtoolPlugin(this) } } /* ============================================== 下面这些就是一些内部方法或者是向外部暴露的方法（API） ============================================== */ get state() { return this._vm._data.$$state } set state(v) { if (process.env.NODE_ENV !== 'production') { assert(false, `Use store.replaceState() to explicit replace store state.`) } } commit(_type, _payload, _options) { // check object-style commit const { type, payload, options } = unifyObjectStyle(_type, _payload, _options) // 配置参数处理 const mutation = { type, payload } const entry = this._mutations[type] if (!entry) { if (process.env.NODE_ENV !== 'production') { console.error(`[vuex] unknown mutation type: ${type}`) } return } // 专用修改 state 方法，其余修改 state 的方法均为非法修改 this._withCommit(() =&gt; { entry.forEach(function commitIterator(handler) { handler(payload) }) }) // 订阅者函数遍历执行，传入当前的 mutation 对象和当前的 state this._subscribers.forEach(sub =&gt; sub(mutation, this.state)) if ( process.env.NODE_ENV !== 'production' &amp;&amp; options &amp;&amp; options.silent ) { console.warn( `[vuex] mutation type: ${type}. Silent option has been removed. ` + 'Use the filter functionality in the vue-devtools' ) } } dispatch(_type, _payload) { // check object-style dispatch const { type, payload } = unifyObjectStyle(_type, _payload) // 配置参数处理 const action = { type, payload } // 当前 type 下所有 action 处理函数集合 const entry = this._actions[type] if (!entry) { if (process.env.NODE_ENV !== 'production') { console.error(`[vuex] unknown action type: ${type}`) } return } // 订阅者函数遍历执行，传入当前的 action 对象和当前的 state this._actionSubscribers.forEach(sub =&gt; sub(action, this.state)) return entry.length &gt; 1 ? Promise.all(entry.map(handler =&gt; handler(payload))) : entry[0](payload) } subscribe(fn) { return genericSubscribe(fn, this._subscribers) } subscribeAction(fn) { return genericSubscribe(fn, this._actionSubscribers) } // watch 作用是响应式的监测一个 getter 方法的返回值，当值改变时调用回调 // getter 接收 store 的 state 作为唯一参数 watch(getter, cb, options) { if (process.env.NODE_ENV !== 'production') { assert(typeof getter === 'function', `store.watch only accepts a function.`) } // 函数首先断言 watch 的 getter 必须是一个 func // 接着利用了 this._watcherVM 的 $watch 方法，观测 getter 方法返回值的变化 // 如果有变化则调用 cb 函数，回调函数的参数为新值和旧值 // watch 方法返回的是一个方法，调用它则取消观测 return this._watcherVM.$watch(() =&gt; getter(this.state, this.getters), cb, options) } // 替换整个 rootState（一般用于调试） // 调用 this._withCommit 方法修改 Store 的 rootState // 因为不能在 mutation 的回调函数外部去改变 state replaceState(state) { this._withCommit(() =&gt; { this._vm._data.$$state = state }) } // 动态注册一个模块 installModule registerModule(path, rawModule, options = {}) { // 判断 path ==&gt; 转为 Array if (typeof path === 'string') path = [path] if (process.env.NODE_ENV !== 'production') { assert(Array.isArray(path), `module path must be a string or an Array.`) assert(path.length &gt; 0, 'cannot register the root module by using registerModule.') } this._modules.register(path, rawModule) installModule(this, this.state, path, this._modules.get(path), options.preserveState) // reset store to update getters... // 这个方法在下面 resetStoreVM(this, this.state) } // 与上面那个方法相对应，注销一个动态模块 unregisterModule(path) { if (typeof path === 'string') path = [path] if (process.env.NODE_ENV !== 'production') { assert(Array.isArray(path), `module path must be a string or an Array.`) } this._modules.unregister(path) this._withCommit(() =&gt; { const parentState = getNestedState(this.state, path.slice(0, -1)) Vue.delete(parentState, path[path.length - 1]) }) resetStore(this) } // 热加载新的 action 和 mutation hotUpdate(newOptions) { this._modules.update(newOptions) resetStore(this, true) } _withCommit(fn) { const committing = this._committing this._committing = true fn() this._committing = committing }}function genericSubscribe(fn, subs) { if (subs.indexOf(fn) &lt; 0) { subs.push(fn) } return () =&gt; { const i = subs.indexOf(fn) if (i &gt; -1) { subs.splice(i, 1) } }}// 重置 store 对象，然后再次安装 Module 对应的属性function resetStore(store, hot) { store._actions = Object.create(null) store._mutations = Object.create(null) store._wrappedGetters = Object.create(null) store._modulesNamespaceMap = Object.create(null) const state = store.state // init all modules // 最后一个参数传入 true，即 hot 参数为 true // 这样会在 installModule 当中的 if (!isRoot &amp;&amp; !hot) { ... } 的逻辑便不会执行 // 由于 hot 为 true，就不会重新对状态树做设置，则 state 会保持不变 // 因为已经明确的删除了对应 path 下的 state 了，要做的事情只不过就是重新注册一遍 muations、actions 以及 getters installModule(store, state, [], store._modules.root, true) // reset vm // 重置 Store 的 _vm 对象 resetStoreVM(store, state, hot)}function resetStoreVM(store, state, hot) { const oldVm = store._vm // bind store public getters store.getters = {} const wrappedGetters = store._wrappedGetters const computed = {} forEachValue(wrappedGetters, (fn, key) =&gt; { // use computed to leverage its lazy-caching mechanism computed[key] = () =&gt; fn(store) Object.defineProperty(store.getters, key, { get: () =&gt; store._vm[key], enumerable: true // for local getters }) }) // use a Vue instance to store the state tree // suppress warnings just in case the user has added // some funky global mixins const silent = Vue.config.silent Vue.config.silent = true store._vm = new Vue({ data: { $$state: state }, computed }) Vue.config.silent = silent // enable strict mode for new vm if (store.strict) { enableStrictMode(store) } if (oldVm) { if (hot) { // dispatch changes in all subscribed watchers // to force getter re-evaluation for hot reloading. store._withCommit(() =&gt; { oldVm._data.$$state = null }) } Vue.nextTick(() =&gt; oldVm.$destroy()) }}/* 接收五个参数 store -- 当前 Store 的实例 rootState -- 根 state path -- 当前嵌套模块的路径数组 module -- 当前安装的模块 hot -- 当动态改变 modules 或者热更新的时候为 true*/function installModule(store, rootState, path, module, hot) { // 判断是否为根 const isRoot = !path.length /** * 我们在构造函数中调用的时候为 installModule(this, state, [], options) * 所以这里的 path.length 为空，所以 isRoot 为 true * 而 module 自然就是传递进来的 options * 即 state，actions，mutations，getters 和嵌套的 modules */ // 新增的模块命名空间 const namespace = store._modules.getNamespace(path) // register in namespace map // 是否设置了命名空间，若存在则在 namespace 中进行 module 的存储 if (module.namespaced) { store._modulesNamespaceMap[namespace] = module } // set state // 非根组件设置 state 方法 if (!isRoot &amp;&amp; !hot) { // 在不是根组件且不是 hot 条件的情况下 // 通过 getNestedState 方法拿到该 module 父级的 state /** // 根据 path 查找 state 上的嵌套 state function getNestedState (state, path) { return path.length ? path.reduce((state, key) =&gt; state[key], state) : state } */ const parentState = getNestedState(rootState, path.slice(0, -1)) // 由于模块的 path 是根据模块的名称 concat 连接的 // 所以 path 的最后一个元素就是当前模块的模块名 // 然后拿到其所在的 moduleName const moduleName = path[path.length - 1] /** _withCommit (fn) { // 保存之前的提交状态 const committing = this._committing // 进行本次提交，若不设置为 true，直接修改 state // 在 strict 模式下，Vuex 将会产生非法修改 state 的警告 this._committing = true // 执行 state 的修改操作 fn() // 修改完成后还原本次修改之前的状态 this._committing = committing } */ // 一个代理方法，Vuex 中所有触发 mutation 的进行 state 的修改操作都会经过它 // 保证同步修改 state 的过程中 this._committing 的值始终为 true // 可以统一管理监控 state 状态的修改 // 这样当我们观测 state 的变化的时候，如果 this._committing 不为 true，则说明这个状态的修改是有问题的 // 拿到 parentState 和 moduleName // 然后利用 Vue.set 方法将 state 设置到父级 state 对象的 moduleName 属性中 // 由此实现该模块的 state 注册 // 注：如果是首次执行，因为是根目录注册，所以并不会执行该条件中的方法 store._withCommit(() =&gt; { Vue.set(parentState, moduleName, module.state) }) } // module 上下文环境设置 // 命名空间和根目录条件判断完毕后，接下来定义 local 变量和 module.context 的值 // makeLocalContext 方法会为该 module 设置局部的 dispatch，commit 方法以及 getters 和 state（namespace 的存在需要做兼容处理） const local = module.context = makeLocalContext(store, namespace, path) // 分别对 mutations，actions，getters 进行注册，见下 // 注册对应模块的 mutation，供 state 修改使用 module.forEachMutation((mutation, key) =&gt; { const namespacedType = namespace + key registerMutation(store, namespacedType, mutation, local) }) // 注册对应模块的 action，供数据操作、提交 mutation 等异步操作使用 module.forEachAction((action, key) =&gt; { const type = action.root ? key : namespace + key const handler = action.handler || action registerAction(store, type, handler, local) }) // 注册对应模块的 getters，供 state 读取使用 module.forEachGetter((getter, key) =&gt; { const namespacedType = namespace + key registerGetter(store, namespacedType, getter, local) }) // 这个是 Store 中的 Module // 需要注意这里传入的 path 参数是不为空的 // 注册完了根组件的 actions、mutations 以及 getters 后，递归调用自身 // 为子组件注册其 state，actions、mutations 以及 getters 等 module.forEachChild((child, key) =&gt; { installModule(store, rootState, path.concat(key), child, hot) })}/** * make localized dispatch, commit, getters and state * if there is no namespace, just use root ones */function makeLocalContext(store, namespace, path) { const noNamespace = namespace === '' const local = { dispatch: noNamespace ? store.dispatch : (_type, _payload, _options) =&gt; { const args = unifyObjectStyle(_type, _payload, _options) const { payload, options } = args let { type } = args if (!options || !options.root) { type = namespace + type if (process.env.NODE_ENV !== 'production' &amp;&amp; !store._actions[type]) { console.error(`[vuex] unknown local action type: ${args.type}, global type: ${type}`) return } } return store.dispatch(type, payload) }, commit: noNamespace ? store.commit : (_type, _payload, _options) =&gt; { const args = unifyObjectStyle(_type, _payload, _options) const { payload, options } = args let { type } = args if (!options || !options.root) { type = namespace + type if (process.env.NODE_ENV !== 'production' &amp;&amp; !store._mutations[type]) { console.error(`[vuex] unknown local mutation type: ${args.type}, global type: ${type}`) return } } store.commit(type, payload, options) } } // getters and state object must be gotten lazily // because they will be changed by vm update Object.defineProperties(local, { getters: { get: noNamespace ? () =&gt; store.getters : () =&gt; makeLocalGetters(store, namespace) }, state: { get: () =&gt; getNestedState(store.state, path) } }) return local}function makeLocalGetters(store, namespace) { const gettersProxy = {} const splitPos = namespace.length Object.keys(store.getters).forEach(type =&gt; { // skip if the target getter is not match this namespace if (type.slice(0, splitPos) !== namespace) return // extract local getter type const localType = type.slice(splitPos) // Add a port to the getters proxy. // Define as getter property because // we do not want to evaluate the getters in this time. Object.defineProperty(gettersProxy, localType, { get: () =&gt; store.getters[type], enumerable: true }) }) return gettersProxy}/* 接收四个参数 store 为当前 Store 实例 type 为 mutation 的 type handler 为 mutation 执行的回调函数，作用就是同步修改当前模块的 state local 为当前模块的路径*/function registerMutation(store, type, handler, local) { // 通过 type 拿到对应的 mutation 对象数组 const entry = store._mutations[type] || (store._mutations[type] = []) // 将 mutation 包装成函数 push 到数组当中，同时添加载荷 payload 参数 // 所以 commit 实际调用的不是我们传入的 handler，而是经过封装的 entry.push(function wrappedMutationHandler(payload) { // 调用 handler 并将 state 传入 handler.call(store, local.state, payload) })}function registerAction(store, type, handler, local) { // 通过 type 拿到对应的 actions 对象数组 const entry = store._actions[type] || (store._actions[type] = []) // 存储新的封装过的 action handler entry.push(function wrappedActionHandler(payload, cb) { // 传入 state 等对象供我们之前的 action handler 使用 let res = handler.call(store, { dispatch: local.dispatch, commit: local.commit, getters: local.getters, state: local.state, rootGetters: store.getters, rootState: store.state }, payload, cb) /* export function isPromise (val) { return val &amp;&amp; typeof val.then === 'function' } */ // 兼容 Promise if (!isPromise(res)) { res = Promise.resolve(res) } // 判断 store._devtoolHook，只有当用到 Vuex devtools 开启的时候，才能捕获 Promise 过程 if (store._devtoolHook) { return res.catch(err =&gt; { store._devtoolHook.emit('vuex:error', err) throw err }) } else { return res } })}function registerGetter(store, type, rawGetter, local) { // getters 只允许存在一个处理函数，若重复需要报错 if (store._wrappedGetters[type]) { if (process.env.NODE_ENV !== 'production') { console.error(`[vuex] duplicate getter key: ${type}`) } return } // 存储新的封装过的 getters 处理函数 store._wrappedGetters[type] = function wrappedGetter(store) { // 为之前的 getters 传入对应的状态 return rawGetter( local.state, // local state local.getters, // local getters store.state, // root state store.getters // root getters ) }}function enableStrictMode(store) { store._vm.$watch(function () { return this._data.$$state }, () =&gt; { if (process.env.NODE_ENV !== 'production') { assert(store._committing, `Do not mutate vuex store state outside mutation handlers.`) } }, { deep: true, sync: true })}function getNestedState(state, path) { return path.length ? path.reduce((state, key) =&gt; state[key], state) : state}function unifyObjectStyle(type, payload, options) { if (isObject(type) &amp;&amp; type.type) { options = payload payload = type type = type.type } if (process.env.NODE_ENV !== 'production') { assert(typeof type === 'string', `Expects string as the type, but found ${typeof type}.`) } return { type, payload, options }}export function install(_Vue) { if (Vue &amp;&amp; _Vue === Vue) { if (process.env.NODE_ENV !== 'production') { console.error( '[vuex] already installed. Vue.use(Vuex) should be called only once.' ) } return } Vue = _Vue applyMixin(Vue)}","link":"/2018/09/11/Vue/11/"},{"title":"Angular 中传递参数的几种方式","text":"我们先来看看几种比较常用的方式 输入输出属性（装饰器）这个应该也是用的最多的一种方式 123@Input() ...@Output() change: EventEmitter&lt;number&gt; = new EventEmitter&lt;number&gt;(); 模版变量123&lt;!-- 父组件 --&gt;&lt;child-component #child&gt;&lt;/child-component&gt;&lt;button (click)=\"child.name = 'zhangsan'\"&gt;设置子组件名称&lt;/button&gt; 使用 @ViewChild 装饰器1234567891011import { ChildComponent } from './child.component';export class AppComponent { @ViewChild(ChildComponent) childCmp: ChildComponent; ngAfterViewInit() { this.childCmp.name = 'zhangsan'; }} 利用 Subject（基于 rxjs）子组件利用服务发送数据流，父组件订阅流 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// message.service.tsimport { Injectable } from '@angular/core';import { Observable } from 'rxjs/Observable';import { Subject } from 'rxjs/Subject';@Injectable()export class MessageService { private subject = new Subject&lt;any&gt;(); sendMessage(message: string) { this.subject.next({ text: message }); } clearMessage() { this.subject.next(); } getMessage(): Observable&lt;any&gt; { return this.subject.asObservable(); }}// home.component.tsimport { Component } from '@angular/core';import { MessageService } from './message.service';@Component({ selector: 'exe-home', template: ` &lt;div&gt; &lt;h1&gt;Home&lt;/h1&gt; &lt;button (click)=\"sendMessage()\"&gt;Send Message&lt;/button&gt; &lt;button (click)=\"clearMessage()\"&gt;Clear Message&lt;/button&gt; &lt;/div&gt;`})export class HomeComponent { constructor(private messageService: MessageService) { } sendMessage(): void { this.messageService.sendMessage('Message from Home Component to App Component!'); } clearMessage(): void { this.messageService.clearMessage(); }}// app.component.tsimport { Component, OnDestroy } from '@angular/core';import { Subscription } from 'rxjs/Subscription';import { MessageService } from './message.service';@Component({ selector: 'my-app', template: ` &lt;div&gt; &lt;div *ngIf=\"message\"&gt;{{message.text}}&lt;/div&gt; &lt;exe-home&gt;&lt;/exe-home&gt; &lt;/div&gt; `})export class AppComponent implements OnDestroy { message: any; subscription: Subscription; constructor(private messageService: MessageService) { this.subscription = this.messageService .getMessage().subscribe(message =&gt; { this.message = message; }); } ngOnDestroy() { this.subscription.unsubscribe(); }} 其他：还可以使用 evnetBus 中转的方式，更多可见 文档 路由参数的传递接下来我们再看看如果通过路由来进行参数的传递，主要分为三种方式 在查询参数中传递 在路由路径中传递 在路由配置中传递 下面就一个一个来看 在查询参数中传递如下所示，只需在标签当中使用 queryParams 添加跳转的路由和需要的参数即可 123&lt;a [routerLink]=\"['/pages', 'case']\" [queryParams]=\"{ case: this.case.id }\"&gt; &lt;button&gt;预览&lt;/button&gt;&lt;/a&gt; 而在对应组件当中则可以通过 ActivatedRoute 来进行接收 12345678910111213import { ActivatedRoute } from '@amgular/router';export class StockComponent implements OnInit { private caseId: number; constructor(private _activatedRoute: ActivatedRoute) {} ngOnInit() { this.caseId = this._activatedRoute.snapshot.queryParams['id']; }} 在路由路径中传递12345// 定义路由const routes: Routes = [ { path: 'case/:id', component: CaseItemComponent }, ...]; 然后在路由的时候传递数据即可 1&lt;a [routerLink]=\"['/case', '123']\"&gt;预览&lt;/a&gt; 接受参数的方式和上面是一样的，同样是通过 ActivatedRoute 来获取，但是有一点需要注意的就是 如果使用的是 snapshot 的方式传递数据，因为仅仅初始化一次，路由到自身不能传递参数，需要使用订阅模式 1this._activatedRoute.params.subscribe((params: Params) =&gt; this.caseId = params['id']); 在路由配置中传递方式如下，首先在路由当中配置 1234const routes: Routes = [ { path: 'case/:id', component: CaseItemComponent, data: { id: '123' } }, ...]; 接受参数 1this.caseId = this._activatedRoute.snapshot.date[0]['id'];","link":"/2019/07/11/Angular/13/"},{"title":"link 和 @import 的区别","text":"几种区别如下 从属关系区别@import 是 CSS 提供的语法规则，只有导入样式表的作用 link 是 HTML 提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等 加载顺序区别加载页面时，link 标签引入的 CSS 被同时加载 @import 引入的 CSS 将在页面加载完毕后被加载，如果网速慢的话，可能会导致页面的样式混乱 兼容性区别@import 是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别 link 标签作为 HTML 元素，不存在兼容性问题 DOM 可控性区别可以通过 JavaScript 操作 DOM ，插入 link 标签来改变样式 由于 DOM 方法是基于文档的，无法使用 @import 的方式插入样式 权重差异（存在争议）按一般的理解来说，CSS 中的权重，一般指的是选择器的优先级，即 1!important &gt; 行内样式 &gt; ID &gt; 类、伪类、属性 &gt; 标签名 &gt; 通配符 但是在网上看到有关于 link 引入的样式权重大于 @import 引入的样式这样的讨论，不过经过实际操作验证发现存在问题 如果分别把 @import 的样式放置在 link 的前面和后面测试，结果发现前面的被后面的 link 所覆盖，所以说这个说法是不完善的 在《CSS 权威指南》中写道： @import 一定要写在除 @charset 外的其他任何 CSS 规则之前，如果置于其它位置将会被浏览器忽略 而且，在 @import 之后如果存在其它样式，则 @import 之后的分号是必须书写，不可省略的 那么这里又会存在一个小问题，在加载页面的时候，link 标签引入的 CSS 是会先于 @import 引入的 CSS 加载，那么 link 标签引入的样式又怎会把 @import 引入的样式层叠掉呢？ 个人简单的理解是 可以把 @import 这种导入 CSS 文件的方式理解成一种替换，CSS 解析引擎在对一个 CSS 文件进行解析时 如在文件顶部遇到 @import，将被替换为该 @import 导入的 CSS 文件中的全部样式 其虽然后被加载，却会在加载完毕后置于样式表顶部，最终渲染时自然会被下面的同名样式层叠","link":"/2017/11/11/CSS/10/"},{"title":"什么是 FOUC","text":"在页面加载解析时，文档结构表（html）一般会优于样式表（CSS）渲染 这时候渲染出来的是没有样式的页面，然后当浏览器解析到样式表的时候，又结合样式表重新渲染了一遍文档，这时候页面就添加了样式，而前后两次的页面变换会出现一瞬间的闪烁 这种现象称之为文档样式短暂失效（Flash of Unstyled Content），简称为 FOUC 当然，这跟浏览器的渲染有关，不同浏览器的有不同的渲染机制，这并不是 BUG，有的浏览器会采用白屏来处理，而有的又会使用 FOUC 无样式内容闪烁 页面解析和页面渲染大家都听说过 script 会阻塞 html 页面解析，而 link 则不会，结果也确实是这样的，style，link 等样式资源的下载、解析确实不会阻塞页面的解析，但它们会阻塞页面的渲染 来看看两者的区别 页面解析 - 阻塞 html 页面解析，html 页面会被继续下载，但阻塞点后面的标签不会被解析，img，link 等不会发请求获取外部资源 页面渲染 - 阻塞 html 页面渲染，html 页面会被继续下载，阻塞点后面的标签会继续被解析，img，link 等会继续发送请求获取外部资源，但不会合成 Rendering Tree 或不会触发页面渲染，也不会执行 JavaScript 代码 解决办法现在我们知道 FOUC 是由于页面采用临时样式来渲染页面而导致的，那有什么方案可以解决呢？ 第一种方式是确保样式表最先渲染即可，比如 CSS 样式表添加到 head 标签中，使用 link 标签将样式表放在顶部，防止白屏问题意外出现，将 JavaScript 放在底部 这是因为脚本会阻塞其后组件的下载，进而影响到后面内容的呈现 另外一种方式可以先隐藏 body，然后当样式资源加载完成后再显示 body 渲染机制节选自 Critical Rendering Path 想要理清楚为什么会这样，我们需要先来了解一下 Web 浏览器的渲染机制，简单来说有以下几个步骤 1、解析 html 标签, 构建 DOM 树（Document Object Model，浏览器将 html 解析成树形的数据结构，简称 DOM） 2、解析 CSS 标签, 构建 CSSOM 树（CSS Object Model，浏览器将 CSS 代码解析成树形的数据结构，见下方） DOM 和 CSSOM 都是以 Bytes ==&gt; characters ==&gt; tokens ==&gt; nodes ==&gt; object model 这样的方式生成最终的数据 DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点 3、把 DOM 和 CSSOM 组合成 渲染树（render tree） 4、在渲染树的基础上进行布局, 计算每个节点的几何结构 5、把每个节点绘制到屏幕上（painting） Render Tree 和 DOM 一样，以多叉树的形式保存了每个节点的 CSS 属性、节点本身属性、以及节点的孩子节点 display: none 的节点不会被加入 Render Tree，而 visibility: hidden 则会，所以如果某个节点最开始是不显示的，设为 display: none 是更优的 浏览器的渲染过程1、Create/Update DOM And request css/image/js：浏览器请求到 html 代码后，在生成 DOM 的最开始阶段（应该是 Bytes → characters 后），并行发起 CSS、图片、JavaScript 的请求，无论他们是否在 HEAD 里 注意：发起 JavaScript 文件的下载 request 并不需要 DOM 处理到那个 script节点 2、Create/Update Render CSSOM：CSS 文件下载完成，开始构建 CSSOM 3、Create/Update Render Tree：所有 CSS 文件下载完成，CSSOM 构建结束后，和 DOM 一起生成 Render Tree 4、Layout：有了 Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的 CSS 定义以及他们的从属关系，下一步操作称之为 Layout，顾名思义就是计算出每个节点在屏幕中的位置 5、Painting：Layout 后，浏览器已经知道了哪些节点要显示（which nodes are visible）、每个节点的 CSS 属性是什么（their computed styles）、每个节点在屏幕中的位置是哪里（geometry），就进入了最后一步：Painting，按照算出来的规则，通过显卡，把内容画到屏幕上 以上五个步骤前三个步骤之所有使用 'Create/Update' 是因为 DOM、CSSOM、Render Tree 都可能在第一次 Painting 后又被更新多次，比如 JavaScript 修改了 DOM 或者 CSS 属性 Layout 和 Painting 也会被重复执行，除了 DOM、CSSOM 更新的原因外，图片下载完成后也需要调用 Layout 和 Painting 来更新网页 关于 CSSOMCSSOM 是 CSS Object Model 的缩写 大体上来说，CSSOM 是一个建立在 Web 页面上的 CSS 样式的映射，它和 DOM 类似，但是只针对 CSS 而不是 html，浏览器将 DOM 和 CSSOM 结合来渲染 Web 页面 CSSOM是做什么的CSSOM 将样式表中的规则映射到页面对应的元素上 虽然 CSSOM 采取了复杂的措施来做这件事，但是 CSSOM 最终的功能还是将样式映射到它们应该对应的元素上去 更确切地说，CSSOM 识别 tokens 并把这些 tokens 转换成一个树结构上的对应的结点，所有结点以及它们所关联的页面中的样式就是所谓的 CSS Object Model 从上面的渲染机制可以看出，CSSOM 对于 Web 页面的展示起着重要作用 使用CSSOM一个好消息就是你不必为了优化你的 Web 页面而去了解 CSSOM 是怎样工作的，这里有几个关于 CSSOM 的关键点你需要知道，利用这些关键点可以优化页面的加载速度 CSSOM 阻止任何东西渲染 CSSOM 在加载一个新页面时必须重新构建 页面中 CSS 的加载和页面中 JavaScript 的加载是有关系的 CSSOM 阻止任何东西渲染 所有的 CSS 都是阻塞渲染的（意味着在 CSS 没处理好之前所有东西都不会展示） 具体的原因是，如果浏览器在 CSS 检查之前展示了页面，那么每个页面都是没有样式的，等一会之后又突然有了样式，整个页面的体验就会很糟糕 由于 CSSOM 被用作创建 render tree，那么如果不能高效的利用 CSS 会有一些严重的后果，而主要的后果就是你的页面在加载时白屏 CSSOM 在加载一个新页面时必须重新构建 这意味着即使你的 CSS 文件被缓存了，也并不意味着这个已经构建好了的 CSSOM 可以应用到每一个页面 当用户跳到你的另一个页面时（即使浏览器缓存了所有需要的 CSS），CSSOM 也必须重新构建一遍 也就是说，如果你的 CSS 文件写得很蹩脚，或者体积很大，这也会对你页面加载产生负面的影响 页面中 CSS 的加载和页面中 JavaScript 的加载是有关系的 JavaScript 的加载可能会阻塞 CSSOM 的构建 简单来说，CSSOM 是展示任何东西的必需品，在 CSSOM 构建之前，所有东西都不会展示 如果你阻塞了 CSSOM 的构建，CSSOM 的构建就会消耗更长的时间，这就意味着页面的渲染也需要更长的时间 如果你的 JavaScript 阻塞了 CSSOM 的构建，你的用户就会面对更长时间的白屏 参考 解秘 FOUC CSSOM 介绍","link":"/2019/07/07/JavaScript/44/"},{"title":"在列表中插入 3 个，30 个，300 个 li，并绑定事件","text":"今天在网上看到一道面试题，感觉可以从中引申出不少问题，所以在此特意记录一下 由来题目是这样的，要求为题目当中的三个 li 绑定点击事件，并输出对应的 index 1234567&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; 第一印象就是直接获取到这三个元素，然后每个元素绑定一个点击事件，如下 1234567var list = document.getElementsByTagName('li')for (var i = 0; i &lt; list.length; i++) { list[i].onclick = function () { alert(i) }} 很明显这样写并没有实现我们想要的结果，不管点击哪一个 li 都只打印了一个结果就是 3，那么这是什么原因呢？ onclick 是一个事件，这个事件委托了并没有去触发，只有触发的时候才会调用回调函数，代码自上而下运行这时候 i 的值已经变为 3 了，所以每个点击事件的回调结果都是 3 我们来稍微调整一下，使用一个匿名函数将其包裹一下，并且在每次循环的时候将当前 i 的值传递给匿名函数 123456789var list = document.getElementsByTagName('li');for (var i = 0; i &lt; list.length; i++) { +function (j) { list[j].onclick = function () { alert(j); }; }(i)} 这样的话点击不同的 li 就会打印对应的 index 值 简单来说就是改变 i 的作用域，保留它的值，因为之前的代码当中，i 的作用域是全局的，所以打印的结果都是 3 现在是作为实参传递到匿名函数当中，并调用，就变成形参写传递到了事件当中 这样就改变掉了其作用域，也就是将原来有的值保留了下来，所以结果就是打印对应的 index 值 下面我们来稍微扩展一下，采用动态添加的方式 动态插入 3 个 li，并且绑定事件现在我们换成动态插入的模式，本质上实现的原理和之前是一样的 我们直接使用循环创建三个 li 元素，并且绑定事件之后插入到 body 当中 1234567891011for (var i = 0; i &lt; 3; i++) { var item = document.createElement('li'); item.innerText = i + 1; item.addEventListener('click', function () { alert(this.innerText) }, false) document.body.appendChild(item)} 动态插入 30 个 li，并且绑定事件现在变成了插入 30 个 li，数据量不算太大，用 for 循环直接生成勉强也可以完成任务 这个时候可以将事件的绑定方式换成使用事件委托，而不是在绑定到 li 之上 12345678910111213const el = document.bodyfor (var i = 0; i &lt; 30; i++) { var item = document.createElement('li'); item.innerText = i + 1; el.appendChild(item)}el.addEventListener('click', function (e) { if (e.target.tagName === 'LI') { alert(e.target.innerHTML) }}, false) 动态插入 300 个 li，并且绑定事件当数据量变的很大的时候，如果依然使用 for 循环一次性生成的话，可能会引起性能上面的问题 这个时候就可以采用 documentFragment + requestAnimationFrame 的方式来分批次插入数据 目的是减少 DOM 操作次数、缩短循环时间，每次插入的时机是在页面重新渲染之前 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 获取容器元素const el = document.body// 生成总数const total = 300;// 每次插入多少const listSize = 4;// 分多少次插入const listCount = total / listSize;// 已经完成的批次let listDone = 0;function appendItems() { let fragment = document.createDocumentFragment(); for (let i = 0; i &lt; listSize; i++) { const item = document.createElement('li'); item.innerText = (listSize * listDone + i) + 1; fragment.appendChild(item) } // 每批次只修改一次 DOM el.appendChild(fragment) listDone += 1; listAppend()}function listAppend() { if (listDone &lt; listCount) { window.requestAnimationFrame(appendItems); }}listAppend()el.addEventListener('click', function (e) { if (e.target.tagName === 'LI') { alert(e.target.innerHTML) }}, false) window.requestAnimationFrame()requestAnimationFrame 是浏览器用于定时循环操作的一个接口，类似于 setTimeout，主要用途是按帧对网页进行重绘 设置这个 API 的目的是为了让各种网页动画效果能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果 代码中使用这个 API，就是告诉浏览器希望执行一个动画，让浏览器在下一个动画帧安排一次网页重绘 使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用，语法如下 1id = window.requestAnimationFrame(callback) 它会返回一个 id 结果，用于传递给 window.cancelAnimationFrame(id) 来取消重绘 参考 window.requestAnimationFrame","link":"/2018/06/11/JavaScript/45/"},{"title":"数组常用方法的实现","text":"这里只简单介绍五个方法，splice，push，pop，shift 和 unshift Array.prototype.splice()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465Array.prototype.splice = function (start, deleteCount) { var max = Math.max, min = Math.min, delta, // 偏移量 element, insertCount = max(arguments.length - 2, 0), // 排除掉 arguments 参数中 start 和 deleteCount，剩余是待插入元素 k = 0, len = this.length, // 对 array 调用时，this 指向当前数组 new_len, result = [], // 返回数组 shift_count; // 需移位的数量 start = start || 0; // start 默认值为 0 if (start &lt; 0) start += len; // start &lt; 0 时，从数组后端开始 start = max(min(start, len), 0); // 经过处理，0 &lt;= start &lt;= len deleteCount = typeof deleteCount === 'number' ? deleteCount : len; // deleteCount 默认值是 len deleteCount = min(deleteCount, len - start); // deleteCount &lt;= 可删除数量 deleteCount = max(deleteCount, 0); // 0 &lt;= deleteCount &lt;= 可删除数量 delta = insertCount - deleteCount; new_len = len + delta; // 获取删除元素 while (k &lt; deleteCount) { element = this[start + k]; if (element != undefined) { result[k] = element; } k += 1; } shift_count = len - start - deleteCount; // 待插入数量小于删除数量，原数组后续元素依次向左偏移 if (delta &lt; 0) { // 从 start 至 start + insertCount 留给待插入元素 k = start + insertCount; while (shift_count) { this[k] = this[k - delta]; k += 1; shift_count -= 1; } this.length = new_len; // 待插入数量大于删除数量，原数组后续元素依次向右偏移 // delta === 0 时，待插入数量等于删除数量，无需偏移 } else if (delta &gt; 0) { k = 1; while (shift_count) { this[new_len - k] = this[len - k]; k + 1; shift_count -= 1; } // 非必须，因给一开始 this[new_len - k] 赋值时，length 属性已经自动设置为数组最后元素下标值 // this.length = new_len; } // 最后将待插入元素插入原数组 for (k = 0; k &lt; insertCount; k += 1) { // 排除掉 arguments 参数中 start 和 deleteCount this[start + k] = arguments[k + 2]; } return result;}; Array.prototype.push()1234567891011121314151617181920212223242526Array.prototype.push = function () { // 对 arguments 对象通过 array.slice 方法转换成数组 var args = Array.prototype.slice.apply(arguments); // 通过 array.concat 连接两个数组 var params = [this.length, 0].concat(args); // 对数组调用 splice 方法 // start = this.length // deleteCount = 0 // insertItems = args this.splice.apply(this, params); // 返回新的数组 length return this.length;};// 上述步骤合并，简写为下面方式（简单来说就是利用 concat 拼接两个数组）Array.prototype.push = function () { this.splice.apply(this, [this.length, 0].concat(Array.prototype.slice.apply(arguments))); return this.length;}; Array.prototype.pop()1234// 删除并返回数组的最后一个元素Array.prototype.pop = function () { return this.splice(this.length - 1, 1)[0];} Array.prototype.shift()1234// 和上面一样，但是删除并返回数组的第一个元素Array.prototype.shift = function () { return this.splice(0, 1)[0];} Array.prototype.unshift()12345// 向数组的开头添加一个或更多元素，并返回新的长度Array.prototype.unshift = function () { this.splice.apply(this, [0, 0].concat(Array.prototype.slice.apply(arguments))); return this.length;};","link":"/2019/04/17/JavaScript/46/"},{"title":"jQuery.each 和 $(selector).each() 的区别","text":"我们先来看看 $(selector).each() 的使用 $(selector).each()$(selector).each() 一般用于 jQuery 对象的遍历 each() 方法为每个匹配元素规定要运行的函数 123$('ul li').each(function(){ alert($(this).text())}); 通过源码可知，each 方法实际上调用的就是 jQuery.each() 方法 1234567// ...each: function(callback, args) { return jQuery.each(this, callback, args);}// ... $.each而 $.each() 使用的范围就很广了，可用于遍历任何的集合（无论是数组或对象） 下面是几个例子： 1234567891011121314151617181920212223// 参数 i 为遍历索引值，n 为当前的遍历对象var arr = [{ name: 'zhangsan', email: 'zhangsan@gmail.com' }, { name: 'lisi', email: 'lisi@gmail.com' }]$.each(arr, function (i, n) { console.log(`索引: ${i} 对应值为：${n.name}`);});var arr1 = ['one', 'two', 'three', 'four', 'five'];$.each(arr1, function () { console.log(this);});var arr2 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]$.each(arr2, function (i, item) { console.log(item[0]); // 1 4 7});var obj = { one: 1, two: 2, three: 3, four: 4, five: 5 };$.each(obj, function (key, val) { console.log(obj[key]); // 1 2 3 4 5}); each 方法剖析方法 .each() 遍历当前 jQuery 对象，并在每个元素上执行回调函数，每当回调函数执行时，会传递当前循环次数作为参数，循环次数从 0 开始计数 更重要的是，回调函数是在当前元素为上下文的语境中触发的，即关键字 this 总是指向当前元素，在回调函数中返回 false 可以终止遍历 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105// jQuery.each 方法用于遍历一个数组或对象,并对当前遍历的元素进行处理 // jQuery.each 方法可以为处理函数增加附带的参数（带参数与不带参数的回调使用方法不完全一致） // 静态方法 jQuery.each() 是一个通用的遍历迭代方法，用于无缝地遍历对象和数组// 对于数组和含有 length 属性的类数组对象（如函数参数对象 arguments），该方法通过下标遍历，从 0 到 length - 1// 对于其他对象则通过属性名遍历（for-in）// 在遍历过程中，如果回调函数返回 false，则终止遍历// ------------------------------------------// 总的来说就是：// 1. 对于对象，通过 for-in 循环遍历属性名，对于数组或类数组对象，则通过 for 循环遍历下标// 2. 如果传入了参数 args，使用 apply，执行回调函数时只传入一个参数 args// 3. 如果未传入参数 args，使用 call，执行回调函数时传入两个参数：下标或属性名，对应的元素或属性值// ------------------------------------------// 关于参数 args：传给回调函数 callback 的参数数组，可选// 如果没有传入参数 args，则执行回调函数时会传入两个参数（下标或属性名，对应的元素或属性值）// 如果传入了参数 args，则只把该参数传给回调函数each: function (object, callback, args) { // 当需要遍历的是一个对象时, name 变量用于记录对象的属性名 var name, // 当需要遍历的是一个数组时, i 变量用于记录循环的数组下标 i = 0, // 遍历数组长度,当需要遍历的对象是一个数组时存储数组长度 // 如果需要遍历的是一个对象, 则 length === undefined length = object.length, // 变量 isObj 表示参数 object 是对象还是数组，以便决定遍历方式 // 如果 object.length 是 undefined 或 object 是函数，则认为 object 是对象，设置变量 isObj 为 true，将通过属性名遍历 // 否则认为是数组或类数组对象，设置变量 isObj 为 false，将通过下标遍历 isObj = length === undefined || jQuery.isFunction(object); // 回调函数具有附加参数时, 执行第一个分支 // if(!!args) { if (args) { // 需要遍历的是一个对象 if (isObj) { // 遍历对象属性, name 是对象的属性名,再函数顶部已声明 for (name in object) { // 调用 callback 回调函数, 且回调函数的作用域表示为当前属性的值 if (callback.apply(object[name], args) === false) { // 如果在 callback 回调函数中使用 return false; 则不执行下一次循环 break; } } } // 需要遍历的是一个数组 else { // 循环变量的自增在循环内部执行 for (; i &lt; length;) { // 调用 callback 函数, 与上面的 callback 调用一致 // 此处 callback 函数中的 this 指向当前数组元素 // 根据下标 i 依次执行 if (callback.apply(object[i++], args) === false) { break; } } } } // 回调函数没有附加参数时,执行第二个分支 else { // 需要遍历的是一个对象 if (isObj) { for (name in object) { // 调用 callback 回调函数 // 在不带参数的对象遍历中, 作用域表示为当前属性的值 // 且回调函数包含两个参数, 第一个数当前属性名, 第二个是当前属性值 if (callback.call(object[name], name, object[name]) === false) { // 作用同上 break; } } } // 需要遍历的是一个数组 else { for (var value = object[0]; i &lt; length &amp;&amp; callback.call(value, i, value) !== false; value = object[++i]) { } } } // jQuery 并没有把以上两段很相似的代码合并，这是因为在合并后需要反复判断变量 isObj 的值，避免性能下降 // 返回 object ，方法 .each 调用 jQuery.each() 的时候，把当前的 jQuery 对象作为参数 object 传入 // 在这里返回该参数，以支持链式语法 return object;}","link":"/2017/06/04/jQuery/01/"},{"title":"deferred 对象","text":"jQuery.Deferred() 基于 Promises/A 规范实现，因为 jQuery 本身的设计风格，jQuery.Deferred() 并没有完全遵循 Promises/A 规范 jQuery 的 Deferred 对象支持多个回调绑定多个任务，任务本身既可以是同步也可以是异步的，deferred 对象就是 jQuery 的回调函数解决方案 说起 deferred，就不得不提到 promise，deferred 和 promise 不同，它们没有共通的规范 deferred 和 promise 的关系简单来说，deferred 和 promise 具有如下的关系 deferred 拥有 promise deferred 具备对 promise 的状态进行操作的特权方法 如果说 promise 是用来对值进行抽象的话，deferred 则是对处理还没有结束的状态或操作进行抽象化的对象，我们也可以从这一层的区别来理解一下这两者之间的差异 promise 代表了一个对象，这个对象的状态现在还不确定，但是未来一个时间点它的状态要么变为正常值（FulFilled），要么变为异常值（Rejected） 而 deferred 对象表示了一个处理还没有结束的这种事实，在它的处理结束的时候，可以通过 promise 来取得处理结果 而本文中主要介绍 deferred 对象，更多关于 promise 和 deferred 的内容可以参考文底链接 deferred 对象的含义就是延迟到未来某个点再执行，它解决了如何处理耗时操作的问题，对那些操作提供了更好的控制，以及统一的编程接口 deferred 的使用有了 deferred 对象以后，我们可以这样写： 123$.ajax('test.html') .done(function () { alert('success'); }) .fail(function () { alert('error'); }); 可以看到，done() 相当于 success 方法，fail() 相当于 error 方法，采用链式写法以后，代码的可读性大大提高 一个较完整的例子 12345678910111213141516171819202122232425$.when(wait()) .done(function () { alert('success'); }) .fail(function () { alert('error'); });// 如果代码是上面这样，done() 方法会立即执行，原因在于 $.when() 的参数只能是 deferred 对象// 所以必须对 wait() 进行改写（如下所示）var dtd = $.Deferred(); // 新建一个 deferred 对象var wait = function (dtd) { var tasks = function () { alert('done'); // 改变 deferred 对象的执行状态 dtd.resolve(); }; setTimeout(tasks, 5000); return dtd;};// 现在，wait() 函数返回的是 deferred 对象，这就可以加上链式操作了// wait() 函数运行完，就会自动运行 done() 方法指定的回调函数$.when(wait(dtd)) .done(function () { alert('success'); }) .fail(function () { alert('error'); }); resolve() 和 reject()jQuery 规定，deferred 对象有三种执行状态 - 未完成，已完成和已失败 如果执行状态是已完成（resolved），deferred 对象立刻调用 done() 方法指定的回调函数 如果执行状态是已失败，调用 fail() 方法指定的回调函数 如果执行状态是未完成，则继续等待，或者调用 progress() 方法指定的回调函数（jQuery1.7 版本添加） 前面部分的 Ajax 操作时，deferred 对象会根据返回结果，自动改变自身的执行状态，但是，在 wait() 函数中，这个执行状态必须由程序员手动指定 dtd.resolve() 的意思是，将 dtd 对象的执行状态从未完成改为已完成，从而触发 done() 方法 类似的，还存在一个 deferred.reject() 方法，作用是将 dtd 对象的执行状态从未完成改为已失败，从而触发 fail() 方法： 12345678910111213141516// 新建一个 Deferred 对象var dtd = $.Deferred();var wait = function (dtd) { var tasks = function () { alert('done'); // 改变 Deferred 对象的执行状态 dtd.reject(); }; setTimeout(tasks, 5000); return dtd;};$.when(wait(dtd)) .done(function () { alert('success'); }) .fail(function () { alert('error'); }); promise 对象大多数情况下，我们不想让用户从外部更改 deferred 对象的状态，这时，你可以在 deferred 对象的基础上，返回一个针对它的 promise 对象 我们可以把后者理解成，promise 是 deferred 的只读版，或者更通俗地理解成 promise 是一个对将要完成的任务的承诺 你可以通过 promise 对象，为原始的 deferred 对象添加回调函数，查询它的状态，但是无法改变它的状态 也就是说 promise 对象不允许你调用 resolve 和 reject 方法 12345678910111213141516171819var wait = function (dtd) { // 在函数内部，新建一个 Deferred 对象 var dtd = $.Deferred(); var tasks = function () { alert('done'); // 改变 Deferred 对象的执行状态 dtd.resolve(); }; setTimeout(tasks, 5000); // 返回 promise 对象 return dtd.promise();};$.when(wait()) .done(function () { alert('success'); }) .fail(function () { alert('error'); }); then() 方法then() 的作用也是指定回调函数，它可以接受三个参数，也就是三个回调函数 第一个参数是 resolve 时调用的回调函数，第二个参数是 reject 时调用的回调函数，第三个参数是 progress() 方法调用的回调函数 1deferred.then(doneFilter[, failFilter][, progressFilter]) 在 jQuery 1.8 之前，then() 只是 .done() 和 .fail() 写法的语法糖，两种写法是等价的 在 jQuery 1.8 之后，then() 返回一个新的 deferred 对象，而 done() 返回的是原有的 deferred 对象 如果 then() 指定的回调函数有返回值，该返回值会作为参数，传入后面的回调函数 123456789101112131415161718192021222324252627282930313233var defer = jQuery.Deferred();defer.done(function (a, b) { return a * b;}).done(function (result) { console.log('result = ' + result);}).then(function (a, b) { return a * b;}).done(function (result) { console.log('result = ' + result);}).then(function (a, b) { return a * b;}).done(function (result) { console.log('result = ' + result);});defer.resolve(2, 3);// 在 jQuery 1.8 版本之前result = 2result = 2result = 2// 在 jQuery 1.8 版本之后result = 2result = 6result = NaN 这一点需要特别注意，比如下面这个实例： 123456$.ajax(url1, { dataType: 'json' }) .then(function (data) { return $.ajax(url2, { data: { user: data.userId } }); }).done(function (data) { // 处理的是从 url2 获取的数据，而不是从 url1 获取的数据 }); 利用 then() 会修改返回值这个特性，我们可以在调用其他回调函数之前，对前一步操作返回的值进行处理 12345678// 先使用 then() 方法，从返回的数据中取出所需要的字段（firstName）var post = $.post('/echo/json/') .then(function (p) { return p.firstName; });// 后面的操作就可以只处理这个字段了post.done(function (r) { console.log(r); }); 有时，Ajax 操作返回 json 字符串里面有一个 error 属性，表示发生错误，这个时候，传统的方法只能是通过 done() 来判断是否发生错误 但是通过 then() 方法，可以让 deferred 对象调用 fail() 方法 123456789101112131415var myDeferred = $.post('/echo/json/', { json: JSON.stringify({ 'error': true }) }) .then(function (response) { if (response.error) { return $.Deferred().reject(response); } return response; }, function () { return $.Deferred().reject({ error: true }); });myDeferred.done(function (response) { $('#status').html('success!');}).fail(function (response) { $('#status').html('error');}); state 方法该方法用来返回 deferred 对象目前的状态 1234567var deferred = new $.Deferred();deferred.state(); // 'pending'deferred.resolve();deferred.state(); // 'resolved' 返回值有三个： pending：表示操作还没有完成 resolved：表示操作成功 rejected：表示操作失败 notify() 和 progress()progress() 用来指定一个回调函数，当调用 notify() 方法时，该回调函数将执行，它的用意是提供一个接口，使得在非同步操作执行过程中，可以执行某些操作，比如定期返回进度条的进度 1234567891011121314151617181920var userProgress = $.Deferred();var $profileFields = $('input');var totalFields = $profileFields.lengthuserProgress.progress(function (filledFields) { var pctComplete = (filledFields / totalFields) * 100; $('#progress').html(pctComplete.toFixed(0));});userProgress.done(function () { $('#thanks').html('Thanks for completing your profile!').show();});$('input').on('change', function () { var filledFields = $profileFields.filter('[value!='']').length; userProgress.notify(filledFields); if (filledFields == totalFields) { userProgress.resolve(); }}); always()always() 也是指定回调函数，不管是 resolve 或 reject 都要调用 pipe 方法pipe 方法接受一个函数作为参数，表示在调用 then、 done、 fail 或者 always 方法并且指定的回调函数之前 先运行 pipe 方法指定的回调函数，它通常用来对服务器返回的数据做初步处理 综合实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 使用 deferred 对象写一个 wait 方法，表示等待多少毫秒后再执行$.wait = function (time) { return $.Deferred(function (dfd) { setTimeout(dfd.resolve, time); });}// 使用$.wait(5000).then(function () { alert('from the future!');});// 改写 setTimeout 方法// 在上面的 wait 方法的基础上，还可以改写 setTimeout 方法，让其返回一个 deferred 对象function doSomethingLater(fn, time) { var dfd = $.Deferred(); setTimeout(function () { dfd.resolve(fn()); }, time || 0); return dfd.promise();}var promise = doSomethingLater(function () { console.log('已经延迟执行');}, 100);// 自定义操作使用 deferred 接口// 利用 deferred 接口，使得任意操作都可以用 done() 和 fail() 指定回调函数Twitter = { search: function (query) { var dfr = $.Deferred(); $.ajax({ url: 'http://search.twitter.com/search.json', data: { q: query }, dataType: 'jsonp', success: dfr.resolve }); return dfr.promise(); }}// 使用方法Twitter.search('intridea').then(function (data) { alert(data.results[0].text);});// deferred 对象的另一个优势是可以附加多个回调函数function doSomething(arg) { var dfr = $.Deferred(); setTimeout(function () { dfr.reject('Sorry, something went wrong.'); }); return dfr;}doSomething('uh oh').done(function () { alert('erroring here!');}).fail(function (message) { alert(message)}); 参考 什么是 Promise Promise 对象 大白话讲解 Promise Promise &amp; Deferred objects in JavaScript Pt.1: Theory and Semantics. The Deferred anti-pattern Coming from jQuery","link":"/2017/06/21/jQuery/02/"},{"title":"jQuery 源码的总体架构","text":"因为最近在项目当中使用 jQuery 比较多，所以打算抽点时间去研究一下 jQuery 源码，深入了解一下 主要参考的是 jQuery 技术内幕，大致整理了一下，方便自己理解，更多详细可以去参考原书籍 源码的总体架构整体的架构如下 12345678910111213141516171819202122232425(function (window, undefined) { // 构造 jQuery 对象 var jQuery = function (selector, context) { return new jQuery.fn.init(selector, context, rootjQuery); } // 工具函数 Utilities // 异步队列 Deferred // 浏览器测试 Support // 数据缓存 Data // 队列 queue // 属性操作 Attribute // 事件处理 Event // 选择器 Sizzle // DOM 遍历 // DOM 操作 // CSS 操作 // 异步请求 Ajax // 动画 FX // 坐标和大小 window.jQuery = window.$ = jQuery;})(window); jQuery 的最外层是一个自调用匿名函数，通过定义一个匿名函数，创建了一个私有的命名空间，该命名空间的变量和方法，不会破坏全局的命名空间 参数中传入 window 变量，使得 window 由全局变量变为局部变量，当在 jQuery 代码块中访问 window 时，不需要将作用域链回退到顶层作用域，这样可以更快的访问 window，更重要的是将 window 作为参数传入，可以在压缩代码时进行优化 传入 undefined 是因为在自调用匿名函数的作用域内，确保 undefined 是真的未定义，因为 undefined 在某些浏览器下是能够被重写，被赋予新的值的 构造函数 jQuery()构造函数 jQuery() 有 7 种用法，如下： jQuery(selector, context)接收一个 CSS 选择器表达式（selector）和可选的选择器上下文（context），返回一个包含了匹配的 DOM 元素的 jQuery 对象 例如，在一个事件监听函数中，可以像下面这样限制查找范围： 1234$('div.foo').click(function() { // 限定查找范围 $('span', this).addClass('bar');}); 如果选择器表达式 selector 是简单的 &quot;#id&quot; ，且没有指定上下文 context，则调用浏览器原生方法 document.getElementById() 查找属性 id 等于指定值的元素 如果是比 &quot;#id&quot; 复杂的选择器表达式或指定了上下文，则通过 jQuery 方法 .find() 查找，因此 $('span', this) 等价于 $(this).find('span') jQuery(html, ownerDocument) 和 jQuery(html, props)用所提供的 html 代码创建 DOM 元素 12345678// 单标签 两种方式都可以往 body 中插入 div/* * 1 $('&lt;div&gt;').appendTo('body'); * 2 $('&lt;div&gt;&lt;/div&gt;').appendTo('body'); */// 多标签嵌套$('&lt;div&gt;&lt;span&gt;foo&lt;/span&gt;&lt;/div&gt;').appendTo('body'); jQuery(element or elementsArray)如果传入一个 DOM 元素或 DOM 元素数组，则把 DOM 元素封装到 jQuery 对象中并返回 123456789101112131415161718// 传入 DOM 元素$('li').each(function (index, ele) { $(ele).on('click', function () { // 这里的 DOM 元素就是 this $(this).css('background', 'red'); })})// 传入 DOM 数组var aLi = document.getElementsByTagName('li');// 集合转数组aLi = [].slice.call(aLi);var $aLi = $(aLi);// 所有的 li 的内容都变成 '我是jQuery对象'$aLi.html(`我是jQuery对象`); jQuery(object)如果传入一个普通 JavaScript 对象，则把该对象封装到 jQuery 对象中并返回 12345678910111213// 定义一个普通 JavaScript 对象var foo = { foo: 'bar', hello: 'world' };// 封装成 jQuery 对象var $foo = $(foo);// 绑定一个事件$foo.on('custom', function () { console.log(`custom event was called`);});// 触发这个事件$foo.trigger('custom'); // 在控制台打印 `custom event was called` jQuery( callback )当传进去的参数是函数的时候，则在 document 对象上绑定一个 ready 事件监听函数，当 DOM 结构加载完成的时候执行 12345678$(function () {})// 以上代码和下面的效果是一样的$(document).ready(function () { // ...}) jQuery(jQuery object)如果传入一个 jQuery 对象，则创建该 jQuery 对象的一个副本并返回，副本与传入的 jQuery 对象引用完全相同的 DOM 元素 jQuery()如果不传入任何的参数，则返回一个空的 jQuery 对象，属性 length 为 0 这个功能可以用来复用 jQuery 对象，例如，创建一个空的 jQuery 对象，然后在需要时先手动修改其中的元素，再调用 jQuery 方法，从而避免重复创建 jQuery 对象 总体结构 123456789101112131415161718192021222324252627282930 16 (function (window, undefined) { // 构造 jQuery 对象 22 var jQuery = (function() { 25 var jQuery = function( selector, context ) { 27 return new jQuery.fn.init( selector, context, rootjQuery ); 28 }, // 一堆局部变量声明 97 jQuery.fn = jQuery.prototype = { 98 constructor: jQuery, 99 init: function( selector, context, rootjQuery ) { ... }, // 一堆原型属性和方法319 };322 jQuery.fn.init.prototype = jQuery.fn;324 jQuery.extend = jQuery.fn.extend = function() { ... };388 jQuery.extend({ // 一堆静态属性和方法892 });955 return jQuery;957 })(); // 省略其他模块的代码9246 window.jQuery = window.$ = jQuery;9266 })(window);","link":"/2017/06/23/jQuery/03/"},{"title":"jQuery.fn.init()","text":"下面我们来看看初始化方法 return new jQuery.fn.init(selector, context, rootjQuery)，源码如下 1234// 构造 jQuery 对象var jQuery = function (selector, context) { return new jQuery.fn.init(selector, context, rootjQuery);} 我们先来看看为什么要执行一个 return new jQuery.fn.init( ... ) 操作 return new jQuery.fn.init( … )如果构造函数有返回值，运算符 new 所创建的对象会被丢弃，返回值将作为 new 表达式的值 通过在构造函数 jQuery() 内部用运算符 new 创建并返回另一个构造函数的实例，省去了构造函数 jQuery() 前面的运算符 new 即创建 jQuery 对象时，可以省略运算符 new 直接写 jQuery() 或者 $() jQuery.fn.init() 和 jQuery.fn.init.prototype = jQuery.fn源码如下 1234567891011(function (window, undefined) { // ... jQuery.fn.init.prototype = jQuery.fn; // 省略其他模块的代码 window.jQuery = window.$ = jQuery;})(window); 当我们在调用 jQuery 构造函数时，实际返回的是 jQuery.fn.init() 的实例 在执行 jQuery.fn.init.prototype = jQuery.fn 时，用构造函数 jQuery() 的原型对象覆盖了构造函数 jQuery.fn.init() 的原型对象 从而使构造函数 jQuery.fn.init() 的实例也可以访问构造函数 jQuery() 的原型方法和属性 那么这里就存在一个问题了 为什么要覆盖构造函数 jQuery() 的原型对象 jQuery.prototype 因为在原型对象 jQuery.prototype 上定义的属性和方法会被所有 jQuery 对象继承，这样可以有效减少每个 jQuery 对象所需的内存 下面我们就正式来看一下 jQuery.fn.init() 这个方法 jQuery.fn.init(selector, context, rootjQuery)构造函数 jQuery.fn.init() 负责解析参数 selector 和 context 的类型，并执行相应的逻辑，最后返回 jQuery.fn.init() 的实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154// ① 定义构造函数 jQuery.fn.init(selector, context, rootjQuery) 它接受 3 个参数// 参数 selector：可以是任意类型的值，但只有 undefined、DOM 元素// 字符串、函数、jQuery 对象、普通 JavaScript 对象这几种类型是有效的// 参数 context：可以不传入，或者传入 DOM 元素、jQuery 对象、普通 JavaScript 对象之一// 参数 rootjQuery：包含了 document 的 jQuery 对象，用于 // document.getElementById() 查找失败、selector 是选择器表达式且未指定 context、selector 是函数的情况init: function(selector, context, rootjQuery) { var match, elem, ret, doc; // ② 参数 selector 可以转换为 false，例如是 undefined、空字符串、null 等 // 则直接返回 this，此时 this 是空 jQuery 对象，其属性 length 等于 0 // 如果 selector 为空，!selector 为 false // 比如 $(''), $(null), or $(undefined) if (!selector) { // 此时 this 为空 jQuery 对象 return this; } // ③ 如果参数 selector 有属性 nodeType，则认为 selector 是 DOM 元素 // 比如 $(DOMElement) if (selector.nodeType) { // 将第一个元素和属性 context 指向 selector this.context = this[0] = selector; this.length = 1; return this; } // ④ 如果参数 selector 是字符串 'body'，手动设置属性 context 指向 document 对象 // 第一个元素指向 body 元素，最后返回包含了 body 元素引用的 jQuery 对象 // 如果选中的是 body，则利用 !context 进行优化（因为 body 只会出现一次） if (selector === 'body' &amp;&amp; !context &amp;&amp; document.body) { // context 指向 document 对象 this.context = document; this[0] = document.body; this.selector = selector; this.length = 1; return this; } // ⑤ 如果参数 selector 是其他字符串，则先检测 selector 是 HTML 代码还是类似 #id 这样的选择符 if (typeof selector === 'string') { // 如果是以 '&lt;' 开头 以 '&gt;' 结尾，且长度大于等于 3 if (selector.charAt(0) === \"&lt;\" &amp;&amp; selector.charAt(selector.length - 1) === \"&gt;\" &amp;&amp; selector.length &gt;= 3) { // 则跳过 queckExpr 正则检查，这里假设为 HTML 片段，比如 '&lt;div&gt;&lt;/p&gt;' match = [null, selector, null]; } else { // 否则，用正则 quickExpr 检测参数 selector 是否是稍微复杂 // 一些的 HTML 代码（如'abc&lt;div&gt;' ）或 #id，匹配结果存放在数组 match 中 match = quickExpr.exec(selector); } // ⑥ 如果参数 selector 是单独标签 // 根据上面正则返回的结果，调用 document.createElement() 创建标签对应的 DOM 元素 // 如果 match[1] 不是 undefined，即参数 selector 是 HTML 代码 // 或者 match[2] 不是 undefined，即参数 selector 是 #id，并且未传入参数 context // 所以就省略了对 match[2] 的判断，完整的表达式为 if ( match &amp;&amp; (match[1] || match[2] &amp;&amp; !context) ) if (match &amp;&amp; (match[1] || !context)) { // HANDLE: $(html) -&gt; $(array) // 开始处理参数 selector 是 HTML 代码的情况 if (match[1]) { // 先修正 context 和 doc context = context instanceof jQuery ? context[0] : context; doc = (context ? context.ownerDocument || context : document); // 正则 rsingleTag 检测 HTML 代码是否是单独标签，匹配结果存放在数组 ret 中 // rsingleTag = /^&lt;(\\w+)\\s*\\/?&gt;(?:&lt;\\/\\1&gt;)?$/ ret = rsingleTag.exec(selector); // 如果数组 ret 不是 null，则是单独标签，调用 document.createElement() 创建标签对应的 DOM 元素 if (ret) { // 如果 context 是普通对象，则调用 jQuery 方法 .attr() 并传入参数 context // 同时把参数 context 中的属性、事件设置到新创建的 DOM 元素上 if (jQuery.isPlainObject(context)) { // 之所以放在数组中，是方便后面的 jQuery.merge() 方法调用 selector = [document.createElement(ret[1])]; // 调用 attr 方法，传入参数 context jQuery.fn.attr.call(selector, context, true); } else { selector = [doc.createElement(ret[1])]; } // ⑦ 如果参数 selector 是复杂 HTML 代码，则利用浏览器的 innerHTML 机制创建 DOM 元素 } else { ret = jQuery.buildFragment([match[1]], [doc]); selector = (ret.cacheable ? jQuery.clone(ret.fragment) : ret.fragment).childNodes; } return jQuery.merge(this, selector); // ⑧ 参数 selector 是 '#id'，且未指定参数 context } else { elem = document.getElementById(match[2]); if (elem &amp;&amp; elem.parentNode) { // 即使是 documen.getElementById 这样核心的方法也要考虑到浏览器兼容问题，可能找到的是 name 而不是 id if (elem.id !== match[2]) { return rootjQuery.find(selector); } // 如果所找到元素的属性 id 值与传入的值相等，则设置第一个元素 // 属性 length、context、selector，并返回当前 jQuery 对象 this.length = 1; this[0] = elem; } this.context = document; this.selector = selector; return this; } // HANDLE: $(expr, $(...)) // ⑨ 参数 selector 是选择器表达式 // 没有指定上下文，执行 rootjQuery.find()，指定了上下文且上下文是 jQuery 对象，执行 context.find() } else if (!context || context.jquery) { return (context || rootjQuery).find(selector); // HANDLE: $(expr, context) // (which is just equivalent to: $(context).find(expr) // 如果指定了上下文，且上下文不是 jQuery 对象 } else { // 先创建一个包含 context 的 jQuery 对象，然后调用 find 方法 return this.constructor(context).find(selector); } // HANDLE: $(function) // ⑩ 参数 selector 是函数 } else if (jQuery.isFunction(selector)) { return rootjQuery.ready(selector); } // selector 是 jquery 对象 // 如果参数 selector 含有属性 selector，则认为它是 jQuery 对象，将会复制它的属性 selector 和 context if (selector.selector !== undefined) { this.selector = selector.selector; this.context = selector.context; } // 参数 selector 是任意其他值，最后（合并）返回当前 jQuery 对象 return jQuery.makeArray(selector, this);},","link":"/2017/07/11/jQuery/04/"},{"title":"jQuery 中的辅助方法（上）","text":"下面我们来看几个辅助函数，内容比较多，分为两部分介绍，篇幅较长的会另开介绍 第一部分主要介绍下面几个方法 jQuery.noConflict([removeAll]) jQuery.isFunction(obj)， jQuery.isArray(obj) jQuery.type(obj) jQuery.isWindow(obj) jQuery.isNumeric(value) jQuery.isPlainObject(object) jQuery.makeArray(obj) jQuery.inArray(value, array[, fromIndex]) jQuery.merge(first, second) jQuery.grep(array, function(elementOfArray, indexInArray)[, invert]) jQuery.noConflict([removeAll])方法 jQuery.noConflict( [removeAll] ) 用于释放 jQuery 对全局变量 $ 的控制权 可选参数 removeAll 表示是否释放对全局变量 jQuery 的控制权，$ 仅仅是 jQuery 的别名 没有 $ ，其余功能也是可以正常使用的（使用 jQuery） 如果需要使用另一个 JavaScript 库，可以调用 $.noConflict() 返回 $ 给其他库 123456789101112131415161718192021222324// 先把可能存在的 window.jQuery 和 $ 备份到局部变量 _jQuery 和 _$ 上_jQuery = window.jQuery,_$ = window.$,jQuery.extend({ noConflict: function (deep) { // 只有当前 jQuery 库持有全局变量 $ 的情况下，才会释放 $ 的控制权给前一个 JavaScript 库 if (window.$ === jQuery) { window.$ = _$; } // 只有在当前 jQuery 库持有全局变量 jQuery 的情况下，才会释放 jQuery 的控制权给前一个 JavaScript 库 if (deep &amp;&amp; window.jQuery === jQuery) { window.jQuery = _jQuery; } return jQuery; }}),// ...略window.jQuery = window.$ = jQuery; 如果有必要（例如，在一个页面中使用多个版本的 jQuery 库，但很少有这样的必要），也可以释放全局变量 jQuery 的控制权 只需要给这个方法传入参数 true 即可 从 jQuery 1.6 开始增加了对 window.$ === jQuery 的检测，如果不检测，则每次调用 jQuery.noConflict() 时都会释放 $ 给前一个 JavaScript 库 当页面中有两个以上定义了 $ 的 JavaScript 库时，对 $ 的管理将会变得混乱 jQuery.isFunction(obj)， jQuery.isArray(obj)判断传入的参数是否是函数/数组，这两个方法的实现依赖方法 jQuery.type(obj)，通过返回值是否是 function/array 来判断 1234567isFunction: function(obj) { return jQuery.type(obj) === 'function';},isArray: Array.isArray || function (obj) { return jQuery.type(obj) === 'array';}, jQuery.type(obj)用于判断参数的 JavaScript 类型，如果参数是 undefined 或 null，返回 &quot;undefined&quot; 或 &quot;null&quot; 如果参数是内部对象，则返回对应的字符串名称，其他一律返回 object 12345678910111213type: function (obj) { // 若为 undefined / null ==&gt; 转换为字符串 'undefined' / 'null' return obj == null ? String(obj) // 以上的返回值形式为 [object class]，其中 class 是内部对象类 // 例如 Object.prototype.toString.call(true) 会返回 [object Boolean] // 然后从对象 class2type 中取出 [object class] 对应的小写字符串并返回 : class2type[toString.call(obj)] // 如果未取到则一律返回 object || 'object';}, 下面是原型方法 toString() 和 class2type 的定义及初始化 123456789101112131415161718192021toString = Object.prototype.toString,// [[Class]] --&gt; type pairsclass2type = {};// class2type 的定义jQuery.each('Boolean Number String Function Array Date RegExp Object').split(' '), function (i, name) { class2type['[object' + name + ']'] = name.toLowerCase();}// 对象 class2type 初始化后的结构为{ '[object Array]': 'array' '[object Boolean]': 'boolean' '[object Date]': 'date' '[object Function]': 'function' '[object Number]': 'number' '[object Object]': 'object' '[object RegExp]': 'regexp' '[object String]': 'string'} jQuery.isWindow(obj)用于判断传入的参数是否是 window 对象，通过检测是否存在特征属性 setInterval 来实现 123456789// 1.7.2 之前isWindow: function (obj) { return obj &amp;&amp; typeof obj === 'object' &amp;&amp; 'setInterval' in obj;},// 1.7.2 之后，该方法修改为检测特征属性 window, 该属性是对窗口自身的引用isWindow: function (obj) { return obj != null &amp;&amp; obj == obj.window;} jQuery.isNumeric(value)用于判断传入的参数是否是数字，或者看起来是否像数字 123isNumeric: function (obj) { return !isNaN(parseFloat(obj)) &amp;&amp; isFinite(obj);}, 先用 parseFloat(obj) 尝试把参数解析为数字，然后判断其是否合法 然后在使用 isFinite(obj) 判断其是否是有限的，均通过验证则返回 true jQuery.isPlainObject(object)用于判断传入的参数是否为纯粹的对象，即 {} 或 new Object() 创建的对象 123456789101112131415161718192021isPlainObject: function (obj) { if (!obj || jQuery.type(obj) !== 'object' || obj.nodeType || jQuery.isWindow(obj)) { return false; } try { if (obj.constructor &amp;&amp; !hasOwn.call(obj, 'constructor') &amp;&amp; !hasOwn.call(obj.constructor.property, 'isPrototypeOf')) { return false } } catch (e) { return false; } var key; for (key in obj) { } return key === undefined || hasOwn.call(obj, key);}, 如果参数 obj 满足下列条件之一，则返回 false 参数 obj 可以转换为 false Object.prototype.toString.call(obj) 返回的不是 [object, Object] 参数 obj 是 DOM 元素 参数 obj 是 window 对象 如果参数 obj 不满足以上所有条件，则至少可以确定参数 obj 是对象 try…catch… 检查对象 obj 是否由构造函数 Object() 创建，如果对象 obj 满足以下所有条件，则认为不是由构造函数 Object() 创建，而是由自定义构造函数创建，返回 false 对象 obj 含有属性 constructor，由构造函数创建的对象都有一个 constructor 属性，默认引用了该对象的构造函数，如果对象 obj 没有属性 constructor，则说明该对象必然是通过对象字面量 {} 创建的 对象 obj 的属性 constructor 是非继承属性，默认情况下，属性 constructor 继承自构造函数的原型对象，如果属性 constructor 是非继承属性，说明该属性已经在自定义构造函数中被覆盖 对象 obj 的原型对象中没有属性 isPrototypeOf，属性 isPrototypeOf 是 Object 原型对象的特有属性，如果对象 obj 的原型对象中没有，说明不是由构造函数 Object() 创建，而是由自定义构造函数创建 执行以上检测时抛出了异常，在 IE 8/9 中，在某些浏览器对象上执行以上检测时会抛出异常，也应该返回 false 函数 hasOwn() 指向 Object.prototype.hasOwnProperty(property)，用于检查对象是否含有执行名称的非继承属性 for...in... 检查对象 obj 的属性是否都是非继承属性，如果没有属性，或者所有属性都是非继承属性，则返回 true，如果含有继承属性，则返回 false，执行 for-in 循环时，JavaScript 会先枚举非继承属性，再枚举从原型对象继承的属性 最后，如果对象 obj 的最后一个属性是非继承属性，则认为所有属性都是非继承属性，返回 true；如果最后一个属性是继承属性，即含有继承属性，则返回 false jQuery.makeArray(obj)可以将一个类数组对象转换为真正的数组，在 jQuery 内部，还可以为方法 jQuery.makeArray() 传入第二个参数 这样，第一个参数中的元素被合并入第二个参数，最后会返回第二个参数，此时返回值的类型不一定是真正的数组 1234567891011121314151617181920212223242526272829303132333435push = Array.prototype.push, // 定义方法 makeArray() 接收两个参数 // array 待转换的对象，可以是任何类型 // results 仅在 jQuery 内部使用，如果传入参数 results，则在该参数上添加元素 makeArray: function (array, results) { // 定义返回值，如果传入了参数 results 则把该参数作为返回值，否则新建一个空数组返回 var ret = results || []; // 过滤掉 null undefined if (array != null) { var type = jQuery.type(array); if (array.length == null || type === 'string' || type === 'function' || type === 'regexp' || jQuery.isWindow(array)) { // 之所以不是 ret.push(array) 是因为 ret 不一定是真正的数组，如果只传入 array，则返回值 // ret 是真正的数组，如果还传入了第二个参数，则返回值 ret 取决于该参数的类型 push.call(ret, array) } else { // 否则认为 array 是数组或类数组对象，执行合并 jQuery.merge(ret, array) } } // 返回 return ret; } jQuery.inArray( value, array[, fromIndex] )在数组中查找指定的元素并返回其下标，未找到则返回 -1 1234567891011121314151617181920212223242526272829303132333435// 定义方法 inArray 接收三个参数// elem 需要查找的值// array 数组，将遍历这个数组来查找参数value在其中的下标// i 指定开始的位置，默认是0（即查找整个数组）inArray: function ( elem, array, i ) { var len; // 过滤掉可以转换为 false 的情况 if (array) { // 如果支持 indexOf 这调用 indexOf 返回下标 if (indexOf) { return indexOf.call(array, elem, i); } len = array.length; // 修正参数 i，如果未指定i，则初始化为0，表示从头开始 // 如果 i &lt; 0，则加上数组长度 len，即从末尾开始计算 // 调用 Math.max() 在 0 和 len + i 之间取最大值，如果 len + i 依然 &lt; 0 ，则修正为 0 ，从头开始 i = i ? i &lt; 0 ? Math.max(0, len + i) : i : 0; // 开始遍历，查找与指定值 elem 相等的元素，并返回其下标 for ( ; i &lt; len; i++) { // 如果 i in array 返回false，则说明 array 的下标是不连续的，无需比较 if ( i in array &amp;&amp; array[i] === elem ) { return i; } } } return -1;} 通常我们会比较 jQuery.inArray() 的返回值是否大于 0 来判断某个元素是否是数组张的元素： 123if (jQuery.inArray(elem, array) &gt; 0) { // elem 是 array 中的元素} 但是这种写法比较繁琐，可以利用按位非运算符（~）简化上面的代码： 123if ( ~jQuery.inArray(elem, aray) ) { // elem 是 array 中的元素} 按位非运算符（~）会将运算数的所有位取反，相当于改变它的符号并且减 1： 1234~-1 == 0; // true~0 == -1; // true~1 == -2; // true~2 == -3; // true 更进一步，可以结合使用按位非运算符（~）和逻辑非运算符（!）把 jQuery.inArray() 的返回值转换为布尔类型： 1234!!~jQuery.inArray(elem, array)// 如果 elem 可以匹配 array 中的某个元素，则该表达式的值为 true// 如果 elem 匹配不到 array 中的某个元素，则该表达式的值为 false jQuery.merge( first, second )方法 jQuery.merge() 用于合并两个数组的元素到第一个数组中，事实上，第一个参数可以是数组或类数组对象 即必须含有整型（或可以转换为整型）属性 length，第二个参数则可以是数组，类数组对象或任何含有连续整型的对象 合并行为是不可逆的，即将第二个数组合并到第一个以后，第一个数组就改变了 如果不希望如此，则可以在调用 jQuery.merge() 之前创建一份数组的备份 1var newArray = $.merge([], oldArray); 方法 jQuery.merge() 的定义如下： 1234567891011121314151617181920212223242526272829// 定义方法jQuery.merge() 接收2个参数// first 数组或类对象，必须含有整型（或可以转换为整型）属性 length// second 数组，类数组对象或任何含有连续整型的对象，合并至 firstmerge: function (first, second) { // first.length 必须是整型或者可以转换为整型，否则后面 i++ 返回 NaN var i = first.length, j = 0; // 如果是数值类型，则当数组处理，添加至 first if ( typeof second.length === 'number' ) { for ( var l = second.length; j &lt; l; j++ ) { first[i++] = second[j]; } // 如果没有length，则当作含有连续整型属性的对象，例如 {0: 'a', 1: 'b'} // 把其中的非 undefined 元素逐个插入参数 first中 } else { while (second[j] !== undefined) { first[i++] = second[j++]; } } // 修正 length 因为 first 可能不是真正的数组 first.length = i; // 返回参数 return first;} jQuery.grep( array, function ( elementOfArray, indexInArray )[, invert])用于查找数组张满足过滤函数的元素，原数组不会受影响 如果参数 invert 没有传入或者为 false 元素只有在过滤函数返回 true 或者返回值可以转换为 true 的时候，才会被保存在最终的结果数组中，即返回一个满足回调函数的元素数组 如果参数 invert 为 true，则反之 123456789101112131415161718// 定义方法 jQuery.grep() 接收三个参数// array 待遍历查找的数组// callback 过滤每个元素的函数，执行的时候传入两个参数，当前元素和它的下标，返回一个布尔值// inv 如果参数 inv 是 false 或者没有传入，jQuery.grep() 会返回一个满足回调函数的元素数组// 如果为 true，则返回一个不满足回调函数的元素数组grep: function (elems, callback, inv) { var ret = [], retVal; inv = !!inv; for (var i = 0; length = elems.length, i &lt; length; i++) { retVal = !!callback(elems[i], i); if ( inv !== retVal ) { ret.push(elems[i]); } } return ret;}","link":"/2017/07/15/jQuery/05/"},{"title":"jQuery 中的工具方法（下）","text":"第二部分主要介绍下面几个方法 createSafeFragment(document) fixDefaultChecked(elem) .pushStack(elements, name, arguments) .end() .eq(index)，.first()，.last()，.slice(start[, end]) .push(value, ...), .sort([orderfunc]), .splice(start,deleteCount, value, ...) createSafeFragment(document)123456789101112131415function createSafeFragment(document) { var list = nodeNames.split('|'); safeFrag = document.createDocumentFragment(); if (safeFrag.createElement) { while (list.length) { safeFrag.createElement(list.pop()); } } return safeFrag;}var nodeNames = 'abbr|article|aside|audio|canvas|datalist|details|figcaption|figure|footer|' + 'header|hgroup|mark|meter|nav|output|progress|section|summary|time|video' 变量 nodeNames 中存放了所有的 html5 标签，createSafeFragment() 在传入的文档对象 document 上创建一个新的文档片段 然后在该文档片段上逐个创建 html5 元素，从而兼容不支持 html5 的浏览器，使之正确的解析和渲染 fixDefaultChecked(elem)主要用于修正复选框和单选按钮的选中状态 1234567891011121314151617// Used in clean, fixes the defaultChecked propertyfunction fixDefaultChecked(elem) { if (elem.type === 'checkbox' || elem.type === 'radio') { elem.defaultChecked = elem.checked; }}// Finds all inputs and passes them to fixDefaultCheckedfunction findInputs(elem) { var nodeName = (elem.nodeName || '').toLowerCase(); if (nodeName === 'input') { fixDefaultChecked(elem); // Skip scripts, get other children } else if (nodeName !== 'script' &amp;&amp; typeof elem.getElementsByTagName !== 'undefined') { jQuery.grep(elem.getElementsByTagName('input'), fixDefaultChecked); }} 遍历转换后的 DOM 元素集合，在每个元素上调用函数 findInputs(elem) 函数 findInputs(elem) 会找出其中的复选框和单选按钮，并调用函数 fixDefaultChecked(elem) 把属性 checked 的值赋值给属性 defaultChecked .pushStack(elements, name, arguments)原型方法 .pushStack() 创建一个新的空 jQuery 对象，然后把 DOM 元素集合放进这个 jQuery 对象中 并保留对当前 jQuery 对象的引用，它对 jQuery 对象遍历，DOM 查找，DOM 遍历，DOM 插入等方法提供支持 123456789101112131415161718192021222324252627282930313233343536// 定义方法 .pushStack()，接收三个参数（即构建一个新的 jQuery 对象并入栈，新对象位于栈顶）// elems 将放入新 jQuery 对象的元素数组（或类数组）// name 产生元素数组 elems 的 jQuery 方法名// selector 传给 jQuery 方法的参数，用于修正原型属性 .selectorpushStack: function (elems, name, selector) { // 创建一个空的 jQuery 对象，this.constructor 指向构造函数 jQuery var ret = this.constructor(); // 合并参数 elems if (jQuery.isArray(elems)) { // 如果是数组 push.apply(ret, elems); } else { // 不是数组的情况 jQuery.merge(ret, elems); } // 设置属性 prevObject， 指向当前 jQuery 对象，从而形成一个链式栈 ret.prevObject = this; // 指向当前 jQuery 的上下文 ret.context = this.context; // 在 ret 上设置属性 selector，方便调试 if (name === 'find') { ret.selector = this.selector + (this.selector ? ' ' : '') + selector; } else if (name) { ret.selector = this.selector + '.' + name + '(' + selector + ')'; } // 返回 ret return ret;} .end()结束当前链中最近的筛选操作，并将匹配元素集合还原为之前的状态 123end: function() { return this.prevObject || this.constructor(null); } 返回一个 jQuery 对象，如果属性 prevObject 不存在，则构建一个空的 jQuery 对象返回 方法 pushStach() 用于入栈，end() 则用于出栈，比如： 1234$('ul li').find('div').css('backgroundColor','red') .end() .find('span')css('backgroundColor','blue') .end(); .eq(index)，.first()，.last()，.slice(start[, end])方法 .first() 和 .last() 通过调用 .eq(index) 实现 .eq(index) 则通过 .slice(start[, end]) 实现 .slice(start[, end]) 则通过调用 .pushStack(elements, name, arguments) 实现 方法调用链为： .first() / last() ==&gt; .eq(index) ==&gt; .slice(start[, end]) ==&gt; .pushStack(elements, name, arguments) 1234567891011121314151617181920eq: function(i) { // 如果 i 是字符串，就通过 '+i' 转换为数值 i = +i; return i === -1 ? this.slice(i) : this.slice(i, i + 1);},first: function() { return this.eq(0);},last: function() { return this.eq(-1);},slice: function() { // 先借用数组方法 slice() 从当前 jQuery 对象中获取指定范围的子集（数组） // 在调用方法 .pushStack() 把子集转换为 jQuery 对象，同时通过属性 prevObject 保留了对当前 jQuery 对象的引用 return this.pushStack(slice.apply(this, arguments), 'slice', slice.call(arguments).join(','));} .push(value, …), .sort([orderfunc]), .splice(start,deleteCount, value, …)方法 .push( value, ... ) 向当前 jQuery 对象的末尾添加新元素，并返回新长度 123var foo = $(document);foo.push(document.body); // 2 方法 .sort( [orderfunc] ) 对当前 jQuery 对象中的元素进行排序，可以传入一个比较函数来指定排序方式 123456789var foo = $([33, 4, 1111, 222]);foo.sort(); // [1111, 222, 33, 4]foo.sort(function (a, b) { return a - b;})// [4, 33, 222, 1111] 方法 .splice( start,deleteCount, value, ... ) 向当前 jQuery 对象中插入, 删除或替换元素 如果从当前 jQuery 对象中删除了元素，则返回含有被删除元素的数组 1234567var foo = $('&lt;div id=\"d1\" /&gt;&lt;div id=\"d2\" /&gt;&lt;div id=\"d3\" /&gt;');// [&lt;div id=\"d1\"&gt;&lt;/div&gt;, &lt;div id=\"d2\"&gt;&lt;/div&gt;, &lt;div id=\"d3\"&gt;&lt;/div&gt;]foo.splice(1, 2);// [&lt;div id=\"d2\"&gt;&lt;/div&gt;, &lt;div id=\"d3\"&gt;&lt;/div&gt;] 以上三个方法仅在内部使用，都指向同名的数组方法，因此它们的参数，功能和返回值与数组方法完全一致 12345push: push,sort: [].sort,splice: [].splice 方法汇总构造 jQuery 对象模块的原型属性和方法可以总结为下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344jQuery.fn = jQuery.prototype // 原型属性和方法 .constructor // 指向构造函数 jQuery().init( selector, context, rootjQuery ) // 构造函数，解析参数 selector 和 context 的类型， // 并执行相应的逻辑，最后返回 jQuery.fn.init() 的实例.selector // 记录 jQuery 査找和过滤 DOM 元素时的选择器表达式.jquery // 正在使用的 jQuery 版本号.length // jQuery 对象中元素的个数.size() // 返回当前 jQuery 对象中元素的个数.toArray() // 将当前 jQuery 对象转换为真正的数组.get( [index] ) // 返回当前 jQuery 对象中指定位置的元素或包含了全部元素的数组.pushStack( elements, name, arguments ) // 创建一个新的空 jQuery 对象，然后把 DOM 元素集合放入这个jQuery 对象中， // 并保留对当前 jQuery 对象的引用.each( function(index, Element) ) // 遍历当前 jQuery 对象中的元素，并在每个元素上执行回调函数.ready( handler ) // 绑定 ready 事件.eq( index ) // 将匹配元素集合缩减为位于指定位置的新元素 .first() // 将匹配元素集合缩减为集合中的第一个元素.last() // 将匹配元素集合缩减为集合中的最后一个元素.slice() // 将匹配元素集合缩减为指定范围的子集.map( callback(index, domElement) ) // 遍历当前 jQuery 对象中的元素，并在每个元素上执行回调函数， // 将回调函数的返回值放入一个新的 jQuery 对象中.end() // 结束当前链条中最近的筛选操作，并将匹配元素集合还原为之前的状态.push() // Array.prototype.push.sort() // [].sort.splice() // [].splice","link":"/2017/07/16/jQuery/06/"},{"title":"jQuery.extend() 和 jQuery.fn.extend()","text":"主要用于合并两个或多个对象的属性到第一个对象，它们的语法如下 123jQuery.extend([deep], target, object1[, objectN])jQuery.fn.extend([deep], target, object1[, objectN]) 参数 deep 是可选的布尔值，表示是否进行深度合并（即递归合并） 合并行为默认是不递归的，如果第一个参数的属性本身是一个对象或数组，它会被第二个或后面的其他参数的同名属性完全覆盖 如果为 true，表示进行深度合并，合并过程是递归的 参数 target 是目标对象，参数 object1 和 objectN 是源对象，包含了待合并的属性 如果提供了两个或更多的对象，所有源对象的属性将会合并到目标对象 如果仅仅提供一个对象，意味着参数 target 被忽略，jQuery 或 jQuery.fn 被当作目标对象 通过这种方式可以在 jQuery 或 jQuery.fn 上添加新的属性和方法 方法 jQuery.extend() 和 jQuery.fn.extend() 执行的关键步骤如下： 修正参数 deep 和 target 源对象的起始下标 逐个遍历源对象： 遍历源对象的属性 覆盖目标对象的同名属性，如果是深度合并，则先递归调用 jQuery.extend() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283jQuery.extend = jQuery.fn.extend = function () { // 定义局部变量 var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false; // options 指向某个源对象 // name 表示某个源对象的某个属性名 // src 表示目标对象的某个属性的原始值 // copy 表示某个源对象的某个属性的值 // copyIsArray 指示变量 copy 是否是数组 // clone 表示深度复制时原始值的修正值 // target 指向目标对象 // i 表示源对象的起始下标 // length 表示参数的个数，用于修正变量 target // deep 指示是否执行深度复制，默认为 false // 修正目标对象 target、源对象起始下标 i // 如果第一个参数是布尔，则修正为第一个为 deep，第二个为 target，期望对象从第三个元素开始 // 若第一个不是布尔，则是期望第二个元素开始（i 初始为 1） if (typeof target === \"boolean\") { deep = target; target = arguments[1] || {}; i = 2; } // 如果 target 不是对象，函数，统一替换为 {} （因为在基本类型上设置非原生属性是无效的） if (typeof target !== \"object\" &amp;&amp; !jQuery.isFunction(target)) { target = {}; } // 如果两者相等，表示期望的源对象没有传入，则把 jQuery 和 jQuery.fn 作为目标，并且把源对象开始下标减一 // 从而使得传入的对象被当作源对象，相等有两种情况 // 1. extend(object) 只传入了一个参数 // 2. extend(deep, object) 第一个参数为布尔 if (length === i) { target = this; --i; } // 逐个遍历源对象 for (; i &lt; length; i++) { // 遍历源对象的属性 if ((options = arguments[i]) !== null) { for (name in options) { // 覆盖目标对象的同名属性 src = target[name]; copy = options[name]; // 避免 src（原始值）与 copy（复制值）相等进入死循环 if (target === copy) { continue; } // 如果原始值 src 不是数组 ==&gt; 修正为空数组 // 复制值是普通 javaScript 对象，如果原始值 src 不是普通 javaScript 对象 ==&gt; 修正为 {}，修正后的 src 赋值给原始值的副本 clone // 调用 jQuery.isPlainObject(copy) 判断复制值 copy 是否为纯粹的 javaScript 对象 // 只有通过对象直接量 {} 或 new Object() 创建的对象，才会返回 true if (deep &amp;&amp; copy &amp;&amp; (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) { if (copyIsArray) { copyIsArray = false; clone = src &amp;&amp; jQuery.isArray(src) ? src : []; } else { clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : []; } // 递归合并 copy 到 clone 中，然后覆盖对象的同名属性 target[name] = jQuery.extend(deep, clone, copy); // 如果不是深度合并，且不为 undefined，则直接覆盖目标的对象的同名属性 } else if (copy !== undefined) { target[name] = copy; } } } }}","link":"/2017/07/18/jQuery/07/"},{"title":"jQuery.buildFragment(args, nodes, scripts)","text":"一些需要注意的地方 如果 HTML 代码符合缓存条件，则尝试从缓存对象 jQuery.fragments 中读取缓存的 DOM 元素 创建文档片段 DocumentFragment 调用方法 jQuery.clean(elems, context, fragment, scripts) 将 HTML 代码转换为 DOM 元素，并存储在创建的文档片段中 如果 HTML 代码符合缓存条件，则把转换后的 DOM 元素放入缓存对象 jQuery.fragments 最后返回文档片段和缓存状态 {fragment: fragment, cacheable: cacheable} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// ① 定义函数 buildFragmentjQuery.buildFragment = function (args, nodes, scripts) { // ② 定义局部变量，修正文档对象 doc // 变量 fragment 指向稍后可能创建的文档片段 Document Fragment // 变量 cacheable 表示 HTML 代码是否符合缓存条件 // 变量 cacheresults 指向从缓存对象jQuery.fragments 中取到的文档片段，其中包含了缓存的 DOM 元素 // 变量 doc 表示创建文档片段的文档对象 var fragment, cacheable, cacheresults, doc, first = args[0]; if (nodes &amp;&amp; nodes[0]) { // ownerDocument 表示 DOM 元素所在的文档对象，如果 ownerDocument 不存在，则假定 nodes[0] 为文档对象 doc = nodes[0].ownerDocument || nodes[0]; } // 然后再次检查 doc.createDocumentFragment 是否存在 if (!doc.createDocumentFragment) { doc = document; } // ③ 尝试从缓存对象 jQuery.fragments 中读取缓存的 DOM 元素 // html 代码需要满足下列所有条件，才认为符合缓存条件 if (args.length === 1 &amp;&amp; typeof first === \"string\" &amp;&amp; first.length &lt; 512 &amp;&amp; doc === document &amp;&amp; first.charAt(0) === \"&lt;\" &amp;&amp; // 使用的正则方法如下 // rnocache = /&lt;(?:script|object|embed|option|style)/i, // checked = \"checked\" or checked // rchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i, !rnocache.test(first) &amp;&amp; (jQuery.support.checkClone || !rchecked.test(first)) &amp;&amp; // var nodeNames = \"abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|\" + // \"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video\"; // var rnoshimcache = new RegExp(\"&lt;(?:\" + nodeNames + \")[\\\\s/&gt;]\", \"i\"); (jQuery.support.html5Clone || !rnoshimcache.test(first))) { // 如果为 true，则必须先复制一份再使用，否则可以直接使用 cacheable = true; // 读取缓存 cacheresults = jQuery.fragments[first]; if (cacheresults &amp;&amp; cacheresults !== 1) { fragment = cacheresults; } } jQuery.fragments = {}; // ④ 转换 HTML 代码为 DOM 元素 // 创建文档片段 // 如果 !fragment 为 true，表示需要执行转换过程，有三种可能 // 1） html 代码不符合缓存条件 // 2） html 代码符合，但是是第一次转换，没有对应的缓存 // 3） html 代码符合，但是是第二次转换，对应的缓存值为 1 if (!fragment) { fragment = doc.createDocumentFragment(); jQuery.clean(args, doc, fragment, scripts); } // ⑤ 转换后的dom元素放入 jQuery.fragments if (cacheable) { jQuery.fragments[first] = cacheresults ? fragment : 1; } // 返回文档片段和缓存状态 {fragment: fragment, cacheable: cacheable} // fragment 中包含转换后的 dom 元素，cacheable 表示缓存状态 return { fragment: fragment, cacheable: cacheable };}; jQuery.buildFragment() 的用法总结为： 如果 HTML 代码不符合缓存条件，则总是会执行转换过程 如果 HTML 代码符合缓存条件，第一次转换后设置缓存值为 1，第二次转换后设置为文档片段，从第三次开始则从缓存中读取","link":"/2017/08/02/jQuery/08/"},{"title":"jQuery.clean(elems, context, fragment, scripts)","text":"方法 jQuery.clean(elems, context, fragment, scripts) 负责把 HTML 代码转换成 DOM 元素，并提取其中的 script 元素 创建一个临时 div 元素，并插入一个安全文档片段中 为 HTML 代码包裹必要的父标签，然后用 innerHTML 赋值给临时 div ，从而将 HTML 代码转换为 DOM 元素，之后再层层剥去包裹的父元素，得到转换后的 DOM 元素 移除 IE 6/7 自动插入的空 tbody 元素，插入 IE 6/7/8 自动剔除的前导空白符 取到转换后的 DOM 元素集合 在 IE 6/7 中修正复选框和单选按钮的选中状态 合并转换后的 DOM 元素 如果传入了文档片段 fragment，则提取所有合法的 script 元素存入数组 scripts，并把其他元素插入文档片段 fragment 最后返回转换后的 DOM 元素数组 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124// ① 定义函数// elems 数组，包含了待转换的 html 代码// context 文档对象，被 buildFragment() 修正（doc），用于创建文本节点和临时 div// fragment 文档片段，用于存放转换后的 dom 元素// scripts 数组，用于存放转换后的 dom 元素中的 script 元素clean: function(elems, context, fragment, scripts) { var checkScriptType; // ② 修正（再次修正是是为了方便直接调用 jQuery.clean() 转换 HTML 代码为 DOM 元素） context = context || document; if (typeof context.createElement === 'undefined') { context = context.ownerDocument || context[0] &amp;&amp; context[0].ownerDocument || document; } // ③ 遍历待转换的 HTML 代码数组 elems // ret用于存放转换后的 dom 元素 var ret = [], j; // 在 for 语句的第 2 部分取出 elems[i] 赋值给 elem，并判断 elem 的有效性，传统的做法可能是比较循环变 // 量 i 与 elems.length，然后在 for 循环体中把 elems[i] 赋值给elem，再判断 elem 的有效性 // 另外，判断 elem 的有效性时使用的是 '!='，这样可以同时过滤 null 和 undefined，却又不会过滤整型数字 0 for (var i = 0, elem; (elem = elems[i]) != null; i++) { // 如果是数值型，加上一个空字符串，即把 elem 转换为字符串 if (typeof elem === 'number') { elem += ''; } // 用于过滤空字符串，如果是数字 0，前面已经被转换为字符串 '0' 了，elem 为 false 则跳过本次循环 if (!elem) { continue; } // 若是 html 代码 if (typeof elem === 'string') { // 创建文本节点 // 使用正则如下，作用是检测代码中是否含有标签，字符代码，数字代码 // rhtml = /&lt;|&amp;#?\\w+;/ // 调用 document.cerateTextNode() 创建文本节点 if (!rhtml.test(elem)) { elem = context.createTextNode(elem); // 修正自关闭标签 } else { // 使用正则如下 // rxhtmlTag = /&lt;(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^&gt;]*)\\/&gt;/ig elem = elem.replace(rxhtmlTag, '&lt;$1&gt;&lt;/$2&gt;'); // 创建临时 div 元素 // 使用正则如下 // rtagName = /&lt;([\\w:]+)/ // 提取 html 中标签，删除前导空白符和左尖括号 var tag = (rtagName.exec(elem) || ['', ''])[1].toLowerCase(), wrap = wrapMap[tag] || wrapMap._default, deoth = wrap[0], div = context.createElement('div'); // 如果传入的文档对象 context 是当前文档对象，则把临时 div 插入 safeFragment 中 // 否则调用 createSafeFragment() 新建一个安全文档碎片（低版本浏览器也能识别的）在插入 if (context === document) { safeFragment.appendChild(div); } else { createSafeFragment(context).appendChild(div); } // 包裹必要父元素，赋给临时 div div.innerHTML = wrap[1] + elem + wrap[2]; // 用 while 循环层层剥去包裹的父元素，最终变量 div 将指向 HTML代码对应的 DOM 元素的父元素 while (depth--) { div = div.lastChild; } // 省略 // 移除 IE 6/7 自动插入的空 tbody 元素 ... // 插入 IE 6/7/8 自动剔除的前导空白符 ... // 取到转换后的 DOM 元素集合 elem = div.childNodes; // 省略 // 在 IE 6/7 中修正复选框和单选按钮的选中状态 ... if (elem.nodeType) { ret.push(elem); } else { ret = jQuery.merge(ret, elem); } } } } // 如果传入文档片段 fragment 的情况 // 遍历数组 ret，提取 script 存入 [scripts]，将其他元素插入文档片段 fragment if (fragment) { // 初始化函数 checkScriptType，用于检测 script 元素是否是可执行 // 使用正则如下 // rscriptType = /\\/(java|ecma)script/i checkScriptType = function (elem) { return !elem.type || rscriptType.test(elem.type); }; for (i = 0; ret[i]; i++) { if (scripts &amp;&amp; jQuery.nodeName(ret[i], 'script') &amp;&amp; (!ret[i].type || ret[i].type.toLowerCase() === 'text/javascript')) { scripts.push(ret[i].parentNode ? ret[i].parentNode.removeChild(ret[i]) : ret[i]); } else { if (ret[i].nodeType === 1) { var jsTags = jQuery.grep(ret[i].getElementsByTagName('script'), checkScriptType); ret.splice.apply(ret, [i + 1, 0].concat(jsTags)); } fragment.appendChild(ret[i]); } } } // 返回数组 ret // 但是要注意，如果传入了文档片段 fragment 和数组 scripts // 那么调用 jQuery.clean() 的代码应该从文档片段 fragment 中读取转换后的 DOM 元素，并从数组 scripts 中读取合法的 script 元素 // 如果未传入，则只能使用返回值 ret return ret;}","link":"/2017/08/11/jQuery/09/"},{"title":"JavaScript 中常用的设计模式","text":"这里简单的介绍一下单例模式，工厂模式，代理模式和观察者模式 单例模式简单来说，任意对象都是单例，无须特别处理 1var obj = { name: 'zhangsan', age: 20 }; 一个通用的惰性单例 123456var getSingle = function (fn) { var result; return function () { return result || (result = fn.apply(this, arguments)) }} 工厂模式工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类 该模式使一个类的实例化延迟到了子类，而子类可以重写接口方法以便创建的时候指定自己的对象类型 123456789101112var Car = (function () { var Car = function (name, age) { this.name = name; this.age = age; }; return function (name, age) { return new Car(name, age); };})();var zhangsan = new Car('zhangsan', 20);var lisi = new Car('lisi', 22); 即 123456789101112131415var productManager = {};productManager.createProductA = function () { console.log('ProductA');}productManager.createProductB = function () { console.log('ProductB');}productManager.factory = function (typeType) { return new productManager[typeType];}productManager.factory('createProductA'); 代理模式简单来说，就是新建个类调用老类的接口，包装一下 12345678910111213141516171819202122232425function Person() { }Person.prototype.sayName = function () { console.log('zhangsan');}Person.prototype.sayAge = function () { console.log(20);}function PersonProxy() { this.person = new Person(); var that = this; this.callMethod = function (functionName) { console.log('before proxy:', functionName); // 代理 that.person[functionName](); console.log('after proxy:', functionName); }}var p = new PersonProxy();p.callMethod('sayName'); // 代理调用 Person 的方法 sayName()p.callMethod('sayAge'); // 代理调用 Person 的方法 sayAge() 另外在 ES6 当中提供了 Proxy 对象也可以用来实现代理，基本语法为 1let x = new Proxy(target, handler); target 是你要代理的对象，它可以是任何合法对象(数组，对象，函数等等) handler 是你要自定义操作方法的一个集合 x 是一个被代理后的新对象，它拥有 target 的一切属性和方法，只不过其行为和结果是在 handler 中自定义的 一个实例 12345678910111213141516171819202122232425262728293031323334353637383940let obj = { a: 1, b: 2,}const p = new Proxy(obj, { get(target, key, value) { if (key === 'c') { return '我是自定义的一个结果'; } else { return target[key]; } }, set(target, key, value) { if (value === 4) { target[key] = '我是自定义的一个结果'; } else { target[key] = value; } }})console.log(obj.a) // 1console.log(obj.c) // undefinedconsole.log(p.a) // 1console.log(p.c) // 我是自定义的一个结果obj.name = 'zhangsan';console.log(obj.name); // zhangsanobj.age = 4;console.log(obj.age); // 4p.name = 'zhangsan';console.log(p.name); // zhangsanp.age = 4;console.log(p.age); // 我是自定义的一个结果 通过上面的代码可以很清楚的看到 Proxy 对象的作用，即是之前所受的用于定义基本操作的自定义行为 同样的 get 和 set 操作，没有没代理的对象所得的结果是其 JavaScript 本身的执行机制运行计算后所得到的，而被代理了的对象的结果则是我们自定义的 观察者模式简单来说就是事件模式，比如按钮的 onclick 的应用 1234567891011121314151617181920212223242526272829303132333435363738394041function Publisher() { this.listeners = [];}// 发布者Publisher.prototype = { addListener: function (listener) { this.listeners.push(listener); }, removeListener: function (listener) { delete this.listeners[listener]; }, notify: function (obj) { for (var i = 0; i &lt; this.listeners.length; i++) { var listener = this.listeners[i]; if (typeof listener !== 'undefined') { listener.process(obj); } } }};function Subscriber() { }// 订阅者Subscriber.prototype = { process: function (obj) { console.log(obj); }};var publisher = new Publisher();publisher.addListener(new Subscriber());publisher.addListener(new Subscriber());// 发布一个对象到所有订阅者publisher.notify({ name: 'zhangsan', ageo: 30 });// 发布一个字符串到所有订阅者publisher.notify('2 subscribers will both perform process');","link":"/2017/08/17/JavaScript/47/"},{"title":"once/bind/debouce/throttle 实现原理","text":"这些函数在平常的开发过程中会经常用到，我们就来看看它们到底是如何实现的 once原理是利用闭包的特性，传递参数，执行完一次以后就自动解除绑定 1234567function once(dom, event, callback) { var handle = function () { callback(); dom.removeEventListener(event, handle); } dom.addEventListener(event, handle)} 第二种方式，基本原理差不多，定义一个局部变量，用来标记函数是否已经调用 12345678910111213const once = (fn) =&gt; { let done = false; return function () { done ? undefined : ((done = true), fn.apply(this, arguments)); }}const test = once(() =&gt; { console.log(`test`);})test(); // testtest(); // undefined bind简单的实现方式为 12345678910Function.prototype.bind = Function.prototype.bind || function (context) { // 保存 this const self = this; // 保存第一部分参数（拆分） const args = Array.prototype.slice.call(arguments, 1); return function () { // 合并参数（实现 currying 功能） return self.apply(context, args.concat(Array.prototype.slice.call(arguments))); }} MDN 上 bind 的实现为下面这种，详细解释可见 bind 的定义与实现 123456789101112131415161718192021222324if (!Function.prototype.bind) { Function.prototype.bind = function (oThis) { if (typeof this !== 'function') { throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable'); } var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function () { }, fBound = function () { return fToBind.apply(this instanceof fNOP ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments))); }; fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound; };} debounce 和 throttle在某些场景下，比如拖拽（mousemove），窗口大小调整（resize）等事件，触发频率比较高，若稍处理函数很复杂的话，就需要较多的运算执行时间，响应速度跟不上触发频率，往往会出现延迟，导致假死或者卡顿感 这种情况下就出现了函数节流（throttle），和其类似的就是 debounce 函数，这两个函数的目的都是为了解决上述问题 原理比如每天上班大厦底下的电梯，把电梯完成一次运送，类比为一次函数的执行和响应，假设电梯有两种运行策略 throttle 和 debounce ，超时设定为 15 秒，不考虑容量限制 throttle 策略的电梯，保证如果电梯第一个人进来后，15 秒后准时运送一次，不等待，如果没有人，则待机 debounce 策略的电梯，如果电梯里有人进来，等待 15 秒，如果有人进来，15 秒等待重新计时，直到 15 秒超时，开始运送 debounce 实现123456789101112// 空闲控制 返回函数连续调用时，空闲时间必须大于或等于 time，handle 才会执行var deBounce = function (fn, wait = 300) { let timer return function () { if (timer) { clearTimeOut(timer) } timer = setTimeOut(() =&gt; { fn.apply(this, arguments) }, wait) }} throttle 实现123456789101112// 频率控制 返回函数连续调用时，handle 执行频率限定为 次/time// throttle(time, handle)var throttle = function (fn, wait = 300) { let prev = +new Date(); return function () { const args = argument, now = +new Date(); if (now &gt; prev + wait) { prev = now; fn.apply(this, args) } }}","link":"/2017/08/25/JavaScript/48/"},{"title":"如何监听对象和数组的属性改变","text":"我们先来看看如何监听对象的属性改变 监听对象属性改变在 ES5 中新增了一个 Object.defineProperty 的方法，使用这个方法可以直接在一个对象上定义一个新属性，或者修改一个已经存在的属性，并返回这个对象 1Object.defineProperty(obj, prop, descriptor) 其接受的第三个参数可以取 get/set 并各自对应一个 getter/setter 的方法 123456789101112131415161718var a = { obj: 0 };Object.defineProperty(a, 'obj', { get: function () { console.log('get：' + obj); return obj; }, set: function (value) { obj = value; console.log('set:' + obj); }});a.obj = 2; // set: 2console.log(a.obj); // get：2 有个缺点就是在 IE8 及更低版本 IE 是无法使用的，因为这个特性是没有 polyfill 的，所以无法在不支持的平台实现 Proxy另外还可以使用 ES6 提供的 Proxy 代理来处理 1234567891011121314151617var user = {}var proxy = new Proxy(user, { get(target, property) { return target[property] }, set(target, property, value) { target[property] = value }})proxy.name = 'zhangsan'console.log(user)// {name: 'zhangsan'} 监听数组的变化简单来说，就是定义一个新数组，然后继承原生的 Array，然后重写其中我们需要监听的方法（pop，push 等） 12345678910111213141516171819class NewArray extends Array { constructor(...args) { // 调用父类 Array 的 constructor super(...args) } push(...args) { console.log(`监听到数组变化`) // 调用父类方法 return super.push(...args); }}let arr = [1, 2];let newArr = new NewArray(...arr);console.log(newArr) // [1, 2]newArr.push(3); // 监听到数组变化console.log(newArr) // [1, 2, 3] 关于 ES5 以下实现在 ES5 及以下的 JavaScript 无法完美继承数组，因为 Array 构造函数执行时不会对传进去的 this 做任何处理，不止 Array，String，Number，Regexp，Object 等等 JavaScript 的内置类都不行 数组其响应式的 length 属性以及内部的 [[class]] 属性我们无法再 JavaScript层面实现，这就导致我们无法去用任何一个对象来模仿一个数组 但是可以使用非标准属性 __proto__ 来实现，如下 123456789101112131415161718192021// 首先获取 Array 原型const oldMethod = Object.create(Array.prototype);const newMethod = [];['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(method =&gt; { // 在 newMethod 上进行方法的重写 // 这里需要注意的是重写的方法是定义在 newMethod 的属性上而不是其原型属性（newMethod.__proto__ 没有改变） newMethod[method] = function () { console.log(`监听到数组的变化`) return oldMethod[method].apply(this, arguments) }})let list = [1, 2]// 将需要监听的数组的原型指针指向我们重新定义的新对象list.__proto__ = newMethodlist.push(3)// 如果不设定指向，则默认使用原生的方法let list2 = [1, 2]list2.push(3)","link":"/2017/08/29/JavaScript/49/"},{"title":"IOS 端点击事件 300ms 的延迟响应的问题","text":"移动设备上的 web 网页是有 300ms 延迟的，往往会造成按钮点击延迟甚至是点击失效 这是由于区分单击事件和双击屏幕缩放的历史原因造成的 原理分析双击缩放是指用手指在屏幕上快速点击两次，IOS 自带的 Safari 浏览器会将网页缩放至原始比例 原因就出在浏览器需要如何判断快速点击上，当用户在屏幕上单击某一个元素时候，例如跳转链接 &lt;a href=&quot;#&quot;&gt;&lt;/a&gt; 此处浏览器会先捕获该次单击，但浏览器不能决定用户是单纯要点击链接还是要双击该部分区域进行缩放操作 所以，捕获第一次单击后，浏览器会先等待一段时间 t，如果在 t 时间区间里用户未进行下一次点击，则浏览器会做单击跳转链接的处理 如果 t 时间里用户进行了第二次单击操作，则浏览器会禁止跳转，转而进行对该部分区域页面的缩放操作 这个 t 在 IOS safari 下，大概为 300 毫秒，这就是延迟的由来 引起问题造成的后果用户纯粹单击页面，页面需要过一段时间才响应，给用户慢体验感觉 对于 Web 开发者来说是，页面 JavaScript 捕获 click 事件的回调函数处理，需要 300ms 后才生效 也就间接导致影响其他业务逻辑的处理 解决办法一般常见的有以下几种解决方案： 使用 fastclick.js 库可以解决在手机上点击事件的 300ms 延迟 zepto 的 touch 模块，tap 事件也是为了解决在 click 的延迟问题 触摸事件的响应顺序为 1touchstart ==&gt; touchmove ==&gt; touchend ==&gt; click 也可以通过绑定 ontouchstart 事件，加快对事件的响应，解决 300ms 延迟问题 点透问题问题如下： 在点击弹出来的选择组件的右上角完成后会让完成后面的 input 输入框聚焦，弹出输入键盘，也就是点透了 这是因为 zepto 的 tap 是通过兼听绑定在 document 上的 touch 事件来完成 tap 事件的模拟的，及 tap 事件是冒泡到 document 上触发的 在点击完成时的 tap 事件（touchstart/touchend）需要冒泡到 document 上才会触发，而在冒泡到 document 之前，用户手的接触屏幕（touchstart）和离开屏幕（touchend）是会触发 click 事件的 因为 click 事件有延迟触发（就是上面的 300ms，这也就是为什么移动端不用 click 而用 tap 的原因），所以在执行完 tap 事件之后，弹出来的选择组件马上就隐藏了 此时 click 事件还在延迟的 300ms 之中，当 300ms 到来的时候，click 到的其实不是完成而是隐藏之后的下方的元素，如果正下方的元素绑定的有 click 事件此时便会触发，如果没有绑定 click 事件的话就当没 click，但是正下方的是 input 输入框（或者 select 选择框或者单选复选框等其他组件），点击默认聚焦而弹出输入键盘，也就出现了上面的点透现象 点透的解决办法几种解决方案： 方案一：引入 fastclick.js，因为 fastclick 源码不依赖其他库所以你可以在原生的 JavaScript 前直接加上 123window.addEventListener('load', function () { FastClick.attach(document.body);}, false); 方案二：用 touchend 代替 tap 事件并阻止掉 touchend 的默认行为 preventDefault() 1234$('#cbFinish').on('touchend', function (event) { // ... event.preventDefault();}); 方案三：延迟一定的时间（300ms+）来处理事件 12345$('#cbFinish').on('tap', function (event) { setTimeout(function () { // ... }, 320);}); 如果实在不行，那还是用 click 吧","link":"/2017/09/06/JavaScript/50/"},{"title":"从请求的异步回调函数中取值的解决办法","text":"很常见的一个问题，就是如何在 Ajax 请求的回调当中将返回的结果拿到函数外部来进行使用 代码如下 12345function load_val() { $.get('url', function (data) { // 如何把这里取到的 data 通过 load_val 函数返回出去？ });} 如果通过一个全局变量来获取，自然也不是不可以，不过这里就涉及到一点：如果使用了全局变量来获取后，该怎么使用呢？ 还是上面这个例子，我们稍微改造一下 123456789101112131415161718var obj = '';function load_val() { $.get('url', function (data) { // 在此处将 data 赋予全局变量 obj = data; });}// 调用函数获取数据load_val();function use_val() { obj += 1; console.log(obj);}use_val(); 上面这个例子很好理解，我们想通过 obj 这个全局变量获取 Ajax 异步过来的 data 数据，然后在 use_val 这个函数中使用 obj 这个变量 看似没问题，实际上问题很严重 在 use_val() 中的 obj 真的是 data 的值么？答案是否定的，而是 '' 因为就这段代码而言，obj = data 是在 use_val() 执行完才在异步回调函数内实现的，在此之前，obj一直是 '' 于是又有人说，那我写个延时函数，等待 obj = data 后再执行呗，那样就太不优雅了，那么该如何解决呢？ 123456789101112131415161718// 定义一个回调函数function load_val(callback) { $.get('url', function (data) { // 将返回结果当作参数通过回调函数返回 callback(data); });}load_val(function (data) { // 这里可以得到值 obj = data; use_val();});function use_val() { obj += 1; console.log(obj);} 也就是在所需要调用的回调函数外加一个函数，这个函数包含一个参数，该参数是个函数 然而这个函数有着依赖于回调函数给出的值的参数，所以经过这两层，就能将原本回调函数里的值给取出来","link":"/2017/09/17/JavaScript/51/"},{"title":"JavaScript 异步加载方案","text":"一般比较常见的莫过于 defer 与 async deferHTML4 为 script 标签定义了一个扩展属性 defer defer 指明本元素所含的脚本不会修改 dom，因此代码能安全地延迟执行，但是该属性并不是一个理想的跨浏览器解决方案 该属性只有 IE4+ 和 firefox3.5+ 的浏览器支持，用法如下 1&lt;script type='text/javascript' src='test.js' defer&gt;&lt;/script&gt; 带有 defer 属性的 script 标签可以放置在文档的任何位置，当一个带有 defer 属性 JavaScript 文件下载时，它不会阻塞浏览器的其他进程 因此这类文件可以与页面中的其他资源并行下载，带有 defer 属性的 script 标签在 dom 加载完成（onload 事件触发前执行） asyncHTML5 规范引入了 async 属性，用于异步加载脚本 1&lt;script type=\"text/javascript\" src=\"test.js\" async&gt;&lt;/script&gt; async 与 defer 的相同点是采用并行下载，在下载的过程中不会产生阻塞，区别在于 async 是加载完成后自动执行，而 defer 需要等待页面完成后执行 动态创建 script主要原理是使用 JavaScript 可以动态创建 HTML 中几乎所有的内容，所以我们可以利用 JavaScript 动态地创建 script 标签并添加到 HTML 中 123456var script = document.createElement('script');script.type = 'text/javasctipt';script.src = 'index.js';document.getElementByTagName('head')[0].appendChild(script) 我们可以使用如下方法跟踪并确保脚本下载完成并准备就绪 123456789101112131415161718192021222324function loadScript(url, callback) { // 创建标签 var script = document.createElement('script'); script.type = 'text/javasctipt'; // 如果是 IE if (script.readyState) { script.onreadystatechange = function () { if (script.readyState == 'loaded' || script.readyState == 'complete') { script.onreadystatechange = null; callback() } } } else { script.onload = function () { callback(); } } // 赋值 script.src = url; document.getElementByTagName('head')[0].appendChild(script)} 调用方法 123loadScript('index.js', function() { console.log(`javascript file is loaded`);}) XMLHttpRequest 脚本注入还可以通过 XHR 对象获取脚本并注入到页面 1234567891011121314151617181920212223242526// 获取 XMLHttpRequest 对象（考虑兼容性）var getXmlHttp = function () { var obj; if (window.XMLHttpRequest) { obj = new XMLHttpRequest(); } else { obj = new ActiveXObject('Microsoft.XMLHTTP'); } return obj;};// 采用 Http 请求 get 方式，open() 方法的第三个参数表示采用异步（true）还是同步（false）来进行处理var xmlHttp = getXmlHttp();xmlHttp.open('GET', 'index.js', true);xmlHttp.onreadystatechange = function () { if (xmlHttp.readyState == 4) { if (xmlHttp.status &gt;= 200 &amp;&amp; xmlHttp.status &lt; 300 || xmlHttp.status == 304) { var script = document.createElement('script'); script.text = xmlHttp.responseText; document.body.appendChild(script); } }}xmlHttp.send(null);","link":"/2017/09/19/JavaScript/52/"},{"title":"Reflect 对象","text":"Reflect 对象与 Proxy 对象一样，也是 ES6 为了操作对象而提供的新 API 简单来说两点，一个就是将 Object 对象的一些明显属于语言内部的方法（比如 Object.defineProperty），放到 Reflect 对象上 另一个就是让 Object 操作都变成函数行为，因为 ES5 很多 Object 操作都是命令式的（另外一个原因就是这些方法可能是全局的，或者要通过原型来调用，统一起来） 这里只简单的介绍几个常用的方法，详细的可见 ECMAScript 6 入门 和 Reflect - MDN Reflect.apply(target, thisArgument, argumentsList)与 ES5 的 Function.prototype.apply 方法是类似的 比如查找数组中最大数 1234567// ES6 Reflect.apply(Math.max, undefined, [1, 2, 3, 4, 5])// ES5Math.max.apply(undefined, [1, 2, 3, 4, 5])Function.prototype.apply.call(Math.max, undefined, [1, 2, 3, 4, 5]) 切割字符串 1234567// ES6 Reflect.apply(String.prototype.slice, 'hello world', [2, 8]); // 'llo wo'// ES5 'hello world'.slice(2, 8); // 'llo wo'String.prototype.slice.apply('hello world', [2, 8]); // 'llo wo' Reflect.construct(target, argumentsList[, newTarget])与使用 new target(...args) 方法类似，相当于提供了一种新的不使用 new 来调用构造函数的方法 target 表示被运行的目标函数 argumentsList 调用构造函数传递的参数数组或者伪数组 newTarget 参数为构造函数，表示使用 Reflect.construct 后生成的对象是谁的实例 如果没有传递第三个参数，默认和 target 一样 如果没有传递第三个参数，那么 target 就是唯一的构造函数，但是如果传递了第三个参数，那就表示实例将由两部分组成，实力的属性部分（constructor）由第一个参数部分生成，实例的方法部分由第三个参数生成 1234567891011121314151617181920212223242526272829303132333435363738394041424344class A1 { constructor(name) { console.log('Class A1 is invoked!'); this.name = name; } getName() { console.log(this.name); return this.name; }}class B1 { constructor(age) { console.log('Class B1 is invoked!'); this.age = age; } getAge() { console.log(this.age); return this.age; }}// 使用 A1 类作为构造函数let a1 = Reflect.construct(A1, ['happy']);// 使用 B1 类作为构造函数let b1 = Reflect.construct(A1, ['happy'], B1);console.log(a1);console.log(b1);// A1 {name: \"happy\"}// name: \"happy\"// __proto__:// constructor: class A1// getName: ƒ getName()// __proto__: Object// B1 {name: \"happy\"}// name: \"happy\"// __proto__:// constructor: class B1// getAge: ƒ getAge()// __proto__: Object Reflect.defineProperty(target, propertyKey, attributes)与 Object.defineProperty 相似，不过如果 Object.defineProperty 的属性定义失败了，就会抛出一个错误 而 Reflect.defineProperty 如果定义属性失败的话就会返回 false 123456789let obj = {};let result = Reflect.defineProperty(obj, 'name', { configurable: true, enumerable: true, value: 'happy'});console.log(result) // true Reflect.getPrototypeOf(target)与 Object.getPrototypeOf 方法是一样的，都是返回一个对象的原型，也就是内部的 [[Prototype]] 属性的值 如果要获取原型的那个值不是一个对象，那么函数 Reflect.getPrototypeOf 会抛出一个异常 对于给定对象的原型，如果没有继承的属性，则返回 null Reflect.ownKeys(target)返回由目标对象自身的属性键组成的数组，包括 symbol 的值 123456789101112131415161718let a = Symbol.for('a');let b = Symbol.for('b');let obj = { [a]: 10, [b]: 20, key1: 30, key2: 40};let arr1 = Object.getOwnPropertyNames(obj);console.log(arr1); // [ 'key1', 'key2' ]let arr2 = Object.getOwnPropertySymbols(obj);console.log(arr2); // [ Symbol(a), Symbol(b) ]let arr3 = Reflect.ownKeys(obj);console.log(arr3); // [ 'key1', 'key2', Symbol(a), Symbol(b) ]","link":"/2017/09/21/JavaScript/53/"},{"title":"进程与线程","text":"最近在深入学习 Node.js，有涉及到这一部分内容，翻出来重新更新整理一下 主要涉及到浏览器与 Node.js 当中的进程与线程相关知识，Node.js 的相关内容篇幅较大 最后更新于：2019 年 10 月 18 日 对于操作系统来说，一个任务就是进程（process），比如打开一个浏览器就是启动了一个浏览器进程，打开一个记事本就启动了一个记事本进程 有些进程还不止同时干一件事，比如 word，它可以同时进行打字、拼写检查，打印等，在一个进程的内部，要同时干多件事，就需要同时运行多个子任务，我们把进程内的这些子任务称为线程（thread） 由于每个进程至少要干一件事，所以，一个进程至少有一个线程，当然也可以有多个，也可以多个线程同时执行 简单来说就是，线程是最小的执行单元，而进程由至少一个线程组成 进程进程是系统进行资源分配和调度的基本单位，是操作系统结构的基础，进程是线程的容器 Node.js 里通过命令行可以开启一个服务进程，多进程就是进程的复制（fork），fork 出来的每个进程都拥有自己的独立空间地址、数据栈 一个进程无法访问另外一个进程里定义的变量、数据结构，只有建立了 IPC 通信（进程间通信技术），进程之间才可数据共享（关于 IPC 通信见下方） 我们可以通过一个简单的示例来验证一下 123456const http = require('http');http.createServer().listen(3000, () =&gt; { process.title = '测试进程' console.log(`process.pid: `, process.pid);}); 打开任务管理器，可以在进程选项当中发现我们刚开启的 Node.js 进程 线程线程是操作系统能够进行运算调度的最小单位，线程是隶属于进程的，被包含于进程之中 一个线程只能隶属于一个进程，但是一个进程是可以拥有多个线程的 同一块代码，可以根据系统 CPU 核心数启动多个进程，每个进程都有属于自己的独立运行空间，进程之间是不相互影响的 同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等 但同一进程中的多个线程有各自的调用栈（call stack），自己的寄存器环境（register context），自己的线程本地存储（thread-local storage） 之所以设置线程这个单位，是因为 在一个程序中，多个线程可以同步或者互斥并行完成工作，简化了编程模型 线程较进程来讲，更轻 线程虽然微观并行，但是在一个进程内部，一个线程阻塞后，会执行这个进程内部的其他线程，而不是整体阻塞，提高了 CPU 的利用率 单线程单线程就是一个进程只开一个线程，所谓的单线程和多线程，本质上指在一个进程内的单线程和多线程 单线程：单线程就是一个进程中只有一个线程，程序顺序执行，前面的执行完，才会执行后面的程序 多线程：多线程就是一个进程中只有多个线程，在进程内部进行线程间的切换，由于每个线程执行的时间片很短，所以在感觉上是并行的 JavaScript 中的单线程执行机制JavaScript 就是属于单线程，程序顺序执行，本质上执行的是基于浏览器的一个事件队列，要执行的函数和触发事件的回调函数都被放在这个队列中，但是浏览器是事件驱动的、异步的、多线程的 浏览器内部有一个事件轮询（event loop），是一个大的内部消息循环，会轮询大的消息队列，并执行，也就是 JavaScript 要处理的事件队列，是浏览器维护的 浏览器至少有四个线程（不同浏览器会有差异） JavaScript 引擎线程 界面渲染线程 浏览器事件触发线程 http 请求线程 再来看看 setTimeout 和 Ajax setTimeout：JavaScript 在执行到延时函数时，会触发浏览器的定时器，到设置时间，浏览器再将这个函数放入执行的函数队列，再由 JavaScript 引擎执行，都是在浏览器空闲了才会执行 Ajax：是真正的异步，在调用 Ajax 的时候，浏览器会开辟一个新的线程，去处理这个请求，得到响应后，如果这个请求有回调，会将这个回调再放入事件队列中，再由 JavaScript 引擎执行 JavaScript 中的阻塞浏览器虽然是多线程，但是由于 JavaScript 具有阻塞特性（比如 alert），无论外链还是内嵌脚本，在浏览器执行解释 JavaScript 脚本的时候，浏览器是不会去做别的事情的，比如渲染页面，而是直到 JavaScript 下载并执行完毕 这样一来，JavaScript 脚本的下载、解释执行，会反使页面的继续绘制，给用户带来不良的体验 所以避免此类情况的话可以采用下面一些方式 将 &lt;script&gt; 内嵌和外链，在可以的情况下放在 &lt;body&gt; 底部（对于 CSS，浏览器是并行下载的） 在页面 onload 后再加载 JavaScript 可以使用 html5 的 &lt;script&gt; 标签的 defer 属性，在页面加载完成后下载 使用动态创建 &lt;script&gt; 标签的方式，在页面加载完成后添加进去（createElement） 简单来说就是一句话，先让页面渲染完，再加载 JavaScript Node.js 的运行机制也是基于事件轮询 （event loop），但是和浏览器当中的是不一样的，详细见 Node.js 中的事件轮询机制 来看下面这个 Node.js 的示例，我们实现一个计算耗时过长造成线程阻塞的例子，来了解阻塞所带来的后果 123456789101112131415161718192021222324const http = require('http');const computation = () =&gt; { let sum = 0; console.info('计算开始'); console.time('计算耗时'); for (let i = 0; i &lt; 10000000000; i++) { sum += i }; console.info('计算结束'); console.timeEnd('计算耗时'); return sum;};const server = http.createServer((req, res) =&gt; { const sum = computation(); res.end(`Sum is ${sum}`);});server.listen('3000', _ =&gt; { console.log(`app is running at port 3000.`);}); 运行完成后可以发现，页面会处于很长时间的空白状态，而执行完成以后会发现，计算耗时会有 13554.335ms 左右，不过不用担心，在后面我们会使用 child_process.fork 来实现多个进程来处理 多线程多线程就是没有一个进程只开一个线程的限制，可以有效避免代码阻塞导致的后续请求无法处理 多线程的代价还在于创建新的线程和执行期上下文线程的切换开销，由于每创建一个线程就会占用一定的内存，当应用程序并发大了之后，内存将会很快耗尽 类似于上面单线程模型中例举的例子，需要一定的计算会造成当前线程阻塞的，还是推荐使用多线程来处理 线程同步线程同步是指多线程通过特定的东西（如互斥量）来控制线程之间的执行顺序（同步） 也可以说是在线程之间通过同步建立起执行顺序的关系，如果没有同步那线程之间是各自运行各自的 方式和机制可以配合 《进程与线程的一个简单解释》 这篇文章来进行理解，图文并茂，解释的很详细 主要有临界区（Critical Section）、互斥量（Mutex）、信号量（Semaphore）、事件（Event）四种方式 区别如下： 临界区 通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问，在任意时刻只允许一个线程对共享资源进行访问 如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开 临界区在被释放后，其他线程才可以抢占 互斥量 采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限 因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问 互斥不仅能实现同一应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享 信号量 它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目 事件 通过通知操作的方式来保持线程的同步，还可以方便实现对多个线程的优先级比较的操作 Node.js 的线程与进程Node.js 是 JavaScript 在服务端的运行环境，构建在 Chrome 的 V8 引擎之上，基于事件驱动、非阻塞 I/O 模型，充分利用操作系统提供的异步 I/O 进行多任务的执行，适合于 I/O 密集型的应用场景 因为异步，程序无需阻塞等待结果返回，而是基于回调通知的机制，原本同步模式等待的时间，则可以用来处理其它任务 在单核 CPU 系统之上一般采用 单进程 + 单线程 的模式来开发 在多核 CPU 系统之上，可以用过 child_process.fork 开启多个进程（在 v0.8 版本之后新增了 Cluster 来实现多进程架构），即 多进程 + 单线程 模式 注意：开启多进程不是为了解决高并发，主要是解决单进程模式下 Node.js 的 CPU 利用率不足的情况，充分利用多核 CPU 的性能 processNode.js 中的进程（process）是一个全局对象，无需 require 直接使用，给我们提供了当前进程中的相关信息 process.env – 环境变量，例如通过 process.env.NODE_ENV 获取不同环境项目配置信息 process.nextTick – 这个在谈及 Event Loop 时经常为会提到 process.pid – 获取当前进程 id process.ppid – 当前进程对应的父进程 process.cwd() – 获取当前进程工作目录 process.platform – 获取当前进程运行的操作系统平台 process.uptime() – 当前进程已运行时间，例如 pm2 守护进程的 uptime 值 进程事件 – process.on('uncaughtException', cb) 捕获异常信息、process.on('exit', cb) 进程退出监听 三个标准流 – 标准输出（process.stdout）、标准输入（process.stdin）、标准错误输出（process.stderr） 以上仅列举了部分常用到功能点，除了 process 之外，Node.js 还提供了 child_process 模块用来对子进程进行操作 总结 JavaScript 是单线程，但是做为宿主环境的 Node.js 并非是单线程的 由于单线程原故，一些复杂的、消耗 CPU 资源的任务建议不要交给 Node.js 来处理，当你的业务需要一些大量计算、视频编码解码等 CPU 密集型的任务，可以采用 C 语言 Node.js 和 Nginx 均采用事件驱动方式，避免了多线程的线程创建、线程上下文切换的开销，如果业务大多是基于 I/O 操作，那么你可以选择 Node.js 来开发 Nodejs 进程创建Node.js 提供了 child_process 内置模块，用于创建子进程，有四种方式可以选择 child_process.spawn() – 适用于返回大量数据，例如图像处理，二进制数据处理 child_process.exec() – 适用于小量数据，maxBuffer 默认值为 200 * 1024 超出这个默认值将会导致程序崩溃，数据量过大可采用 spawn child_process.execFile() – 类似 child_process.exec()，区别是不能通过 shell 来执行，不支持像 I/O 重定向和文件查找这样的行为 child_process.fork() – 衍生新的进程，进程之间是相互独立的，每个进程都有自己的 V8 实例、内存，系统资源是有限的，不建议衍生太多的子进程出来，通长根据系统 CPU 核心数设置 .exec()、.execFile()、.fork() 底层都是通过 .spawn() 实现的 .exec()、execFile() 额外提供了回调，当子进程停止的时候执行 child_process.spawn(command[, args][, options])spawn 方法创建一个子进程来执行特定命令，用法与 execFile 方法类似，但是没有回调函数，只能通过监听事件，来获取运行结果，它属于异步执行，适用于子进程长时间运行的情况 12345678910111213141516var child_process = require('child_process');var path = '.';var ls = child_process.spawn('/bin/ls', ['-l', path]);ls.stdout.on('data', function (data) { console.log('stdout: ' + data);});ls.stderr.on('data', function (data) { console.log('stderr: ' + data);});ls.on('close', function (code) { console.log('child process exited with code ' + code);}); spawn 方法接受两个参数，第一个是可执行文件，第二个是参数数组 spawn 对象返回一个对象，代表子进程，该对象部署了 EventEmitter 接口，它的 data 事件可以监听，从而得到子进程的输出结果 spawn 方法与 exec 方法非常类似，只是使用格式略有区别 123child_process.exec(command, [options], callback)child_process.spawn(command, [args], [options]) 但是需要区分两者的默认参数不同 spawn 的 options 默认为: 12345{ cwd: undefined, env: process.env, setsid: false} exec 的 options 默认为： 12345678{ encoding: 'utf8', timeout: 0, /* 子进程最长执行时间 */ maxBuffer: 200*1024, /* stdout 和 stderr 的最大长度 */ killSignal: 'SIGTERM', cwd: null, env: null} child_process.exec(command[, options][, callback])创建一个 shell，然后在 shell 里执行命令，执行完成后，将 stdout、stderr 作为参数传入回调方法 123456789101112131415161718192021var exec = require('child_process').exec;// 成功的例子exec('ls -al', function (error, stdout, stderr) { if (error) { console.error('error: ' + error); return; } console.log('stdout: ' + stdout); console.log('stderr: ' + typeof stderr);});// 失败的例子exec('ls hello.txt', function (error, stdout, stderr) { if (error) { console.error('error: ' + error); return; } console.log('stdout: ' + stdout); console.log('stderr: ' + stderr);}); 不过需要注意的是，如果传入的命令是用户输入的，有可能产生类似 sql 注入的风险，比如 12345678exec('ls hello.txt; rm -rf *', function (error, stdout, stderr) { if (error) { console.error('error: ' + error); // return; } console.log('stdout: ' + stdout); console.log('stderr: ' + stderr);}); child_process.execFile(file[, args][, options][, callback])跟 .exec() 类似，不同点在于，没有创建一个新的 shell，至少有两点影响 比 child_process.exec() 效率高一些 一些操作，比如 I/O 重定向，文件 glob 等不支持 123456789101112131415var child_process = require('child_process');child_process.execFile('node', ['--version'], function (error, stdout, stderr) { if (error) { throw error; } console.log(stdout);});child_process.execFile('/Users/a/.nvm/versions/node/v6.1.0/bin/node', ['--version'], function (error, stdout, stderr) { if (error) { throw error; } console.log(stdout);}); 从源码层面来看，exec() 和 execFile() 最大的差别就在于是否创建了 shell，那么可以手动设置 shell，比如下面的代码差不多是等价的 1234567891011121314151617var child_process = require('child_process');var execFile = child_process.execFile;var exec = child_process.exec;exec('ls -al .', function (error, stdout, stderr) { if (error) { throw error; } console.log(stdout);});execFile('ls -al .', { shell: '/bin/bash' }, function (error, stdout, stderr) { if (error) { throw error; } console.log(stdout);}); execFile() 内部最终还是通过 spawn() 实现的，如果没有设置 { shell: '/bin/bash' }，那么 spawm() 内部对命令的解析会有所不同，execFile('ls -al .') 会直接报错 child_process.fork(modulePath[, args][, options])fork 方法直接创建一个子进程来执行脚本，fork('./child.js') 相当于 spawn('node', ['./child.js']) 与 spawn 方法不同的是，fork 会在父进程与子进程之间建立一个通信管道，用于进程之间的通信（IPC） 123456789101112131415161718// parent.jsvar child_process = require('child_process');var child = child_process.fork('./child.js');child.on('message', function (m) { console.log('message from child: ' + JSON.stringify(m));});child.send({ from: 'parent' });// child.jsprocess.on('message', function (m) { console.log('message from parent: ' + JSON.stringify(m));});process.send({ from: 'child' }); 运行结果如下 123message from child: { 'from': 'child' }message from parent: { 'from': 'parent' } 实战在之前章节当中，我们实现了一个计算耗时的函数，可以发现在 CPU 计算密度大的情况程序会造成阻塞导致后续请求需要等待 下面采用 child_process.fork 方法来进行改写，主要流程有以下几步 在进行 cpmpute 计算时创建子进程 子进程计算完成通过 send 方法将结果发送给主进程 主进程通过 message 监听到信息后处理并退出 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// fork_app.jsconst http = require('http');const fork = require('child_process').fork;const server = http.createServer((req, res) =&gt; { if (req.url == '/compute') { const compute = fork('./fork_compute.js'); compute.send('开启一个新的子进程'); // 当一个子进程使用 process.send() 发送消息时会触发 'message' 事件 compute.on('message', sum =&gt; { res.end(`Sum is ${sum}`); compute.kill(); }); // 子进程监听到一些错误消息退出 compute.on('close', (code, signal) =&gt; { console.log(`收到 close 事件，子进程收到信号 ${signal} 而终止，退出码 ${code}`); compute.kill(); }) } else { res.end(`ok`); }});server.listen(3000, () =&gt; { console.log(`app is running at port 3000`);});// fork_compute.jsconst computation = () =&gt; { let sum = 0; console.info('计算开始'); console.time('计算耗时'); for (let i = 0; i &lt; 10000000000; i++) { sum += i }; console.info('计算结束'); console.timeEnd('计算耗时'); return sum;};process.on('message', msg =&gt; { console.log(msg, 'process.pid', process.pid); const sum = computation(); // 如果 Node.js 进程是通过进程间通信产生的，那么 process.send() 方法可以用来给父进程发送消息 process.send(sum);}) Node.js 多进程架构模型多进程架构解决了单进程、单线程无法充分利用系统多核 CPU 的问题，下面就通过一个示例来了解如何启动一批 Node.js 进程来提供服务 主进程 master.js代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// master.jsconst fork = require('child_process').fork;const cpus = require('os').cpus();const server = require('net').createServer();server.listen(3000);process.title = 'node-master'const workers = {};const createWorker = () =&gt; { const worker = fork('worker.js') worker.on('message', function (message) { if (message.act === 'close') { createWorker(); } }) worker.on('exit', function (code, signal) { console.log('worker process exited, code: %s signal: %s', code, signal); delete workers[worker.pid]; }); worker.send('server', server); workers[worker.pid] = worker; console.log('worker process created, pid: %s ppid: %s', worker.pid, process.pid);}for (let i = 0; i &lt; cpus.length; i++) { createWorker();}process.once('SIGINT', close.bind(this, 'SIGINT')); // kill(2) Ctrl-Cprocess.once('SIGQUIT', close.bind(this, 'SIGQUIT')); // kill(3) Ctrl-\\process.once('SIGTERM', close.bind(this, 'SIGTERM')); // kill(15) defaultprocess.once('exit', close.bind(this));function close(code) { console.log('进程退出！', code); if (code !== 0) { for (let pid in workers) { console.log('master process exited, kill worker pid: ', pid); workers[pid].kill('SIGINT'); } } process.exit(0);} master.js 作为入口文件，主要处理以下逻辑： 创建一个 server 并监听 3000 端口 根据系统 cpu 个数开启多个子进程 通过子进程对象的 send 方法发送消息到子进程进行通信 在主进程中监听了子进程的变化，如果是自杀信号重新启动一个工作进程 主进程在监听到退出消息的时候，先退出子进程在退出主进程 工作进程下面来看看上面我们 fork 的 worker.js，主要逻辑如下 创建一个 server 对象，注意最开始并没有监听 3000 端口 通过 message 事件接收主进程 send 方法发送的消息 监听 uncaughtException 事件，捕获未处理的异常，发送关闭信息由主进程重建进程，子进程在链接关闭之后退出 1234567891011121314151617181920212223242526272829// worker.jsconst http = require('http');const server = http.createServer((req, res) =&gt; { res.writeHead(200, { 'Content-Type': 'text/plan' }); res.end('I am worker, pid: ' + process.pid + ', ppid: ' + process.ppid); // 测试异常进程退出、重建 throw new Error('worker process exception!');});let worker;process.title = 'node-worker'process.on('message', function (message, sendHandle) { if (message === 'server') { worker = sendHandle; worker.on('connection', function (socket) { server.emit('connection', socket); }); }});process.on('uncaughtException', function (err) { console.log(err); process.send({ act: 'close' }); worker.close(function () { process.exit(1); })}) 测试控制台执行 node master.js 可以看到已成功创建了四个工作进程 12345$ node masterworker process created, pid: 19280 ppid: 19279worker process created, pid: 19281 ppid: 19279worker process created, pid: 19282 ppid: 19279worker process created, pid: 19283 ppid: 19279 打开活动监视器查看我们的进程情况，由于在创建进程时对进程进行了命名，很清楚的看到一个主进程对应多个子进程 想要了解更多可以参考 Egg 官方文档当中的 多进程模型和进程间通讯 守护进程本章节主要涉及下面几个问题 什么是守护进程 守护进程的作用 如何编写守护进程 守护进程运行在后台不受终端的影响，比如在 Node.js 当中，当我们打开终端执行 node app.js 开启一个服务进程之后，这个终端就会一直被占用，如果关掉终端，服务就会断掉，即前台运行模式 如果采用守护进程进程方式，这个终端在我们使用 node app.js 开启一个服务进程之后，还可以在这个终端上做些别的事情，且不会相互影响 创建步骤主要有下面四个步骤 借助 clild_process 中的 spawn 创建子进程 在子进程中创建新会话，在 spawn 的第三个参数中，可以设置 detached 属性，如果该属性为 true，则会调用系统函数 setsid 方法 改变子进程工作目录（如：/ 或 /usr/ 等），options.cwd 指定当前子进程工作目录若不做设置默认继承当前工作目录 父进程终止（运行 daemon.unref() 退出父进程） 123456789101112131415// index.jsconst spawn = require('child_process').spawn;function startDaemon() { const daemon = spawn('node', ['daemon.js'], { cwd: '/usr', detached: true, stdio: 'ignore', }); console.log('守护进程开启 父进程 pid: %s, 守护进程 pid: %s', process.pid, daemon.pid); daemon.unref();}startDaemon() daemon.js 文件里处理逻辑开启一个定时器每 10 秒执行一次，使得这个资源不会退出，同时写入日志到子进程当前工作目录下 12345678910// daemon.jsconst fs = require('fs');const { Console } = require('console');// custom simple loggerconst logger = new Console(fs.createWriteStream('./stdout.log'), fs.createWriteStream('./stderr.log'));setInterval(function () { logger.log('daemon pid: ', process.pid, ', ppid: ', process.ppid);}, 1000 * 10); 运行测试123$ node index.js守护进程开启 父进程 pid: 47608, 守护进程 pid: 47609 打开活动监视器查看，目前只有一个进程 47609，这就是我们需要进行守护的进程 当然，以上只是一个简单的示例，在实际工作中对守护进程的健壮性要求还是很高的，比如进程的异常监听、工作进程管理调度、进程挂掉之后重启等等 推荐阅读 Nodejs 编写守护进程 了解更多 问题汇总主要包括以下内容 什么是进程和线程？两者之间有什么区别？ 什么是孤儿进程？ 创建多进程时，代码里有 app.listen(port) 在进行 fork 时，为什么没有报端口被占用？ 什么是 IPC 通信，如何建立 IPC 通信？什么场景下需要用到 IPC 通信？ 父进程与子进程是如何通信的？ Node.js 是单线程还是多线程？ 如何实现一个简单的命令行交互程序？ 如何让一个 js 文件在 Linux 下成为一个可执行命令程序? 进程的当前工作目录是什么? 有什么作用? 多进程或多个 Web 服务之间的状态共享问题？ 下面一个一个来看 什么是进程和线程？两者之间有什么区别？之前已经介绍过了，这里小小的总结一下 关系：进程中包含着至少一个线程 在进程创建之初，就会包含一个线程，这个线程会根据需要，调用系统库函数去创建其他线程 但需要注意的是，这些线程之间是没有层级关系的，他们之间协同完成工作，在整个进程完成工作之后，其中的线程会被销毁，释放资源 共性：都包含三个状态，就绪、阻塞、运行 阻塞就是资源未到位，等待资源中 就绪，就是资源到位了，但是 CPU 未到位，还在运行其他 什么是孤儿进程？父进程创建子进程之后，父进程退出了，但是父进程对应的一个或多个子进程还在运行，这些子进程会被系统的 init 进程收养，对应的进程 ppid 为 1，这就是孤儿进程 12345678910111213141516171819202122232425262728// master.jsconst fork = require('child_process').fork;const server = require('net').createServer();server.listen(3000);const worker = fork('worker.js');worker.send('server', server);console.log('worker process created, pid: %s ppid: %s', worker.pid, process.pid);// 创建子进程之后，主进程退出，此时创建的 worker 进程会成为孤儿进程process.exit(0);// worker.jsconst http = require('http');const server = http.createServer((req, res) =&gt; { // 记录当前工作进程 pid 及父进程 ppid res.end('I am worker, pid: ' + process.pid + ', ppid: ' + process.ppid);});let worker;process.on('message', function (message, sendHandle) { if (message === 'server') { worker = sendHandle; worker.on('connection', function (socket) { server.emit('connection', socket); }); }}); 在控制台进行测试，输出当前工作进程 pid 和 父进程 ppid 123$ node masterworker process created, pid: 32971 ppid: 32970 由于在 master.js 里退出了父进程，活动监视器所显示的也就只有工作进程 再次验证，打开控制台调用接口，可以看到工作进程 32971 对应的 ppid 为 1（为 init 进程），此时已经成为了孤儿进程 123$ curl http://127.0.0.1:3000I am worker, pid: 32971, ppid: 1 创建多进程时，代码里有 app.listen(port) 在进行 fork 时，为什么没有报端口被占用？我们先来看一个端口被占用的情况 123456789101112131415// master.jsconst fork = require('child_process').fork;const cpus = require('os').cpus();for (let i = 0; i &lt; cpus.length; i++) { const worker = fork('worker.js'); console.log('worker process created, pid: %s ppid: %s', worker.pid, process.pid);}//worker.jsconst http = require('http');http.createServer((req, res) =&gt; { res.end('I am worker, pid: ' + process.pid + ', ppid: ' + process.ppid);}).listen(3000); 以上代码示例，控制台执行 node master.js 只有一个 worker 可以监听到 3000 端口，其余将会抛出 Error: listen EADDRINUSE :::3000 错误 那么多进程模式下怎么实现多端口监听呢？ 通过上面的多进程当中的示例可以发现，在这种情况下就可以通过句柄传递来实现多端口监听 当父子进程之间建立 IPC 通道之后，通过子进程对象的 send 方法发送消息，第二个参数 sendHandle 就是句柄，可以是 TCP 套接字、TCP 服务器、UDP 套接字等 为了解决上面多进程端口占用问题，我们将主进程的 socket 传递到子进程，修改代码 123456789101112131415161718192021222324252627282930313233343536//master.jsconst fork = require('child_process').fork;const cpus = require('os').cpus();const server = require('net').createServer();server.listen(3000);process.title = 'node-master'for (let i = 0; i &lt; cpus.length; i++) { const worker = fork('worker.js'); worker.send('server', server); console.log('worker process created, pid: %s ppid: %s', worker.pid, process.pid); if (i + 1 === cpus.length) { console.log('serve close'); // 关闭服务器监听，交由子进程处理 server.close(); }}// worker.jsconst http = require('http');const server = http.createServer((req, res) =&gt; { res.end('I am worker, pid: ' + process.pid + ', ppid: ' + process.ppid);});let worker;process.title = 'node-worker'process.on('message', function (message, sendHandle) { if (message === 'server') { worker = sendHandle; worker.on('connection', function (socket) { server.emit('connection', socket); }); }}); 验证一番，控制台执行 node master.js 以下结果是我们预期的，多进程端口占用问题已经被解决了 123456$ node master.jsworker process created, pid: 34512 ppid: 34511worker process created, pid: 34513 ppid: 34511worker process created, pid: 34514 ppid: 34511worker process created, pid: 34515 ppid: 34511 关于多进程端口占用问题，也可以参考 通过源码解析 Node.js 中 cluster 模块的主要功能实现 什么是 IPC 通信，如何建立 IPC 通信？什么场景下需要用到 IPC 通信？IPC（Inter-process communication），即进程间通信技术，由于每个进程创建之后都有自己的独立地址空间，实现 IPC 的目的就是为了进程之间资源共享访问 实现 IPC 的方式有多种方式，例如管道、消息队列、信号量、Domain Socket 等，在 Node.js 当中是通过 pipe 来实现 我们先来看一个未使用 IPC 的情况 12345678// pipe.jsconst spawn = require('child_process').spawn;const child = spawn('node', ['worker.js'])console.log(process.pid, child.pid);// worker.jsconsole.log('I am worker, PID: ', process.pid); 控制台执行 node pipe.js，输出主进程 id、子进程 id，但是子进程 worker.js 的信息并没有在控制台打印，原因是新创建的子进程有自己的 stdio 流 123$ node pipe.js41948 41949 下面我们再来创建一个父进程和子进程之间传递消息的 IPC 通道实现输出信息的示例 通过修改 pipe.js 让子进程的 stdio 和当前进程的 stdio 之间建立管道链接，还可以通过 spawn() 方法的 stdio 选项建立 IPC 机制 12345// pipe.jsconst spawn = require('child_process').spawn;const child = spawn('node', ['worker.js'])child.stdout.pipe(process.stdout);console.log(process.pid, child.pid); 再次执行 node pipe.js，可以发现 worker.js 的信息也打印了出来 123$ 42473 42474I am worker, PID: 42474 父进程与子进程是如何通信的？父进程在创建子进程之前会先去创建 IPC 通道并一直监听该通道，之后开始创建子进程并通过环境变量（NODE_CHANNEL_FD）的方式将 IPC 频道的文件描述符传递给子进程 子进程启动时根据传递的文件描述符去链接 IPC 通道，从而建立父子进程之间的通信机制 Node.js 是单线程还是多线程？JavaScript 是单线程的，但是做为其在服务端运行环境的 Node.js 并非是单线程的 至于 JavaScript 为什么是单线程？这个问题需要从浏览器说起，在浏览器环境中对于 DOM 的操作，不可能存在多个线程来对同一个 DOM 同时操作 那也就意味着对于 DOM 的操作只能是单线程，避免 DOM 渲染冲突 在浏览器环境中 UI 渲染线程和 JavaScript 执行引擎是互斥的，一方在执行时都会导致另一方被挂起，这是由 JavaScript 引擎所决定的 如何实现一个简单的命令行交互程序？采用子进程 child_process 的 spawn 方法，如下所示： 12345const spawn = require('child_process').spawn;const child = spawn('echo', ['test']);// 将子进程的输出做为当前进程的输入，打印在控制台child.stdout.pipe(process.stdout); 运行 123$ node execfile// test 如何让一个 js 文件在 Linux 下成为一个可执行命令程序? 新建 hello.js 文件，头部须加上 #!/usr/bin/env node，表示当前脚本使用 Node.js 进行解析 赋予文件可执行权限 chmod + x chmod + x /${dir}/hello.js，目录自定义 在 /usr/local/bin 目录下创建一个软链文件 sudo ln -s /${dir}/hello.js /usr/local/bin/hello，文件名就是我们在终端使用的名字 终端执行 hello 相当于输入 node hello.js 123#!/usr/bin/env nodeconsole.log(&apos;hello world!&apos;); 终端测试 123$ hellohello world! 进程的当前工作目录是什么? 有什么作用?进程的当前工作目录可以通过 process.cwd() 命令获取，默认为当前启动的目录，如果是创建子进程则继承于父进程的目录，可通过 process.chdir() 命令重置 例如通过 spawn 命令创建的子进程可以指定 cwd 选项设置子进程的工作目录 有什么作用？例如通过 fs 模块来读取文件，如果设置为相对路径则相对于当前进程启动的目录进行查找，所以启动目录设置有误的情况下将无法得到正确的结果 还有一种情况程序里引用第三方模块也是根据当前进程启动的目录来进行查找的 12345// 设置当前进程目录process.chdir('/Users/may/Documents/test/') // 获取当前进程目录console.log(process.cwd()); 多进程或多个 Web 服务之间的状态共享问题？多进程模式下各个进程之间是相互独立的，例如用户登陆之后 Session 的保存，如果保存在服务进程里，那么如果我有 4 个工作进程，每个进程都要保存一份这是没必要的，如果服务重启了数据也会丢失 多个 Web 服务也是一样的，还会出现我在 A 机器上创建了 Session，当负载均衡分发到 B 机器上之后还需要在创建一份 一般的做法是通过 Redis 或者数据库来做数据共享 参考 线程和进程的区别是什么？ Child Process 模块 Nodejs 进阶：如何玩转子进程（child_process）","link":"/2019/05/04/JavaScript/54/"},{"title":"JavaScript 中的栈和堆","text":"首先要先说一下耳熟能详的「堆栈」，要区分数据结构和内存中各自「堆栈」的含义 数据结构中的堆和栈是两种不同的、数据项按序排列的数据结构，这里主要介绍的是内存中的堆区与栈区 内存中的堆区与栈区在 C 语言中，各个区别如下 栈区是分配局部变量的空间 堆区是地址向上增长的用于分配我们申请的内存空间 另外还有静态区是分配静态变量、全局变量空间的 只读区是分配常量和程序代码空间的 一个简单的例子 123456789101112int a = 0; // 全局初始化区char *p1; // 全局未初始化区main() { int b; // 栈 char s[] = \"abc\"; // 栈 char *p2; // 栈 char *p3 = \"123\"; // 在常量区，p3 在栈上 static int c =0； // 全局（静态）初始化区 p1 = (char *)malloc(10); // 堆 p2 = (char *)malloc(20); // 堆} 而 JavaScript 是高级语言，底层依靠 C/C++ 来编译实现，其变量划分为基本数据类型和引用数据类型 基本数据类型包括 Undefined，Null，Boolean，Number、String（ES6 当中新增了 Symbol() 基本数据类型） 这些类型在内存中分别占有固定大小的空间，他们的值保存在栈空间，通过按值访问、拷贝和比较 引用类型包括 Object，Array，Function，Error，Date 这些类型大小不固定，栈内存中存放地址指向堆内存中的对象，是按引用访问的（和 C 语言的指针类似） 对于引用类型的变量，栈内存中存放的只是该对象的访问地址，在堆内存中为该值分配空间，由于这种值的大小不固定，因此不能把他们保存在栈内存中 但是内存地址大小是固定的，因此可以将堆内存地址保存到栈内存中 这样一来，当查询引用类型的变量的时候，就会先从栈中读取堆内存地址，然后在根据地址取出对应的值 显而易见的是，JavaScript 中所有引用类型创建实例的时候，都是显式或者隐式的 new 出对应类型的实例，实际上就是对应 C 语言的 malloc 分配内存函数 栈和队列的区别 栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的 队列先进先出，栈先进后出 栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除 有一个比较好的记忆方式 队列相当我们去银行柜台排队，大家依次鱼贯而行，先进去排队的最先出来 栈比较像我们在家中洗碗，最后洗好的碗叠在最上面的，而下次拿的时候是最先拿到最后叠上去的碗 栈和堆的区别 栈区（stack） – 由编译器自动分配释放，存放函数的参数值，局部变量的值等 堆区（heap） – 一般由程序员分配释放，若程序员不释放，程序结束时可能由 OS 回收 堆（数据结构） – 堆可以被看成是一棵树，如：堆排序 栈（数据结构） – 一种先进后出的数据结构","link":"/2019/05/05/JavaScript/55/"},{"title":"Angular 属性绑定 [] 和 {{}} 的差异","text":"当我们在 Angular 中给属性绑定一个变量的时候，主要有三种绑定方式 [property] = &quot;variable&quot; property = &quot;&quot; [attr.property] = &quot;xxx&quot; [[]] 和 {{}}我们来通过一个示例看看它们之间的区别 123456789101112131415@Component({ selector: \"my-test\", template: `&lt;br&gt;222222{{test}}`})export class TestComponent { @Input() test: any; @Input() testTwo: string; ngOnChanges(change) { console.log(this.test) console.log(this.testTwo) console.log(change) }} 然后我们来使用它 123&lt;my-test [test]=\"str\" [testTwo]=\"'[]'\"&gt;&lt;/my-test&gt;---------------------------&lt;my-test test=\"{{str}}\" [testTwo]=\"'{}'\"&gt;&lt;/my-test&gt; str 是一个字符串，并且我们通过 input 或者 button 来改变 str 的值的时候 两者在页面上的显示和控制台的打印都是正常的，看起来并没有什么差异 但是在 str 还没有赋值之前，前者打印的是 undefined，而后者打印的是空字符串 这样并不能看出什么，我们试着传递一个对象过去，这下便可以看出区别了 前者可以正常的显式我们传递的对象，比如 {a: 1, b: 2}，但是后者显式的却是 '[Object Object]' [attr.Attribute] 和 基本属性在 Angular 中还有一种 attribute 绑定，写法为 [attr.Attribute]=&quot;variable&quot;，那么它和 [property]=&quot;variable&quot; 的区别又在哪里呢 我们先来看看 Dom 的 property（属性）和 attribute（特性） property 指的是 DOM 中的属性，是 JavaScript 里的对象 attribute 指的是 HTML 标签上的特性，它的值只能够是字符串 DOM 中的有一个 attribute 的属性，其中就是 html 标签上的特性列表 两者之间的数据绑定是单向的，更改 attribute 会同步到 property，但反之则不然 更改 property 和 attribute 的值，都会将更新反映到 HTML 页面中 一个简单的示例 1&lt;div id=\"test\"&gt;&lt;/div&gt; 首先我们来获取这个元素，使用 var testElm = document.getElementById('test') 那么这个 element 的 id 特性就是 testElm.getAttribute('id')，而其 id 属性为 testElm.id DOM 的 element 只有基本特性会有一一对应的属性，例如 id、title 等，比如我们添加一个自定义特性 test 1&lt;div id=\"test\" test=\"my-test\"&gt;&lt;/div&gt; 那么 testElm.getAttribute('test') 或者 testElm.attributes[1] 就是它的 test 特性，但是它并没有对应的 test 属性 对于自定义属性，H5 提供了一个 data-* 的特性 &lt;div id=&quot;test&quot; data-test=&quot;my-test&quot;&gt;&lt;/div&gt; 那么它的特性就是 testElm.getAttribute('test')，而对应的属性则是 testElm.dataset.test 在 Angular 当中，由于 element 没有这些属性，中括号 [] 的属性绑定语法自然不行，而且模版编译的时候会报错 所以对于非基本属性，Angular 提供了这种 [attr.Attribute]=&quot;variable&quot; 的特性绑定语法 当然，在 property 是基本属性时，使用 [property]=&quot;variable&quot; 绑定属性，然后改变 variable 的值，对应的 attribute 也会跟着属性同步，Angular 应该是做了属性和特性的数据双向绑定的工作 所以只有 property 是基本属性，两者一样，例如 [id] 和 [attr.id] 的作用并无区别 两个需要注意的地方一个就是常见的传值的差异 123[property]=\"false\"[property]=\"{{false}}\" 特别需要注意，因为后者其实绑定的是 'false'（字符串） 一旦用在了 if 语句当中就可能出现问题 另外一个就是 Input 标签的 maxlength 特性对应的是 maxLength 属性（注意 L 是大写），虽然是大写，但是在浏览器当中解析出来的依然是 &lt;input maxlength=&quot;10&quot; /&gt;（小写） 所以写成 [attr.maxlength]、[attr.maxLength]、[maxLength] 都是可以，但是 [maxlength] 就不行，同理 minlength/minLength 是一样的 小结综上所诉，属性绑定最好还是用中括号，双大括号用于展示，如 1&lt;div&gt;{{obj | json}}&lt;/div&gt; 实际上在渲染视图之前，Angular 把这些插值表达式翻译成相应的属性绑定 还有就是，它依然可以用于执行 Angular 的模板语法，例如 123property=\"{{fun()}}\"property=\"{{a ? b : c}}\" 只是它会做多一步，把 return 的值转换成 string","link":"/2019/06/22/Angular/14/"},{"title":"在 Angular 当中使用 WebSocket","text":"在正式展开之前，我们先来看看 WebSocket 和 Socket.IO WebSocketWebSocket 是 HTML5 新增的协议，它的目的是在浏览器和服务器之间建立一个不受限的双向通信的通道，比如说服务器可以在任意时刻发送消息给浏览器 Websocket 协议本质上是一个基于 TCP 的协议，它由通信协议和编程 API 组成，WebSocket 能够在浏览器和服务器之间建立双向连接，以基于事件的方式，赋予浏览器事实通信的能力 既然是双向通信，就意味着服务器端和客户端可以同时发送并响应请求，而不再像 http 的请求和响应 为了建立一个 WebSocket 连接，客户端浏览器首先要向服务器发起一个 http 请求，这个请求和通常的 http 请求不同，包含了一些附加头信息，其中附加头信息 'Upgrade: WebSocket' 表明这是一个申请协议升级的 http 请求 服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的 WebSocket 连接就建立起来了，双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接 WebSocket API一个简单的实例 大致流程为：打开一个连接，为连接创建事件监听器，断开连接，消息时间，发送消息返回到服务器，关闭连接 12345678910111213141516171819202122// 创建一个 Socket 实例var socket = new WebSocket('ws://localhost:8000');// 打开 Socketsocket.onopen = function (event) { // 发送一个初始化消息 socket.send('socket init') // 监听消息 socket.onmessage = function (event) { console.log('Message listener') } // 监听 socket 的关闭 socket.onclose = function (event) { console.log('closed') } // 关闭 socket.close()} ws 表示 WebSocket 协议，参数为 url（以 ws 开头） onopen，onclose，onmessage 方法把事件连接到 Socket 实例上 onmessage 事件提供了一个 data 属性，它可以包含消息的 body 部分（消息的 body 部分必须为一个字符串，可以进行序列化或者反序列化，以便传递更多的数据） Socket.IOSocket.IO 是 Node.js 当中的一个模块，它是通过 WebSocket 进行通信的一种简单方式 Socket.IO 使用检测功能来判断是否建立 WebSocket 连接，或者是 Ajax long-polling 连接，或 Flash 等，可快速创建实时的应用程序 一个简单的示例，客户端 index.html 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang='en'&gt;&lt;head&gt; &lt;meta charset='UTF-8'&gt; &lt;title&gt;Socket.io&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;I Am Socket.IO&lt;/h1&gt; &lt;script src='./socket.io.js'&gt;&lt;/script&gt; &lt;script&gt; var socket=io.connect('ws://localhost:8000'); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 服务端 index.js 1234567891011121314151617181920var http = require('http');var fs = require('fs');var sever = http.createServer(function (req, res) { fs.readFile('./index.html', function (err, data) { res.writeHead(200, { 'Content-Type': 'text/html' }); res.end(data, 'utf-8'); });}).listen(3000);// 为了在服务器上加入 Socket.io 的功能，必须将 Socket.IO 库包括进来，而后附加到服务器上var io = require('socket.io').listen(sever);// 在启动了服务器的 Socket.io 之后，用于初始化io.socket.on('connection', function (socket) { console.log('user conneted'); socket.on('disconnect', function () { console.log('user disconnet'); });}); 向服务器发送数据到客户端 1234io.sockets.on('connection', function (socket) { // 向客户端发送消息 socket.emit('message', { text:'you have connected' });}); 只要客户端连接，它就将数据发送给每一个新的客户端，而如果想给当前所有的客户端都发送消息，则需要发送广播消息 123456io.sockets.on('connection', function (socket) { // 单个客户端发送消息 socket.emit('message', { text: 'A new user has connected' }); // 广播消息给客户端 socket.broadcast.emit('massage', { text: 'A new user has connected' });}); 接下来需要做的就是客户端先连接 Socket.io 服务器，然后侦听在 'message' 事件上接收的数据，然后做出响应 1234var socket = io.connect('ws://localhost:8000');socket.on('message', function (data) { console.log(`${data.text}`);}); 在 Angular 项目当中使用 WebSocket主要是结合 WebSocket 和 rxjs 两者一起使用 12345678910111213141516171819202122// socket.service.tsimport { Injectable } from '@angular/core';import { Observable } from 'rxjs';@Injectable()export class SocketService { ws: WebSocket; constructor() { } createObservableSocket(url: string): Observable&lt;any&gt; { this.ws = new WebSocket(url); return new Observable( observer =&gt; { this.ws.onmessage = (event) =&gt; observer.next(event.data); this.ws.onerror = (event) =&gt; observer.error(event); this.ws.onclose = (event) =&gt; observer.complete(); }); }} 当然别忘了在当前 module 当中进行注册 1234567891011121314151617import { SocketService } from './header/socket.service';@NgModule({ declarations: [ AppComponent, ... ], imports: [ BrowserModule, ... ], providers: [SocketService], bootstrap: [AppComponent]})export class AppModule {} 最后是导入使用 1234567891011121314151617181920212223import { Component, OnInit } from '@angular/core';import { SocketService } from './socket.service';@Component({ selector: 'app-header', templateUrl: './header.component.html', styleUrls: ['./header.component.css']})export class HeaderComponent implements OnInit { messageCount = 0; constructor(public socketService: SocketService) { } ngOnInit() { this.socketService.createObservableSocket('ws://localhost:8000') .map(event =&gt; JSON.parse(event)) .subscribe( event =&gt; this.messageCount = event.messageCount ); }}","link":"/2019/05/20/Angular/15/"},{"title":"缓存穿透和缓存雪崩","text":"分布式缓存系统面临的问题 缓存一致性问题 缓存系统与底层数据的一致性 这点在底层系统是可读可写时，写得尤为重要 有继承关系的缓存之间的一致性 为了尽量提高缓存命中率，缓存也是分层的，分为全局缓存和二级缓存，他们是存在继承关系的，全局缓存可以有二级缓存来组成 多个缓存副本之间的一致性 为了保证系统的高可用性，缓存系统背后往往会接两套存储系统（如 MemCache，Redis 等） 缓存穿透一般的缓存系统，都是按照 key 去缓存查询，如果不存在对应的 value，就应该去后端系统查找（比如 DB） 如果 key 对应的 value 是一定不存在的，并且对该 key 并发请求量很大，就会对后端系统造成很大的压力，这就叫做缓存穿透 如何避免 对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该 key 对应的数据 insert 了之后清理缓存 对一定不存在的 key 进行过滤，可以把所有的可能存在的 key 放到一个大的 Bitmap 中，查询时通过该 Bitmap 过滤 缓存雪崩当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统（比如 DB）带来很大压力 如何避免 在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量，比如对某个 key 只允许一个线程查询数据和写缓存，其他线程等待 不同的 key ，设置不同的过期时间，让缓存失效的时间点尽量均匀 做二级缓存，A1 为原始缓存，A2 为拷贝缓存，A1 失效时，可以访问 A2，A1 缓存失效时间设置为短期，A2 设置为长期（此点为补充） 缓存数据的淘汰策略有两种： 定时去清理过期的缓存 当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存 两者各有优劣，第一种的缺点是维护大量缓存的 key 是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂，具体用哪种方案，可以根据自己的应用场景来权衡 预估失效时间 版本号（必须单调递增，时间戳是最好的选择） 提供手动清理缓存的接口","link":"/2018/03/03/MySQL/01/"},{"title":"数据库中的事务和锁","text":"在数据库方向，我们会经常听到事务这个东西，我们就来看看它到底是什么 事务事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消 也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做 事务的结束有两种 当事务中的所以步骤全部成功执行时，事务提交 如果其中一个步骤失败，将发生回滚操作，撤消撤消之前到事务开始时的所以操作 事务的 ACID A （Atomicity） 原子性 事务必须是原子工作单元，对于其数据修改，要么全都执行，要么全都不执行 C （Consistency） 一致性 事务在完成时，必须使所有的数据都保持一致状态 在相关数据库中，所有规则都必须应用于事务的修改，以保持所有数据的完整性 事务结束时，所有的内部数据结构（如 B 树索引或双向链表）都必须是正确的 I （Isolation） 隔离性 并发事务所做的修改必须与任何其他并发事务所做的修改隔离 事务识别数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是第二个事务修改它之后的状态 事务不会识别中间状态的数据 D （Durability） 持久性 事务完成之后，它对于系统的影响是永久性的，该修改即使出现系统故障也将一直保持 锁在事务获取数据块当前状态的依赖关系（比如通过读取或修改数据）之前，它必须保护自己不受其他事务对同一数据进行修改的影响，事务通过请求锁定数据块来达到此目的，锁有多种模式，如共享或独占 锁模式定义了事务对数据所拥有的依赖关系级别，如果某个事务已获得特定数据的锁，则其他事务不能获得会与该锁模式发生冲突的锁，如果事务请求的锁模式与已授予同一数据的锁发生冲突，则数据库引擎实例将暂停事务请求直到第一个锁释放 引入锁的机制主要是用来处理多个用户同时对数据库的并发操作时会带来以下几种数据不一致的问题（四大冲突问题） 脏读 某个事务读取的数据是另一个事务正在处理的数据，而另一个事务可能会回滚，造成第一个事务读取的数据是错误的 不可重复读 在一个事务里两次读入数据，但另一个事务已经更改了第一个事务涉及到的数据，造成第一个事务读入旧数据 幻读 幻读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行，同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据，那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样 更新丢失 多个事务同时读取某一数据，一个事务成功处理好了数据，被另一个事务写回原值，造成第一个事务更新丢失 锁模式 共享锁（S 锁） 允许并发事务在封闭式并发控制下读取 （SELECT）资源，资源上存在共享锁（S 锁）时，任何其他事务都不能修改数据 读取操作一完成，就立即释放资源上的共享锁（S 锁），除非将事务隔离级别设置为可重复读或更高级别，或者在事务持续时间内用锁定提示保留共享锁（S 锁） 更新锁（U 锁） 更新锁在共享锁和排他锁的杂交，更新锁意味着在做一个更新时，一个共享锁在扫描完成符合条件的数据后可能会转化成排他锁 这里面有两个步骤： 扫描获取 Where 条件时，这部分是一个更新查询，此时是一个更新锁 如果将执行写入更新，此时该锁升级到排他锁，否则，该锁转变成共享锁 更新锁可以防止常见的死锁 排他锁 排他锁（X 锁）可以防止并发事务对资源进行访问，排他锁不与其他任何锁兼容 使用排他锁（X 锁）时，任何其他事务都无法修改数据，仅在使用 NOLOCK 提示或未提交读隔离级别时才会进行读取操作","link":"/2018/11/04/MySQL/02/"},{"title":"字符编码","text":"这里主要介绍 ASCII，UTF-8，GBK，GB2312 和 Unicode ASCII由于计算机是美国人发明的，因此，最早只有 127 个字母被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为 ASCII 编码，比如大写字母 A 的编码是 65，小写字母 z 的编码是 122 但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和 ASCII 编码冲突 Unicode 编码因此，Unicode 应运而生，Unicode 把所有语言都统一到一套编码里，Unicode 只是一个符号集，Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求 我们常见的 UTF-8 就是 Unicode 其中一个实现方式（还有 utf-16、utf-10 等） UTF-8 编码ASCII 编码是 1 个字节，而 Unicode 编码通常是 2 个字节，如果统一成 Unicode 编码，乱码问题从此消失了 但是，如果你写的文本基本上全部是英文的话，用 Unicode 编码比 ASCII 编码需要多一倍的存储空间，在存储和传输上就十分不划算 因此，又出现了把 Unicode 编码转化为的 UTF-8 编码（可变长编码），UTF-8 编码把一个 Unicode 字符根据不同的数字大小编码成 1 - 6 个字节，常用的英文字母被编码成 1 个字节，汉字通常是 3 个字节，只有很生僻的字符才会被编码成 4 - 6 个字节 再次强调：unicode 是一种编码方式，和 ASCII 是同一个概念，而 UTF-8，UTF-16 等是一种存储方式，在存储和传输上节约空间、提高性能的一种编码形式 GBK 和 GB2312总体说来，GBK 包括所有的汉字，包括简体和繁体，而 GB2312 则只包括简体汉字 GBK 是 GB2312 的扩展，除了兼容 GB2312 外，它还能显示繁体中文，还有日文的假名","link":"/2017/12/24/Essay/01/"},{"title":"JavaScript 中的垃圾回收机制","text":"先来看看《JavaScript 权威指南》当中关于垃圾回收机制的介绍 由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配 JavaScript 程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体 只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript 的解释器将会消耗完系统中所有可用的内存，造成系统崩溃 现在各大浏览器通常用采用的垃圾回收有两种方法：标记清除、引用计数 标记清除这是 JavaScript 中最常用的垃圾回收方式 当变量进入执行环境是，就标记这个变量为 “进入环境”，从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们，当变量离开环境时，则将其标记为 “离开环境” 引用计数另一种不太常见的垃圾回收策略是引用计数（有时候会造成内存泄漏，一般发生在循环引用） 引用计数的含义是跟踪记录每个值被引用的次数，当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是 1 相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减 1 当这个引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来 这样，垃圾收集器下次再运行时，它就会释放那些引用次数为 0 的值所占的内存","link":"/2017/12/25/Essay/02/"},{"title":"Windows 下的 MySQL 安装汇总","text":"这里以 MySQL 5.6 版本为基准 下载首先进入 MySQL 官网进行下载，根据下图地址依次进入即可 点进去以后可以发现右边有一个 MySQL Community Server 5.6 » 的版本，点击进去选择对应的机器和相应版本 不需要进行登录，直接点击 No thanks, just start my download. 下载即可 下载完成之后进行解压，这里解压到 E 盘，目录文件如下所示 配置不要急着使用，先来进行配置，依次打开 计算机 ==&gt; 系统属性 ==&gt; 高级系统配置 ==&gt; 环境变量 然后选中 Path 目录，点击编辑，在末尾处追加 E:\\mysql\\bin; 即可，注意别漏了 ; 这里安装的路径为 E 盘下的 mysql，可以根据自己实际的位置进行调整 修改配置文件配置完环境变量之后先不要启动 mysql，还需要修改一下配置文件 默认的配置文件是在 E:\\mysql\\my-default.ini，可以自己再建立一个 my.ini 文件，拷贝 my-default.ini 当中的内容，然后照下图所示进行修改 安装接下来就可以进行安装了，以管理员身份运行 cmd，然后进入 E:\\mysql\\bin 目录，执行 1mysqld --install 进行安装，若无报错，则会提示安装成功，控制台会显示 Service successfully installed. 表示安装成功 如果遇到 Can't connect to MySQL server on localhost 错误，则是因为没有以管理员身份运行，重新尝试一下即可 需要注意：若之前安装过 mysql，但由于某种原因未卸载干净，当再次安装 mysql 时，会提示此服务已存在 这是可以使用 sc delete mysql 命令，删除之前的版本，再执行 mysqld –install 命令即可 启动以及登录使用 net start mysql 命令启动 mysql 服务，然后使用 mysql –u root –p 进行登录即可 需要注意，第一次登录的时候没有密码，直接回车即可","link":"/2018/03/22/MySQL/03/"},{"title":"MySQL 基本的增删改查","text":"数据库的新增和删除创建数据库 12345678// 常规方式create databse yy;// 使用 `` 避免库名（兼容性）create database `database`;// 判断数据库 yy 是否存在，如果不存在才创建此数据库，并且设定新数据库的字符集编码为 utf8 格式create database if not exists yy default character set utf8; 删除数据库12345drop database yy;drop database if exists yy;drop database if exists `yy`; 表的增删改查新建一张表12345create table if not exists y1( yid int unsigned not null auto_increment, yname varchar(30) not null, primary key(yid))engine = myisam auto_increment = 100 default charset utf8; 一些需要注意的地方 名称 解释 if not exists 如果不存在再去创建 unsigned int 分为无符号，unsigned 和有符号 signed 两种类型，默认为 signed，二者的区别就是无符号类型能保存 2 倍于有符号类型的数据 not null 表示不为空 auto_increment 自增加，比如 id 添加数据后自动变为 1234... engine 表示存储引擎，一般分为 myisam，innodb 等，MySQL 5.5 起，默认为 innodb，但是我们大部分时候都采用 myisam（若是不涉及事务的话，选用这个速度较快），innodb 一般用于事务（比如票务查询，银行业务转账），engine 中的 auto_increment 表示编号字段默认从 100 开始（上例中），即 101, 102, 103... 删除表同库的操作类似 123456drop table y1;drop table if exists y1;// 删除多个表drop table y1, y2, y3; 修改表当中的类型及字段名修改表名 这个在一般情况下使用的比较少 12345rename table y1 to y2;// &lt;===等价于==&gt;alter table y2 rename y1; 修改表结构 1234567891011121314151617181920212223242526272829// 先查看一下表结构desc y1;// ==&gt;+-------+------------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+------------------+------+-----+---------+----------------+| yid | int(10) unsigned | NO | PRI | NULL | auto_increment || yname | varchar(30) | NO | | NULL | |+-------+------------------+------+-----+---------+----------------+// 修改字段名并重新指定数据类型alter table y1 change yid userid int;alter table y1 change yname username varchar(30) not null;// 修改字段类型alter table 表名 monify 字段名 字段类型;// ==&gt;+----------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| userid | int(11) | NO | PRI | 0 | || username | varchar(30) | NO | | NULL | |+----------+-------------+------+-----+---------+-------+ 新增表结构中的字段 123456789101112131415// 新增的时候可以指定插入的位置，只需要使用 after 关键字alter table y1 add usertel varchar(20);alter table y1 add useraddress varchar(50) after username;// ==&gt;+-------------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------------+-------------+------+-----+---------+-------+| userid | int(11) | NO | PRI | 0 | || username | varchar(30) | NO | | NULL | || useraddress | varchar(50) | YES | | NULL | || usertel | varchar(20) | YES | | NULL | |+-------------+-------------+------+-----+---------+-------+ 删除表结构中的字段 1234567891011alter table y1 drop column usertel;// ==&gt;+-------------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------------+-------------+------+-----+---------+-------+| userid | int(11) | NO | PRI | 0 | || username | varchar(30) | NO | | NULL | || useraddress | varchar(50) | YES | | NULL | |+-------------+-------------+------+-----+---------+-------+ 查询表 12345678910111213141516171819202122232425// 查看表show tables;// ==&gt;+--------------+| Tables_in_yy |+--------------+| stu |+--------------+// 查看表结构desc stu;// ==&gt;+----------+---------------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+----------+---------------------+------+-----+---------+----------------+| id | int(10) unsigned | NO | PRI | NULL | auto_increment || name | varchar(30) | NO | | NULL | || age | tinyint(3) unsigned | NO | | NULL | || birthday | datetime | YES | | NULL | || address | varchar(50) | YES | | NULL | || score | decimal(4,1) | YES | | NULL | |+----------+---------------------+------+-----+---------+----------------+ 表结构的增删改查create（新增表）先建立一个新的学生表，用于后续的添加数据和查询操作 1234567891011121314151617181920212223// 新建立一个学生表create table stu( id int unsigned not null auto_increment, name varchar(30) not null, age tinyint unsigned not null, birthday datetime, address varchar(50), score decimal(4, 1), primary key(id))engine=myisam auto_increment = 201201 default charset=utf8;// ==&gt; +----------+---------------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+----------+---------------------+------+-----+---------+----------------+| id | int(10) unsigned | NO | PRI | NULL | auto_increment || name | varchar(30) | NO | | NULL | || age | tinyint(3) unsigned | NO | | NULL | || birthday | datetime | YES | | NULL | || address | varchar(50) | YES | | NULL | || score | decimal(4,1) | YES | | NULL | |+----------+---------------------+------+-----+---------+----------------+ 需要注意，关于 birthday 字段，一般不直接存储年龄，而是存储出生日期 insert （插入数据）先来进行插入一些数据，以方便一些后面的操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758insert into stu values(null, \"张三\", \"18\", \"2005-2-4\", \"bj\", \"65\");// into 可以省略（仅限 mysql 中，oracle 中不加则报错，建议全都加上）insert stu values(null, \"李四\", \"19\", \"2006-6-6\", \"sh\", \"68.5\");// 也可以一次插入多条数据insert stu values(null, \"王五\", \"20\", \"20106-7-8\", \"sz\", \"90\"), (null, \"赵六\", \"19\", \"1996-5-6\", \"gz\", \"80.5\");// 也可以只插入部分数据insert stu(name, age, score) values(\"孙七\", \"18\", \"85\"), (\"钱八\", \"22\", \"88\");// replace 插入replace into stu(name, age, score) values(\"梁九\", \"15\", \"76\"), (\"刘十\", \"26\", 95);// replace 与 insert 的区别// replace 可以插入也可以替换，在主键存在的情况下，replace 会直接替换数据replace into stu values(201206, \"真钱八\", \"28\", \"2018-08-18\", \"ss\", \"98\");// ==&gt;+--------+--------+-----+---------------------+---------+-------+| id | name | age | birthday | address | score |+--------+--------+-----+---------------------+---------+-------+| 201201 | 张三 | 18 | 2005-02-04 00:00:00 | bj | 60.0 || 201202 | 李四 | 19 | 2006-06-06 00:00:00 | sh | 60.5 || 201203 | 王五 | 20 | 0000-00-00 00:00:00 | sz | 60.5 || 201204 | 赵六 | 19 | 1996-05-06 00:00:00 | gz | 60.5 || 201205 | 孙七 | 18 | NULL | NULL | NULL || 201206 | 真钱八 | 28 | 2018-08-18 00:00:00 | ss | 98.0 || 201207 | 梁九 | 15 | NULL | NULL | NULL || 201208 | 刘十 | 26 | NULL | NULL | NULL |+--------+--------+-----+---------------------+---------+-------+// 还可以复制表，即把当前表内容复制一份在插入其中insert into stu(name, age, birthday, address, score) select name, age, birthday, address, score from stu;// ==&gt;+--------+--------+-----+---------------------+---------+-------+| id | name | age | birthday | address | score |+--------+--------+-----+---------------------+---------+-------+| 201201 | 张三 | 18 | 2005-02-04 00:00:00 | bj | 60.0 || 201202 | 李四 | 19 | 2006-06-06 00:00:00 | sh | 60.5 || 201203 | 王五 | 20 | 0000-00-00 00:00:00 | sz | 60.5 || 201204 | 赵六 | 19 | 1996-05-06 00:00:00 | gz | 60.5 || 201205 | 孙七 | 18 | NULL | NULL | NULL || 201206 | 真钱八 | 28 | 2018-08-18 00:00:00 | ss | 98.0 || 201207 | 梁九 | 15 | NULL | NULL | NULL || 201208 | 刘十 | 26 | NULL | NULL | NULL || 201209 | 张三 | 18 | 2005-02-04 00:00:00 | bj | 60.0 || 201210 | 李四 | 19 | 2006-06-06 00:00:00 | sh | 60.5 || 201211 | 王五 | 20 | 0000-00-00 00:00:00 | sz | 60.5 || 201212 | 赵六 | 19 | 1996-05-06 00:00:00 | gz | 60.5 || 201213 | 孙七 | 18 | NULL | NULL | NULL || 201214 | 真钱八 | 28 | 2018-08-18 00:00:00 | ss | 98.0 || 201215 | 梁九 | 15 | NULL | NULL | NULL || 201216 | 刘十 | 26 | NULL | NULL | NULL |+--------+--------+-----+---------------------+---------+-------+ delete（删除数据）123456789101112131415161718192021222324252627282930delete from stu where id = 201216;// ==&gt;+--------+--------+-----+---------------------+---------+-------+| id | name | age | birthday | address | score |+--------+--------+-----+---------------------+---------+-------+| 201201 | 张三 | 18 | 2005-02-04 00:00:00 | bj | 60.0 || 201202 | 李四 | 19 | 2006-06-06 00:00:00 | sh | 60.5 || 201203 | 王五 | 20 | 2008-08-08 00:00:00 | wh | 80.0 || 201204 | 赵六 | 19 | 1996-05-06 00:00:00 | gz | 60.5 || 201205 | 孙七 | 18 | NULL | NULL | NULL || 201206 | 真钱八 | 28 | 2018-08-18 00:00:00 | ss | 98.0 || 201207 | 梁九 | 15 | NULL | NULL | NULL || 201208 | 刘十 | 26 | NULL | NULL | NULL || 201209 | 张三 | 18 | 2005-02-04 00:00:00 | bj | 60.0 || 201210 | 李四 | 19 | 2006-06-06 00:00:00 | sh | 60.5 || 201211 | 王五 | 20 | 0000-00-00 00:00:00 | sz | 60.5 || 201212 | 赵六 | 19 | 1996-05-06 00:00:00 | gz | 60.5 || 201213 | 孙七 | 18 | NULL | NULL | NULL || 201214 | 真钱八 | 28 | 2018-08-18 00:00:00 | ss | 98.0 || 201215 | 梁九 | 15 | NULL | NULL | NULL |+--------+--------+-----+---------------------+---------+-------+// 无条件，删除所有记录delete from stu;// 还可以直接清空（全部删除）数据表记录，auto_increment 自动编号从 1 重新分配// 用的较少truncate table stu; update（更新数据）123456789update stu set score = 80, address = \"wh\", birthday = \"2008-08-08\" where id = 201203;// ==&gt;+--------+------+-----+---------------------+---------+-------+| id | name | age | birthday | address | score |+--------+------+-----+---------------------+---------+-------+| 201203 | 王五 | 20 | 2008-08-08 00:00:00 | wh | 80.0 |+--------+------+-----+---------------------+---------+-------+ select（查询数据）12345678910111213141516171819202122232425262728293031323334353637383940// 最基本的查询方式select * from stu;// ==&gt;// 去掉了重复的数据，然后整理更新了一下，用来查询+--------+------+-----+------------+-------+| id | name | age | birthday | score |+--------+------+-----+------------+-------+| 201209 | 张三 | 18 | 2005-02-04 | 65.0 || 201210 | 李四 | 19 | 2006-06-06 | 68.5 || 201211 | 王五 | 20 | 1995-02-06 | 90.0 || 201212 | 赵六 | 19 | 1991-03-16 | 80.5 || 201213 | 孙七 | 18 | 1992-05-06 | 85.0 || 201214 | 钱八 | 22 | 2002-12-16 | 88.0 || 201215 | 孙七 | 18 | 2008-08-08 | 85.0 || 201216 | 钱八 | 22 | 1998-08-28 | 88.0 || 201217 | 梁九 | 15 | 1988-01-02 | 76.0 || 201218 | 刘十 | 26 | 1989-11-22 | 95.0 |+--------+------+-----+------------+-------+// 只查询姓名和成绩select name, score, from stu;// ==&gt;+------+-------+| name | score |+------+-------+| 张三 | 65.0 || 李四 | 68.5 || 王五 | 90.0 || 赵六 | 80.5 || 孙七 | 85.0 || 钱八 | 88.0 || 孙七 | 85.0 || 钱八 | 88.0 || 梁九 | 76.0 || 刘十 | 95.0 |+------+-------+ 关于查询操作查询的基本条件，&lt;，&gt;，&lt;=，=&gt;，=，!=，&lt;&gt;123456789101112// 查询分数小于 80 分的select name, score from stu where score &lt; 80;// 等于 90 分的select name, score from stu where score = 90;// 省略一些// 关于 != 和 &lt;&gt; 都表示否定，还有一个 not 也表示否定select name, score from stu where score != 90;select name, score from stu where score &lt;&gt; 90;select name, score from stu where not score = 90; 范围查询，between..and123456789101112131415161718// 查询分数在 80 ~ 90 之间，注意：包含 80 和 90select name, score from stu where score between 80 and 90;// 查询分数不在 80 ~ 90 之间select name, score from stu where score not between 80 and 90;// ==&gt;+------+-------+| name | score |+------+-------+| 王五 | 90.0 || 赵六 | 80.5 || 孙七 | 85.0 || 钱八 | 88.0 || 孙七 | 85.0 || 钱八 | 88.0 |+------+-------+ 模糊查询 like（% 和 _）需要注意的是：如果查询语句中没有 like，比如 select * from stu where name = &quot;张%&quot;; 查询语句不会报错，但是 % 不再是任意符号，因为判断的是等号，不再支持通配符 12345678// _ 表示一个任意字符，比如查询名字为两个字的用户select name from stu where name like \"__\"// 查询名字为两个字的而且是姓张的select name from stu where name like \"张_\"// % 表示零个或多个字符，比如查询姓名中含有三这个字的用户select name from stu where name like \"%三%\" 基本条件 in，后面接一个限定范围12345// 查询 id 为 201209, 201210, 201208 的三条数据select * from stu where id in (201209, 201210, 201208);// 也可以使用 not in 排除这三条数据select * from stu where id not in (201209, 201210, 201208); 基本条件 null在查询的时候，比如某个字段的数据为 null 不能直接使用 = null（还有一个 is not null） 123456789101112131415161718// 不报错，但是查询为空（这个语句尽量不要出现）select * from stu where score = null;// 这个时候可以使用 is nullselect * from stu where score is null;// 然后可以批量处理这些数据，比如成绩为 null 的全部设为 0 分update stu set score = 0 where score is null;//---- 注意区分 \"\" 和 null// 这个表示查询名字为空字符串的select * from stu where name = \"\";// 这个表示查询名子没有填写的select * from stu where name is null;","link":"/2018/03/23/MySQL/04/"},{"title":"使用 Python 操作 MySQL","text":"这里默认数据库帐号为 root，密码为空，使用的数据库为 testdb 新建数据库表首先创建一个名为 testdb 的数据库，用于后续操作 12345678910111213mysql&gt; create database testdb;mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || test || testdb |+--------------------+ 然后我们就可以使用 python 来操作这个数据库了 12345678910111213141516171819202122import pymysql# 打开数据库连接，使用 cursor() 方法来得到一个游标对象db = pymysql.connect('localhost', 'root', '', 'testdb')cursor = db.cursor()# 定义需要执行的 sql 语句sql = '''create table users( first_name char(20) not null, last_name char(20), age int, sex char(1), income float)'''# 使用 execute() 方法执行 SQLcursor.execute(sql)# 关闭数据库连接db.close() 执行完该操作以后，我们就可以再次查看数据库来得到相应结果 123456789101112131415161718192021mysql&gt; use testdb;mysql&gt; show tables;+------------------+| Tables_in_testdb |+------------------+| users |+------------------+mysql&gt; desc users;+------------+----------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+------------+----------+------+-----+---------+-------+| first_name | char(20) | NO | | NULL | || last_name | char(20) | YES | | NULL | || age | int(11) | YES | | NULL | || sex | char(1) | YES | | NULL | || income | float | YES | | NULL | |+------------+----------+------+-----+---------+-------+ 插入数据使用 python 来执行数据插入操作 12345678910111213141516171819202122import pymysql# 打开数据库连接，使用 cursor() 方法来得到一个游标对象db = pymysql.connect('localhost', 'root', '', 'testdb')cursor = db.cursor()# 定义需要执行的 sql 语句sql = '''insert into users values('AAA', 'aaaaa', '22', 'M', 2000)'''try: # 执行 SQL 语句 cursor.execute(sql) # 提交到数据库执行 db.commit()except: # 如果发生错误，则执行回滚操作 db.rollback()# 关闭数据库连接db.close() 执行完成以后可以进入到数据库中来进行查看 1234567mysql&gt; select * from users;+------------+-----------+------+------+--------+| first_name | last_name | age | sex | income |+------------+-----------+------+------+--------+| AAA | aaaaa | 22 | M | 2000 |+------------+-----------+------+------+--------+ 然后我们使用同样的方式多插入几条数据，以便用于后面的查询操作，最后结果如下 12345678+------------+-----------+------+------+--------+| first_name | last_name | age | sex | income |+------------+-----------+------+------+--------+| AAA | aaaaa | 22 | M | 2000 || AAA | aaaaa | 21 | M | 2200 || BBB | bbbbb | 26 | M | 4000 || CCC | ccccc | 28 | M | 6000 |+------------+-----------+------+------+--------+ 数据库查询操作python 查询数据库主要会用到两个方法，使用 fetchone() 方法来获取单条数据, 使用 fetchall() 方法获取多条数据 fetchone(): 该方法获取下一个查询结果集，结果集是一个对象 fetchall(): 接收全部的返回结果行 rowcount: 这是一个只读属性，并返回执行 execute() 方法后影响的行数 比如我们来查询收入大于等于 2200 的所有数据 123456789101112131415161718192021222324252627import pymysql# 打开数据库连接，使用 cursor() 方法来得到一个游标对象db = pymysql.connect('localhost', 'root', '', 'testdb')cursor = db.cursor()# 定义需要执行的 sql 语句sql = '''select * from users where income &gt;= 2200'''try: # 执行 SQL 语句 cursor.execute(sql) # 获取所有的记录列表 results = cursor.fetchall() # 循环打印 for row in results: print(\"fname=%s,lname=%s,age=%d,sex=%s,income=%d\" % (row[0], row[1], row[2], row[3], row[4] ))except: # 如果发生错误，则抛出一个错误 print (\"Error: unable to fetch data\")# 关闭数据库连接db.close() 执行以后可以看到控制台输出 123fname=AAA,lname=aaaaa,age=21,sex=M,income=2200fname=BBB,lname=bbbbb,age=26,sex=M,income=4000fname=CCC,lname=ccccc,age=28,sex=M,income=6000 数据库更新操作更新操作用于更新数据表的的数据，以下实例将 TESTDB 表中 收入大于等于 2200 数据的 AGE 字段递增 1 12345678910111213141516171819202122import pymysql# 打开数据库连接，使用 cursor() 方法来得到一个游标对象db = pymysql.connect('localhost', 'root', '', 'testdb')cursor = db.cursor()# 定义需要执行的 sql 语句sql = '''update users set age = age + 1 where income &gt;= 2200'''try: # 执行 SQL 语句 cursor.execute(sql) # 提交到数据可 db.commit()except: # 否则执行回滚操作 db.rollback()# 关闭数据库连接db.close() 查询后可以看到结果 12345678910mysql&gt; select * from users;+------------+-----------+------+------+--------+| first_name | last_name | age | sex | income |+------------+-----------+------+------+--------+| AAA | aaaaa | 22 | M | 2000 || AAA | aaaaa | 22 | M | 2200 || BBB | bbbbb | 27 | M | 4000 || CCC | ccccc | 29 | M | 6000 |+------------+-----------+------+------+--------+ 数据库删除操作删除操作用于删除数据表中的数据，以下实例将删除 TESTDB 表中 收入小于 2200 的记录 1234567891011121314151617181920import pymysql# 打开数据库连接，使用 cursor() 方法来得到一个游标对象db = pymysql.connect('localhost', 'root', '', 'testdb')cursor = db.cursor()# 定义需要执行的 sql 语句sql = \"delete from users where income &lt; '%d'\" % (2200)try: # 执行 SQL 语句 cursor.execute(sql) # 提交到数据可 db.commit()except: # 否则执行回滚操作 db.rollback()# 关闭数据库连接db.close() 查询后可以看到结果 123456789mysql&gt; select * from users;+------------+-----------+------+------+--------+| first_name | last_name | age | sex | income |+------------+-----------+------+------+--------+| AAA | aaaaa | 22 | M | 2200 || BBB | bbbbb | 27 | M | 4000 || CCC | ccccc | 29 | M | 6000 |+------------+-----------+------+------+--------+ 执行事务事务机制可以确保数据一致性，事务应该具有四个属性：原子性、一致性、隔离性、持久性（通常称为 ACID 特性） 原子性（atomicity）：一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做 一致性（consistency）：事务必须是使数据库从一个一致性状态变到另一个一致性状态，一致性与原子性是密切相关的 隔离性（isolation）：一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰 持久性（durability）：持续性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的，接下来的其他操作或故障不应该对其有任何影响 Python DB API 的事务提供了两个方法 commit 和 rollback 123456789# ...try: # 执行SQL语句 cursor.execute(sql) # 向数据库提交 db.commit()except: # 发生错误时回滚 db.rollback() 对于支持事务的数据库，在 Python 数据库编程中，当游标建立之时，就自动开始了一个隐形的数据库事务 commit() 方法游标的所有更新操作，rollback() 方法回滚当前游标的所有操作，每一个方法都开始了一个新的事务 错误处理DB API 中定义了一些数据库操作的错误及异常 异常 描述 Warning 当有严重警告时触发，例如插入数据是被截断等等，必须是 StandardError 的子类 Error 警告以外所有其他错误类，必须是 StandardError 的子类 InterfaceError 当有数据库接口模块本身的错误（而不是数据库的错误）发生时触发， 必须是 Error 的子类 DatabaseError 和数据库有关的错误发生时触发， 必须是 Error 的子类 DataError 当有数据处理时的错误发生时触发，例如：除零错误，数据超范围等等， 必须是 DatabaseError 的子类 OperationalError 指非用户控制的，而是操作数据库时发生的错误，例如：连接意外断开、 数据库名未找到、事务处理失败、内存分配错误等等操作数据库是发生的错误， 必须是 DatabaseError 的子类 IntegrityError 完整性相关的错误，例如外键检查失败等，必须是 DatabaseError 子类 InternalError 数据库的内部错误，例如游标（cursor）失效了、事务同步失败等等， 必须是 DatabaseError 子类 ProgrammingError 程序错误，例如数据表（table）没找到或已存在、SQL 语句语法错误、 参数数量错误等等，必须是 DatabaseError 的子类 NotSupportedError 不支持错误，指使用了数据库不支持的函数或 API 等，例如在连接对象上 使用 rollback() 函数，然而数据库并不支持事务或者事务已关闭，必须是 DatabaseError 的子类","link":"/2018/03/29/MySQL/05/"},{"title":"Sequelize 与 MySQL","text":"MySQL 安装过程就略过了，推荐安装 5.6 版本，安装见 Windows 下的 MySQL 安装汇总 基于 koa.js，相关源码可以见 koa-Sequelize 访问 MySQL当安装好了 MySQL 以后，访问 MySQL 数据库只有一种方法，就是通过网络发送 SQL 命令，MySQL 服务器执行后返回结果 启动和关闭方式如下 启动 MySQL 服务 net start mysql 关闭 MySQL 服务 net stop mysql 退出 MySQL 命令行 exit 可以使用 mysql -u root -p 来连接本地数据库（没有指定 --host 参数，所以我们连接到的是 localhost） 12345678// 注意有个分号mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema |+--------------------+1 row in set (0.00 sec) 对于 Node.js 程序，访问 mysql 也是通过网络发送 sql 命令给 mysql 服务器（通常称为 mysql 驱动程序） ORM在使用 Node.js 来处理关系型操作数据库时，为了方便，通常都会选择一个合适的 ORM（Object Relationship Model）框架，毕竟直接操作 SQL 比较繁琐，通过 ORM 框架，我们可以使用面向对象的方式来操作表，这里主要介绍 Sequelize 更多关于 Sequelize 内容可参考 Sequelize 选择 Sequelize 的原因：只要 API 返回 promise，就可以用 await 调用 用 Sequelize 查询 pets 表12345678// 因为 Sequelize 返回的对象是 Promise，所以我们可以用 then() 和 catch() 分别异步响应成功和失败Pet.findAll().then(function (pets) { for (let pet in pets) { console.log(`${pet.id}: ${pet.name}`) }}).catch(function (err) { // err}) 可以改用 ES7 的 await() 来调用 1var pets = await Pet.findAll(); 但是 await 有一个限制，必须在 async 函数中调用，所以修改为 123(async () =&gt; { var pets = await Pet.findAll()})(); 实战我们可以在 test 数据库中创建一个 pets 表： 1234567891011121314grant all privileges on test.* to 'root'@'%' identified by 'root';use test;create table pets ( id varchar(50) not null, name varchar(100) not null, gender bool not null, birth varchar(10) not null, createdAt bigint not null, updatedAt bigint not null, version bigint not null, primary key (id)) engine=innodb; 第一条 grant 命令是创建 mysql 的用户名和口令，并赋予操作 test 数据库的所有权限 第二条 use 命令把当前库切换为 test 创建 pets 表 然后新建 config.js 用以配置 mysql 123456789var config = { database: 'test', // 使用的数据库名 username: 'root', password: 'root', host: 'localhost', // 主机名 port: 3306 // mysql 默认 3306}module.exports = config; 下面就可以在 app.js 中操作数据库了，在操作之前需要两件准备工作 第一步，创建一个 sequelize 对象实例 123456789101112const Sequelize = require('sequelize');const config = require('./config');var sequelize = new Sequelize(config.database, config.username, config.password, { host: config.host, dialect: 'mysql', pool: { max: 5, min: 0, idle: 30000 }}); 第二步，定义模型 Pet，告诉 Sequelize 如何映射数据库表 1234567891011121314var Pet = sequelize.define(\"pet\", { id: { type: Sequelize.STRING(50), primaryKey: true }, name: Sequelize.STRING(100), gender: Sequelize.BOOLEAN, birth: Sequelize.STRING(10), createdAt: Sequelize.BIGINT, updatedAt: Sequelize.BIGINT, version: Sequelize.BIGINT}, { timestamps: false }); 使用 sequelize.define() 定义 model 的时候，传入 pet，默认的表名就是 pets 第二个参数指定列名和数据类型，如果是主键，需要更详细的指定 第三个参数是额外配置，我们传入 {timestamps: false } 是为了关闭 Sequelize 的自动添加 timestamp 功能（自动化） 然后添加数据，有两种方式，第一种是使用 promise： 123456789101112131415var now = Date.now();Pet.create({ id: \"g-\" + now, name: \"abc\", gander: false, birth: \"2002-02-02\", createdAt: now, updatedAt: now, version: 0}).then(function (p) { console.log(`created:` + JSON.stringify(p))}).catch(function (err) { console.log(`err: ` + err)}) 第二种方式是使用 await： 123456789101112(async () =&gt; { var dog = await PageTransitionEvent.create({ id: 'd-' + now, name: 'def', gender: false, birth: '2003-03-03', createdAt: now, updatedAt: now, version: 0 }) console.log(`created: ` + JSON.stringify(dog))})(); 查询数据1234567891011(async () =&gt; { var pets = await pets.findAll({ where: { name: \"abc\" } }); console.log(`find ${pets.length} pets`); for (let p of pets) { console.log(JSON.stringify(p)); }})() 更新数据1234567(async () =&gt; { var p = await queryFromSomewhere(); p.gender = true; p.updatedAt = Date.now(); p.version ++; await p.save();})() 删除数据1234(async () =&gt; { var p = await queryFromSomewhere(); await p.destory();})() model我们把通过 sequelize.define() 返回的 Pet 称为 Model，它表示一个数据模型 通过 Pet.findAll() 返回的一个或一组对象称为 Model 实例，每个实例都可以直接通过 JSON.stringify 序列化为 JSON 字符串，只是多了一些由 Sequelize 添加的方法，比如 save()（更新） 和 destory()（删除） 步骤总结如下 通过某个 model 对象的 findAll() 方法获取实例 如果要更新实例，先对实例属性赋予新值，在调用 save() 方法 如果要删除实例，直接调用 destory() 方法 需要注意的是：findAll() 方法可以接收 where，order这些参数，这和将要生成的 SQL 语句是对应的","link":"/2018/03/31/MySQL/06/"},{"title":"Git 基本操作","text":"小贴士：使用 git help log / add / commit... 可以查看相关命令的操作方式 安装/初始化安装过程就省略了，官网直接下载，直接下一步下一步就行，没有什么特别需要注意的地方，安装完成后首先需要设置用户和地址 123git config --global user.name 'name'git congig --global user.email 'email' 然后新建一个文件夹用作 git 仓库，再初始化这个 git 仓库 12345git init // 初始化pwd // 显示当前目录ls // 显示当前目录文件 然后添加文件到 git 仓库 123git add 文件名 // 添加文件，可以反复添加多次git commit -m '描述' // 提交文件到仓库 git add 的各种区别123456789101112131415161718git add -A // 添加所有改动git add * // 添加新建文件和修改，但是不包括删除git add . // 添加新建文件和修改，但是不包括删除git add -u // 添加修改和删除，但是不包括新建文件// 在 commit 前撤销 add:git reset &lt;file&gt; // 撤销提交单独文件git reset // unstage all due changes// add / commit 前撤销对文件的修改:git checkout -- README.md // 注意, add 添加后(同 commit 提交后)就无法通过这种方式撤销修改 版本管理查看工作区状态使用 1git status // 查看工作区状态 如果出现如下警告： 12warning: CRLF will be replaced by LF in readme.txt.The file will have its original line endings in your working directory. 可以使用： 1git config core.autocrlf false 至于出现原因，详细见：git 如何避免 ‘warning: LF will be replaced by CRLF’ 提示？ 提交前的时候可以查看具体修改了哪些内容，使用 12345678git diff // 工作区 和 暂存区 的比较git diff --cached // 暂存区 和 分支 的比较// 还有下面这个// HEAD 参数是可变的，也就是可以将工作区的内容与版本库里指定的任意版本比较// 比如 git diff 345et6 --&lt;file&gt;git diff HEAD --&lt;file&gt; 版本回退可以使用 git log 命令来查看历史记录 1git log 如果感觉输出信息太多，可以使用 --pretty=oneline 参数（使其一行显示） 1git log --pretty=oneline 回退到上一个版本，使用 reset 命令 1git reset --hard HEAD^ 如果回退到前两个版本，可以使用 HEAD^^ 或者 Head~2，依次类推 123git reset --hard Head^^git reset --hard HEAD~2 如果回退版本后，在使用 git log 后就查看不到之前最新版本的信息了 这个时候可以使用下面命令指定回到之前某个版本（4cda21 这个就是之前使用 git log 查看的版本号，只需要前面几位即可，git 会去自动查找） 1git reset --hard 4cda21 但是如果找不到之前的版本号，可以使用下面命令来查看提交过的每一次命令 1git reflog 小小总结 回退/更新 到指定的版本，使用 git reset --hard commit_id 回退前，使用 git log 向跳转到指定版本，使用 git reflog 查看历史提交记录，确定跳转版本 工作区和暂存区简单来说，就是先提交修改的文件到暂存区，然后再一次性提交暂存区的所有修改 add 的作用就是把工作区的更新到暂存区，而 commit 则是把缓冲区更新到仓库 把文件往 git 仓库中添加的时候，是分两步执行的： 首先使用 git add 把文件添加进去，实际上就是把文件修改添加到暂存区 然后使用 git commit 提交修改，实际上就是把暂存区的所有文件提交到当前分支 因为我们在创建 git 版本库的时候，git 自动为我们创建了唯一一个 master 分支，所以， git commit 就是往 master 分支上提交更改 需要注意的是：如果修改文件后，没有使用 git add 将修改放入暂存区，那么在 commit 的时候只会把暂存区的修改提交 简单总结就是：每次修改不 add 到暂存区，就不会加入到 commit 中 撤销修改主要使用下面这两个命令 12345678// 撤销对工作区修改// 这个命令是以最新的存储时间节点（add 和 commit）为参照，覆盖工作区对应文件 file// 这个命令改变的是工作区git checkout -- file// 清空 add 命令向暂存区提交的关于 file 文件的修改（Ustage）// 这个命令仅改变暂存区，并不改变工作区，这意味着在无任何其他操作的情况下，工作区中的实际文件同该命令运行之前无任何变化git reset HEAD -- file 在没有推送到远程仓库之前的撤销主要分为以下几种： 修改了文件，想直接撤销（这个时候还没有 add），使用 git checkout -- file 修改了文件，但是又 add 到了暂存区，这个时候想放弃修改，可以使用 git reset HEAD file 可以把暂存区的修改撤销掉 如果已经 commit，想要撤销修改，这个时候就可以使用版本回退（git reset --hard HEAD^） 一个额外的需求，希望彻底的舍弃本地未 push 的 commit 因为通过像 git reset 这样的操作，如果 push 了远程仓库是看不到被你舍弃的 commit 但是在本地还是可以通过 reflog 来找到，解决办法就是： 这个时候就需要先 reset，然后 push，再去把本地的库删掉，重新 clone 即可 删除修改一般情况，可以直接在文件管理器中把没用的文件删了，或者使用 rm 命令： 1rm test.html 这个时候分为两种情况： 一个就是确定要删除文件 123456// 确认删除// 也可以直接使用这个命令，包含了上面的 rm 操作git rm test.html// 然后提交git commit 另外一个就是如果删错了，可以使用 checkout 撤销修改 1git checkout -- test.html 如果删除后想恢复，需要注意的是会丢失最后一次提交后修改的内容（即修改了以后没有提交直接删除的话，会丢失掉修改的内容） 分支管理我们每次提交，git 都会把它们串成一条时间线，这条时间线就是一个分支，即 master HEAD 严格来说不是指向提交，而是指向 master，master 才是指向提交的，所以 HEAD 指向的就是当前分支 1234 master -- HEAD | |○ -- ○ -- ○ &lt;== 主分支（master） 每次提交，master 分支都会向前移动一步 1234 master -- HEAD | |○ -- ○ -- ○ -- ○ &lt;== 主分支（master） 当我们创建新的分支，比如名称为 test，这个时候 git 会新建了一个名为 test 的指针指向 master 相同的提交 然后再把 HEAD 指向 test，表示当前分支在 test 上 1234567 master | |○ -- ○ -- ○ -- ○ &lt;== 主分支（master） | | test -- HEAD 这个时候开始，对于工作区的修改和提交都是针对 test 分支了，每提交一次，test 分支就前进一步，而 master 保持不变 1234567 master | |○ -- ○ -- ○ -- ○ -- ○ -- ○ &lt;== 主分支（master） | | test -- HEAD 当 test 分支上的工作完成以后，就可以直接把 master 指向 test，即把 test 合并到 master 上，这样就完成了合并 1234567 master -- HEAD | |○ -- ○ -- ○ -- ○ == ○ == ○ &lt;== 主分支（master） | | test 合并完成后，可以选择删除掉 test 分支，这样就仅剩一条 master 分支了 1234 master -- HEAD | |○ -- ○ -- ○ -- ○ == ○ == ○ &lt;== 主分支（master） 操作分支首先创建并切换到 test 分支 12// 创建并切换到 test 分支，-b 命令表示创建并且切换git checkout -b test 相当于下面两条命令 123git branch test git checkout test // 切换分支 使用下面命令可以查看当前分支，并且会列出所有的分支，当前分支前面会标一个 * 号 1git branch 这个时候修改文件，然后 add 和 commit 以后在切换回 master 分支会发现看不到我们修改的内容，因为这一次的提交是在 test 分支上 此时状态如下 1234567891011121314151617git add test.txtgit commit -m 'xxx'git checkout mastergit branch// --------------------------------------------- master -- HEAD | |○ -- ○ -- ○ -- ○ -- ○ == ○ &lt;== 主分支（master） | | test 这个时候就需要合并分支了 1git merge test // 用于合并 指定的分支 到 当前的分支 合并之后再次查看文件内容就会发现，现在 master 分支和 test 分支最新提交是完全一样的了 需要注意控制台当中的 Fast-forward 提示，指的是这次合并是 ‘快进模式’，即直接把 master 指向 test 当前的提交 这时候就可以放心删除 test 分支了 1git baranch -d test 分支操作总结如下： 1234567891011git branch // 查看分支git branch &lt;name&gt; // 创建分支git checkout &lt;name&gt; // 切换分支git branch -b &lt;name&gt; // 创建 + 切换 分支git merge &lt;name&gt; // 合并某分支到当前分支 git barnch -d &lt;name&gt; // 删除分支 冲突解决如果在发生合并的时候发生冲突，类似下面： 1234$ git merge test1Auto-merging test.txtCONFLICT (content): Merge conflict in test.txtAutomatic merge failed; fix conflicts and then commit the result. 这个时候就需要手动解决冲突以后再次提交，使用 git status 命令可以告诉我们冲突的文件： 12345# ...## both modified: test.txt## ... git 使用 &lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt; 标记出不同分支的内容，修改以后在保存提交 123git add test.txtgit commit -m 'xxxxx' 合并完成后就可以删除掉 test1 分支了 使用 git log --graph 命令可以查看分支合并图 在手动修改冲突文件以后（其实不改也行就是确认一下），再次 add and commit，系统就确认那个是最新（merge 后）的版本了 分支管理一般在合并分支的时候，git 会默认优先使用 Fast forward 模式，但这种模式下删除分支后，会丢掉分支信息 这个时候就可以使用 --no-ff 参数，这时的 git 会在 merge 的时候生成一个新的 commit 记录，这样一来就可以从分支历史上看到所有的分支信息了 123// --no-ff 参数，表示禁用 Fast forward// 又因为合并要创建一个新的 commit，所以加上 -m 参数，把描述写进去git merge --no-ff -m 'msg' test Bug 分支在 git 中，每个 bug 都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除 但是如果手头上的工作还没有完成，还没法提交，这个时候就可以用到 stash 功能，可以把工作区临时 ‘储存’ 起来，等 bug 修改完毕了在来继续工作 解决完 bug 之后，可以使用 git stash list 来查看之前储存的工作区 想要恢复有两种方式 一种是使用 git stash apply 来恢复，但是恢复后，stash 内容并没有删除，需要再次使用 git stash drop 来删除 另外一种是使用 git stash pop，在恢复的同时把 stash 的内容也删除了 这个时候再用 git stash list 查看，就看不到任何 stash 内容了 简单来说就是： 在分支 test 正常开发，这时有一个 bug 需要解决，需要先把 test 分支储存起来（stash） 在 master 下新建一个 issue-bug01 分支，解决 bug，成功后在 master 下合并 issue-bug01 然后在 test 下合并 master，这样才会同步里面的 bug 解决方案 然后恢复 test（stash pop），这时系统自动合并，会提示有冲突，因为储存了之前 test 中的东西，此时需要手动去解决冲突 冲突解决完成后，继续开发 test，最后 add commit，最后的最后，在 master 下合并完成后的 test 分支 123456789101112131415161718192021222324252627282930313233343536373839// 当前正在 test 分支开发，需要 bug 先保存起来git stash// 去 master 分支建立 bug 分支git checkout mastergit checkout -b issue-bug01// 然后去修改 buggit add xxx / git commit -m 'xxxx'// master 合并git checkout mastergit merge --no-ff -m 'merge-issue-bug01' issue-bug01// test 合并git checkout testgit merge --no-ff -m 'merge-test' mastergit stash pop// 这时会提示冲突，去文件手动改正# Auto-merging xxx# CONFLICT (content): Merge conflict in xxx// 完成后继续开发分支 testgit add xxxgit comit -m 'xxx'// 分支完成后合并git checkout mastergit merge --no-ff -m 'merge-test' test// 最后删除分支git branch -d test 多人协作工作模式通常是这样： 首先可以试图使用 git push origin branch-name 推送自己的修改 如果推送失败，则因为远程分支比你的本地更新，需要先用 git pull 拉取最新版本（如果有冲突，则解决冲突，并在本地提交） 没有冲突或者解决掉冲突后，再用 git push origin branch-name 推送就能成功 如果 git pull 提示 no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令 git branch --set-upstream branch-name origin/branch-name 标签管理创建标签1234567891011121314151617// 创建标签，默认是打在最新的 commit 上git tag &lt;name&gt; // git tag v1.0// 查看所有标签git tag // 如果之前忘记打标签git tag &lt;name&gt; &lt;commit_id&gt; // git tag v0.9 0e3s452// 标签不是按时间顺序排列的，而是按字母顺序// 查看标签信息git show &lt;tag_name&gt; // git show v0.9// 还可以创建带有说明的标签，-a 指定标签名，-m 指定说明文字git tag -a v0.9 -m 'xxxx' 标签操作12// 删除标签git tag -d v1.0 默认创建的标签只会存储在本地，不会自动推送到远程，所以，打错的标签可以在本地安全删除 如果要推送标签 12345// 推送标签到远程git push origin &lt;tagname&gt; // git push origin v1.0// 或者一次性的推送全部尚未推送到远程的本地标签git push origin --tags 如果标签已经推送到远程，还是想要删除的话： 12345// 需要先从本地删除git tag -d v1.0// 然后再从远程删除，删除的命令也是 push，格式如下git push origin :refs/tags/v1.0","link":"/2017/12/29/Essay/03/"},{"title":"利用 pipe 实现复制","text":"Node.js 的 fs 模块并没有提供一个 copy 的方法，但我们可以很容易的实现一个，比如 123var source = fs.readFileSync('/path/to/source', { encoding: 'utf8' });fs.writeFileSync('/path/to/dest', source); 这种方式是把文件内容全部读入内存，然后再写入文件，对于小型的文本文件，这没有多大问题，比如 grunt-file-copy 就是这样实现的 但是对于体积较大的二进制文件，比如音频、视频文件，动辄几个 GB 大小，如果使用这种方法，很容易使内存爆仓 理想的方法应该是读一部分，写一部分，不管文件有多大，只要时间允许，总会处理完成，这里就需要用到流的概念 1234567891011121314var fs = require('fs');var readStream = fs.createReadStream('/path/to/source');var writeStream = fs.createWriteStream('/path/to/dest');// 当有数据流出时，写入数据readStream.on('data', function (chunk) { writeStream.write(chunk);});// 当没有数据时，关闭数据流readStream.on('end', function () { writeStream.end();}); 上面的写法有一些问题，如果写入的速度跟不上读取的速度，有可能导致数据丢失 正常的情况应该是，写完一段，再读取下一段，如果没有写完的话，就让读取流先暂停，等写完再继续，于是代码可以修改为 12345678910111213141516171819202122var fs = require('fs');var readStream = fs.createReadStream('/path/to/source');var writeStream = fs.createWriteStream('/path/to/dest');// 当有数据流出时，写入数据readStream.on('data', function (chunk) { // 如果没有写完，暂停读取流 if (writeStream.write(chunk) === false) { readStream.pause(); }});// 写完后，继续读取writeStream.on('drain', function () { readStream.resume();});// 当没有数据时，关闭数据流readStream.on('end', function () { writeStream.end();}); 或者使用更直接的 pipe 12// pipe 自动调用了 data, end 等事件fs.createReadStream('/path/to/source').pipe(fs.createWriteStream('/path/to/dest')); 下面是一个完整的复制文件的过程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253var fs = require('fs'), path = require('path'), out = process.stdout;var filePath = '../小电影.mkv';var readStream = fs.createReadStream(filePath);var writeStream = fs.createWriteStream('file.mkv');var stat = fs.statSync(filePath);var totalSize = stat.size;var passedLength = 0;var lastSize = 0;var startTime = Date.now();readStream.on('data', function (chunk) { passedLength += chunk.length; if (writeStream.write(chunk) === false) { readStream.pause(); }});writeStream.on('drain', function () { readStream.resume();});readStream.on('end', function () { writeStream.end();});setTimeout(function show() { var percent = Math.ceil((passedLength / totalSize) * 100); var size = Math.ceil(passedLength / 1000000); var diff = size - lastSize; lastSize = size; out.clearLine(); out.cursorTo(0); out.write('已完成' + size + 'MB, ' + percent + '%, 速度：' + diff * 2 + 'MB/s'); if (passedLength &lt; totalSize) { setTimeout(show, 500); } else { var endTime = Date.now(); console.log(); console.log('共用时：' + (endTime - startTime) / 1000 + '秒。'); }}, 500);","link":"/2017/10/17/Node/07/"},{"title":"迭代协议与生成器","text":"对集合中每个元素进行处理是很常见的操作，比如数组遍历、对象的属性遍历，以往这些操作是通过 for 循环、.forEach、.map 等方式进行 借由迭代器机制为 Map、Array、String 等对象提供了统一的遍历语法，以及更方便的相互转换 为方便编写迭代器还提供了生成器（Generator）语法，迭代器和生成器将迭代的概念直接带入核心语言，并提供了一种机制来自定义 for...of 循环的行为 我们先来看看可迭代协议和迭代器协议 可迭代协议可迭代协议允许 JavaScript 对象去定义或定制它们的迭代行为，例如在一个 for..of 结构中什么值可以被循环 一些内置类型都是内置的可迭代类型并且有默认的迭代行为，比如 Array 或者 Map，另一些类型则不是（比如 Object） 为了变成可迭代对象，一个对象必须实现 @@iterator 方法，意思是这个对象（或者它原型链上的某个对象）必须有一个名字为 Symbol.iterator 的属性 简单来说， 将 [Symbol.iterator] 属性定义为一个迭代器对象即可实现该协议 而 Iterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即 for...of 循环 当使用 for...of 循环遍历某种数据结构时，它会首先调用被遍历集合对象的 Symbol.iterator() 方法，该方法返回一个迭代器对象 迭代器对象可以是拥有 .next() 方法的任何对象，然后在 for...of 的每次循环中，都将调用该迭代器对象上的 .next() 方法 ES6 规定，默认的 Iterator 接口部署在数据结构的 Symbol.iterator 属性 或者说，一个数据结构只要具有 Symbol.iterator 属性，就可以认为是可迭代的（iterable） Symbol.iterator 属性本身是一个函数，就是当前数据结构默认的遍历器生成函数，执行这个函数，就会返回一个遍历器 1234567891011// 数组直接调用 Symbol.iterator 这个接口，这个接口是数组内部已经帮我们实现了的，我们直接调用即可let arr = ['hello', 'world'];let map = arr[Symbol.iterator]();console.log(map.next());console.log(map.next());console.log(map.next());// Object {value: 'hello', done: false}// Object {value: 'world', done: false}// Object {value: undefined, done: true} 迭代器协议又称生成器协议，该协议定义了什么是迭代器对象，迭代器协议定义了一种标准的方式来产生一个有限或无限序列的值 并且当所有的值都已经被迭代后，就会有一个默认的返回值 迭代器（Iterator）就是这样一种机制，它是一种接口，为各种不同的数据结构提供统一的访问机制，任何数据结构只要部署 Iterator 接口，就可以完成遍历操作 Iterator 的作用有三个 为各种数据结构，提供一个统一的、简便的访问接口 使得数据结构的成员能够按某种次序排列 ES6 创造了一种新的遍历命令 for...of 循环，Iterator 接口主要供 for...of 消费 简单来说，只需要实现 .next() 方法，该方法必须要返回一个对象，被返回对象拥有两个属性（如果返回一个非对象值，则需要抛出一个错误） done - 布尔值，如果为 true，则表示迭代器已经超过了可迭代次数，在这种情况下 value 的值可以被省略，如果迭代器可以产生序列中的下一个值，则为 false value - 迭代器可以返回的任何 JavaScript 值，在 done 为 true 的时候可省略 基本语法为 123456var myIterator = { next: function () { // ... }, [Symbol.iterator]: function () { return this }} 使用迭代协议的实例比如 String，就是一个内置的可迭代对象 123var str = 'hi'typeof str[Symbol.iterator] // 'function' String 的默认迭代器会一个接一个返回该字符串的字符 123456const str = 'hi'const iterator = str[Symbol.iterator]();iterator.next() // {value: 'h', done: false}iterator.next() // {value: 'i', done: false}iterator.next() // {value: undefined, done: true} 我们也可以通过自己的 @@iterator 方法重新定义迭代行为 1234567891011121314151617181920var str = new String('hi')str[Symbol.iterator] = function () { return { next: function () { if (this._first) { this._first = false return { value: 'hello', done: false } } else { return { done: true } } }, _first: true }}for (let i of str) { // hello console.log(i)} 在对象上实现 Iterator 接口String，Array，TypedArray，Map 和 Set 是所有内置可迭代对象，因为它们的原型对象都有一个 @@iterator 方法 那么这里存在一个问题，为什么对象（Object）没有部署 Iterator 接口呢？ 有两个原因 一是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定，然而遍历遍历器是一种线性处理，对于非线性的数据结构，部署遍历器接口，就等于要部署一种线性转换 二是对对象部署 Iterator 接口并不是很必要，因为 Map 弥补了它的缺陷，又正好有 Iteraotr 接口 但是我们可以手动的为对象添加一个 Iterator 接口，不过需要注意的就是 如果一个对象要具备可被 for...of 循环调用的 Iterator 接口，就必须在 Symbol.iterator 的属性上部署遍历器生成方法，比如一个实现 50 以内的斐波那契数列的示例 12345678910111213141516171819202122232425let obj = { [Symbol.iterator]: function () { let a = 0, b = 0 return { next: function () { let value = 0 if (!a) { value = a = 1 } else if (!b) { value = b = 1 } else if (b &lt; 50) { value = a + b a = b b = value } return { done: value === 0, value } } } }}for (let i of obj) { // 1 1 2 3 5 8 13 21 34 55 console.log(i)} 生成器对象生成器对象是由一个 Generator 函数（function*）返回的，并且它符合可迭代协议和迭代器协议 12345678910function* g() { yield 1; yield 2;}var iterator = g();iterator.next(); // { value: 1, done: false }iterator.next(); // { value: 2, done: false }iterator.next(); // { value: undefined, done: true } 生成器函数在执行时能暂停，后面又能从暂停处继续执行 调用一个生成器函数并不会马上执行它里面的语句，而是返回一个这个生成器的迭代器（iterator）对象 当这个迭代器的 next() 方法被首次调用时，其内的语句会执行到第一个出现 yield 的位置为止，yield 后紧跟迭代器要返回的值，或者如果用的是 yield*（有星号） 则表示将执行权移交给另一个生成器函数（当前生成器暂停执行） next() 方法返回一个对象，这个对象包含两个属性 value 和 done value 属性表示本次 yield 表达式的返回值 done 属性为布尔类型，表示生成器后续是否还有 yield 语句，即生成器函数是否已经执行完毕并返回 这里有一个需要注意的地方，如果在生成器函数当中使用了 return ，会立即结束执行，done 会立即变为 true 1234567891011function* g() { yield 1; return 2; yield 2;}var iterator = g();iterator.next(); // { value: 1, done: false }iterator.next(); // { value: 2, done: true }iterator.next(); // { value: undefined, done: true } 在调用 next() 方法的时候，如果传入了参数，那么这个参数会作为上一条执行的 yield 语句的返回值 12345678910111213function* g() { let first = yield 1; let second = yield first + 2; // 10 + 2，first 的值是由 next(10) 传递的 yield second + 3; // 5 + 3，需要注意的是，如果在调用的时候不传递参数，则会返回 // { value: NaN, done: false }}let iterator = g();iterator.next() // { value: 1, done: false }iterator.next(10) // { value: 12, done: false }iterator.next(5) // { value: 8, done: false }iterator.next() // { value: undefined, done: true } 现在可以使用生成器方法重新实现之前的的斐波那契数列示例 12345678910111213141516let obj = { [Symbol.iterator]: function* () { let a = 1, b = 1 yield a yield b while (b &lt; 50) { yield b = a + b a = b - a } }}for (let i of obj) { // 1 1 2 3 5 8 13 21 34 55 console.log(i)} yield*yield* 表达式用于委托给另一个 Generator 或可迭代对象，下面是一个基本的示例 12345678910111213141516function* g1() { yield 2;}function* g2() { yield 1; yield* g1(); yield 3;}var iterator = g2();iterator.next() // { value: 1, done: false }iterator.next() // { value: 2, done: false }iterator.next() // { value: 3, done: false }iterator.next() // { value: undefined, done: true } 除了生成器对象这一种可迭代对象，yield* 还可以 yield 其它任意的可迭代对象，比如说数组、字符串、arguments 对象等等 123456789101112131415function* g3() { yield* [1, 2]; yield* '34'; yield* arguments;}var iterator = g3(5, 6);iterator.next() // { value: 1, done: false }iterator.next() // { value: 2, done: false }iterator.next() // { value: '3', done: false }iterator.next() // { value: '4', done: false }iterator.next() // { value: 5, done: false }iterator.next() // { value: 6, done: false }iterator.next() // { value: undefined, done: true } 生成器也可以接收参数12345678910function* g() { var index = arguments[0] || 0; while (true) yield index++;}var gen = g(5);gen.next().value // 5gen.next().value // 6 Map，Set，String，Array 互相转换可迭代协议给出了统一的迭代协议，使得不同类型的集合间转换更加方便，以下是一些很方便的转换技巧 从 Array 生成 Set，可用于数组去重 12345new Set(['1', '2', '3'])// 等价于（但不是 ===）new Set(['1', '2', '3'][Symbol.iterator]()) 从 Set 得到 Array 12345Array.from(new Set(['1', '2', '3'])) // ['1', '2', '3']// 等价于Array.from(['1', '2', '3'][Symbol.iterator]()) 除了 for...of 外，扩展运算符（Spread Syntax）也支持迭代器（Iterables） 1[...new Set(['1', '2', '3'])] 从 String 到 Set，得到字符串中包含的字符 12345678let str = 'abcdefghijklmnopqrstuvwxyz';// Set(26) {'a', 'b', 'c', ...}new Set(str) // 等价于new Set(str[Symbol.iterator]()) 从 Object 到 Map，也就是把传统的 JavaScript 映射转换为 Map 123456let mapping = { 'foo': 'bar'}// {'foo' =&gt; 'bar'}new Map(Object.entries(mapping)) 类似地，Object 的键的集合可以这样获取 123456let mapping = { 'foo': 'bar'}// {'foo'}new Set(Object.keys(mapping)) 生成器对象到底是一个迭代器还是一个可迭代对象生成器对象既是迭代器也是可迭代对象，一个良好的迭代即实现了迭代器协议，又实现了可迭代协议，方式就是可迭代协议返回的是自身 1234567891011121314151617var g = function* () { yield 1; yield 2; yield 3;}();// 'function'，因为有 next() 方法，所以是一个迭代器typeof g.next;// 'function'，因为有 @@iterator 方法，所以是一个迭代器typeof g[Symbol.iterator];// true，因为 @@iterator 方法返回它自身（也是一个迭代器）g[Symbol.iterator]() === g;// [1, 2, 3][...g]; 总结 Iterator 接口的目的就是为所有数据结构提供一种统一访问的机制，用 for...of 实现 一个数据结构只要有 Symbol.iterator 属性，就可以认为是可遍历的 实现了可迭代协议的对象称为可迭代对象（Iterables），这种对象可以用 for...of 来遍历，Map，Set，Array，String 都属于可迭代对象，自定义的对象也可以使用这一机制，成为可迭代对象 可迭代协议：需要实现一个 @@iterator 方法，即在键 [Symbol.iterator] 上提供一个方法，对象被 for...of 调用时，这个方法会被调用，方法应该返回一个迭代器对象（Iterator）用来迭代 简单来说，一个数据结构只要具有 Symbol.iterator 属性，就可以认为是可迭代的（iterable） 实现了迭代器协议的对象称为迭代器对象（Iterator），也就是我们说的迭代器对象 迭代器协议：又称 Iteration Protocol，需要实现一个 next() 方法，每次调用会返回一个包含 value（当前指向的值）和 done（是否已经迭代完成）的对象 简单来说，只需要实现 .next() 方法 参考 迭代协议 迭代器和生成器 Generator GeneratorFunction function* yield yield* ES6生成器：可迭代协议与迭代器协议 给对象部署Iterator接口","link":"/2019/07/13/JavaScript/56/"},{"title":"JavaScript 中一些常用方法的实现","text":"一些常用方法的实现，常见算法的汇总，在这里做下记录，方便以后可以快速查询（可以直接参考左边目录） once12345678// oncefunction once(dom, event, callback) { var handle = function () { callback() dom.removeEventListener(event, handle) } dom.addEventListener(event, handle)} debounce123456789101112// debouncevar deBounce = function (fn, wait = 300) { let timer return function () { if (timer) { clearTimeOut(timer) } timer = setTimeOut(() =&gt; { fn.apply(this, arguments) }, wait) }} thorttle1234567891011// thorttlevar throttle = function (fn, wait = 300) { let prev = +new Date() return function () { const args = argument, now = +new Date() if (now &gt; prev + wait) { prev = now fn.apply(this, args) } }} call12345678910111213// callFunction.prototype.call = function (context, ...args) { if (context === null || context === undefined) { context = window } else { context = Object(context) } let fn = Symbol() context[fn] = this let result = context[fn](...args) delete context[fn] return result} apply12345678910111213// applyFunction.prototype.apply = function (context) { if (context === null || context === undefined) { context = window } else { context = Object(context) } let fn = Symbol() context[fn] = this let result = arguments[1] ? context[fn](...arguments[1]) : context[fn]() delete context[fn] return result} bind12345678910// bindFunction.prototype.myBind = function (oThis, ...args) { const thisFn = this let fToBind = function (...params) { const context = this instanceof fToBind ? this : Object(oThis) return thisFn.apply(context, ...args, ...params) } fToBind.prototype = Object.create(thisFn.prototype) return fToBind} prev123456789101112function getRealPrev(elem) { // 原理就是遍历 elem 节点的前面，直到返回第一个 nodeType 为 1 的节点 var o = elem; // 循环遍历，将循环的结果再次赋予 o，依次向上查询 while (o = o.previousSibling) { if (o.nodeType == 1) { return o; } return null; }} next123456789101112function getRealNext(elem) { // 原理就是遍历 elem 节点的后面，直到返回第一个 nodeType 为 1 的节点 var o = elem; // 循环遍历，将循环的结果再次赋予 o，依次向下查询 while (o = o.nextSibling) { if (o.nodeType == 1) { return o; } return null; }} prevAll1234567891011121314function getRealprevAll(elem) { // 原理就是遍历 elem 节点的前面，直到返回第一个 nodeType 为 1 的节点 var o = elem; var result = []; // 循环遍历，将循环的结果再次赋予 o，依次向上查询 // 如果不存在上一个节点，则会返回 null，便自动停止循环 while (o = o.previousSibling) { if (o.nodeType == 1) { result.unshift(o) } return result; }} nextAll1234567891011121314function getRealnextAll(elem) { // 原理就是遍历 elem 节点的后面，直到返回第一个 nodeType 为 1 的节点 var o = elem; var result = []; // 循环遍历，将循环的结果再次赋予 o，依次向下查询 // 如果不存在下一个节点，则会返回 null，便自动停止循环 while (o = o.nextSibling) { if (o.nodeType == 1) { result.push(o) } return result; }} Array.prototype.splice()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465Array.prototype.splice = function (start, deleteCount) { var max = Math.max, min = Math.min, delta, // 偏移量 element, insertCount = max(arguments.length - 2, 0), // 排除掉 arguments 参数中 start 和 deleteCount，剩余是待插入元素 k = 0, len = this.length, // 对 array 调用时，this 指向当前数组 new_len, result = [], // 返回数组 shift_count; // 需移位的数量 start = start || 0; // start 默认值为 0 if (start &lt; 0) start += len; // start &lt; 0 时，从数组后端开始 start = max(min(start, len), 0); // 经过处理，0 &lt;= start &lt;= len deleteCount = typeof deleteCount === 'number' ? deleteCount : len; // deleteCount 默认值是 len deleteCount = min(deleteCount, len - start); // deleteCount &lt;= 可删除数量 deleteCount = max(deleteCount, 0); // 0 &lt;= deleteCount &lt;= 可删除数量 delta = insertCount - deleteCount; new_len = len + delta; // 获取删除元素 while (k &lt; deleteCount) { element = this[start + k]; if (element != undefined) { result[k] = element; } k += 1; } shift_count = len - start - deleteCount; // 待插入数量小于删除数量，原数组后续元素依次向左偏移 if (delta &lt; 0) { // 从 start 至 start + insertCount 留给待插入元素 k = start + insertCount; while (shift_count) { this[k] = this[k - delta]; k += 1; shift_count -= 1; } this.length = new_len; // 待插入数量大于删除数量，原数组后续元素依次向右偏移 // delta === 0 时，待插入数量等于删除数量，无需偏移 } else if (delta &gt; 0) { k = 1; while (shift_count) { this[new_len - k] = this[len - k]; k + 1; shift_count -= 1; } // 非必须，因给一开始 this[new_len - k] 赋值时，length 属性已经自动设置为数组最后元素下标值 // this.length = new_len; } // 最后将待插入元素插入原数组 for (k = 0; k &lt; insertCount; k += 1) { // 排除掉 arguments 参数中 start 和 deleteCount this[start + k] = arguments[k + 2]; } return result;}; Array.prototype.push()1234567891011121314151617181920212223242526Array.prototype.push = function () { // 对 arguments 对象通过 array.slice 方法转换成数组 var args = Array.prototype.slice.apply(arguments); // 通过 array.concat 连接两个数组 var params = [this.length, 0].concat(args); // 对数组调用 splice 方法 // start = this.length // deleteCount = 0 // insertItems = args this.splice.apply(this, params); // 返回新的数组 length return this.length;};// 上述步骤合并，简写为下面方式（简单来说就是利用 concat 拼接两个数组）Array.prototype.push = function () { this.splice.apply(this, [this.length, 0].concat(Array.prototype.slice.apply(arguments))); return this.length;}; Array.prototype.pop()1234// 删除并返回数组的最后一个元素Array.prototype.pop = function () { return this.splice(this.length - 1, 1)[0];} Array.prototype.shift()1234// 和上面一样，但是删除并返回数组的第一个元素Array.prototype.shift = function () { return this.splice(0, 1)[0];} Array.prototype.unshift()12345// 向数组的开头添加一个或更多元素，并返回新的长度Array.prototype.unshift = function () { this.splice.apply(this, [0, 0].concat(Array.prototype.slice.apply(arguments))); return this.length;}; 浅拷贝123456789101112var obj = { a: 1, arr: [2, 3] };var shallowObj = shallowCopy(obj);function shallowCopy(src) { var dst = {}; for (var prop in src) { if (src.hasOwnProperty(prop)) { dst[prop] = src[prop]; } } return dst;} 深拷贝123456789function deepCopy(o) { // 根据传入的元素判断是数组还是对象 let c = o instanceof Array ? [] : {}; for (let i in o) { // 注意数组也是对象类型，如果遍历的元素是对象，进行深度拷贝 c[i] = typeof o[i] === 'object' ? deepCopy(o[i]) : o[i]; } return c;} mixin123456789101112131415161718192021function extend(destClass, srcClass) { var destProto = destClass.prototype; var srcProto = srcClass.prototype; for (var method in srcProto) { if (!destProto[method]) { destProto[method] = srcProto[method]; } }}function Book() { }Book.prototype.printName = function () { console.log('I am a book, named hello');};function JS() { }extend(JS, Book);var js = new JS();js.printName() mixin 多继承1234567891011121314151617181920212223242526function extend(destClass) { var classes = Array.prototype.slice.call(arguments, 1); for (var i = 0; i &lt; classes.length; i++) { var srcClass = classes[i]; var srcProto = srcClass.prototype; var destProto = destClass.prototype; for (var method in srcProto) { if (!destProto[method]) { destProto[method] = srcProto[method]; } } }}function Book() { }Book.prototype.getName = function () { };Book.prototype.setName = function () { };function Tech() { }Tech.prototype.showTech = function () { };function JS() { }extend(JS, Book, Tech);var js = new JS();console.log(js.__proto__); 事件模型12345678910111213141516171819202122232425262728293031323334353637383940var Emitter = function () { this._listeners = {};};// 注册事件Emitter.prototype.on = function (eventName, callback) { var listeners = this._listeners[eventName] || []; listeners.push(callback); this._listeners[eventName] = listeners;}// 触发事件Emitter.prototype.emit = function (eventName) { var args = Array.prototype.slice.apply(arguments).slice(1), listeners = this._listeners[eventName]; if (!Array.isArray(listeners)) return; listeners.forEach(function (callback) { try { callback.apply(this, args); } catch (e) { console.error(e); } });}// 实例对象var emitter = new Emitter();emitter.on('event2', function (arg1, arg2) { console.log('get event2', arg1, arg2);})emitter.on('event1', function (arg1, arg2) { console.log('get event1', arg1, arg2);})console.log('emit event');emitter.emit('event2', 'arg1', 'arg2');emitter.emit('event1', 'arg1', 'arg2'); 拖拽123456789101112131415161718var div = document.getElementById('div');div.onmousedown = function (e) { var e = e || event; var disX = e.clientX - div.offsetLeft; var disY = e.clientY - div.offsetTop; document.onmousemove = function (e) { var e = e || event; div.style.left = e.clientX - disX + 'px'; div.style.top = e.clientY - disY + 'px'; } document.onmouseup = function () { document.onmousemove = null; document.onmouseup = null; }} base64 格式 转为 blob 格式1234567891011121314function dataURItoBlob(base64Data) { var byteString; if (base64Data.split(',')[0].indexOf('base64') &gt;= 0) { byteString = atob(base64Data.split(',')[1]); } else { byteString = unescape(base64Data.split(',')[1]); } var mimeString = base64Data.split(',')[0].split(':')[1].split(';')[0]; var ia = new Uint8Array(byteString.length); for (var i = 0; i &lt; byteString.length; i++) { ia[i] = byteString.charCodeAt(i); } return new Blob([ia], { type: mimeString });} Ajax123456789101112131415161718192021222324252627var xhr = new xhrRequest();if (xhr) { xhr.open('GET', url); xhr.onreadystatechange = function () { if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) { console.log(xhr.responseText); } }; xhr.send();}// ---------------------------------------------------// 如果需要使用 POST 请求发送表单数据，使用 setRequestHeader() 来添加 http 头// 然后在 send() 方法中添加需要发送的数据// 在 Form 元素的语法中，EncType 表明提交数据的格式，用 Enctype 属性指定将数据回发到服务器时浏览器使用的编码类型// 下面是三种常用的设置方式// application/x-www-form-urlencoded 窗体数据被编码为 名称/值 对，这是标准的编码格式// multipart/form-data 窗体数据被编码为一条消息，页上的每个控件对应消息中的一个部分// text/plain 窗体数据以纯文本形式进行编码，其中不含任何控件或格式字符 xhr.open('POST', url, true);xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');xhr.send(data); Promise 版本 Ajax123456789101112131415161718192021222324function getJSON(url) { return new Promise((resolve, reject) =&gt; { var xhr = new XMLHttpRequest() xhr.open('GET', url, true) xhr.onreadystatechange = function () { if (this.readyState === 4) { if (this.status === 200) { resolve(this.responseText, this) } else { var resJson = { code: this.status, response: this.response } reject(resJson, this) } } } xhr.send() })}// 使用getJSON(url).then(function (data) { console.log(data)}).catch(function (status) { console.log(`Error: ${status}`)}) getElementsByClassName()12345678910111213141516function getElementsByClassName(classname) { if (document.querySelectorAll) { return document.querySelectorAll('.' + classname); } else { var elements = document.getElementsByTagName('*'); var reg = new RegExp('(^|\\\\s)' + classname + '(\\\\s|$)'); var results = []; for (let i = 0, length = elements.length; i &lt; length; i++) { if (reg.test(elements[i].className)) { results.push(elements[i]); } } } return results;} 斐波纳契数列（fibonacci）123456789101112function fn(n) { var a = []; a[0] = 0, a[1] = 1; for (var i = 2; i &lt; n; i++) { a[i] = a[i - 1] + a[i - 2]; } for (var i = 0; i &lt; n; i++) { console.log(a[i]); }}fn(20); 阶乘函数123456789101112131415161718192021222324// 使用 arguments.callee// 但是需要注意，在严格模式下，ES5 禁止使用 arguments.callee()// 当一个函数必须调用自身的时候，要么给函数表达式一个名字，要么使用一个函数声明function factorial(num) { if (num &lt;= 1) { return 1; } else { return num * arguments.callee(num - 1); }}factorial(3); // 6// 方式二const factorial = (function f(num) { if (num &lt;= 1) { return 1; } else { return num * f(num - 1) }})factorial(3); // 6 单例模式123456var getSingle = function (fn) { var result; return function(){ return result || (result = fn.apply(this, arguments)) }} 工厂模式123456789101112var Car = (function () { var Car = function (name, age) { this.name = name; this.age = age; }; return function (name, age) { return new Car(name, age); };})();var zhangsan = new Car('zhangsan', 20);var lisi = new Car('lisi', 22); 代理模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// ES6 之前function Person() { }Person.prototype.sayName = function () { console.log('zhangsan');}Person.prototype.sayAge = function () { console.log(20);}function PersonProxy() { this.person = new Person(); var that = this; this.callMethod = function (functionName) { console.log('before proxy:', functionName); // 代理 that.person[functionName](); console.log('after proxy:', functionName); }}var p = new PersonProxy();p.callMethod('sayName'); // 代理调用 Person 的方法 sayName()p.callMethod('sayAge'); // 代理调用 Person 的方法 sayAge()// ES6 之后let obj = { a: 1, b: 2,}const p = new Proxy(obj, { get(target, key, value) { if (key === 'c') { return '我是自定义的一个结果'; } else { return target[key]; } }, set(target, key, value) { if (value === 4) { target[key] = '我是自定义的一个结果'; } else { target[key] = value; } }})console.log(obj.a) // 1console.log(obj.c) // undefinedconsole.log(p.a) // 1console.log(p.c) // 我是自定义的一个结果obj.name = 'zhangsan';console.log(obj.name); // zhangsanobj.age = 4;console.log(obj.age); // 4p.name = 'zhangsan';console.log(p.name); // zhangsanp.age = 4;console.log(p.age); // 我是自定义的一个结果 观察者模式1234567891011121314151617181920212223242526272829303132333435// 被观察者class Subject { constructor() { this.list = [] } addListener(target) { this.list.push(target) } notify() { this.list.forEach(el =&gt; { el.say() }) }}// 观察者class Observer { constructor(name) { this.name = name } say() { console.log(this.name) }}const target = new Subject()const person1 = new Observer('zhangsan')const person2 = new Observer('lisi')target.addListener(person1)target.addListener(person2)target.notify() 发布订阅模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Target { constructor() { this.list = {} } // 订阅 lister(type, fn) { if (this.list[type]) { this.list[type].push(fn) } this.list[type] = [fn] } // 发布 trigger(type, ...args) { this.list[type].forEach(list =&gt; { list(...args) }) } // 删除 remove(type, fn) { let fns = this.list[type] if (!fns) return false; if (fn) { for (let i = 0; i &lt; fns.length; i++) { let _fn = fns[i] if (_fn === fn) { fns.splice(i, 1) } } } }}const target = new Target()const clickHandle = function(e) { console.log(`click, ${e}`) }const dbClickHandle = function(e) { console.log(`dbClick, ${e}`) }target.lister('click', clickHandle)target.lister('dbclick', dbClickHandle)target.remove('click', clickHandle)target.trigger('click', 'zhangsan')target.trigger('click', 'lisi')target.trigger('dbclick', 'wangwu') 冒泡排序比较相邻的元素，如果第一个比第二个大，就交换他们两个 12345678910111213141516function bubbleSort(arr) { // i 表示所需循环的趟数 // j 表示这一趟需要比较的次数 var i = arr.length, j; while (i &gt; 0) { for (j = 0; j &lt; i - 1; j++) { if (arr[j] &gt; arr[j + 1]) { var temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } i--; } return arr;} 快速排序找基准（一般是以中间项为基准）然后遍历数组，小于基准的放在 left，大于基准的放在 right，最后递归调用 123456789101112131415161718192021222324252627function quickSort(arr) { // 如果数组 &lt;=1，则直接返回 if (arr.length &lt;= 1) { return arr; } // 以中间点为基准 var pivotIndex = Math.floor(arr.length / 2); // 利用 splice() 方法得到基准值，用于最后的拼接还原 var pivot = arr.splice(pivotIndex, 1)[0]; // 定义左右数组 var left = []; var right = []; // 比基准小的放在 left，比基准大的放在 right for (var i = 0; i &lt; arr.length; i++) { if (arr[i] &lt;= pivot) { left.push(arr[i]); } else { right.push(arr[i]); } } // 递归 return quickSort(left).concat([pivot], quickSort(right));} 插入排序每步将一个待排序的对象，按其排序码大小，插入到前面已经排好序的一组对象的适当位置上，直到对象全部插入为止 12345678910111213141516function insertSort(array) { var i = 1, j, step, key, len = array.length; for (; i &lt; len; i++) { step = j = i; key = array[j]; while (--j &gt; -1) { if (array[j] &gt; key) { array[j + 1] = array[j]; } else { break; } } array[j + 1] = key; } return array;} 数组去重1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 第一种 Setvar newArr = [...new Set(arr)]// 第二种 对象键值对法function unique(arr) { var res = []; var json = {}; for (var i = 0; i &lt; arr.length; i++) { if (!json[arr[i]]) { res.push(arr[i]); json[arr[i]] = 1; } } return res;}// 第三种 indexOfArray.prototype.unique = function () { var arr = []; for (var i = 0; i &lt; this.length; i++) { if (arr.indexOf(this[i]) == -1) { arr.push(this[i]); } } return arr;}// 第四种 相邻进行比较Array.prototype.unique = function () { this.sort(); var arr = [this[0]]; for (var i = 1; i &lt; this.length; i++) { if (this[i] !== arr[arr.length - 1]) { arr.push(this[i]); } } return arr;}// 第五种 indexOf + filterarr.filter((el, index, _this) =&gt; { return _this.indexOf(el) === index;})// 第六种 reduce，不过这个主要是针对数组对象function unique(arr, initialValue, id) { let hash = {}; return arr.reduce((item, next) =&gt; { hash[next.id] ? '' : hash[next.id] = true &amp;&amp; item.push(next); return item }, initialValue);}let arr = [{ 'id': 1 }, { 'id': 2 }, { 'id': 2 }, { 'id': 3 }]const newArr = unique(arr, [], 'id'); 数组降维123456789101112131415161718192021222324let arr = [[12], 4, [333, [4444, 5555]], [9, [111, 222]]]// 方法一，将数组字符串化，然后在还原为数字数组function reduceDimension(arr) { return arr.toString().split(',').map(item =&gt; Number(item))}// 方法二，利用 apply 和 concat转换（不会改变现有的数组，会返回被连接数组的一个副本），但是只能剔除一个维度// 如果要实现多维，递归调用即可function reduceDimension(arr) { return Array.prototype.concat.apply([], arr);}// 方法三，递归（据说这个效率最高）function reduceDimension(arr) { let ret = []; let toArr = arr =&gt; { arr.forEach(item =&gt; { item instanceof Array ? toArr(item) : ret.push(item) }) } toArr(arr); return ret;} 字符串去重123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 第一种 for 遍历function unique1(str) { var newStr = ''; var flag; for (var i = 0; i &lt; str.length; i++) { flag = 1; for (var j = 0; j &lt; newStr.length; j++) { if (str[i] == newStr[j]) { flag = 0; break; } } if (flag) newStr += str[i]; } return newStr;}// 第二种 indexOffunction unique2(str) { var newStr = ''; for (var i = 0; i &lt; str.length; i++) { if (newStr.indexOf(str[i]) == -1) { newStr += str[i]; } } return newStr;} // 第三种 searchfunction unique3(str) { var newStr = ''; for (var i = 0; i &lt; str.length; i++) { if (newStr.search(str[i]) == -1) newStr += str[i]; } return newStr;}// 第四种 利用对象属性function unique4(str) { var obj = {}; var newStr = ''; for (var i = 0; i &lt; str.length; i++) { if (!obj[str[i]]) { newStr += str[i]; obj[str[i]] = 1; } } return newStr;} 生成区间随机数，并排序123456789101112131415var arr = [];var randomNum = function (n, m) { return parseInt(Math.random() * (m - n) + n)}for (var i = 0; i &lt; 20; i++) { arr.push(randomNum(40, 80))}// 排序console.log(arr.sort(function (a, b) { return a - b }))// 乱序console.log(arr.sort(function () { return 0.5 - Math.random() })) 取数组的并集，交集和差集12345678910111213141516171819202122232425262728293031323334353637383940// 这里有一些需要注意的地方// 如果两个数组 A 和 B 当中没有重复的元素，以下三种都是可以正常实现的// 如果数组当中有重复的元素，需要使用 ES6 当中的 Set 数据结构// 如果数组当中包含 NaN，可以考虑在结尾处添加 .filter(v =&gt; !isNaN(v)) 过滤掉即可let a = [1, 2, 3, 4];let b = [2, 3, 4, 5, 6];// ES7 并集a.concat(b.filter(v =&gt; !a.includes(v))) // [1, 2, 3, 4]// ES7 交集a.filter(v =&gt; b.includes(v)) // [2, 3]// ES7 差集a.concat(b).filter(v =&gt; !a.includes(v) || !b.includes(v)) // [1, 4]// ------------let aSet = new Set(a)let bSet = new Set(b)// ES6 并集Array.from(new Set(a.concat(b))) // [1, 2, 3, 4]// ES6 交集Array.from(new Set(a.filter(v =&gt; bSet.has(v)))) // [2, 3]// ES6 差集Array.from(new Set(a.concat(b).filter(v =&gt; !aSet.has(v) || !bSet.has(v)))) // [1, 4]// ------------// ES5 并集a.concat(b.filter(v =&gt; a.indexOf(v) === -1)) // [1, 2, 3, 4]// ES5 交集a.filter(v =&gt; b.indexOf(v) !== -1) // [2, 3]// ES5 差集a.filter(v =&gt; b.indexOf(v) === -1).concat(b.filter(v =&gt; a.indexOf(v) === -1)) // [1, 4] 统计数组中每一项出现的次数1[5, 5, 4, 3, 2,1, 4, 5, 5, 4, 3, 2, 2, 1].reduce((ad, ap) =&gt; (ad[ap] = ++ad[ap] || 1, ad), {}) 寻找字符串中出现次数最少的、并且首次出现位置最前的字符1234var str = 'cbaacfdeaebb';[...new Set(str)].map(el =&gt; ({ el, len: str.split(el).length })) .reduce((a, e) =&gt; (a.len &gt; e.len ? e : a)).el; 生成指定长度数组（[0, 1, 2, 3 … N - 1]）12345678910111213141516171819202122232425262728293031323334353637// 方法一，ES5Array.apply(null, { length: N }).map(function (value, index) { return index});// 方法二，ES6Array.from(new Array(N), (v, i) =&gt; i)// 方法三Array.from(Array(N).keys())// 方法四[...Array(N).keys()]// 方法五Object.keys(Array(N).join().split(',')).map(v =&gt; Number(v))// 方法六Object.keys(Array(N).fill()).map(v =&gt; Number(v))// 方法七Object.keys(Array.apply(null, { length: 100 })).map(v =&gt; Number(v))// 方法八Array(N).fill().map((v, i) =&gt; i)// 方法九Array.prototype.recursion = function (length) { if (this.length === length) { return this; } this.push(this.length); this.recursion(length);}arr = []arr.recursion(100) 短横变驼峰12345function strToCamel(str) { return str.replace(/(^\\w)|-(\\w)/g, (m, $1, $2) =&gt; $1 ? $1.toUpperCase() : $2.toUpperCase());}strToCamel('border-right-color') 千位分隔符12345678910function commafy(num) { return num &amp;&amp; num .toString() // 也可以使用 /\\B(?=(\\d{3})+$)/g .replace(/(\\d)(?=(\\d{3})+\\.)/g, function ($0, $1) { return $1 + ','; });}commafy(1234567.90) 解析 url1234567function urlParam(url) { const param = {}; url.replace(/[?&amp;](.*?)=([^&amp;]*)/g, (m, $1, $2) =&gt; param[$1] = $2); return param;}urlParam('https://www.baidu.com?id=123&amp;name=zhangsan') 字符串大小写切换12345678function caseConvert(str) { return str.replace(/([a-z]*)([A-Z]*)/g, (m, s1, s2) =&gt; { return `${s1.toUpperCase()}${s2.toLowerCase()}` })}caseConvert('abcdefg')caseConvert('ABCDEFG') 去空格1234str.replace(/\\s*/g, ''); //去除字符串内所有的空格str.replace(/^\\s*|\\s*$/g, ''); //去除字符串内两头的空格str.replace(/^\\s*/, ''); //去除字符串内左侧的空格str.replace(/(\\s*$)/g, ''); //去除字符串内右侧的空格 去除所有的 html1var con = content.replace(/&lt;[^&gt;]+&gt;/g,''); 提取括号中的数值1/\\(([^()]+)\\)/g.exec('add(18)') 匹配空行1^[\\s]*\\n 验证邮政编码12345// 共六位数，第一位不能为 0const pattern = /^[1-9]{1}[0-9]{5}$/;const str = '430000';console.log(pattern.test(str)); // true 验证压缩包后缀名12345// 文件名（字母_数字）.zip|gz|rarconst pattern = /^[\\w]+\\.(zip|gz|rar)$/;const str = 'a12_.zip';console.log(pattern.test(str)); // true","link":"/2019/08/02/JavaScript/57/"},{"title":"Angular 中的变化检测机制","text":"今天在群里看到一个讨论，是关于 Angular 的变化检查机制，依稀记得在 AngularJS 当中是使用的脏检查机制 而在 Angular 2.x+ 之后的版本当中依然采用的是脏检查机制，不过使用的是进行优化过的版本 为了探明到底有啥区别，就打算抽点时间，研究研究新版本的脏检查机制，顺便记录记录，就当加深点印象了 为保持区别，文中所指的 AngularJS 所表示的版本为 1.x+ 的版本，而 Angular 则为 2.x+的版本 什么是变化检测一句话概括：一种更改检测机制，用于遍历组件树，检查每个组件的变化，并在组件属性发生变化的时候触发 DOM 的更新 变化检测（脏检查）的基本任务是获取程序内部状态的变化，并使其在用户界面上以某种方式可见，这种状态的变化可以来自于 JavaScript 的任何数据结构，最终呈现为用户界面中的段落、表单、链接或者按钮等 DOM 对象 然而在程序运行时发生变化情况比较复杂，我们需要确定模型中发生什么变化，以及什么地方需要更新 DOM 节点，毕竟操作 DOM 树十分昂贵，所以我们不仅需要找出待更新的地方，还需要保持操作数尽可能小 关于更多循环脏值检测可以见 AngularJS: The Bad Parts 数据的变化那么问题来了，既然是变化检测，那么数据在何时会变化，又是哪些因素会引起数据变化？ 基本上应用程序状态的改变可以由三类活动引起 用户输入操作，比如点击，表单提交等 请求服务端数据 定时事件，比如 setTimeout，setInterval 这几点有一个共同点，就是它们都是异步的，也就是说，所有的异步操作是可能导致数据变化的根源因素 所以每当执行一些异步操作时，我们的应用程序状态可能发生改变，而这时则需要去更新视图 通知变化在数据进行变化了之后，在 Angular 中又是谁来通知数据即将变化的呢？ 在 AngularJS 当中使用了观察者和监听器的概念，一个观察者是一个用来返回一个被监听的对象的值的函数，一般是由 $scope.$apply() 或者 $scope.$digest 来进行触发 而在 Angular 当中则接入了 NgZone，由它来监听 Angular 所有的异步事件 Angular 在启动时会重写（通过 Zone.js）部分底层浏览器 API，比如 addEventListener 12345678910111213// this is the new version of addEventListenerfunction addEventListener(eventName, callback) { // call the real addEventListener callRealAddEventListener(eventName, function () { // first call the original callback callback(...); // and then run Angular-specific functionality var changed = angular2.runChangeDetection(); if (changed) { angular2.reRenderUIPart(); } });} 而在 Angular 当中常见的有两种方式来触发变化检测，一种方法是基于组件的生命周期钩子 123456ngAfterViewChecked() { if (this.callback &amp;&amp; this.clicked) { console.log('changing status ...'); this.callback(Math.random()); }} 在开发模式下运行 Angular 会在控制台中得到一条错误日志，生产模式下则不会抛出 另一种方法是手动控制变化检测的打开或者关闭，并手动触发 123456constructor(private ref: ChangeDetectorRef) { ref.detach(); setInterval(() =&gt; { this.ref.detectChanges(); }, 5000);} 改善的脏检查同样是循环脏值检测，虽然 Angular 并没有类似于 AngularJS 的观察者的概念，但是跟踪数据模型属性变化的函数还是存在 它们只跟踪数据模型中的变化，而不像 AngularJS 中跟踪所有的内容 Angular 的核心是组件化，组件的嵌套会使得最终形成一棵组件树，Angular 的变化检测可以分组件进行，每个组件都有对应的变化检测器 ChangeDetector 可想而知这些变化检测器也会构成一棵树，如下图所示 另外，Angular 的数据流是自顶向下，从父组件向子组件的的单向流动，变化监测树与之相呼应，单项数据量保证变化监测的高效性和可预测性 尽管检查了父组件之后，子组件可能会改变父组件的数据使得父组件需要再次被检查，这是不被推荐的数据处理方式 在开发模式下，Angular 会进行二次检查，如果出现上述情况，二次检查就会产生如下报错：ExpressionChangedAfterItHasBeenCheckedError（可以参考文章底部链接） 而在生产环境中，脏检查只会执行一次 相比之下，AngularJS 采用的是双向数据流，错综复杂的数据流使得它不得不多次检查，使得数据最终趋向稳定，但是在理论上，数据可能永远不稳定 而 AngularJS 给出的策略是，脏检查超过 10 次，就认为程序有问题，不再进行检查（$digest 循环的上限是 10 次，更多可见 angular-digest-loop） Angular 中的变化检测首先我们需要注意的是在 Angular 中每个组件都有自己的变化检测器，这使得我们可以对每个组件分别控制如何以及何时进行变化检测 由于每个组件都有其自己的变化检测器，即一个 Angular 应用程序由一个组件树组成，所以逻辑结果就是我们也有一个变化检测器树 这棵树也可以看作是一个流向图，而数据总是从上到下流动，数据从上到下的原因是因为变化检测也总是从上到下对每一个单独的组件进行 每一次从根组件开始，单向数据流比循环脏检查更可预测，我们总是可以知道视图中使用的数据来自哪里 我们假设在组件树的某个地方触发一个事件，比如一个按钮被点击，NgZone 会进行事件的处理并通知 Angular，然后变化检测依次向下传递 另外，Angular 还提供了定制变化检测策略的能力 1234export enum ChangeDetectionStrategy { OnPush, // 表示变化检测对象的状态为 `CheckOnce` Default, // 表示变化检测对象的状态为 `CheckAlways`} 从 ChangeDetectionStrategy 可以看到，Angular 有两种变化检测策略，Default 是 Angular 默认的变化检测策略，也就是之前提到的脏检查（只要有值发生变化，就全部检查，但是是经过优化后的单向数据流检查） 可以根据场景来设置更加高效的变化检测方式：onPush onPush 策略，就是只有当输入数据的引用发生变化或者有事件触发时，组件才进行变化检测 123456789101112@Component({ template: ` &lt;h2&gt;{{vData.name}}&lt;/h2&gt; &lt;span&gt;{{vData.email}}&lt;/span&gt; `, // 设置该组件的变化检测策略为 onPush changeDetection: ChangeDetectionStrategy.OnPush})class VCardCmp { @Input() vData;} 比如上面这个例子，当 vData 的属性值发生变化的时候，这个组件不会发生变化检测，只有当 vData 重新赋值的时候才会发生变化检测 当组件中的输入对象是不变量时，可采用 onPush 变化检测策略，减少变化检测的频率，换个角度来说，为了更加智能地执行变化检测，可以在只接受输入的子组件中采用 onPush 策略 当输入属性不变时，Angular 可以跳过整个变更检测子树，如果我们在 Angular 应用程序中使用不可变对象，我们所需要做的就是告诉 Angular 组件可以跳过变化检测（如果它的输入没有改变的话） 正如上面的例子所示，VCardCmp 只依赖于它的输入属性，我们可以告诉 Angular 跳过这个组件的子树的变化检测 更优的变化检测Angular 每次都要检查每个组件，因为事件发生的原因也许是应用程序状态已经改变，但是如果我们能够告诉 Angular 只对那些改变状态的应用程序部分运行变化检测，那不是很好吗？ 事实证明，有些数据结构可以给我们什么时候发生变化的一些保证，那就是 Immutables 和 Observables Immutables比如我们拥有一个组件 VCardApp 使用 v-card 作为子组件，其具有一个输入属性 vData，并且我们可以使用 changeData 方法改变 vData 对象的 name 属性（并不会改变该对象的引用） 12345678910111213141516@Component({ template: '&lt;v-card [vData]=\"vData\"&gt;&lt;/v-card&gt;'})class VCardApp { constructor() { this.vData = { name: 'Christoph Burgdorf', email: 'christoph@thoughtram.io' } } changeData() { this.vData.name = 'Pascal Precht' }} 当某些事件导致 changeData 执行时，vData.name 发生改变并传递至 v-card 中，v-card 组件的变化检测器检查给定的数据新 vData 是否与以前一样 在数据引用未变但是其参数改变的情况下，Angular 也需要对该数据进行变化监测，这就是 immutable 数据结构发挥作用的地方 Immutable 为我们提供不可变的对象：这意味着如果我们使用不可变的对象，并且想要对这样的对象进行更改，我们会得到一个新的引用（保证原始对象不变） 1234567var vData = Immutables.create({ name: 'Pascal Precht'});var vData2 = vData.set('name', 'Christoph Burgdorf')vData === vData2 // false Observables与不可变的对象不同，当进行更改时 Observables 不会给我们提供新的引用，而是发射我们可以订阅的事件来对他们做出反应，比如下面这个示例 我们用购物车建立一个电子商务应用程序，每当用户将产品放入购物车时，我们需要在用户界面中显示一个小计数器，以便用户可以看到购物车中的产品数量 123456789101112131415@Component({ template: '{{counter}}', changeDetection: ChangeDetectionStrategy.OnPush})class CartBadgeCmp { @Input() addItemStream: Observable&lt;any&gt;; counter = 0; ngOnInit() { this.addItemStream.subscribe(() =&gt; { this.counter++; // application state changed }) }} 该组件有一个 counter 属性和一个输入属性 addItemStream，当产品被添加到购物车时，这是一个被触发的事件流 另外，我们设置了变化检测策略为 OnPush，只有当组件的输入属性发生变化时，变化检测才会执行 如前所述，引用 addItemStream 永远不会改变，所以组件的子树从不执行变更检测 当整个树被设置成 OnPush 后，我们如何通知 Angular 需要对这个组件进行变化检测呢？ 正如我们所知，变化检测总是从上到下执行的，所以我们需要的是一种可以检测树的整个路径到发生变化的组件的变化的方法 我们可以通过依赖注入访问组件的 ChangeDetectorRef，这个注入来自一个叫做 markForCheck 的 API，它标记从组件到根的路径，以便下次更改检测的运行 12345678constructor(private cd: ChangeDetectorRef) { }ngOnInit() { this.addItemStream.subscribe(() =&gt; { this.counter++; // application state changed this.cd.markForCheck(); // marks path })} 下面是在可观察事件被触发后，变化检测开始前 现在当执行更改检测时，它将从上到下进行 并且一旦更改检测运行结束，它将恢复 OnPush 整个树的状态 参考 Change And Its Detection In JavaScript Frameworks ANGULAR CHANGE DETECTION EXPLAINED change detection in Angular Tuning Angular’s Change Detection ExpressionChangedAfterItHasBeenCheckedError TAKING ADVANTAGE OF OBSERVABLES IN ANGULAR Angular Change Detection - How Does It Really Work? Change And Its Detection In JavaScript Frameworks","link":"/2019/07/22/Angular/16/"},{"title":"CSS 当中的单位","text":"我们先来看看比较常见的三个单位 px，em，rem 的区别 px – 相对长度单位，也是用的最多的一种单位，像素 px 是相对于显示器屏幕分辨率而言的 em – 值并不是固定的，会继承父级元素的字体大小，代表倍数 rem – 值并不是固定的，是 CSS3 新增的一个相对单位（简单记法，r 是 root 的缩写），相对于根元素 &lt;html&gt; 的字体大小，也代表倍数 emem 的使用是相对于其父级的字体大小的（继承），即倍数，浏览器的默认字体高都是 16px，未经调整的浏览器显示 1em = 16px 但是有一个问题，如果设置 1.2em 则变成 19.2px，问题是 px 表示大小时数值会忽略掉小数位的 而且 1em = 16px 的关系不好转换，因此，常常人为地使 1em = 10px 这里要借助字体的 % 来作为桥梁 因为默认时字体 16px = 100%，则有 10px = 62.5%，所以首先在 body 中全局声明 font-size = 62.5% = 10px 也就是定义了网页 body 默认字体大小为 10px，由于 em 有继承父级元素字体大小的特性，如果某元素的父级没有设定字体大小，那么它就继续了 body 默认字体大小 1em = 10px 但是由于 em 是相对于其父级字体的倍数的，当出现有多重嵌套内容时，使用 em 分别给它们设置字体的大小往往要重新计算 比如说你在父级中声明了字体大小为 1.2em，那么在声明子元素的字体大小时设置 1em 才能和父级元素内容字体大小一致，而不是1.2em（避免 1.2 * 1.2 = 1.44em） 1234&lt;span&gt; outer &lt;span&gt;inner&lt;/span&gt; &lt;/span&gt; 1234567body { font-size: 62.5%;}span { font-size: 1.6em;} 结果 外层 &lt;span&gt; 为 body 字体 10px 的 1.6 倍，即 16px 内层 &lt;span&gt; 为外层内容字体 16px 的 1.6 倍，即 25px（也有可能是 26px，不同浏览器取舍小数不同） 明显地，内部 &lt;span&gt; 内的文字受到了父级 &lt;span&gt; 的影响，基于这点，在实际使用中给我们的计算带来了很大的不便 有一个比较普遍的误解，认为 em 单位是相对于父元素的字体大小，事实上，根据 W3 标准 ，它们是相对于使用 em 单位的元素的字体大小 父元素的字体大小可以影响 em 值，但这种情况的发生，纯粹是因为继承 remrem 转化为像素大小取决于页面根元素的字体大小，即 html 元素的字体大小 比如默认的 html 的 font-size 属性为 16px，那么想设置 12px 的文字就是 12 / 16 = 0.75(rem) rem 的原理布局的本质是等比缩放，一般是基于宽度 假设将屏幕宽度分为 100 份，每份宽度是 1rem，1rem 的宽度是 屏幕宽度 / 100 然后子元素设置 rem 单位的属性， 通过改变 html 元素的字体大小，就可以设置子元素的实际大小 仍然是上面的例子，CSS 改为 12345678html { font-size: 62.5%;}span { font-size: 16px; font-size: 1.6rem;} 结果：内外 &lt;span&gt; 的内容均为 16px 有时候会遇到 rem 布局加载闪烁的问题，这时可以使用媒体查询设置默认根元素字体大小，或者调整对应闪烁元素的长度 vh 和 vw在 CSS3 当中引入了所谓的视窗单位，它允许我们更接近浏览器窗口来定义大小，如下图 在桌面端，视窗指的是在桌面端，指的是浏览器的可视区域 而在移动端，它涉及3个视窗 Layout Viewport（布局视窗） Visual Viewport（视觉视窗） Ideal Viewport（理想视窗） 而视窗单位中的视窗 桌面端指的是浏览器的可视区域 移动端指的就是 Viewport 中的 Layout Viewport 比如说我们有一个 1000px * 800px 的视窗（Viewport） vw —— 1vw = 视窗宽度的 1%，即 50vw = 500px vh —— 1vh = 视窗高度的 1%，即 50vh = 400px vmin —— vmin 的值是当前 vw 和 vh 中较小的值，在我们的例子里因为是横向模式，所以 50vmin = 400px vmax —— 大尺寸的百分比，50vmax = 500px 这里我们发现视窗宽高都是 100vw／100vh，很类似百分比单位，但是 vw 和 % 之间是有区别的 % 大部分相对于祖先元素，也有相对于自身的情况比如（border-radius、translate 等） vw/vh 则相对于视窗的尺寸 从对比中我们可以发现，vw 单位与百分比类似，但是这里的 vw 更像是理想的百分比单位，任意层级元素，在使用 vw 单位的情况下，1vw 都等于视图宽度的百分之一 在移动端使用过程中，vw 和 vh 都是根据视窗来确定实际像素的，但是视窗上的宽度和高度比例不一定是 1:1 的 而且一般来说，vh 和 vw 不用同时使用，使用 vw 一般就满足移动端适配的要求了 vw 单位换算同样的，如果要将 px 换算成 vw 单位，很简单，只要确定视图的窗口大小（布局视窗） 如果我们将布局视窗设置成分辨率大小，比如对于 iphone 6/7 375*667 的分辨率，那么 px 可以通过如下方式换算成 vw 11px = (1 / 375) *100 vw 兼容性 从上图可以发现，绝大多数的浏览器支持 vw 单位，但是 ie 9-11 不支持 vmin 和 vmax 考虑到 vmin 和 vmax 单位不常用，vw 单位在绝大部分高版本浏览器内的支持性很好 但是 opera 浏览器整体不支持 vw 单位，如果需要兼容 opera 浏览器的布局，不推荐使用 vw 参考 CSS3 的 REM 设置字体大小 别说你懂 CSS 相对单位","link":"/2019/08/04/CSS/11/"},{"title":"Http 报文头","text":"http 协议是以 ASCII 码传输，建立在 TCP/IP 协议之上的应用层规范，规范把 http 请求分为三个部分，如下图所示 每条报文都包含一条来客户端的请求，或者一条来自客户端的响应，它们由三个部分组成 对报文进行描述的请求行（start line）、包含属性的请求头（header），以及可选的包含数据的请求体（body） 请求行与请求头就是由行分隔的 ASCII 文本，每行都以一个由两个字符组成的行终止序列作为结束，其中包括一个回车符和一个换行符，这个行终止符可以写作 CRLF（空行） 注意，尽管 http 规范中说明应该用 CRLF 来表示行终止，但稳健的做法也应该接受单个换行符作为行的终止 而报文又分为请求报文和响应报文，下面我们一个一个来了解 请求报文http 请求报文由请求行、请求头、空行（有时会忽略掉这一部分）和请求体（请求数据）四个部分组成，如下图所示： 可能一眼看上去比较复杂，我们可以简化一下，如下 1234&lt;method&gt; &lt;request-URL&gt; &lt;version&gt;&lt;header&gt; &lt;entity-body&gt; 请求报文示例在详细展开之前，我们先来看一个请求报文示例 12345678910GET / HTTP/1.1Host: www.baidu.comConnection: keep-aliveCache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.110 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Encoding: gzip, deflate, sdch, brAccept-Language: zh-CN,zh;q=0.8,en;q=0.6,id;q=0.4Cookie: PSTM=1490844191; BIDUPSID=2145FF54639208435F60E1E165379255; 请求行请求行由请求方法、URL 和 http 协议版本组成，它们之间用空格分开 1GET / HTTP/1.1 请求方法（method）客户端希望服务器对资源执行的动作，http/1.1 协议 规定的 http 请求方法有 OPTIONS、GET、HEAD、POST、PUT、DELETE 等 一般比较常用的是 GET 和 POST 这两个方法，但是关于 POST 请求，并没有规定数据必须使用什么编码方式 我们可以采取默认值，也可以手动进行指定，关于这一点可以参考页面底部的 POST 提交数据方式 请求 URL（request-URL）用来命名资料的完整 URL，或者 URL 的路径部分，如果直接与服务器进行对话，只要 URL 的路径部分是资源的绝对路径，通常就不会有什么问题 协议及版本（version）报文所使用的 http 版本，其格式看起来是下面这样的 1http/&lt;major&gt;.&lt;minor&gt; 其中主版本号（major）与次版本号（minor）都是整数 请求头报文头包含若干个属性，格式为 key: value 形式的键值对，服务端据此获取客户端的信息 可以有零个或多个报文头，每个报文头都包含一个名字，后面跟着一个英文冒号（:），然后是一个可选的空格，接着是一个值，最后是一个 CRLF 报文头是由一个空行（CRLF）结束的，表示了报文头列表的结束和实体主体部分的开始，有些 http 版本，比如 http/1.1，要求有效的请求或响应报文中必须包含特定的报文头 这里只简单介绍几个比较常见的属性，详细的报文头属性可以见 http header fields User-Agent：用户代理信息（Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 ...） Accept：客户端可识别的内容类型列表（text/html,application/xhtml+xml,application/xml） 请求报文可通过一个 Accept 报文头属性告诉服务端，客户端接受什么类型的响应 Accept 属性的值可以为一个或多个 MIME 类型的值，关于 MIME 类型可以见 内容类型 Accept-Language：客户端可接受的自然语言（zh-CN,zh;q=0.8,en;q=0.6,id;q=0.4） Accept-Encoding：客户端可接受的编码压缩格式（gzip, deflate, sdch, br） Host：请求的主机名，允许多个域名同处一个 ip 地址，即虚拟主机（www.baidu.com） connection：连接方式 close：告诉 Web 服务器或代理服务器，在完成本次请求的响应后，断开连接 keep-alive：告诉 Web 服务器或代理服务器，在完成本次请求的响应后，保持连接，以等待后续请求 Cookie：存储于客户端扩展字段，向同一域名的服务端发送属于该域的 Cookie（PSTM=1490844191; BIDUPSID=2145FF54639208435F60E1E165379255;） 客户端的 Cookie 通过报文头的 Cookie 属性来传给服务端 服务端就是通过 http 请求报文头的 Cookie 属性的 sessionId 的值把用户关联起来的 Referer：表示这个请求是从哪个 URL 过来的，比如广告商就可以得知某个用户是哪一个源头过来的 Cache-Control：对缓存进行控制，如一个请求希望响应返回的内容在客户端要被缓存一年，或不希望被缓存就可以通过这个报文头达到目的 如设置 Cache-Control: no-cache 则相当于让服务端将对应请求返回的响应内容不要在客户端缓存 空行（请求）最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头 请求体它将一个页面表单中的组件值通过键值对形式编码成一个格式化串，它承载多个请求参数的数据 报文体可以传递请求参数，请求 URL 也可以通过类似于 /index.html?param1=value1&amp;param2=value2 的方式传递请求参数 请求数据不在 GET 方法中使用，而是在 POST 方法中使用，与请求数据相关的最常使用的请求头是 Content-Type 和 Content-Length 响应报文http 的响应报文也由四部分组成（状态行、响应头、空行（有时会忽略掉这一部分）和响应体），如下图所示 响应报文也可以进行简化，如下 1234&lt;version&gt;&lt;status&gt;&lt;reason-phrase&gt;&lt;headers&gt; &lt;entity-body&gt; 响应报文示例同样的，我们先来看一个响应报文示例 12345678HTTP/1.1 200 OKServer: bfe/1.0.8.18Date: Thu, 30 Mar 2019 12:28:00 GMTContent-Type: text/html; charset=utf-8Connection: keep-aliveCache-Control: privateExpires: Thu, 30 Mar 2019 12:27:43 GMTSet-Cookie: BDSVRTM=0; path=/ 状态行（status-line）状态行也大致分为四个部分：HTTP-Version，Status-Code，Reason-Phrase，CRLF HTTP-Version：http 协议版本 Status-Code：状态码 Reason-Phrase：状态码描述 CRLF：回车/换行符 状态码（status-code）格式是三位数字，其描述了请求过程中所发生的情况，每个状态码的第一位数字用于描述状态的一般类别，一般是由以下五段组成 1xx – 处理中，一般是告诉客户端，请求已经收到了，正在处理 2xx – 处理成功，一般表示请求已受理、已经处理完成等信息 3xx – 重定向到其它地方，它让客户端再发起一个请求以完成整个处理 4xx – 处理发生错误，错误发生在客户端，如客户端的请求一个不存在的资源，客户端未被授权，禁止访问等 5xx – 处理发生错误，错误发生在服务端，如服务端抛出异常，路由出错，http 版本不支持等 状态码描述（reason-phrase）也就是所谓的原因短语，数字状态码的可读版本，包含行终止序列之前的所有文本，原因短语只对人类有意义 比如说，尽管响应行 http/1.0 200 NOT OK 和 http/1.0 200 OK 中原因短语的含义不同，但同样都会被当作成功的标志 下面是一个假想的请求报文与响应报文 不过需要注意的是，一组 http 报文头总是应该以一个空行（仅有 CRLF）结束，甚至即使没有报文头和实体的主体部分也应该如此 但由于历史原因，很多客户端和服务器都在没有实体的主体部分时，（错误的）省略了最后的 CRLF 为了与这些流行但不符合规则的实现兼容，客户端和服务器都应该接受那些没有最后那个 CRLF 的报文 响应头响应头也是由格式为 key: value 形式的键值对组成 响应头域允许服务器传递不能放在状态行的附加信息，这些域主要描述服务器的信息和 Request-URI 进一步的信息，典型的响应头有： Server：包含处理请求的原始服务器的软件信息 Date：服务器日期 Content-Type：返回的资源类型（MIME） Connection：连接方式 close：连接已经关闭 keep-alive：连接已保持，在等待本次连接的后续请求 Cache-Control：缓存控制 Expires：设置过期时间 Set-Cookie：设置 Cookie 信息 空行（响应）最后一个响应头之后是一个空行，发送回车符和换行符，通知浏览器以下不再有响应头 响应体服务器返回给浏览器的响应信息，下面是百度首页的响应体片段： 12345678910111213&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=Edge\"&gt; &lt;link rel=\"icon\" sizes=\"any\" mask href=\"//www.baidu.com/img/baidu.svg\"&gt; &lt;title&gt;百度一下，你就知道&lt;/title&gt;&lt;/head&gt;&lt;body&gt; ...&lt;/body&gt;&lt;/html&gt; POST 提交数据方式之前提到过，请求分为请求行、请求头和请求主体，类似于下面这样： 1234&lt;method&gt; &lt;request-URL&gt; &lt;version&gt;&lt;headers&gt;&lt;entity-body&gt; 协议规定 POST 提交的数据必须放在消息主体（entity-body）中，但协议并没有规定数据必须使用什么编码方式 实际上，开发者完全可以自己决定消息主体的格式，只要最后发送的 http 请求满足上面的格式就可以 服务端通常是根据请求头（headers）中的 Content-Type 字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析 所以说到 POST 提交数据方案，包含了 Content-Type 和消息主体编码方式两部分 application/x-www-form-urlencoded这个也就是所谓的表单提交方式了，浏览器的原生 &lt;form&gt; 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据 请求类似于下面这样 123456POST / HTTP/1.1Host: foo.comContent-Type: application/x-www-form-urlencodedContent-Length: 13say=Hi&amp;to=Mom 可以发现 Content-Type 被指定为 application/x-www-form-urlencoded 传递的是对应的 key 和 val multipart/form-data这种方式一般用来上传文件，也是一种常见的 POST 数据提交的方式 在我们使用表单上传文件时，必须让 &lt;form&gt; 表单的 enctype 等于 multipart/form-data 123456789101112POST /test.html HTTP/1.1 Host: example.org Content-Type: multipart/form-data;boundary=\"boundary\" --boundary Content-Disposition: form-data; name=\"field1\" value1 --boundary Content-Disposition: form-data; name=\"field2\"; filename=\"example.txt\" value2 首先生成了一个 boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂 然后 Content-Type 里指明了数据是以 multipart/form-data 来编码，指明本次请求的 boundary 是什么内容 消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以 --boundary 开始，紧接着是内容描述信息，然后是回车，最后是字段具体内容（文本或二进制） 如果传输的是文件，还要包含文件名和文件类型信息，消息主体最后以 --boundary-- 标示结束 上面提到的这两种 POST 数据的方式，都是浏览器原生支持的，而且现阶段标准中原生 &lt;form&gt; 表单也只支持这两种方式 通过 &lt;form&gt; 元素的 enctype 属性指定，默认为 application/x-www-form-urlencoded，其实 enctype 还支持 text/plain，不过用得比较少 application/jsonapplication/json 这个 Content-Type 一般用来告诉服务端消息主体是序列化后的 JSON 字符串 JSON 格式支持比键值对复杂得多的结构化数据，AngularJS 中的 Ajax 功能，默认就是提交 JSON 字符串 1234var data = { 'title': 'test', 'sub': [1, 2, 3] };$http.post(url, data).success(function (result) { // ...}); 最终发送的请求是 1234POST http://www.example.com http/1.1 Content-Type: application/json;charset=utf-8{\"title\":\"test\",\"sub\":[1,2,3]}. 这种方案，可以方便的提交复杂的结构化数据，特别适合 RESTful 的接口 text/xml这种方案现在一般使用较少，XML 作为编码方式的远程调用规范，典型的 XML-RPC 请求是这样的 123456789101112POST http://www.example.com http/1.1 Content-Type: text/xml&lt;?xml version=\"1.0\"?&gt;&lt;methodCall&gt; &lt;methodName&gt;examples.getStateName&lt;/methodName&gt; &lt;params&gt; &lt;param&gt; &lt;value&gt;&lt;i4&gt;41&lt;/i4&gt;&lt;/value&gt; &lt;/param&gt; &lt;/params&gt;&lt;/methodCall&gt; XML-RPC 协议简单、功能够用，各种语言的实现都有 JavaScript 中，也有类似 XML-RPC over AJAX 这样的库来支持以这种方式进行数据交互，能很好的支持已有的 XML-RPC 服务 不过，XML 结构过于臃肿，一般场景用 JSON 会更灵活方便 参考 http 报文主体 http/1.1 协议 multipart/form-data rfc1867 http 头字段 内容类型（Content-Type） XML-RPC over AJAX 四种常见的 POST 提交数据方式","link":"/2019/08/17/HTTP/07/"},{"title":"什么是 Node.js","text":"其实在工作过程中一直有个想法，就是好好地深入的去学习一下 Node.js，无奈各种工作，家庭，生活和一些其他的原因导致此事一直搁浅 之前也有零零散散的学过，但是都算不得上深入，框架的使用也都只是停留在会用的阶段，底层的实现也没有知根知底的去探个究竟 所以打算在这 2019 年剩下的一段时间里，静下心来好好地学一下 Node.js，补充一下相关知识和一些流行框架的内容 应该会是一个系列文章，记录的就是在学习 Node.js 过程当中的一些笔记，心得和想法吧 既然打算从头开始深入的学习 Node.js，那我们就先来看看什么是 Node.js 吧 主要参考的是 如何正确的学习 Node.js 部分 什么是 Node.js按照官方的说法是 1Node.js® is a JavaScript runtime built on Chrome's V8 JavaScript engine. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient. Node.js' package ecosystem, npm, is the largest ecosystem of open source libraries in the world. 简单的总结一下，主要有下面这几点 Node.js 不是语言或者框架，也不是 JavaScript 的应用，它只是一个 JavaScript 运行时环境 构建在 Chrome's V8 的 JavaScript 引擎之上（Chrome V8 引擎以 C/C++ 为主，相当于使用JavaScript 写法，转成 C/C++ 调用） 特点是事件驱动（event-driven），非阻塞 I/O 模型（non-blocking I/O model） 用自己的话来说就是 Node.js 不是一门语言也不是框架，它是基于 Google V8 引擎的 JavaScript 运行时环境，同时结合 Libuv 扩展了 JavaScript 功能，使之支持 io、fs 等只有语言才有的特性，使得 JavaScript 能够同时具有 DOM 操作和 I/O、文件读写、操作数据库等能力 一般主要用来开发低延迟的网络应用，也就是那些需要在服务器端环境和前端实时收集和交换数据的应用（API、即时聊天、微服务）等 基本原理如下图，简要的介绍了 Node.js 是基于 Chrome V8 引擎构建的，由事件循环（Event Loop）分发 I/O 任务 最终工作线程（Work Thread）将任务丢到线程池（Thread Pool）里去执行，而事件循环只要等待执行结果就可以了 核心概念主要分为三个部分 Chrome V8 引擎 Event Loop 事件循环 Thread Pool 线程池 简单的梳理一下 Chrome V8 是 JavaScript 引擎，而 Node.js 又内置 Chrome V8 引擎，所以它使用的 JavaScript 语法 JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事，这就意味着，所有任务需要排队，如果前一个任务结束，才会执行后一个任务，如果前一个任务耗时很长，后一个任务就不得不一直等着 由 Event Loop 将 I/O 任务放到线程池里 换一个维度来看，如下图 同样的，我们也来简单的梳理一下 Chrome V8 解释并执行 JavaScript 代码（这就是为什么浏览器能执行 JavaScript 原因） 由事件循环和线程池组成，负责所有 I/O 任务的分发与执行 在解决并发问题上，异步是最好的解决方案，可以简单的理解为排队和叫号的机制 排队的时候，等待就可以了，而取号的过程，则是由 Event Loop 来接受处理，而真正执行操作的是具体的线程池里的 I/O 任务 之所以说 Node.js 是单线程，就是因为在接受任务的时候是单线程的，它无需在进程或者线程当中切换上下文，所以非常高效，但它在执行具体任务的时候是多线程的 关于更多的应用场景的介绍可以参考 Node.js 应用场景 异步流程控制Node.js 的核心就是异步流程控制，如下图是 Node.js 解决异步流程问题的演进 红色代表 promise，是使用最多的，无论 async 还是 generator 都可用 蓝色是 Generator，过度货 绿色是 Async 函数，趋势 推荐使用 Async 函数加 promise 组合 简单来说，就是以下三点 callback promise Async/Await 下面一个一个来看 Api写法：Error-first Callback 和 EventEmitterError-first Callback也就是错误优先的回调写法，两条规则 回调函数的第一个参数返回的 error 对象，如果 error 发生了，它会作为第一个 err 参数返回，如果没有，一般做法是返回 null 回调函数的第二个参数返回的是任何成功响应的结果数据，如果结果正常，没有 error 发生，err 会被设置为 null，并在第二个参数就出返回成功结果数据 123function(err, res) { // process the error and result} EventEmitterNode.js 使用事件驱动模型，当 webserver 接收到请求，就把它关闭然后进行处理，再去服务下一个 web 请求 当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户 这个模型非常高效可扩展性非常强，因为 webserver 一直接受请求而不等待任何读写操作（也就是所谓的事件驱动 IO） 在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数 事件模块是 Node.js 内置的对发布订阅模式（publish/subscribe）的实现，通过 EventEmitter 属性，提供了一个构造函数 该构造函数的实例具有 on 方法，可以用来监听指定事件，并触发回调函数，任意对象都可以发布指定事件，被 EventEmitter 实例的 on 方法监听到 下面是一个简单的示例 12345678910const EventEmitter = require('events');class MyEmitter extends EventEmitter {}const myEmitter = new MyEmitter();myEmitter.on('event', () =&gt; { console.log('触发了一个事件');});myEmitter.emit('event'); 如果同时绑定了多个事件监听器，则事件监听器回调函数是会被先后调用，而事件参数则作为回调函数参数传递 本质上就是发布订阅模式的实现，下面是一个简单的发布订阅模式的手动实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Target { constructor() { this.list = {} } // 订阅 lister(type, fn) { if (this.list[type]) { this.list[type].push(fn) } this.list[type] = [fn] } // 发布 trigger(type, ...args) { this.list[type].forEach(list =&gt; { list(...args) }) } // 删除 remove(type, fn) { let fns = this.list[type] if (!fns) return false; if (fn) { for (let i = 0; i &lt; fns.length; i++) { let _fn = fns[i] if (_fn === fn) { fns.splice(i, 1) } } } }}const target = new Target()const clickHandle = function(e) { console.log(`click, ${e}`) }const dbClickHandle = function(e) { console.log(`dbClick, ${e}`) }target.lister('click', clickHandle)target.lister('dbclick', dbClickHandle)target.remove('click', clickHandle)target.trigger('click', 'zhangsan')target.trigger('click', 'lisi')target.trigger('dbclick', 'wangwu') Promisepromise 意味着一个还没有完成的操作，但在未来会完成的，promise 最主要的交互方法是通过将函数传入它的 then 方法从而获取得 promise 最终的值 要点有三个 递归，每个异步操作返回的都是 promise 对象 状态机，三种状态转换，只在 promise 对象内部可以控制，外部不能改变状态 全局异常处理 定义1234567var promise = new Promise(function (resolve, reject) { if (/* everything turned out fine */) { resolve('Stuff worked!'); } else { reject(Error('It broke')); }}); 每个 promise 定义都是一样的，在构造函数里传入一个匿名函数，参数是 resolve 和 reject，分别代表成功和失败时候的处理 调用123456promise.then(function (text) { console.log(text) return `promise`.reject(new Error('Error'))}).catch(function (err) { console.log(err)}) 它的主要交互方式是通过 then 函数，如果 promise 成功执行 resolve 了，那么它就会将 resolve 的值传给最近的 then 函数，作为它的 then 函数的参数 如果出错 reject，那就交给 catch 来捕获异常，更多内容可以参考下面几个链接 Node.js 最新技术栈之 Promise 篇 理解 Promise 的工作原理 Promise 迷你书 终极解决方案：Async/Await下面是一段 Koa 2 应用里的一段代码 12345678910exports.list = async (ctx, next) =&gt; { try { let students = await Student.getAllAsync(); await ctx.render('students/index', { students: students }) } catch (err) { return ctx.api_error(err); }}; 它做了三件事 通过 await Student.getAllAsync() 来获取所有的 students 信息 通过 await ctx.render 渲染页面 由于是同步代码，使用 try/catch 做的异常处理 综上，比如一个读取文件的操作，采用 await + promise 的写法 123456789const Promise = require('bluebird')const fs = Promise.promisifyAll(require('fs'))async function test() { const contents = await fs.readFileAsync('myfile.js', 'utf8') console.log(contents)}test()","link":"/2019/09/01/Node/08/"},{"title":"前端字体优化","text":"最近在工作当中遇到了关于前端字体优化的问题，主要是因为产品是一款在线的编辑工具，其中可以提供给用户各种不同的字体来进行编辑 所以在载入编辑区的过程当中会变得十分缓慢，所以特意抽了些时间研究了一下，在这里顺便记录一下 在正式展开之前，可以先了解一下 各平台的默认字体情况 如何加载自定义字体在 CSS3 当中，使用 @font-face 即可加载自定义字体了 使用 @font-face 可以定义某个特定字体资源的位置，其样式特征用于网页 12345678910@font-face { font-family: 'SomeFont'; font-style: normal; font-weight: 500; src: local('Some Font Italic'), url('/fonts/someFont.woff2') format('woff2'), url('/fonts/someFont.woff') format('woff'), url('/fonts/someFont.ttf') format('ttf'), url('/fonts/someFont.eot') format('eot');} 使用 local() 指令，我们可以引用、加载和使用本地安装的字体 使用 url() 指令，我们可以加载外部字体，并且该指令可以包含一个可选的 format() 提示，指示由提供的网址所引用的字体的格式 对大型 unicode 字体进行子集内嵌以提高性能，比如使用 unicode-range 子集内嵌，并为较旧的浏览器提供手动子集内嵌回退 减少风格字体变体的数量以改进网页和文本呈现性能 为了兼容不同的浏览器，我们一般会使用多个格式，也许你会遇到类似下面这样的写法 123456@font-face { font-family: 'SomeFont'; src: url('someFont.eot'); /* IE9 Compat Modes */ src: url('someFont.eot?#iefix') format('embedded-opentype'), /* IE6 - IE8 */ url('someFont.woff') format('woff'), /* Modern Browsers */} 可以注意到，上面例子当中有两个 src 属性，并且还有一个 ?#iefix 的后缀，它是有何作用的呢？ 绝大多数情况下，第一个 src 是可以去掉的，除非需要支持 IE9 下的兼容模式 在 IE9 中可以使用 IE7 和 IE8 的模式渲染页面，微软修改了在兼容模式下的 CSS 解析器，导致使用 ? 的方案失效 由于 CSS 解释器是从下往上解析的，所以在上面添加一个不带问号的 src 属性便可以解决此问题 IE9 之前的版本没有按照标准解析字体声明，当 src 属性包含多个 url 时，它无法正确的解析而返回 404 错误，而其他浏览器会自动采用自己适用的 url 因此把仅 IE9 之前支持的 EOT 格式放在第一位，然后在 url 后加上 ?，这样 IE9之前的版本会把问号之后的内容当作 url 的参数 至于 #iefix 的作用，一是起到了注释的作用，二是可以将 url 参数变为锚点，减少发送给服务器的字符 字体格式现在网络上使用的字体容器格式有四种 EOT、TTF、WOFF 和 WOFF2 遗憾的是，无论选择的范围有多宽，都不会有在所有旧浏览器和新浏览器上都可以使用的单一通用格式 EOT 仅 IE 支持 TTF 具有 部分 IE 支持 WOFF 的支持最广泛，但它在许多较旧的浏览器中不可用 WOFF 2.0 支持 对于许多浏览器来说还未实现， 所以一般采用以下方式，采用多个样式，让浏览器自动采用自己所适用的 将 WOFF 2.0 变体提供给支持它的浏览器 将 WOFF 变体提供给大多数浏览器 将 TTF 变体提供给旧 Android（4.4 版以下）浏览器 将 EOT 变体提供给旧 IE（IE9 之下）浏览器 还有一种 SVG 字体，因为兼容性和用途有限，可以忽略不提 但是在使用过程当中也会遇到问题，通常来说，字体文件一般加载都是非常缓慢的，因为中文字体文字数量庞大，字体文件也变得非常之大 页面加载之后，还需要很长的时间来下载字体，下载完成之后，才会正确显示，在用户看来，就是打开页面很久之后字体又变了，体验非常不好 期间试了多种方法，看了很多文档，大致总结一下，一般比较常见的有以下几种方案 压缩字体大小并且使用缓存这个应该是比较常用的方法了，但是效果的提升不是很明显 一般的做法是在服务器开启 http/2，并对静态资源设置 E-TAG 和 Cache-Control 来进行缓存 也可以在服务器端配置 GZIP 压缩，可以有效的减小字体文件大小 可以考虑使用 Zopfli 压缩 处理 EOT、TTF 和 WOFF 格式，Zopfli 是一个 zlib 兼容压缩工具，该工具通过 gzip 提供 ~5% 的文件大小缩减 font-spider一开始也准备使用 字蛛（font-spider），但是在这个项目里面我们并不能知道用户添加的文本有哪些，输入的标题有哪些 所以也就不能使用这个方法了，但是还是抽空了解了一下使用方式，那么什么是 font-spider呢，引用官方的话如下 字蛛是通过分析本地 CSS 与 HTML 文件获取 WebFont 中没有使用的字符，并将这些字符数据从字体中删除以实现压缩，同时生成跨浏览器使用的格式 使用起来感觉很简单，首先进行安装 1$ npm install font-spider -g 安装完成以后就可以在 CSS 中使用 WebFont 12345678910111213141516/* 声明 WebFont */@font-face { font-family: 'myfont'; src: url('../font/myfont.eot'); src:url('../font/myfont.eot?#font-spider') format('embedded-opentype'), url('../font/myfont.woff') format('woff'), url('../font/myfont.ttf') format('truetype'), url('../font/myfont.svg') format('svg'); font-weight: normal; font-style: normal;}/*使用选择器指定字体*/.test &gt; p { font-family: 'myfont';} 注意需要指定 ?#font-spider 后缀，关于这个属性，上面已经介绍过了 配置完成了以后，就可以在当前路径下，或者要压缩字体的 html 文件下执行以下操作 1font-spider ./demo/*.html 这时，font-spider 就会帮助我们将页面依赖的字体将会自动压缩好，并且原 .ttf 字体是会备份的 下面是尝试过程当中遇到的一些坑 格式相关问题，font-spider 主要依据 ttf 格式的文件来进行分析压缩的，所以 font-face 的路径必须存在 ttf 格式的，其他格式不行 路径，引入路径要使用相对路径，否则会报 Web Font was not found 局限性，font-spider 仅适用于固定文本，如果文字内容为动态可变的，新增的文字将无法显示为特殊字体 解决办法是将备份还原，重新压缩 font-spider xxx.html 如果不添加 options，会默认备份原文件 如果是 base64 形式的字体，可能会报不存在引入文件的错误，所以如果不想压缩某个字体包的话，就先注释其 font-face 一旦压缩一次后，再次压缩别的是没用的 比如说在一个文件夹里压缩了字体，生成了字体包，又在另一个文件夹里压缩字体，这两个文件夹的字体共用一个字体包和 font-face 所以再次压缩的就是上一个压缩字体包进行压缩的，所以导致页面中有的字体没有转化过来 解决办法，使用 font-spider file1/*.html file2/*.html file3/*.html 命令，压缩所有指定文件即可 fontmin另外一个方法和 font-spider 差不多，但是感觉用起来更为方便一些，那就是 fontmin 简答来说，fontmin 可以提取 ttf 字体文件中需要用到的文字，然后转换为 woff 文件输出，更为方便的就是我们可以手动指定输出内容 123456789101112131415161718const Fontmin = require('fontmin');const fontmin = new Fontmin() .src('assets/fonts/SourceHanSerifCN-Light.ttf') .dest('build/fonts/') .use(Fontmin.glyph({ text: '天地玄黄宇宙洪荒', hinting: false })) .use(Fontmin.ttf2woff({ deflate: true }));fontmin.run((err) =&gt; { if (err) { throw err; }}); src 制定了输入字体文件路径（必须是 ttf 文件） dest 是输出路径 use(Fontmin.glyph({text, hinting})) 会生成一个只包含 text 字符的字体文件子集 hinting 指定所生成的 ttf 文件是否包含控制值表、字体程序区之类的信息（用于保留完整的 TrueType 轮廓描述信息） use(Fontmin.ttf2woff({deflate: true})) 用来将上一步生成的 ttf 文件转化为 woff，进一步压缩大小 同样的，这个方法也只能用来处理固定的文本内容，我们无法得知用户输入的内容，所以这个方案也被 pass 掉了 使用 Unicode-range 子集内嵌在查找文档的过程中，发现了一个很少见的方法，即使用 Unicode-range 子集内嵌 原理是使用 unicode-range 描述符，我们可以指定一个范围值的逗号分隔列表，其中每个可以采用以下三种不同的形式之一： 单一代码点（例如 U+416) 间隔范围（例如 U+400-4ff）：指示范围的开始代码点和结束代码点 通配符范围（例如 U+4??): ? 字符指示任何十六进制数字 1234567891011121314151617181920212223@font-face { font-family: 'SomeFont'; font-style: normal; font-weight: 400; src: local('SomeFont Font'), url('/fonts/someFont-l.woff2') format('woff2'), url('/fonts/someFont-l.woff') format('woff'), url('/fonts/someFont-l.ttf') format('ttf'), url('/fonts/someFont-l.eot') format('eot'); unicode-range: U+000-5FF; /* Latin glyphs */}@font-face { font-family: 'SomeFont'; font-style: normal; font-weight: 400; src: local('SomeFont Font'), url('/fonts/someFont-jp.woff2') format('woff2'), url('/fonts/someFont-jp.woff') format('woff'), url('/fonts/someFont-jp.ttf') format('ttf'), url('/fonts/someFont-jp.eot') format('eot'); unicode-range: U+3000-9FFF, U+ff??; /* Japanese glyphs */} 通过使用 unicode range 子集以及为字体的每种样式变体使用单独的文件，我们可以定义一个复合字体系列 访问者将仅下载变体及变体需要的子集，而不会强制他们下载他们可能从未在网页上看到或使用过的子集 在浏览器不支持 unicode range 的情况下，浏览器会下载所有字体 preload最终敲定的方案是使用 &lt;link rel=preload&gt; 来提前加载字体文件，因为刚好在项目当中，用户在进入编辑区之前会有一个预览页面 在这个页面进行字体的预加载，利用浏览器的缓存功能，这样一来就可以保证用户在进入编辑区的时候不会经历漫长的等待 在此之前，我们先来看看网页加载中的字体加载过程，如下图所示 字体的延迟加载可能会延迟文本呈现，主要原因是由于浏览器必须构造呈现树，这依赖于 DOM 和 CSSOM 树，在此之后，它将知道它将需要哪些字体资源来呈现文本 因此，会将字体请求很好地延迟到其他关键资源之后，并且在取回资源之前可能会阻止浏览器呈现文本，下面是一个简化版本的浏览器渲染过程 浏览器请求 HTML 文档 浏览器开始解析 HTML 响应并构造 DOM 浏览器发现 CSS、JavaScript 和其他资源并分派请求 收到所有 CSS 内容之后，浏览器会立即构造 CSSOM，并将其与 DOM 树组合到一起来构造呈现树 在呈现树指明需要哪些字体变体来呈现网页上的指定文本之后，会立即分派字体请求 浏览器执行布局，并将内容绘制到屏幕上 如果字体还不可用，浏览器可能不会呈现任何文本像素 字体可用之后，浏览器会立即绘制文本像素 网页内容的首次绘制（在构建呈现树之后可以很快完成）和字体资源请求之间的先后顺序就会产生了 FOIT（Flash of Invisible Text） 这种情况下浏览器可能会呈现网页布局而忽略任何文本，在不同浏览器之间实际的行为会有所不同 Safari 在字体下载完成之前会暂停文本呈现 Chrome 和 Firefox 会暂停字体呈现最多 3 秒钟，3 秒钟之后它们会使用一种备用字体，并且字体下载完成之后，它们会立即使用下载的字体重新呈现一次文本 如果请求字体还不可用，IE 会立即使用备用字体呈现，并在字体下载完成之后马上重新呈现 可以发现，这里有一个微观的过程就是字体显示时间线，简单的理解就是分为字体阻止期 – 字体交换期 – 字体失败期 如果我们希望能够让浏览器更早一些的显示出正确字体的文字，那么就需要优化字体载入的时间 所以在这种情况下，我们就可以利用 &lt;link rel=preload&gt; 来提前加载字体文件 我们就可以把 &lt;link rel=preload&gt; 放到 HTML 的 &lt;head&gt;&lt;/head&gt; 中，让浏览器提前下载字体文件，而不用等 DOM 树完成后等 CSS 下载后才去请求 由于下载字体使用了额外的 http 请求，因此 http/2 可以大幅提高性能，它不需要受六个并发 http 请求的限制 当然也可以采用动态加载的方式 123456789function preLoad(href) { const preloadLink = document.createElement('link'); preloadLink.href = href; preloadLink.rel = 'preload'; preloadLink.as = 'font'; preloadLink.type = 'font/woff'; preloadLink.crossorigin = 'anonymous' document.head.appendChild(preloadLink);} 当你在服务器上设置好 E-TAG（告诉客户端你的资源有没有变化）和 Cache-control（告诉客户端缓存时间长度）后，这些字体资源就不需要多次下载，以节省时间 使用 font-display 来控制字体阻止期font-display 是 CSS 中新添加的属性，主要用来控制加载字体显示方式，有以下取值 auto 默认值，典型的浏览器字体加载的行为会发生，也就是使用自定义字体的文本会先被隐藏，直到字体加载结束才会显示 swap 后备文本立即显示直到自定义字体加载完成后再使用自定义字体渲染文本 在大多数情况下，这就是我们所追求的效果 fallback 这个可以理解为 auto 和 swap 的一种折中方式 需要使用自定义字体渲染的文本会在较短的时间（Google 浏览器大概在 100ms）不可见 如果自定义字体还没有加载结束，那么就先加载无样式的文本，一旦自定义字体加载结束，那么文本就会被正确赋予样式 optional 效果和 fallback 几乎一样，都是先在极短的时间内文本不可见，然后再加载无样式的文本 不过 optional 选项可以让浏览器自由决定是否使用自定义字体，而这个决定很大程度上取决于浏览器的连接速度，如果速度很慢，那你的自定义字体可能就不会被使用 将 font-display 设置为 swap 后，意味着阻止期为 0，而交换期为无限长 这样一来你便可以避免网页出现空白文本，而立即用替换字体显示内容，一旦需要的字体下载完成后就可以替换原来的字体正确显示 如果你不知道选择那个作为 font-display 的属性值，可以选择 swap 它不仅提供了自定义字体和内容的可访问性之间的最佳平衡，它还提供了和使用 JavaScript 脚本相同的字体加载行为 如果你在页面上有想要加载的字体，但是最终也可以不加载，这时你就可以考虑使用 fallback 或者 optional 作为 font-display 的值 参考 如何优雅的选择字体 @font-face The Web Open Font Format (WOFF) Web 字体简介: TTF, OTF, WOFF, EOT &amp; SVG 通过rel=”preload”进行内容预加载 css-font-loading Font Face Observer","link":"/2019/08/18/Essay/04/"},{"title":"CSS 常见布局方式","text":"今天无意中在网上看到一张图，是关于 CSS 常见的布局方式汇总的一张图，如下 刚好就借着这个机会整理一下 CSS 当中比较常见的一些布局方式，顺便复习复习布局知识，下面就一个一个来介绍 示例集合可见 Demos 当中的 CSS 板块 文档流布局示例可见 文档流布局 最基本的布局方式，就是按照文档的顺序一个一个显示出来，块元素独占一行，行内元素共享一行，如下 浮动布局示例可见 浮动布局 也是比较常见的布局方式，使用 float 属性，使元素脱离文档流，浮动起来，不过需要注意在使用该属性时引起的其他问题（譬如高度崩塌） 定位布局示例可见 定位布局 与浮动布局类似，也是使元素脱离文档流，浮动起来，不过使用的是 position 属性，结果与浮动布局是一致的 至于两者有何区别，简单来说各有各的优缺点，很多时候我们希望控制的布局流问题不需要 float 和 position 实现，而应该通过显示模型定义来解决 比如现在的 column layout、flex box 等等，也就是下面将要说到的，都是在这个角度解决我们遇到的问题，它们应该才是正解 圣杯布局和双飞翼布局两者的本质其实是差不多的，就是两边顶宽，中间自适应的三栏布局，中间栏要在放在文档流前面以优先渲染，详细的可以参考 CSS布局中圣杯布局与双飞翼布局的实现思路差异在哪里？，这里只截取部分 简单来说就是，双飞翼布局比圣杯布局多创建了一个 div，但是不需要使用相对布局了，圣杯布局和双飞翼布局解决问题的方案在前一半是相同的，也就是三栏全部 float 浮动，但左右两栏加上负 margin 让其跟中间栏 div 并排，以形成三栏布局 不同在于解决中间栏 div 内容不被遮挡问题的思路不一样 圣杯布局：为了中间 div 内容不被遮挡，将中间 div 设置了左右 padding-left 和 padding-right 后，将左右两个 div 用相对布局 position: relative 并分别配合 right 和 left 属性，以便左右两栏 div 移动后不遮挡中间 div 双飞翼布局：为了中间 div 内容不被遮挡，直接在中间 div 内部创建子 div 用于放置内容，在该子 div 里用 margin-left 和 margin-right 为左右两栏 div 留出位置 对比下来可以发现，双飞翼布局多了一个 div，少用大致四个 CSS 属性，至于具体使用哪种方案可以根据实际情况来选择 圣杯布局实现以后如下所示，示例可见 圣杯布局 页面布局如下，很简单的三个 div 被外层父元素包裹，没用多余的额外元素 12345&lt;div class=\"wrapper\"&gt; &lt;div class=\"content\"&gt;Content&lt;/div&gt; &lt;div class=\"left\"&gt;Left&lt;/div&gt; &lt;div class=\"right\"&gt;Right&lt;/div&gt;&lt;/div&gt; 核心 CSS 代码如下 123456789101112131415161718192021222324252627.wrapper { padding: 0 200px;}.content { width: 100%; height: 200px; float: left;}.left { width: 200px; height: 200px; float: left; position: relative; left: -200px; margin-left: -100%;}.right { width: 200px; height: 200px; float: left; position: relative; right: -200px; margin-left: -200px;} 双飞翼布局如果你手动实现一遍以后就会发现，圣杯布局是有弊端的，当你将浏览器宽度缩短到一定程度的时候，会使得中间子元素的宽度比左右子元素宽度小的时候，这时候布局就会出现问题 双飞翼布局的出现就是为了解决此类问题，实现的结果与圣杯布局是一致的，示例可见 双飞翼布局 页面布局如下，与圣杯布局相比有些许不同，可以发现在 Content 的外部多了一层 div，而这个 div 就是用来解决上述问题的 12345&lt;div class=\"content-wrapper\"&gt; &lt;div class=\"content\"&gt;Content&lt;/div&gt;&lt;/div&gt;&lt;div class=\"left\"&gt;Left&lt;/div&gt;&lt;div class=\"right\"&gt;Right&lt;/div&gt; 核心 CSS 代码如下 123456789101112131415161718192021222324.content-wrapper { width: 100%; height: 200px; float: left;}.content { margin-left: 200px; margin-right: 200px;}.left { width: 200px; height: 200px; float: left; margin-left: -100%;}.right { width: 200px; height: 200px; float: left; margin-left: -200px;} flex 布局关于 flex 部分内容主要截取自 flex 布局，感觉讲的比较好理解，图文相对应，不过其中有一些调整，并且添加了一些个人理解，就当复习复习了 flex 是一种新型的布局方式，使用该布局方式可以实现几乎所有你想要的效果，但是要注意其浏览器的兼容性，flex 只支持 IE 10 以上 那么我们就先来看看如何使用 flex 布局 flex 的使用方法很简单，只需要将元素的 display 属性设置为 flex 就可以，也可以设置行内的 flex（inline-flex） 有一个特别需要需要的地方：当设置元素为 flex 布局之后，子元素的 float、clear、vertical-align 的属性将会失效 在 flex 中，最核心的概念就是容器和轴，所有的属性都是围绕容器和轴设置的，其中容器分为父容器和子容器，轴分为主轴和交叉轴 主轴默认为水平方向，方向向右，交叉轴为主轴顺时针旋转 90° 在使用 flex 的元素中，默认存在两根轴 水平的主轴（main axis） 主轴开始的位置称为 main start 结束的位置称为 main end 垂直的交叉轴（cross axis） 交叉轴开始的位置称为 cross start 结束的位置称为 cross end 在使用 flex 的子元素中，占据的主轴空间叫做 main size，占据的交叉轴空间叫做 cross size，如下图所示 之前整理过一篇关于子容器的 flex 取值相关问题，可见 关于子容器属性 flex 取值问题 不过关于容器和元素的属性也只是一笔带过，所以就在之前的基础上扩充一下吧 父容器首先，实现 flex 布局需要先指定一个容器，任何一个容器都可以被指定为 flex 布局，这样容器内部的元素就可以使用 flex 来进行布局 父容器可以统一设置子容器的排列方式，子容器也可以单独设置自身的排列方式，如果两者同时设置，以子容器的设置为准 有下面六种属性可以设置在父容器上，它们分别是： flex-direction：主轴的方向 flex-wrap：超出父容器子容器的排列样式 flex-flow：flex-direction 属性和 flex-wrap 属性的简写形式 justify-content：子容器在主轴的排列方向 align-items：子容器在交叉轴的排列方向 align-content：多根轴线的对齐方式 下面我们就来一个一个深入了解一下 flex-direction决定主轴的方向（即项目的排列方向），但是主轴的方向不一定是水平的，这个属性就是设置主轴的方向，默认是水平方向，从左至右 如果主轴方向设置完毕，那么交叉轴就不需要设置，交叉轴永远是主轴顺时针旋转 90° 123456.div { flex-direction: row; // 默认值，主轴为水平方向，起点在左端 flex-direction: row-reverse; // 主轴为水平方向，起点在右端 flex-direction: column; // 主轴为垂直方向，起点在上 flex-direction: column-reverse; // 主轴为垂直方向，起点在下} flex-wrapflex-wrap 属性决定子容器是否换行排列，不但可以顺序换行而且支持逆序换行 12345.ele { flex-wrap: nowrap; // 默认，不换行 flex-wrap: wrap; // 换行，第一行在上方 flex-wrap: wrap-reverse // 换行，第一行在下方，也就是逆序换行} justify-content主要用于定义如何沿着主轴方向排列子容器 12345678.ele{ justify-content: flex-start; // 默认，左对齐 justify-content: flex-end; // 右对齐 justify-content: center; // 居中 justify-content: space-between; // 两端对齐，项目之间的间隔都相等 justify-content: space-around; // 每个项目两侧的间隔相等，所以项目之间的间隔比项目与边框的间隔大一倍 //（即位于首尾两端的子容器到父容器的距离是子容器间距的一半）} flex-flowflow 即流向，也就是子容器沿着哪个方向流动，流动到终点是否允许换行，比如 flex-flow: row wrap，flex-flow 是一个复合属性，相当于 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap row、column 等，可单独设置主轴方向 wrap、nowrap 等，可单独设置换行方式 row nowrap、column wrap 等，也可两者同时设置 align-itemsalign-items 属性定义子容器在交叉轴上如何对齐，具体的对齐方式与交叉轴的方向有关，假设交叉轴从上到下 12345678910.ele{ align-items: flex-start; // 交叉轴的起点对齐， align-items: flex-end; // 交叉轴的终点对齐， align-items: center; // 交叉轴的中点对齐， align-items: baseline; // 项目的第一行文字的基线对齐 // 这里的 baseline 默认是指首行文字，即 first baseline，所有子容器向基线对齐 // 交叉轴起点到元素基线距离最大的子容器将会与交叉轴起始端相切以确定基线） align-items: stretch; // 默认，如果项目未设置高度或设为 auto，将占满整个容器的高度 //（子容器沿交叉轴方向的尺寸拉伸至与父容器一致）} align-contentalign-content 属性定义了多根轴线的对齐方式，如果项目只有一根轴线，该属性不起作用 简单来说就是当子容器多行排列时，设置行与行之间的对齐方式 12345678.ele{ align-content: flex-start; // 与交叉轴的起点对齐 align-content; flex-end; // 与交叉轴的终点对齐 align-content: center; // 与交叉轴的中点对齐 align-content: space-between; // 与交叉轴两端对齐，轴线之间的间隔平均分布 align-content: space-around; // 每根轴线两侧的间隔都相等，所以，轴线之间的间隔比轴线与边框的间隔大一倍 align-content: stretch; // 默认 轴线占满整个交叉轴} 子容器子容器也有六个属性 order：子容器的排列顺序 flex-grow：子容器剩余空间的拉伸比例 flex-shrink：子容器超出空间的压缩比例 flex-basis：子容器在不伸缩情况下的原始尺寸 flex：flex-grow，flex-shrink 和 flex-basis 的简写 align-self：允许子容器与其他项目采用不一样的对齐方式 orderorder 属性定义项目的排列顺序，可以为负值，数值越小，排列越靠前，默认为 0 123.ele{ order: num; } flex-growflex-grow 属性定义子容器的伸缩比例，按照该比例给子容器分配空间，默认值为 0 123.ele{ flex-grow: &lt;number&gt;;} flex-shrinkflex-shrink 属性定义了子容器弹性收缩的比例，如图，超出的部分按 1: 2 的比例从给子容器中减去 此属性要生效，父容器的 flex-wrap 属性要设置为 nowrap，默认值为 0 123.ele{ flex-shrink: &lt;number&gt;;} flex-basisflex-basis 属性定义了子容器在不伸缩情况下的原始尺寸，主轴为横向时代表宽度，主轴为纵向时代表高度，默认值为 0 123.ele{ flex-basis: &lt;length&gt; | auto;} flex子容器是有弹性的，它们会自动填充剩余空间，子容器的伸缩比例由 flex 属性确定 flex 的值可以是无单位数字（如：1，2，3），也可以是有单位数字（如：15px，30px，60px），还可以是 none 关键字 子容器会按照 flex 定义的尺寸比例自动伸缩，如果取值为 none 则不伸缩 虽然 flex 是多个属性的缩写，允许 1 - 3 个值连用，但通常用 1 个值就可以满足需求，它的全部写法可参考下图 具体取值规则可以参考之前整理的一篇文章 关于子容器属性 flex 取值问题 align-self子容器的 align-self 属性允许单个项目有与其他项目不一样的对齐方式 可覆盖父容器 align-items 属性，如果两者同时设置则以子容器的 align-self 属性为准 默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch 12345678.ele{ align-self: auto; // 继承父元素的 align-items 属性 align-self: flex-start; // 交叉轴的起点对齐 align-self: flex-end; // 交叉轴的终点对齐 align-self: center; // 交叉轴的中点对齐 align-self: baseline; // 项目的第一行文字的基线对齐 align-self: stretch; // 默认，如果项目未设置高度或设为 auto，将占满整个容器的高度} 下面是一张各属性的汇总图 参考 CSS Flexible Box Layout Flex 布局教程：语法篇 Flex 布局学习笔记 30 分钟学会 Flex 布局 弹性盒模型 Flex 指南 grid 布局主要参考的 Learn CSS Grid in 5 minutes 按照惯例，在使用之前我们先来看一下 CSS Grid 的兼容性，如下 可以发现，主流浏览器（Safari，Chrome，Firefox，Edge）的支持还是不错的，那么我们就来看看 CSS Grid 到底是个什么东西 全部示例可见 网格布局 和 网格版圣杯布局 基本概念我们先从一个简单的示例开始，然后在深入了解其中的概念 CSS Grid 布局由两个核心组成部分是 wrapper（父元素）和 items（子元素），wrapper 是实际的 grid（网格），items 是网格内的内容 下面是一个 wrapper 元素，内部包含六个 items 12345678&lt;div class=\"wrapper\"&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt; &lt;div&gt;6&lt;/div&gt;&lt;/div&gt; 要把 wrapper 元素变成一个网格，只要简单地把其 display 属性设置为 grid 即可 123.wrapper { display: grid;} 在这种情况下，我们并没有做其他的操作，它只会简单地将六个 div 堆叠在一起，如下图所示 为了使其成为二维的网格容器，我们需要定义列和行，让我们创建 3 列和 2 行，我们将使用 grid-template-row 和 grid-template-column 属性 12345.wrapper { display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 50px 50px;} 这些值决定了我们希望我们的列有多宽（100px），以及我们希望行数是多高（50px），结果如下 也可以来稍微的调整一下，比如应用以下 CSS 样式 12345.wrapper { display: grid; grid-template-columns: 200px 50px 100px; grid-template-rows: 100px 30px;} 就变成了如下 此时，我们已经了解了 CSS Grid 布局的基本过程，下面我们就来了解一下相应的术语 网格容器（Grid Container）应用 display: grid 的元素，就是所有网格项（grid item）的直接父级元素，在上面的例子中 wrapper 就是网格容器（Grid Container） 123&lt;div class=\"wrapper\"&gt; ...&lt;/div&gt; 网格项（Grid Item）网格容器（Grid Container）的子元素（例如直接子元素），比如下面这里 item 元素就是网格项（Grid Item），但是 sub-item 不是 1234567&lt;div class=\"wrapper\"&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt; &lt;p class=\"sub-item\"&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt;&lt;/div&gt; 网格线（Grid Line）网格线组成了网格，他是网格的水平和垂直的分界线，一个网格线存在行或列的两侧，我们可以引用它的数目或者定义的网格线名称 网格轨道（Grid Track）网格轨道是就是相邻两条网格线之间的空间，就好比表格中行或列，所在在网格中其分为 grid column 和 grid row，每个网格轨道可以设置一个大小，用来控制宽度或高度 网格单元格（Grid Cell）网格单元格是指四条网格线之间的空间，所以它是最小的单位，就像表格中的单元格 网格区域（Grid Area）网格区域是由任意四条网格线组成的空间，所以他可能包含一个或多个单元格，相当于表格中的合并单元格之后的区域 以上就是网格布局中的一些基本概念，下面我们来看具体的操作方法 使用 Grid 布局我们还是在最开始部分的示例之上来进行扩展，首先还是先创建一个 3×3 的网格 需要注意的是，同 flex 布局一样，当元素设置了网格布局之后，元素的 column、float、clear、vertical-align 属性都是无效的 12345678&lt;div class=\"wrapper\"&gt; &lt;div class=\"item1\"&gt;1&lt;/div&gt; &lt;div class=\"item2\"&gt;2&lt;/div&gt; &lt;div class=\"item3\"&gt;3&lt;/div&gt; &lt;div class=\"item4\"&gt;4&lt;/div&gt; &lt;div class=\"item5\"&gt;5&lt;/div&gt; &lt;div class=\"item6\"&gt;6&lt;/div&gt;&lt;/div&gt; 应用的 CSS 代码如下 12345.wrapper { display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px;} 将得到以下布局 细心对比可以发现，我们只在页面上看到 3×2 的网格，而我们定义的则是 3×3 的网格 这是因为我们只有六个子元素来填满这个网格，如果我们再加三个子元素，那么最后一行也会被填满 如果还存在更多的子元素，则是被忽略（即默认是不可见的） 如果要定位和调整子元素大小，我们将使用 grid-column 和 grid-row 属性来设置 1234.item1 { grid-column-start: 1; grid-column-end: 4;} 我们在这里要做的是，我们希望 item1 占据从第一条网格线开始，到第四条网格线结束，换句话说，它将独立占据整行， 以下是在屏幕上显示的内容 可以发现，当我们把第一个子元素设置为占据整个第一行时，它会把剩下的子元素都推到了下一行，至于为什么会有四条网格线，可以参考下面这个图 当然，也可以使用简写方式来实现 123.item1 { grid-column: 1/4;} 下面我们就可以将所有的子元素进行自定义排列 1234567891011121314.item1 { grid-column-start: 1; grid-column-end: 3;}.item3 { grid-row-start: 2; grid-row-end: 4;}.item4 { grid-column-start: 2; grid-column-end: 4;} 也可以采用简写的方式 1234567891011.item1 { grid-column: 1/3;}.item3 { grid-row: 2/4;}.item4 { grid-column: 2/4;} 最终结果如下 我们也可以像 flex 一样设置每一列的宽度 1234.wrapper { grid-template-rows: 50px 100px 60px; grid-template-columns: 1fr 1fr 1fr;} 可以发现，在上面的示例当中我们使用了一个新的单位 fr fr 单位是一个自适应单位，fr 单位被用于在一系列长度值中分配剩余空间，如果多个已指定了多个部分，则剩下的空间根据各自的数字按比例分配 fr 是基于网格容器可用空间来计算的（flex 也是一样），所以我们可以和其他单位混合使用（如果需要的话） 结果如下 也可以利用这个特性来进行单元格的合并 行或列最小和最大尺寸minmax() 函数来创建行或列的最小或最大尺寸，第一个参数定义网格轨道的最小值，第二个参数定义网格轨道的最大值 可以接受任何长度值，也接受 auto 值，auto 值允许网格轨道基于内容的尺寸拉伸或挤压 我们来试试将第一行的高度设置为 minmax(100px, 200px)，第二行的高度设置为 minmax(50px, 200px)，容器总高度设置为 300px，如下 12345.wrapper { height: 300px; grid-template-rows: minmax(100px, 200px) minmax(50px, 200px); grid-template-columns: 1fr 1fr 1fr;} 具体逻辑为：先判断总高度和第一列高度的最大值和第二列高度的最大值之和的两者之间的大小 如果大于，那么第一列和第二列的高度都为设置的最大值 如果是小于，那么第一列和第二列的高度都为设置的最小值 在上面的情况当中是属于小于的情况，所以会先使用总高度减去两列的最小高度得出一个值，在根据这个值来计算最终的高度 总高度 - 第一列最小高度 - 第二列最小高度 = 150px（300px - 100px - 50px = 150px） 第一列高度：第一列最小高度 100px + 150px/2 = 175px 第二列高度：第一列最小高度 50px + 150px/2 = 125px 如下图所示 重复行或者列repeat() 属性可以创建重复的网格轨道，这个适用于创建相等尺寸的网格项目和多个网格项目 repeat() 也接受两个参数：第一个参数定义网格轨道应该重复的次数，第二个参数定义每个轨道的尺寸 简单来说就是简化同样的赋值操作，结果如下图 间距主要使用 grid-column-gap 和 grid-row-gap 两个属性 grid-column-gap：创建列与列之间的距离 grid-row-gap：行与行之间的距离 grid-gap：简写方式，第一个参数为行间距，第二个参数为列间距 1234567891011121314.wrapper { grid-template-rows: 100px 100px; grid-template-columns: 100px 100px 100px; grid-row-gap: 10px; grid-column-gap: 20px;}/* 等同于 ==&gt; */.wrapper { grid-template-rows: 100px 100px; grid-template-columns: 100px 100px 100px; grid-gap: 10px 20px;} 网格区域（grid-template-areas）所谓网格区域（网格区域），简单来说就是一个逻辑空间，主要用来放置一个或多个网格单元格（Grid Cell） 它由四条网格线（Grid line）构成，网格区域每边一条，四边相交组织的网格轨道（Grid Track） 简单点理解，网格区域是有四条网格线交织组成的网格空间，这个空间中可能是一个网格单元格，也可能是多个网格单元格 在 CSS Grid Layout 中定义网格区域有两种方式，一种是通过网格线来定义，另一种是通过 grid-template-areas 来定义 网格线定义网格区域简单来说有下面三个步骤 使用网格线定义网格区域的方法非常的简单，首先依赖于 grid-template-columns 和 grid-template-rows 显式定义网格线，甚至是由浏览器隐式创建网格线 然后通过 grid-area 属性通过取网格线，组成网格线交织区域，那么这个区域就是所讲的网格区域 在使用 grid-area 属性调用网格线，其遵循的取值规则如下 1grid-area: row-start / column-start / row-end / column-end 使用 grid-template-areas 定义网格区域除了使用网格线的交组来定义网格区域之外，在 CSS Grid Layout 中还可以通过 grid-template-areas 属性来定义网格区域的名称，然后需要放在对应网格区域的元素 可以通过 grid-area 属性来指定，而且重复区域可以使用同一个名称来实现跨区域，另外对于空的轨道区域，可以使用点号 . 来代表 具体的使用细节我们就通过下面这个实例来充分的了解一下所谓的网格区域 实例我们要实现的最终结果如下 接下来，我们就一步一步来进行实现 HTML 结构首先我们需要一个容器，如下 123456&lt;div class=\"container\"&gt; &lt;div class=\"header\"&gt;HEADER&lt;/div&gt; &lt;div class=\"menu\"&gt;MENU&lt;/div&gt; &lt;div class=\"content\"&gt;CONTENT&lt;/div&gt; &lt;div class=\"footer\"&gt;FOOTER&lt;/div&gt;&lt;/div&gt; 设置基本的 CSS在来设置一些基本的 CSS 123456.container { display: grid; grid-template-columns: repeat(12, 1fr); grid-template-rows: 50px 350px 50px; grid-gap: 5px;} 经过前面的一些铺垫，这里应用的 CSS 应该很容易理解 使用 grid-template-columns 属性创建一个 12 列的网格，每个列都是一个单位宽度（总宽度的 1/12 ） 使用 grid-template-rows 属性创建 3 行，第一行高度是 50px ，第二行高度是 350px 和第三行高度是 50px 最后，使用 grid-gap 属性在网格中的网格项之间添加一个间隙 添加 grid-template-areas下面就是重点部分，来添加我们的网格区域，简单来说也就是定义 grid-template-areas 属性 12345678910.container { display: grid; grid-gap: 5px; grid-template-columns: repeat(12, 1fr); grid-template-rows: 50px 350px 50px; grid-template-areas: \"h h h h h h h h h h h h\" \"m m c c c c c c c c c c\" \"f f f f f f f f f f f f\";} grid-template-areas 属性背后的逻辑是你在代码中创建的网格可视化表示，正如所见，它有 3 行 12 列，和我们在 grid-template-columns 和 grid-template-rows 中定义的正好呼应 每行代表一行，用网格术语来说是 网格轨道（Grid Track） ，每个字符（h，m，c，f）代表一个网格单元格，四个字母中的每一个现在都形成一个矩形 grid-area（当然你也可以使用自定义字符） 给网格项设定网格区域名称现在我们需要将这些字符与网格中的网格项建立对应的连接，要做到这一点，我们将在网格项使用 grid-area 属性 123456789101112.header { grid-area: h;}.menu { grid-area: m;}.content { grid-area: c;}.footer { grid-area: f;} 最终的结果如下（添加了一些额外的 CSS 样式用于展示） 尝试其他布局现在，我们可以探讨一下使用网格布局的精妙之处，因为我们可以很容易地对布局进行修改尝试，只需修改 grid-template-areas 属性的字符即可，举个例子，比如把 menu 移到右边 123456.wrapper { grid-template-areas: \"h h h h h h h h h h h h\" \"c c c c c c c c c c m m\" \"f f f f f f f f f f f f\";} 可以使用点 . 来创建空白的网格单元格 123456.wrapper { grid-template-areas: \". h h h h h h h h h h .\" \"c c c c c c c c c c m m\" \". f f f f f f f f f f .\";} 还可以添加响应式布局 12345678@media screen and (max-width: 640px) { .container { grid-template-areas: \"m m m m m m h h h h h h\" \"c c c c c c c c c c c c\" \"f f f f f f f f f f f f\"; }} 最终结果如下 参考 CSS Grid Layout Learn CSS Grid in 5 minutes A Complete Guide to Grid Learn to prototype websites quickly with CSS Grid 未来布局之星Grid Don’t use flexbox for overall page layout 原生CSS网格布局学习笔记","link":"/2019/09/12/CSS/12/"},{"title":"IntersectionObserver","text":"按照惯例，我们先来看看 IntersectionObserver 到底是个什么东西，MDN 上的介绍如下 IntersectionObserver 接口（从属于 Intersection Observer API），提供了一种异步观察目标元素与其祖先元素或顶级文档视窗（viewport）交叉状态的方法，祖先元素与视窗（viewport）被称为根（root） 当一个 IntersectionObserver 对象被创建时，其被配置为监听根中一段给定比例的可见区域，一旦 IntersectionObserver 被创建，则无法更改其配置 所以一个给定的观察者对象只能用来监听可见区域的特定变化值，然而你可以在同一个观察者对象中配置监听多个目标元素 看上去云里雾里的，其实简单的总结一下，所谓的 IntersectionObserver 说的就是一种监听目标元素与其祖先或视窗交叉状态的手段，也就是观察一个元素是否在视窗可见 如上图，交叉了就是说明当前元素在视窗里，当前就是可见的了 但是有一点特别需要注意的就是：必须是子元素跟父（祖先）元素发生交叉，如果你想检查两个非父子关系的交叉，是不可以的 本文所有示例可见 IntersectionObserver 基本概念先来看看如何使用，使用方式很简单 1234const io = new IntersectionObserver(callback, options)io.observe(element) // 观察元素io.unobserve(element) // 停止观察io.disconnect() // 关闭观察器 下面我们就来详细介绍具体的配置参数 构造函数1new IntersectionObserver(callback, options) 其实就是一个简单的构造函数，它会返回一个 IntersectionObserver 实例，接收两个参数 callback，是当元素的可见性变化时候的回调函数 options，是一些配置项（可选的） callback当元素的可见性变化时，就会触发 callback 函数，callback 函数会触发两次，元素进入视窗（开始可见时）和元素离开视窗（开始不可见时）都会触发 它接受一个 entries 参数，返回当前已监听并且发生了交叉的目标集合 12345var io = new IntersectionObserver((entries) =&gt; { console.log(entries)})io.observe(document.body) 运行结果如下（$0 表示上一次审查元素的选择的节点） 我们可以看到 callback 函数有个 entries 参数，它是个 IntersectionObserverEntry 对象数组，各个属性如下 属性 解释 boundingClientRect 目标元素的矩形信息 intersectionRatio 相交区域和目标元素的比例值 intersectionRect/boundingClientRect，不可见时小于等于 0 intersectionRect 目标元素和视窗（根）相交的矩形信息，可以称为相交区域 isIntersecting 目标元素当前是否可见值，如果可见则为 true rootBounds 根元素的矩形信息，没有指定根元素就是当前视窗的矩形信息 target 观察的目标元素 time 返回一个记录从 IntersectionObserver 的时间到交叉被触发的时间的时间戳 如下图所示 下面再来看看第二个参数，options options几个比较常用的参数如下 root用于观察的根元素，默认是浏览器的视口，也可以指定具体元素，指定元素的时候用于观察的元素必须是指定元素的子元素 threshold用来指定交叉比例，决定什么时候触发回调函数，是一个数组，默认是 [0] 1234567const options = { root: null, threshold: [0, 0.5, 1]}var io = new IntersectionObserver(callback, options)io.observe(document.querySelector('img')) 上面代码，我们指定了交叉比例为 [0, 0.5, 1]，当观察元素 img 处于 0%、50%、100% 时候就会触发回调函数 rootMargin用来扩大或者缩小视窗的的大小，使用 CSS 的定义方法，10px 10px 30px 20px 表示 top、right、bottom 和 left 的值 12345const options = { root: document.querySelector('.box'), threshold: [0, 0.5, 1], rootMargin: '30px 100px 20px'} 为了方便理解，可以参考下图 首先我们先来看看上图当中的蓝线部分，它就是我们定义的 root 元素，我们添加了 rootMargin 属性，将视窗的增大了，虚线就是现在的视窗，所以元素现在也就在视窗里面了，简单来说就是自定义元素进入视窗的距离 由此可见，root 元素只有在 rootMargin 为空的时候才是绝对的视窗 实际应用在了解完 IntersectionObserver 的相关概念之后，我们来看几个具体的实例，本文所有示例可见 IntersectionObserver 监听元素先来看一个最简单的示例，主要代码如下 123456789let box = document.querySelector('.box')let observe = new IntersectionObserver(entries =&gt; { entries.forEach(item =&gt; { let tips = item.isIntersecting ? `进入` : `离开` console.log(tips) })})observe.observe(box) 结果如下图所示 打开控制台可以发现，每次当元素进入或者离开可视区的时候，控制台当中就会输出对应的字段 我们再来稍微的调整一下，将一个元素替换为多个元素，代码如下 1234let box02 = document.querySelectorAll('.box')let observe02 = new IntersectionObserver(entries =&gt; console.log(`发生交叉行为，目标元素个数为 ${entries.length} 个`))box02.forEach(item =&gt; observe02.observe(item)) 结果如下图所示 根据上图可以发现，虽然元素变成了三个，但是每次发生交叉的时候是一起发生的 再来调整一下，同样还是三个元素，但是排列方式不一样，结果如下图所示 可以发现，在这种情况之下每个目标轮流发生交叉，且当前只触发了一个，所以每次返回的集合长度只有一 如果想指定监听父元素，可以使用 root 参数 1234567891011let box = document.querySelector('.box')let observe = new IntersectionObserver(entries =&gt; { entries.forEach(item =&gt; { let tips = item.isIntersecting ? `进入` : `离开` console.log(tips) })}, { root: document.querySelector('.wrapper')})observe.observe(box) 现在我们已经基本了解了 IntersectionObserver 的一些基本用法，下面我们就来看一些实际场景当中的应用 图片懒加载以前的做法是监听浏览器滚动，然后遍历拿到每个图片的空间信息，然后判断一些位置信息从而进行图片加载，而现在只需要交给交叉观察者去做，页面布局如下 12&lt;!-- 多个 img 元素 --&gt;&lt;img src=\"https://via.placeholder.com/200x130\" data-origin=\"图片真实地址\"&gt; 然后针对图片列表进行监听 123456789101112let images = document.querySelectorAll('img')let observe = new IntersectionObserver(entries =&gt; { entries.forEach(item =&gt; { // 如果目标元素当前可见，则加载图片资源 if (item.isIntersecting) { item.target.src = item.target.dataset.origin observe.unobserve(item.target) } })})images.forEach(item =&gt; observe.observe(item)) 效果如下，只有当对应图片进入可视区以后才会进行加载 也可以通过设置 rootMargin，来自定义图片进入视窗多少距离以后在进行加载 另外，使用该方法如果是横向滚动懒加载一样是可以使用的 传统的懒加载只是监听全局滚动条的滚动，因为它并不是判断目标是否出现在视窗，所以横向的图片会一起加载，即使你没有向左滑动，所以这也是交叉观察者的一大优点 触底使用交叉观察者可以让我们轻松实现滚动到底部自定加载的功能，我们首先在列表底部放一个参照元素，然后使用交叉观察者去监听，布局如下 1234567891011121314&lt;div class=\"box\"&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt; &lt;li&gt;8&lt;/li&gt; &lt;/ul&gt; &lt;!-- 参照元素 --&gt; &lt;div class=\"footer\"&gt;&lt;/div&gt;&lt;/div&gt; class 为 footer 的元素就作为我们的参照元素，下面就可以对其进行监听 123456new IntersectionObserver(entries =&gt; { // 这里使用 forEach 也可，但是我们的示例只有一个，直接使用也行 if (entries[0].isIntersecting) { console.log(`滚动到了底部！`) }}).observe(document.querySelector('.footer')) 结果如下 动画展示一个比较常见的效果，即当某个元素或者列表出现的时候就给该元素或者列表加个动画，比如渐变、偏移等，下面我们就来实现看看 首先是页面布局，跟上面的示例其实差不多，但是这里采用两列，主要 CSS 如下 1234567891011121314151617181920212223242526272829li.show { animation: left 1s ease;}li.show:nth-child(2n) { animation: right 1s ease;}@keyframes left { from { opacity: 0; transform: translate(-40px, 40px); } to { opacity: 1; }}@keyframes right { from { opacity: 0; transform: translate(40px, 40px); } to { opacity: 1; }} 最终效果如下 兼容性IntersectionObserver 的兼容性可见下图 从上图可以发现，IE 是不兼容的，但是官方提供了 polyfill，详细可见 w3c - IntersectionObserver 参考 Intersection Observer Intersection Observer API IntersectionObserver API 使用教程 Intersection Observer v2 IntersectionObserver","link":"/2019/09/22/JavaScript/58/"},{"title":"CSS 中一些小技巧汇总","text":"之前整理过 JavaScript 中一些常用方法的实现，这次就来整理一下 CSS 当中一些小技巧 部分内容参考自 30-seconds-of-css 清除浮动更好的方式无需借助辅助元素进行浮动的清除，一般在 float 布局当中才会使用，不过在实际场景中还是推荐使用 flexbox 布局或者网格布局 12345&lt;div class=\"clearfix\"&gt; &lt;div class=\"item\"&gt;1&lt;/div&gt; &lt;div class=\"item\"&gt;2&lt;/div&gt; &lt;div class=\"item\"&gt;3&lt;/div&gt;&lt;/div&gt; 123456789.clearfix::after { content: ''; display: block; clear: both;}.item { float: left;} 不变宽高比（等比）示例可见 不变宽高比（等比） 给定宽度可变的元素，它将确保其高度以响应方式保持成比例（即其宽高比保持不变） 1&lt;div class=\"box\"&gt;&lt;/div&gt; 12345678910111213141516.box { width: 50%; background: rgb(66, 201, 201);}.box::before { content: ''; padding-top: 100%; float: left;}.box::after { content: ''; display: block; clear: both;} ::before，为元素定义一个伪元素 padding-top: 100%，设置伪元素的内上边距，百分比的值是按照宽度计算的，所以元素是响应式的 此方法还允许将内容正常放置在元素内 图片在容器中自适应示例可见 图片在容器中自适应 设置图像在其容器内的适合度和位置，同时保留其宽高比，等同于 background-size 的效果，但是其可以直接作用于 img 标签上 1&lt;img src=\"https://gitee.com/heptaluan/backups/raw/master/cdn/cover/81.jpg\"&gt; 123456789img { object-fit: contain; object-position: center;}img { object-fit: cover; object-position: right top;} object-fit: contain，容器内显示整个图像，并且保持宽高比 object-fit: cover，用图像填充容器，并保持宽高比 object-position: [x] [y]，对图像的显示部位进行调整 将元素垂直居中于另一个元素示例可见 将元素垂直居中于另一个元素 123&lt;div class=\"center\"&gt; &lt;p&gt;这是一段测试文本（深色区域是由我撑开的）&lt;/p&gt;&lt;/div&gt; 123456789101112131415161718.center { height: 150px; background: rgb(11, 121, 121);}.center::before { content: ''; display: inline-block; height: 100%; vertical-align: middle;}.center p { display: inline-block; vertical-align: middle; font-size: 14px; color: #fff;} 使两个元素在水平方向上垂直对齐，不设置前者的宽度，而是设置高度为 100% 使其保持与容器一致的高度 尝试给 .center::before 添加一点宽度并且设置一个背景色就很明了了 使用 :before 伪元素的样式垂直对齐内联元素而不更改其 position 属性 最后一项占满剩余高度示例可见 最后一项占满剩余高度 通过为最后一个元素提供当前视口中剩余的可用空间，即使在调整窗口大小时，也可以利用可用的视口空间 12345&lt;div class=\"wrapper\"&gt; &lt;div class=\"header\"&gt;Header&lt;/div&gt; &lt;div class=\"content\"&gt;Content&lt;/div&gt; &lt;div class=\"footer\"&gt;Footer&lt;/div&gt;&lt;/div&gt; 123456789.wrapper { height: 100%; display: flex; flex-direction: column;}.wrapper &gt; div:last-child { flex: 1;} display: flex，启用 flex flex-direction: column，将项目的顺序设置成从上到下 flex-grow: 1，flexbox 会将容器的剩余可用空间应用于最后一个子元素，父级必须具有视口高度 flex-grow：1 可以应用于第一个或第二个元素，它将具有所有可用空间 列表计数器示例可见 列表计数器 计数器本质上是由 CSS 维护的变量，其值可以通过 CSS 规则递增以跟踪它们被使用的次数 123456789101112&lt;ul&gt; &lt;li&gt;List item&lt;/li&gt; &lt;li&gt;List item&lt;/li&gt; &lt;li&gt; List item &lt;ul&gt; &lt;li&gt;List item&lt;/li&gt; &lt;li&gt;List item&lt;/li&gt; &lt;li&gt;List item&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt;&lt;/ul&gt; 12345678ul { counter-reset: counter;}li::before { counter-increment: counter; content: counters(counter, '.') ' ';} 可以使用任何类型的 html 标签创建有序列表 counter-reset，初始化计数器，该值是计数器的名称，默认情况下计数器从 0 开始，此属性还可用于将其值更改为任何特定数字 counter-increment，用于可数的元素，一旦计数器重置初始化，计数器的值可以增加或减少 counter(name, style)，显示节计数器的值，通常用于内容属性，此函数可以接收两个参数，第一个作为计数器的名称，第二个参数表示占位内容 CSS 计数器对于制作轮廓列表特别有用，因为计数器的新实例是在子元素中自动创建的，使用 counters() 函数，可以在不同级别的嵌套计数器之间插入分隔文本 创建动态阴影示例可见 创建动态阴影 创建类似于 box-shadow 的阴影，但基于元素本身的颜色 1&lt;div class=\"box\"&gt;&lt;/div&gt; 12345678910111213141516171819.box { width: 200px; height: 200px; position: relative; z-index: 1; background: linear-gradient(75deg, #6d78ff, #00ffb8);}.box::after { content: ''; width: 100%; height: 100%; position: absolute; background: inherit; top: 10px filter: blur(8px); opacity: .7; z-index: -1;} ::after，定义一个伪元素 position: absolute，使伪元素脱离文档流并相对于父级定位 width/height: 100%，对伪元素进行大小调整以填充其父元素的大小，使其大小相等 background: inherit，使伪元素继承父级的线性渐变 top: 10px，将伪元素相对于其父元素略微偏移 filter: blur(8px)，设置伪元素模糊效果，以创建下方阴影效果 opacity: 0.7，设置伪元素透明度 z-index: -1，将伪元素定位在父元素后面但在背景前面 鼠标悬停渐变效果示例可见 鼠标悬停渐变效果 一种鼠标悬停效果，其中渐变跟随鼠标光标 123&lt;button&gt; &lt;span&gt;Hover me&lt;/span&gt;&lt;/button&gt; 12345678910111213141516171819202122232425262728293031323334button { position: relative; background: #6d78ff; padding: 20px 70px; border: none; color: white; font-size: 22px; cursor: pointer; outline: none; overflow: hidden; border-radius: 10px;}span { position: relative; pointer-events: none;}button::before { --size: 0; content: ''; position: absolute; left: var(--x); top: var(--y); width: var(--size); height: var(--size); background: radial-gradient(circle closest-side, #00ffb8, transparent); transform: translate(-50%, -50%); transition: width .2s ease, height .2s ease;}button:hover::before { --size: 300px;} 123456document.querySelector('button').onmousemove = (e) =&gt; { const x = e.pageX - e.target.offsetLeft const y = e.pageY - e.target.offsetTop e.target.style.setProperty('--x', `${x}px`) e.target.style.setProperty('--y', `${y}px`)} 利用伪元素来达到渐变效果，使其显示位置与鼠标悬停位置一致 var() 函数可以代替元素中任何属性中的值的任何部分 重置所有样式示例可见 重置所有样式 使用一个属性将所有样式重置为默认值，这不会影响 direction 和 unicode-bidi 属性 1234&lt;div class=\"box\"&gt; &lt;p&gt;这是一段测试文本（这一段文本属性没有被重置，默认使用的继承过来的属性）&lt;/p&gt; &lt;p&gt;这是一段测试文本（这一段文本属性已被重置，使用控制台可以发现继承过来的属性均已重置）&lt;/p&gt;&lt;/div&gt; 123.box p:last-child { all: initial;} all 属性允许您将所有样式（继承或不继承）重置为默认值 形状分隔符示例可见 形状分隔符 使用 SVG 形状分割两个不同的块以创建更有趣的视觉外观 1&lt;div class=\"box\"&gt;&lt;/div&gt; 12345678910111213.box { position: relative; height: 50px;}.box::after { content: ''; background-image: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 12'%3E%3Cpath d='m12 0l12 12h-24z' fill='%23fff'/%3E%3C/svg%3E\"); position: absolute; width: 100%; height: 12px; bottom: 0;} background-image: url()，添加 SVG 形状作为伪元素的背景图像，默认情况下重复，它必须与要分割的块颜色相同 如果想使用其他图形，可以使用 URL-encoder for SVG 滑动开关示例可见 滑动开关 可以依靠纯 CSS 来实现一个 Switch 滑动开关效果 1&lt;input type=\"checkbox\" id=\"checkbox\" /&gt; &lt;label for=\"checkbox\" class=\"switch\"&gt;&lt;/label&gt; 123456789101112131415161718192021222324252627282930313233343536.switch { position: relative; display: inline-block; width: 60px; height: 30px; background-color: rgba(0, 0, 0, 0.25); border-radius: 20px; cursor: pointer; transition: all 0.3s;}.switch::after { content: ''; position: absolute; width: 28px; height: 28px; border-radius: 18px; background-color: white; top: 1px; left: 1px; transition: all 0.3s;}input[type=\"checkbox\"]:checked + .switch::after { transform: translateX(30px);}input[type=\"checkbox\"]:checked + .switch { background-color: #499AFF;}input[type=\"checkbox\"] { border: 0; width: 0; height: 0;} 利用 input 的 checkbox 的特性来实现整个效果 使用 switch::after 来实现开关外形 在 input:checked 状态下动态调整 switch::after 的位置 最后将 input 隐藏掉，只使用 label 来进行关联 画一个三角形示例可见 画一个三角形 1&lt;div class=\"box\"&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354.box01 { width: 0; height: 0; border-top: 30px solid #499AFF; border-left: 30px solid transparent; border-right: 30px solid transparent;}.box02 { width: 0; height: 0; border-right: 30px solid #499AFF; border-top: 30px solid transparent; border-bottom: 30px solid transparent;}.box03 { width: 0; height: 0; border-bottom: 30px solid #499AFF; border-left: 30px solid transparent; border-right: 30px solid transparent;}.box04 { width: 0; height: 0; border-left: 30px solid #499AFF; border-top: 30px solid transparent; border-bottom: 30px solid transparent;}.box05 { width: 0; height: 0; border-bottom: 50px solid #499AFF; border-left: 30px solid transparent; border-right: 30px solid transparent;}.box06 { width: 30px; height: 30px; border-top: 2px solid #499AFF; border-right: 2px solid #499AFF;}.box07 { width: 30px; height: 30px; border-top: 2px solid #499AFF; border-right: 2px solid #499AFF; transform: rotate(45deg);} 将高度和宽度设为 0，剩下四个边框，再将某一方向边框去掉，除开对应的一边，将另外两边设置为透明即可 如果需要调整角度，在上面基础之上调整对应宽度即可 如果需要空心箭头，设置夹角两边边框即可，方向可以根据需要进行调整 斑马线效果示例可见 斑马线效果 1&lt;div class=\"box\"&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526.box01 { width: 100%; height: 20px; background-color: #499AFF; background-image: linear-gradient(45deg, hsla(0, 0%, 100%, .15) 25%, transparent 0, transparent 50%, hsla(0, 0%, 100%, .15) 0, hsla(0, 0%, 100%, .15) 75%, transparent 0, transparent); background-size: 36px 36px;}.box02 { width: 100%; height: 20px; background-color: #499AFF; background-image: linear-gradient(45deg, hsla(0, 0%, 100%, .15) 25%, transparent 0, transparent 50%, hsla(0, 0%, 100%, .15) 0, hsla(0, 0%, 100%, .15) 75%, transparent 0, transparent); background-size: 36px 36px; animation: progress-bar-stripes 2s linear infinite;}@keyframes progress-bar-stripes { from { background-position: 36px 0; } to { background-position: 0 0; }} 利用 background-image 的 linear-gradient() 函数创建斑马线 如果想让其运动起来，添加动画效果改变其 background-position 位置即可 加载动画示例可见 加载动画 例一 12345&lt;div class=\"box\"&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930.box { height: 80px; display: flex; justify-content: center; align-items: center;}.box &gt; div { width: 12px; height: 12px; margin: 15px 8px; background: #fff; border-radius: 50%; animation: loading .6s infinite alternate}.box &gt; div:nth-child(2) { animation-delay: .2s;}.box &gt; div:nth-child(3) { animation-delay: .4s;}@keyframes loading { to { opacity: 0.1; transform: translate3d(0, -10px, 0); }} 例二 123&lt;div class=\"box\"&gt; &lt;div class=\"loading\"&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526@keyframes loading { from { transform: rotate(0deg); } to { transform: rotate(360deg); }}.box { height: 80px; background: #499AFF; display: flex; justify-content: center; align-items: center;}.box .loading { width: 20px; height: 20px; border: 2px solid #f3f3f3; border-top: 2px solid #00ffb8; border-radius: 50%; animation: loading 3s infinite linear;} 两者原理一致，使用 @keyframes 来定义动画效果，使元素在竖直方向上运动 使用 animation-delay 延迟执行来达到交替的效果 如果设定了元素的 border-radius，则 border-top 会显示为弧形 按钮边框动画示例可见 按钮边框动画 例一 123&lt;div class=\"box\"&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142button { padding: 15px 50px; outline: none; border: none; position: relative; background: #499AFF; cursor: pointer; color: #fff; transition: all .3s;}button::before,button::after { border: 0 solid transparent; transition: all .3s; position: absolute; content: ''; height: 24px; width: 24px;}button::before { border-top: 2px solid rgb(41, 137, 255); left: 0; top: -8px;}button::after { border-bottom: 2px solid rgb(41, 137, 255); right: 0; bottom: -8px;}button:hover { background: rgb(41, 137, 255);} button:hover::before,button:hover::after { width: 100%; height: 100%;} 例二 12345&lt;div class=\"box\"&gt; &lt;button&gt;提交&lt;/button&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152.box { position: relative; overflow: hidden;}.box div { transition: all .35s; cursor: pointer;}.box div:nth-of-type(1) { width: 126px; height: 50px; border: solid #499AFF; border-width: 0 2px; position: absolute; left: 0; top: 0; transform: translate(0, -200px);}.box div:nth-of-type(2) { width: 130px; height: 46px; border: solid #499AFF; border-width: 2px 0; position: absolute; left: 0px; top: 0; transform: translate(-200px, 0);}.box button { width: 130px; height: 50px; outline: none; border: none; position: relative; background: #ccc; cursor: pointer; transition: all .3s;}.box:hover button { background: rgb(187, 187, 187);}.box:hover div:nth-of-type(1),.box:hover div:nth-of-type(2) { transform: translate(0, 0);} 两个示例的原理是一致的，均是使用 :before 和 :after 伪元素作为在悬停时设置动画的边框 悬停下滑线动画示例可见 悬停下滑线动画 当文本悬停时，创建文本下划线动画效果 1&lt;p&gt;这是一段测试文本&lt;/p&gt; 123456789101112131415161718192021222324p { display: inline-block; color: #fff; position: relative; font-size: 16px;}p:after { content: ''; position: absolute; width: 100%; transform: scaleX(0); height: 2px; bottom: -2px; left: 0; background: #fff; transform-origin: bottom right; transition: transform .3s ease-out;}p:hover::after { transform: scaleX(1); transform-origin: bottom left;} display: inline-block，使 p 成为内联块，以防止下划线跨越整行宽度而不仅仅是文本内容 transform: scaleX(0)，最初将伪元素缩放为 0，因此是看不见的 bottom: 0 and left: 0，将伪元素放在父元素的左下角 transition: transform 0.25s ease-out，设置动画效果为 ease-out，并且在 0.25 秒内完成 transform-origin: bottom right，变换中心点到父元素的右下角 :hover::after，然后使用 scaleX(1) 将宽度转换为 100％，然后将中心点更改为左下角，允许它在悬停时从另一个方向转换出来 兄弟元素淡化示例可见 兄弟元素淡化 悬停时兄弟节点淡化显示 1234567&lt;ul class=\"box\"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt;&lt;/ul&gt; 1234567891011121314151617181920212223242526.box { width: 100%; height: 80px; display: flex; justify-content: center; align-items: center; flex-direction: row;}li { list-style: none; width: 50px; height: 50px; line-height: 50px; text-align: center; font-size: 16px; margin: 0 20px; background: #499AFF; color: #fff; transition: opacity .3s; cursor: pointer;}.box:hover li:not(:hover) { opacity: 0.5;} transition: opacity 0.2s，设置 0.2 秒的淡化动画 .box:hover li:not(:hover)，当父级悬停时，选择当前未悬停的 li 子项并将其透明度更改为 0.5","link":"/2019/09/27/CSS/13/"},{"title":"EventEmitter","text":"在 Node.js 当中许多对象都会分发事件，比如一个 net.Server 对象会在每次有新连接时触发一个事件，一个 fs.readStream 对象会在文件被打开的时候触发一个事件，然而所有这些产生事件的对象都是 events.EventEmitter 的实例 本文的主要构成主要分为下面几部分，首先先介绍一下 EventEmitter 类，然后简单的过一遍源码，最后在自己动手来实现一个简单的 EventEmitter 模块 下面我们就一步一步来实现 EventEmitter 类events 模块只提供了一个对象：events.EventEmitter，其核心就是事件触发与事件监听器功能的封装 你可以通过 require('events') 来访问该模块，如下 12345// 引入 events 模块var events = require('events')// 创建 eventEmitter 对象var eventEmitter = new events.EventEmitter() EventEmitter 对象如果在实例化时发生错误，会触发 error 事件，关于 EventEmitter 里面的 error 事件有一点需要注意的地方 EventEmitter 即使绑定了 error 事件也是不会输出的，而是会在控制台打印该异常的堆栈信息，并结束进程，获取异常只能通过 try catch，如下 123eventEmitter.on('error', function (err) { console.error('Error:', err);}); 经过测试可以发现，绑定 error 事件只能自己触发，比如使用 eventEmitter.emit('error') 当没有错误时，会在控制台打印 Error：undefined，而当有错误时不会打印而是直接打印该异常的堆栈信息，并结束进程 关于 EventEmitter 模块的异常处理可见 EventEmitter 模块的异常处理 当添加新的监听器时，newListener 事件会触发，当监听器被移除时，removeListener 事件被触发（这两个是 Node.js 的 EventEmitter 模块自带的特殊事件） 以上就是 EventEmitter 的简单使用方式，但是在深入了解 EventEmitter 之前，我们先来了解一些前置知识 观察者模式源码部分主要参考 深入 EventEmitter 观察者模式是软件设计模式的一种，在此种模式中，一个目标对象管理所有相依于它的观察者对象，并且在它本身的状态改变时主动发出通知，这通常透过呼叫各观察者所提供的方法来实现，此种模式通常被用来实时事件处理系统 —— 维基百科 EventEmitter 本质上是一个观察者模式的实现，所谓观察者模式 它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己 我们可以使用日常生活中，期刊订阅的例子来形象地解释一下上面的概念，期刊订阅包含两个主要的角色：期刊出版方和订阅者，它们之间的关系如下 期刊出版方 - 负责期刊的出版和发行工作 订阅者 - 只需执行订阅操作，新版的期刊发布后，就会主动收到通知，如果取消订阅，以后就不会再收到通知 在观察者模式中也有两个主要角色：观察者和被观察者，它们之间的关系图如下 观察者模式优缺点优点： 支持简单的广播通信，自动通知所有已经订阅过的对象 目标对象与观察者之间的抽象耦合关系能够单独扩展以及重用 缺点： 如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃 观察者模式的应用最常见的例子就是为 DOM 对象添加事件监听 1&lt;button id=\"btn\"&gt;确认&lt;/button&gt; 12345function clickHandler(event) { console.log('按钮已点击!');}document.getElementById('btn').addEventListener('click', clickHandler); 当按钮在点击当同时会触发我们事先绑定好的事件 clickHandler，会在控制台打印出 按钮已点击! 字样 发布/订阅模式 在软件架构中，发布-订阅是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者），而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在，同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者（如果有的话）存在，—— 维基百科 发布/订阅模式与观察者模式非常类似，它们最大的区别是： 发布者和订阅者不知道对方的存在 它们之间需要一个第三方组件，叫做信息中介，它将订阅者和发布者串联起来，它过滤和分配所有输入的消息 发布/订阅模式用来处理不同系统组件的信息交流，即使这些组件不知道对方的存在 那么信息中介是如何过滤消息呢？在发布/订阅模型中，订阅者通常接收所有发布的消息的一个子集，选择接受和处理的消息的过程被称作过滤，有两种常用的过滤形式：基于主题的和基于内容的 在基于主题的系统中，消息被发布到主题或命名通道上，订阅者将收到其订阅的主题上的所有消息，并且所有订阅同一主题的订阅者将接收到同样的消息，发布者负责定义订阅者所订阅的消息类别， 在基于内容的系统中，订阅者定义其感兴趣的消息的条件，只有当消息的属性或内容满足订阅者定义的条件时，消息才会被投递到该订阅者，订阅者需要负责对消息进行分类， 一些系统支持两者的混合：发布者发布消息到主题上，而订阅者将基于内容的订阅注册到一个或多个主题上，基于主题的通信基础结构图如下： 最后我们再来总结一下观察者模式与发布/订阅模式之间的区别 观察者模式 vs 发布/订阅模式 根据图片可知，两者的区别如下 在观察者模式中，观察者知道 Subject 的存在，Subject 一直保持对观察者进行记录，然而，在发布/订阅模式中，发布者和订阅者不知道对方的存在，它们只有通过信息中介进行通信 在发布订阅模式中，组件是松散耦合的，正好和观察者模式相反 观察者模式大多数时候是同步的，比如当事件触发 Subject 就会去调用观察者的方法，而发布/订阅模式大多数时候是异步的（使用消息队列） 下面我们就来正式的看一看 Node.js 当中的 EventEmitter 模块 EventEmitter在 Node.js 当中，大多数的核心 API 都采用惯用的异步事件驱动架构，所有能触发事件的对象都是 EventEmitter 类的实例 这些对象开放了一个 eventEmitter.on() 函数，允许将一个或多个函数绑定到会被对象触发的命名事件上 当 EventEmitter 对象触发一个事件时，所有绑定在该事件上的函数都被同步地调用， 监听器的返回值会被丢弃 本文主要介绍以下几个核心方法 on(event, listener) 为指定事件添加一个监听器到监听器数组的尾部（还有一个 addListener 方法，本质与 on 是一致的，见下方） emit(event, [arg1], [arg2], [...]) 按监听器的顺序执行执行每个监听器，如果事件有注册监听返回 true，否则返回 false once(event, listener) 为指定事件注册一个单次监听器，即监听器最多只会触发一次，触发后立刻解除该监听器 removeListener(event, listener) 移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器，它接受两个参数，第一个是事件名称，第二个是回调函数名称 EventEmitter 基本使用我们首先先来看一个最基本的 EventEmitter 功能，包含了一个观察者和一个被监听的对象，对应的实现就是 EventEmitter 中的 on 和 emit 1234567891011const EventEmitter = require('events');class MyEmitter extends EventEmitter { }const myEmitter = new MyEmitter();myEmitter.on('event', () =&gt; { console.log('触发了一个事件！');});myEmitter.emit('event'); 我们自定义 MyEmitter 类，该类继承于 EventEmitter 类，接着我们通过使用 new 关键字创建了 myEmitter 实例，然后使用 on() 方法监听 event 事件，最后利用 emit() 方法触发 event 事件 EventEmitter 构造函数源码可见 EventEmitter.init.call(this)，如下 123456789function EventEmitter() { EventEmitter.init.call(this);}EventEmitter.usingDomains = false;EventEmitter.prototype._events = undefined; // 事件对象（保存指定的事件类型与对应的监听器）EventEmitter.prototype._eventsCount = 0; // 事件数EventEmitter.prototype._maxListeners = undefined; // 最大的监听器数 在 EventEmitter 构造函数内部，会调用 EventEmitter.init 方法执行初始化操作，EventEmitter.init 的具体实现如下 1234567EventEmitter.init = function () { if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) { this._events = Object.create(null); this._eventsCount = 0; } this._maxListeners = this._maxListeners || undefined;}; 在 EventEmitter.init 内部，会根据条件执行初始化操作，这里有一个比较重要的操作 this._events = Object.create(null) 那么问题来了，为什么要使用 Object.create(null) 来初始化一个新对象而不用更简洁的 {} 呢？ 简单来说，两者的区别可见下图所示 对比可以发现，使用 create 创建的对象，没有任何属性，可以把它当作一个非常纯净的 map 来使用，可以自己定义 hasOwnProperty、toString 方法而不必担心会将原型链上的同名方法覆盖掉 on()源码可见 EventEmitter.prototype.addListener，如下 12345EventEmitter.prototype.addListener = function addListener(type, listener) { return _addListener(this, type, listener, false);};EventEmitter.prototype.on = EventEmitter.prototype.addListener; 通过源码可以发现，其实 EventEmitter 实例上的 addListener 和 on 方法均是调用的 _addListener() 方法 下面我们就来看看 _addListener 的具体实现（这里只截取了一些主要实现部分） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 接收四个参数，依次为// target EventEmitter 实例// type 事件类型// listener 事件监听器// prepend 是否添加在前面function _addListener(target, type, listener, prepend) { var m; var events; var existing; // 这个方式是用于检查监听器是否为函数，如果不是就抛出一个错误 checkListener(listener); events = target._events; // 如果未定义，则使用 Object.create(null) 创建一个纯粹的空对象 if (events === undefined) { events = target._events = Object.create(null); target._eventsCount = 0; } else { // To avoid recursion in the case that type === \"newListener\"! Before // adding it to the listeners, first emit \"newListener\". if (events.newListener !== undefined) { target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the // this._events to be assigned to a new object events = target._events; } existing = events[type]; } if (existing === undefined) { // Optimize the case of one listener. Don't need the extra array object. events[type] = listener; ++target._eventsCount; } else { if (typeof existing === 'function') { // Adding the second element, need to change to array. existing = events[type] = prepend ? [listener, existing] : [existing, listener]; // If we've already got an array, just append. } else if (prepend) { existing.unshift(listener); } else { existing.push(listener); } // Check for listener leak m = _getMaxListeners(target); if (m &gt; 0 &amp;&amp; existing.length &gt; m &amp;&amp; !existing.warned) { // ... } } return target;} 简单的总结一下，主要流程为以下四个步骤 验证监听器是否为函数对象 避免类型为 newListener 的事件类型造成递归调用，优先触发 优化单个监听器的场景，不需使用额外的数组对象 基于 prepend 参数的值，控制监听器的添加顺序 emit()源码见 EventEmitter.prototype.emit，如下 12345678910111213141516171819202122EventEmitter.prototype.emit = function emit(type, ...args) { const events = this._events; // 获取对应的处理器 const handler = events[type]; if (handler === undefined) return false; if (typeof handler === 'function') { apply(handler, this, args); } else { const len = handler.length; // arrayClone 方法为一个数组浅拷贝方法 const listeners = arrayClone(handler, len); for (var i = 0; i &lt; len; ++i) apply(listeners[i], this, args); } return true;}; 剔除掉多余的部分以后可以发现，逻辑还是比较好理解的，先根据事件类型获取对应的处理器，然后根据事件处理器的类型，选择直接调用或者是循环调用 上面我们简单的介绍了 on() 和 emit() 两个方法，它们主要用来添加事件监听和触发事件监听，下面我们再来看看如何移除事件监听 removeListener()源码见 EventEmitter.prototype.emit removeListener() 方法最多只会从监听器数组里移除一个监听器实例，如果任何单一的监听器被多次添加到指定 type 的监听器数组中，则必须多次调用 removeListener() 方法才能移除每个实例 为了方便一次性移除 type 对应的监听器，EventEmitter 为我们提供了 removeAllListeners() 方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859EventEmitter.prototype.removeListener = function removeListener(type, listener) { let originalListener; // 这个方式是用于检查监听器是否为函数，如果不是就抛出一个错误 checkListener(listener); const events = this._events; if (events === undefined) return this; const list = events[type]; if (list === undefined) return this; if (list === listener || list.listener === listener) { if (--this._eventsCount === 0) this._events = Object.create(null); else { delete events[type]; // 如果设置了 removeListener 监听器，则触发 removeListener 事件 if (events.removeListener) this.emit('removeListener', type, list.listener || listener); } } else if (typeof list !== 'function') { let position = -1; // 获取需要移除的监听器的索引值 for (var i = list.length - 1; i &gt;= 0; i--) { if (list[i] === listener || list[i].listener === listener) { originalListener = list[i].listener; position = i; break; } } if (position &lt; 0) return this; if (position === 0) list.shift(); else { if (spliceOne === undefined) spliceOne = require('internal/util').spliceOne; // 关于这个方法，见下方 spliceOne(list, position); } if (list.length === 1) events[type] = list[0]; if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener); } return this; };EventEmitter.prototype.off = EventEmitter.prototype.removeListener; 同样的，可以发现，removeListener() 方法也有一个别名 off()，我们可以简单的梳理一下 removeListener() 方法 在调用 removeListener() 方法时，若 type 事件类型上绑定多个事件处理器，那么内部处理程序会先根据 listener 事件处理器，查找该事件处理器对应的索引值 然后在根据索引值的不同再进行不同的处理，但是可以发现，在处理移除对应的事件处理器的时候使用了 spliceOne() 方法，那么为什么不直接利用 Array 的 splice() 方法呢？ 官方的回答是 spliceOne() 方法的执行速度比 Array#splice() 快大约 1.5 倍，实现如下 123456// About 1.5x faster than the two-arg version of Array#splice().function spliceOne(list, index) { for (var i = index, k = i + 1, n = list.length; k &lt; n; i += 1, k += 1) list[i] = list[k]; list.pop();} 大致原理是从需要删除的位置开始，依次将后一个元素与前一个元素的位置进行互换，在删除掉最后一项 最后我们来介绍一下 EventEmitter 另一个常用的方法 once() once()源码见 EventEmitter.prototype.once，如下 123456789101112131415161718192021222324252627function onceWrapper() { // 如果事件处理器未被调用，则先移除事件监听器并设置 fired 字段值为 true // 然后利用 apply() 方法调用 type 事件类型，对应的事件处理器 if (!this.fired) { this.target.removeListener(this.type, this.wrapFn); this.fired = true; if (arguments.length === 0) return this.listener.call(this.target); return this.listener.apply(this.target, arguments); }}function _onceWrap(target, type, listener) { // 创建了一个 state 对象，该对象有一个 fired 属性，用来标识是否已触发，其默认值是 false const state = { fired: false, wrapFn: undefined, target, type, listener }; const wrapped = onceWrapper.bind(state); wrapped.listener = listener; state.wrapFn = wrapped; return wrapped;}EventEmitter.prototype.once = function once(type, listener) { checkListener(listener); this.on(type, _onceWrap(this, type, listener)); return this;}; 梳理后可以发现，once() 方法依次调用了 _onceWrap() 和 onceWrapper() 方法 使用 state 对象的 fired 属性，用来标识是否已触发 手动实现一个 EventEmitter 模块每一个 EventEmitter 实例都有一个包含所有事件的对象 _events，事件的监听和监听事件的触发，以及监听事件的移除等事件都是在这个 _events 对象的基础上实现 我们首先先成一个 EventEmitter 类，在类的初始化方法中生成这个事件对象 _events 123456789class EventEmitter { constructor() { if (this._events === undefined) { // 创建一个纯粹的空对象用于存放事件对象 this._events = Object.create(null); this._eventsCount = 0; } }} _eventsCount 用于统计事件的个数，也就是 _events 对象有多少个属性 下面我们来实现 emit 方法，emit 所做的事情是在 _events 对象中取出相应 type 的属性，并执行属性所对应的函数 12345678910111213141516171819202122class EventEmitter { constructor() { if (this._events === undefined) { // 创建一个纯粹的空对象用于存放事件对象 this._events = Object.create(null); this._eventsCount = 0; } } emit(type, ...args) { const events = this._events; const handler = events[type]; // 判断相应 type 的执行函数是否为一个函数还是一个数组 if (typeof handler === 'function') { Reflect.apply(handler, this, args); } else { for (var i = 0; i &lt; handler.length; i++) { Reflect.apply(handler[i], this, args); } } return true; }} emit 方法是触发事件，并执行相应的方法，而 on 方法则是对于指定的事件添加监听函数 12345678910111213141516171819202122232425262728293031on(type, listener, prepend){ var m; var events; var existing; events = this._events; // 如果 newListener 存在，则每次添加新方法的时候 emit 出一个 newListener if (events.newListener !== undefined) { this.emit('newListener', type, listener); events = target._events; } existing = events[type]; // 判断相应的 type 的方法是否存在 if (existing === undefined) { // 如果相应的 type 的方法不存在，则新增一个相应 type 的事件 existing = events[type] = listener; ++this._eventsCount; } else { // 如果是函数，则添加 if (typeof existing === 'function') { existing = events[type] = prepend ? [listener, existing] : [existing, listener]; } else if (prepend) { existing.unshift(listener); } else { existing.push(listener); } } return this;} 如果 _events 存在 newListener 属性，也就是说 _event 存在监听 newListener 监听事件，那么每次 on 方法添加事件的时候，都会 emit 出一个 newListener 且在 on 方法的参数中，第三个参数用于指定是在相应事件类型属性所对应的数组头部添加还是尾部添加 在 on 方法中为了可以链式的调用，所以返回了 EventEmitter 模块的实例化本身 在 on 方法的基础上可以实现 addListener 方法和 prependListener 方法 123456EventEmitter.prototype.addListener = EventEmitter.prototype.onEventEmitter.prototype.prependListener = function prependListener(type, listener) { return EventEmitter.prototype.on(type, listener, true); }; 再来看看 removeListener 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849removeListener(type, listener){ var list, events, position, i, originalListener; events = this._events; list = events[type]; // 如果相应的事件对象的属性值是一个函数，也就是说事件只被一个函数监听 if (list === listener) { // 如果 -- 归零，则重新定义为一个新对象 if (--this._eventsCount === 0) { this._events = Object.create(null); } else { // 否则删除该事件，并且如果存在 removeListener 的监听函数，则触发 removeListener delete events[type]; if (events.removeListener) this.emit('removeListener', type, listener); } // 如果不是函数则为函数数组 } else if (typeof list !== 'function') { // 遍历数组，找出 listener 对应函数的索引值 for (i = list.length - 1; i &gt;= 0; i--) { if (list[i] === listener) { position = i; break; } } // 没有找到这个函数，则返回不做任何改动的对象 if (position) { return this; } // 如果数组的第一个函数才是所需要删除的对应 listener 函数，则直接移除 if (position === 0) { list.shift(); } else { // 直接使用 splice 删除即可，如果需要优化则可以采用源码当中的 spliceOne() 方法 list.splice(position, 1); } if (list.length === 1) events[type] = list[0]; // 同上 if (events.removeListener !== undefined) this.emit('removeListener', type, listener); } return this;} 以上就是几个核心方法的实现，removeAllListener 与 removeListener 相似，只要找到传入的 type 所对应属性的值，没有遍历过程，直接删除这个属性即可 EventEmitter 模块的异常处理主要涉及的有以下几种方式 try ... catch domains process.on('uncaughtException') try catch 异常处理方式在 Node.js 中也可以通过 try catch 方式来捕获和处理异常，比如 12345try { let x = x;} catch (e) { console.log(e);} 上述 let x = x 赋值语句的错误会被捕获，这里提异常处理，那么跟事件有什么关系呢？ Node.js 中有一个特殊的事件 error，如果异常没有被捕获，就会触发 process 的 uncaughtException 事件抛出，如果你没有注册该事件的监听器（即该事件没有被处理），则 Node.js 会在控制台打印该异常的堆栈信息，并结束进程（崩溃），比如 1234var events = require('events');var emitter = new events.EventEmitter();emitter.emit('error'); 在上述代码中没有监听 error 的事件函数，因此会触发 process 的 uncaughtException 事件，从而打印异常堆栈信息，并结束进程 对于阻塞或者说非异步的异常捕获，try catch 是没有问题的，但是问题在于：try catch 不能捕获非阻塞或者异步函数里面的异常 举例来说： 1234567try { // 第二个 x 在使用前未定义，会抛出异常 let x = x;} catch (e) { console.log('该异常已经被捕获'); console.log(e);} 上述代码中，因为 try 方法里面是同步的，因此可以捕获异常，但是如果 try 方法里面有异步的函数： 12345678try { process.nextTick(function () { let x = x; });} catch (e) { console.log('该异常已经被捕获'); console.log(e);} 因为 process.nextTick 是异步的，因此在 process.nextTick 内部的错误不能被捕获，也就是说 try catch 不能捕获非阻塞函数内的异常 通过 domains 管理异常Node.js 中 domain 模块能被用来集中地处理多个异常操作，通过 Node.js 的 domain 模块可以捕获非阻塞函数内的异常 1234567891011121314var domain = require('domain');var eventDomain = domain.create();eventDomain.on('error', function (err) { console.log('该异常已经被捕获了'); console.log(err);});eventDomain.run(function () { process.nextTick(function () { // 抛出异常 let x = x; });}); 同样的，即使 process.nextTick 是一个异步函数，domain.on 方法也可以捕获这个异步函数中的异常 即使更复杂的情况下，比如异步嵌套异步的情况下，domain.on 方法也可以捕获异常 1234567891011121314151617var domain = require('domain');var eventDomain = domain.create();eventDomain.on('error', function (err) { console.log('该异常已经被捕获了'); console.log(err);});eventDomain.run(function () { process.nextTick(function () { setTimeout(function () { setTimeout(function () { let x = x; }, 0); }, 0); });}); 在上述的情况下，即使异步嵌套很复杂，也能在最外层捕获到异常 domain 模块缺陷在 Node.js 最新的文档中，domain 被废除（Deprecated），domain 从诞生之日起就有着缺陷，举例来说： 123456789101112131415161718192021var domain = require('domain');var EventEmitter = require('events').EventEmitter;var e = new EventEmitter();var timer = setTimeout(function () { e.emit('data');}, 10);function next() { e.once('data', function () { throw new Error('something wrong here'); });}var d = domain.create();d.on('error', function () { console.log('cache by domain');});d.run(next); 如上述的代码是无法捕获到异常 Error 的，原因在于发出异常的 EventEmitter 实例 e，以及触发异常的定时函数 timer 没有被 domain 包裹 domain 模块是通过重写事件循环中的 nextTick 和 _tickCallback 来事件将 process.domain 注入到 next 包裹的所有异步事件内 解决上述无法捕获异常的情况，只需要将 e 或者 timer 包裹进 domain 12345d.add(e)// ord.add(timer) 就可以成功的捕获异常，但是 domain 模块已经在 Node.js 最新的文档中被废除 process.on(‘uncaughtException’)Node.js 中提供了一个最外层的捕获异常的方法，非阻塞或者异步函数中的异常都会抛出到最外层，如果异常没有被捕获，那么会暴露出来被最外层的 process.on('uncaughtException') 所捕获 12345678910try { process.nextTick(function () { let x = x; }, 0);} catch (e) { console.log('该异常已经被捕获'); console.log(e);}process.on('uncaughtException', function (err) { console.log(err) }) 这样就能在最外层捕获异步或者说非阻塞函数中的异常 但是需要注意避免 uncaughtException 错误引起 Node.js 进程崩溃 参考 深入 EventEmitter events.js eventemitter3 domain process NodeJS 异常处理 uncaughtException 篇","link":"/2019/09/12/Node/09/"},{"title":"正则表达式","text":"最近刚好在复习正则表达式的相关知识，顺便整理一下相关笔记 模式修饰符参数如下 i – 忽略大小写 g – 全局匹配 m – 多行匹配 /hello/ – 两个反斜杠是正则表达式的字面量表示法 两个测试方法test123const test = new RegExp('hello world', 'ig');console.log(test.test('hello world')); // true exec返回的是数组，有就返回数组的值，没有返回为 null 12345const test = new RegExp('hello world', 'ig');console.log(test.exec('hello')); // nullconsole.log(test.exec('hello world')); // ['hello world', index: 0, input: 'hello world', groups: undefined] 四个正则表达式方法match(pattern)将所有匹配的字符串组合成数组返回 1234const pattern = /Box/ig;const str = 'This is a Box! The is a box!';console.log(str.match(pattern)); // ['Box', 'box'] search(pattern)返回字符串中 pattern 开始位置，忽略全局匹配 1234const pattern = /Box/ig;const str = 'This is a Box! The is a box!';console.log(str.search(pattern)); // 10 replace(pattern)替换匹配到的字符串 12345const pattern = /Box/ig;const str = 'This is a Box! The is a box!';console.log(str.replace(pattern, 'Big box'));// This is a Big box! The is a Big box! split(pattern)返回字符串指定 pattern 拆分数组 12345const pattern = /\\s/ig;const str = 'This is a Box! The is a box!';console.log(str.split(pattern));// ['This', 'is', 'a', 'Box!', 'The', 'is', 'a', 'box!'] 匹配模式 + – 其前导字符必须在目标对象中连续出现一次或多次 * – 其前导字符必须在目标对象中出现零次或连续多次 ? – 其前导对象必须在目标对象中连续出现零次或一次 \\s – 用于匹配单个空格符，包括 tab 键和换行符 \\S – 用于匹配除单个空格符之外的所有字符 \\d – 用于匹配从 0 到 9 的数字 \\w – 用于匹配字母，数字或下划线字符 \\W – 用于匹配所有与 \\w 不匹配的字符 . – 用于匹配除换行符之外的所有字符 ^ – 定位符，规定匹配模式必须出现在目标字符串的开头（强制首匹配） $ – 定位符，规定匹配模式必须出现在目标对象的结尾（强制尾匹配，并且只匹配一个） \\b – 定位符，规定匹配模式必须出现在目标字符串的开头或结尾的两个边界之一 \\B – 定位符，则规定匹配对象必须位于目标字符串的开头和结尾两个边界之内，即匹配对象既不能作为目标字符串的开头，也不能作为目标字符串的结尾 /[A-Z]/ – 与从 A 到 Z 范围内任何一个大写字母相匹配 /[a-z]/ – 与从 a 到 z 范围内任何一个小写字母相匹配 /[0-9]/ – 与从 0 到 9 范围内任何一个数字相匹配 /([a-z][A-Z][0-9])+/ – 与任何由字母和数字组成的字符串，如 aB0 等相匹配 1234const pattern = /^[a-z]oogle\\d$/;const str = 'aoogle2';console.log(pattern.test(str)); // true 另外还有一些需要注意的地方： 可以使用 () 把字符串组合在一起，() 符号包含的内容必须同时出现在目标对象中 如果希望实现类似编程逻辑中的或运算，在多个不同的模式中任选一个进行匹配的话，可以使用管道符 | 比如 /to|too|2/，表示与目标对象中的 to、too 或 2 相匹配 还有一个较为常用的否定符 [^]，与之前的定位符 ^ 不同，否定符 [^] 规定目标对象中不能存在模式中所规定的字符串 比如 /[^A-C]/，表示将会与目标对象中除 A，B，和 C 之外的任何字符相匹配 一般来说，当 ^ 出现在 [] 内时就被视做否定运算符，而当 ^ 位于 [] 之外，或没有 [] 时，则应当被视做定位符 12345// 匹配或选择其中某个字符，不是相等，包含的意思const pattern = /baidu|google|bing/;const str = 'baidu a google';console.log(pattern.test(str)); // true 常用正则表达式短横变驼峰12345function strToCamel(str) { return str.replace(/(^\\w)|-(\\w)/g, (m, $1, $2) =&gt; $1 ? $1.toUpperCase() : $2.toUpperCase());}strToCamel('border-right-color') 千位分隔符12345678910function commafy(num) { return num &amp;&amp; num .toString() // 也可以使用 /\\B(?=(\\d{3})+$)/g .replace(/(\\d)(?=(\\d{3})+\\.)/g, function ($0, $1) { return $1 + ','; });}commafy(1234567.90) 解析 url1234567function urlParam(url) { const param = {}; url.replace(/[?&amp;](.*?)=([^&amp;]*)/g, (m, $1, $2) =&gt; param[$1] = $2); return param;}urlParam('https://www.baidu.com?id=123&amp;name=zhangsan') 字符串大小写切换12345678function caseConvert(str) { return str.replace(/([a-z]*)([A-Z]*)/g, (m, s1, s2) =&gt; { return `${s1.toUpperCase()}${s2.toLowerCase()}` })}caseConvert('abcdefg')caseConvert('ABCDEFG') 去空格1234str.replace(/\\s*/g, ''); //去除字符串内所有的空格str.replace(/^\\s*|\\s*$/g, ''); //去除字符串内两头的空格str.replace(/^\\s*/, ''); //去除字符串内左侧的空格str.replace(/(\\s*$)/g, ''); //去除字符串内右侧的空格 去除所有的 html1var con = content.replace(/&lt;[^&gt;]+&gt;/g,''); 提取括号中的数值1/\\(([^()]+)\\)/g.exec('add(18)') 匹配空行1^[\\s]*\\n 检查邮政编码12345// 共六位数，第一位不能为 0const pattern = /^[1-9]{1}[0-9]{5}$/;const str = '430000';console.log(pattern.test(str)); // true 检查压缩包后缀名12345// 文件名（字母_数字）.zip|gz|rarconst pattern = /^[\\w]+\\.(zip|gz|rar)$/;const str = 'a12_.zip';console.log(pattern.test(str)); // true ES6 中正则表达式的扩展在 ES5 当中，有下面两种情况 情况一第一个参数是字符，第二个是修饰符 1234let regex = new RegExp('xyz', 'i');console.log(regex.test('xyz123')); // trueconsole.log(regex.test('xyZ123')); // true 情况二第一个参数是正则表达式，但是此时不接受第二个参数是一个修饰符，否则会报错 12345let regex2 = new RegExp(/xyz/i); // 正确let regex3 = new RegExp(/xyz/i, 'i'); // 错误，Uncaught TypeError: Cannot supply flags when constructing one RegExp console.log(regex2.test('xyz123')); // trueconsole.log(regex2.test('xyZ123')); // true ES6 改变了此行为，第一个参数是正则表达式，第二个参数也可以在指定修饰符 123let regex3 = new RegExp(/abc/ig, 'i');console.log(regex3.flags); // i 在以上示例中，原有正则对象的修饰符是 ig，它会被第二个参数 i 覆盖","link":"/2019/10/17/JavaScript/59/"},{"title":"深入 Node.js","text":"本篇为引导页，整理了一下 Node.js 相关资源，包含从入门到进阶 附一张 Node.js 技术栈学习路线图，来自 Q-Angelo 自整理什么是 Node.js Node.js 中的 libuv module.exports 和 exports EventEmitter Buffer Module http 模块 Stream（流） 背压 Node.js 中的 co 模块 SuperAgent 模块 文章资源streamify-your-node-program 精选的小型 Node.js 模块 stream-handbook Node.js Streams: Everything you need to know Node.js 官方指南（基金会） 源码教程Node.js 技术栈 Node.js 面试问题 深入理解 Node.js：核心思想与源码分析 从零开始 Node.js 系列文章 davidc – 通过源码解析 Node.js 系列 xiedacon – Node.js 源码解析 NodeJS-Nucleus-Plus-Internals Node.js 挖掘系列 Node.js 指南（核心概念与模块） Node.js 源码解析与数据结构 Node.js（Taiwan 社群） 视频资源Nodejs 视频教程（Express + koa） Koa2 库 &amp;&amp; 框架 &amp;&amp; 其他HTTP &amp;&amp; HTTP/2 系列文章 Node.js 命令行程序开发完整教程 Koa.js 设计模式-学习笔记 将下一代 Web 框架 Koa 进行到底 Koa2 进阶学习笔记 Egg 官方文档 Egg.js 深入浅出学习笔记 Deno 进阶开发笔记 koa2 系列教程 Egg.js 仿小米商城项目","link":"/2019/10/12/Node/14/"},{"title":"背压","text":"本篇内容主要参考自 Backpressuring in Streams 数据流中的积压问题通常在数据处理的时候我们会遇到一个普遍的问题：背压，意思是在数据传输过程中有一大堆数据在缓存之后积压着 每次当数据到达结尾又遇到复杂的运算，又或者无论什么原因它比预期的慢，这样累积下来，从源头来的数据就会变得很庞大，像一个塞子一样堵塞住 为解决这个问题，必须存在一种适当的代理机制，确保流从一个源流入另外一个的时候是平滑顺畅的 不同的社区组织针对他们各自的问题单独做了解决，好例子比如 Unix 的管道和 TCP 的 Socket，在 Node.js 中，流（stream）已经是被采纳的解决方案 数据太多，速度太快有太多的例子证明有时 Readable 传输给 Writable 的速度远大于它接受和处理的速度 如果发生了这种情况，消费者开始为后面的消费而将数据列队形式积压起来，写入队列的时间越来越长，也正因为如此，更多的数据不得不保存在内存中知道整个流程全部处理完毕 写入磁盘的速度远比从磁盘读取数据慢得多，因此当我们试图压缩一个文件并写入磁盘时，积压的问题也就出现了，因为写磁盘的速度不能跟上读磁盘的速度 12// 数据将会在读入侧堆积，这样写入侧才能和数据流的读入速度保持同步inp.pipe(gzip).pipe(outputFile); 这就是为什么说积压机制很重要，如果积压机制不存在，进程将用完你全部的系统内存，从而对其它进程产生显著影响，它独占系统大量资源直到任务完成为止 这最终导致一些问题： 明显使得其它进程处理变慢 太多繁重的垃圾回收 内存耗尽 pipe 的背压平衡机制假设现在有一对 Readable 和 Writable，要求编程实现从 Readable 里面读取数据然后写到 Writable 中 那么面临的问题很有可能就是如果两者对数据的 产生/消费 速度不一致，那么需要手动协调两者速度使得任务可以完成，思路可能这样： 0、Readable 进入 flowing 模式，然后进入步骤 2 1、监听 data 事件，一旦有数据到达则进入步骤 2，如果捕捉到 end 事件就结束任务 2、将数据写入到 Writable，如果返回 true 进入步骤 1，否则进入步骤 3 3、Readable 进入 pause 模式，并等待 Writable 发射 drain 事件 4、如果 Writable 发射了 drain 事件，则返回步骤 1 而事实上 pipe() 的过程和上述很相似，它的源码如下 12345678910111213141516171819202122232425262728293031323334353637383940Readable.prototype.pipe = function (dest, pipeOpts) { // ... var ondrain = pipeOnDrain(src); // 当写操作返回 false 的时候，正常情况下必然会在稍后触发一个 drain 事件 dest.on('drain', ondrain); src.on('data', ondata); function ondata(chunk) { var ret = dest.write(chunk); // 如果写操作的返回值为 false，则暂停 readable 流 if (ret === false) { if (((state.pipesCount === 1 &amp;&amp; state.pipes === dest) || (state.pipesCount &gt; 1 &amp;&amp; state.pipes.indexOf(dest) !== -1)) &amp;&amp; !cleanedUp) { state.awaitDrain++; } src.pause(); } } // ... return dest;};function pipeOnDrain(src) { return function () { var state = src._readableState; if (state.awaitDrain) state.awaitDrain--; if (state.awaitDrain === 0 &amp;&amp; EE.listenerCount(src, 'data')) { // 将流重新设为 flowing 模式 state.flowing = true; // 将缓冲区中残留的数据读取并重新触发 data 事件 flow(src); } };} 可以看到： 当向 dest 写入数据返回 false 时，马上调用 src.pause() 暂停流，src.pause() 将暂停事件流，但不会暂停数据生成 也就是说 src 此时依然汲取底层数据填充缓冲区，只是暂停发射 data 事件，等到缓冲区的数据量超过警戒线才会停止汲取 因为写入数据返回 false，因此在稍后的某个时候 dest 必然会发射 drain 事件 当 drain 事件发生后，src 再次进入 flowing 模式自动产生数据，同时将缓冲区中的残留数据写入 dest .pipe() 的生命周期为了对积压有一个更好的理解，这里有一副 Readable 流正通过 piped 流入 Writable 流的整个生命周期图： 1234567891011121314151617181920212223242526272829303132333435363738394041 +===================+ x--&gt; Piping functions +--&gt; src.pipe(dest) | x are set up during |===================| x the .pipe method. | Event callbacks | +===============+ x |-------------------| | Your Data | x They exist outside | .on('close', cb) | +=======+=======+ x the data flow, but | .on('data', cb) | | x importantly attach | .on('drain', cb) | | x events, and their | .on('unpipe', cb) |+---------v---------+ x respective callbacks. | .on('error', cb) || Readable Stream +----+ | .on('finish', cb) |+-^-------^-------^-+ | | .on('end', cb) | ^ | ^ | +-------------------+ | | | | | ^ | | ^ ^ ^ | +-------------------+ +=================+ ^ | ^ +----&gt; Writable Stream +---------&gt; .write(chunk) | | | | +-------------------+ +=======+=========+ | | | | | ^ | +------------------v---------+ ^ | +-&gt; if (!chunk) | Is this chunk too big? | ^ | | emit.end(); | Is the queue busy? | | | +-&gt; else +-------+----------------+---+ | ^ | emit.write(); | | | ^ ^ +--v---+ +---v---+ | | ^-----------------------------------&lt; No | | Yes | ^ | +------+ +---v---+ ^ | | | ^ emit.pause(); +=================+ | | ^---------------^-----------------------+ return false; &lt;-----+---+ | +=================+ | | | ^ when queue is empty +============+ | ^------------^-----------------------&lt; Buffering | | | |============| | +&gt; emit.drain(); | ^Buffer^ | | +&gt; emit.resume(); +------------+ | | ^Buffer^ | | +------------+ add chunk to queue | | &lt;---^---------------------&lt; +============+ 注意：如果你创建一些管道准备把一些流串联起来从而操纵数据，你应该实现 Transform 流 在这种情况下，从 Readable 流中的输出进入 Transform，并且会被管道输送进入 Writable 1Readable.pipe(Transformable).pipe(Writable); 积压将被自动应用，但是同时请注意输入和输出 Transform 的水准值，可以手动控制，并且会影响到积压系统 如果想要了解更多，可以参考 通过源码解析 Node.js 中导流（pipe）的实现 这篇文章","link":"/2019/10/09/Node/13/"},{"title":"Http 模块","text":"http 模块是 Node.js 中非常重要的一个核心模块，通过 http 模块，可以使用其 http.createServer() 方法创建一个 http 服务器 也可以使用其 http.request() 方法创建一个 http 客户端，Node.js 对 http 协议及相关 API 的封装比较底层，其仅能处理流和消息，对于消息的处理，也仅解析成报文头和报文体 但是不解析实际的报文头和报文体内容，这样不仅解决了 http 原本比较难用的特性，也可以支持更多的 http 应用 本文内容主要分为两部分：客户端与服务端，我们就一个一个来看 服务端实现 http 服务端功能，要通过 http.createServer() 方法创建一个服务端对象 http.Server 这个方法接收一个可选传入参数 requestListener，该参数是一个函数，传入后将做为 http.Server 的 request 事件监听 不传入时，则需要通过在 http.Server 对象的 request 事件中单独添加，下面是两种创建 http.Server 对象及添加 request 事件监听器的示例： 1234567891011121314var http = require('http');// 创建 server 对象，并添加 request 事件监听器var server = http.createServer(function (req, res) { res.writeHeader(200, { 'Content-Type': 'text/plain' }); res.end('itbilu.com');});// 创建 server 对象，通过 server 对象的 request 事件添加事件事件监听器var server = new http.Server();server.on('request', function (req, res) { res.writeHeader(200, { 'Content-Type': 'text/plain' }); res.end('itbilu.com');}); http.serverhttp.server 是一个基于事件的 http 服务器，所有的请求都被封装到独立的事件当中，我们只需要对事件编写相应的函数就可以实现 http 服务器的所有功能，它继承自 EventEmitter，提供了以下的事件： request：当客户端请求到来的时候触发该事件，提供两个参数 request 和 response，分别是 http.ServerRequest 和 http.ServerResponse 表示请求和响应的信息 connection：当 TCP 建立连接的时候触发该事件，提供了一个参数 socket，为 net.socket 的实例（底层协议对象） close：当服务器关闭的时候会被触发 除此之外还有 checkContinue、upgrade、clientError 等事件 一般比较常见的还是 request 事件，所以官方也提供了一个更为简便的创建方式 http.createServer([requestListener])，就如上面示例当中的一样 request &amp;&amp; responserequest 代表着请求信息，比如我们请求的 url 地址为 http://localhost:8080/index.html?name=123 则服务器接收到的信息如下 1234567let server = http.createServer((req, res) =&gt; { let { pathname, query } = url.parse(req.url, true) console.log(pathname) // index.html console.log(query) // { name: 123 } console.log(req.url) // /index.html?name=123 console.log(req.headers) // 获取请求头}) response 代表着响应信息 123456789let server = http.createServer((req, res) =&gt; { res.setHeader('Content-Type', 'text/html;charset=utf8') // 一旦调用会立刻向客户端发送 res.writeHead(200, { 'Content-Type': 'text/html;charset=utf8' }) res.statusCode = 400 res.end()}) 客户端http 模块不仅可以做为 http 服务器使用，也适用于客户端，http 模块提供了创建 http 客户端对象的方法，使用客户端对象可以创建对 http 服务的访问 http.request() 方法用于创建 http 请求，该方法会返回一个 http.ClientRequest 对象， 是 http.createClient() 方法的替代方法 请求创建后并不会立即发送请求，我们还可以继续访问和设置请求头，比如使用 setHeader(name, value)、getHeader(name) 和 removeHeader(name) 等 API 进行修改 实际的请求头会与第一个数据块一起发送或当调用 request.end() 时发送 http.ClientRequesthttp.ClientRequest 对象由 http.request() 创建并返回，它是一个正在处理的 http 请求，其头部已经在队列中 header 将会随着第一个数据块发送，或在连接关闭时发送 http.ClientRequest 实现了 Writable Stream 接口，其对于向服务器发送数据，本质上是对这个可写流的操作 它还是一个 EventEmitter，包含 response、socket、upgrade、continue 等事件 http.Agenthttp.Agent 是会把套接字做成资源池，用于 http 客户端请求，当需要自定义一些自定义的代理参数（如主机的套接字并发数、套接字发送 TCP KeepAlive 包的频率等）时可以设置此对象，该对象由构造函数 new Agent([options]) 创建返回 更多详细内容可以参考官方文档 new Agent([options]) http.globalAgentAgent 的全局实例，是 http 客户端的默认请求代理对象，其结构类似如下： 123456789101112131415{ domain: null, _events: { free: [Function] }, _maxListeners: undefined, defaultPort: 80, protocol: 'http:', options: { path: null }, requests: {}, sockets: {}, freeSockets: {}, keepAliveMsecs: 1000, keepAlive: false, maxSockets: Infinity, maxFreeSockets: 256 } GET 请求123456789101112131415161718192021222324const http = require('http')const options = { host: 'localhost', port: 8080, method: 'get', path: '/post'}let req = http.request(options)// 当服务器把请求体发回来的时候，或者说客户端接受到响应的时候req.on('response', (res) =&gt; { let result = [] res.on('data', (data) =&gt; { result.push(data) }) res.on('end', () =&gt; { let str = Buffer.concat(result) console.log(str.toString()) })})// 只有调用 end() 才会真正向服务器发请求req.end() 对应服务端代码如下 123456789101112131415const express = require('express')const app = express()const bodyParser = require('body-parser')// 处理 JSON 的请求体app.use(bodyParser.json())// GET 请求的内容是存储在 req.body 当中app.get('/post', (req, res, next) =&gt; { // console.log(req.body) console.log(123) res.send('123')})app.listen(8080) POST 请求12345678910111213141516171819202122232425262728293031let http = require('http')let options = { host: 'localhost', port: 8080, method: 'POST', path: '/post', headers: { 'Content-Type': 'application/json' }}// 需要注意，此时请求并没发出let req = http.request(options)// 当服务器把请求体发回来的时候，或者说客户端接受到响应的时候req.on('response', (res) =&gt; { let result = [] res.on('data', (data) =&gt; { result.push(data) }) res.on('end', (data) =&gt; { let str = Buffer.concat(result) console.log(str.toString()) })})// 向请求体写数据req.write('{\"name\": \"zhangsan\"}')// 是结束写入请求体，只有调用 end() 才会真正向服务器发请求req.end() 对应服务端代码如下 1234567891011121314const express = require('express')const app = express()const bodyParser = require('body-parser')// 针对 POST 请求，因为内容是一个 chunk 数据流累计的结果// 所以采用 bodyParser 来进行处理app.use(bodyParser.json())app.post('/post', (req, res, next) =&gt; { // console.log(req.body) res.send('123')})app.listen(8080) 请求与响应过程先来回顾一下之前的示例，创建一个基本的服务器 12345const http = require('http')http.createServer((req, res) =&gt; { res.end('Hello World')}).listen(8080) 使用起来就是这么简单，因为 Node.js 已经把具体实现细节给封装起来了，我们只需要调用 http 模块提供的方法即可 那么，一个请求是如何处理，然后响应的呢？我们先来简单的梳理一下 1234567 _______ | | &lt;== resrequest ==&gt; | ? | |_______| ==&gt; req /\\ || http.createServer() 先调用 http.createServer() 生成一个 http.Server 对象来处理请求 每次收到请求，都先解析生成 req（http.IncomingMessage）和 res（http.ServerResponse），然后交由用户函数处理 用户函数调用 res.end() 来结束处理，响应请求 在展开之前，我们先来看看 http.IncomingMessage 和 http.ServerResponse IncomingMessage在 Node.js 服务器接收到请求时，会利用 HTTPParser 对象来解析请求报文，为了便于开发者使用，Node.js 会基于解析后的请求报文创建 IncomingMessage 对象 IncomingMessage 构造函数（代码片段）如下： 1234567891011121314151617function IncomingMessage(socket) { Stream.Readable.call(this); this.socket = socket; this.connection = socket; this.httpVersion = null; this.complete = false; this.headers = {}; // 解析后的请求头 this.rawHeaders = []; // 原始的头部信息 // request (server) only this.url = ''; // 请求 url 地址 this.method = null; // 请求地址}util.inherits(IncomingMessage, Stream.Readable); http 协议是基于请求和响应，请求对象我们已经介绍了，那么接下来就是响应对象，在 Node.js 中，响应对象是 ServerResponse 类的实例 ServerResponse12345678910111213141516function ServerResponse(req) { OutgoingMessage.call(this); if (req.method === 'HEAD') this._hasBody = false; this.sendDate = true; this._sent100 = false; this._expect_continue = false; if (req.httpVersionMajor &lt; 1 || req.httpVersionMinor &lt; 1) { this.useChunkedEncodingByDefault = chunkExpression.test(req.headers.te); this.shouldKeepAlive = false; }}util.inherits(ServerResponse, OutgoingMessage); 通过以上代码，我们可以发现 ServerResponse 继承于 OutgoingMessage 在 OutgoingMessage 对象中会包含用于生成响应报文的相关信息 下面就让我们正式开始探寻 http.createServer() 方法的内部原理 http.createServerhttp.createServer 的实现如下 123456789101112131415161718// lib/http.jsfunction createServer(requestListener) { return new Server(requestListener);}// lib/_http_server.jsfunction Server(requestListener) { if (!(this instanceof Server)) return new Server(requestListener); net.Server.call(this, { allowHalfOpen: true }); if (requestListener) { this.on('request', requestListener); } this.on('connection', connectionListener); // ...} http.createServer() 函数返回一个 http.Server 实例，该实例监听了 request 和 connection 两个事件 request 事件：绑定 requestListener() 函数，req 和 res 准备好时触发 connection 事件：绑定 connectionListener() 函数，连接时触发 用户函数是 requestListener()，也就是说，在触发 request 事件后，就会调用我们设置的 requestListener 函数，如下 123(req, res) =&gt; { res.end('Hello World')} connectionListenerInternalconnection 事件，顾名思义用来跟踪网络连接，因此，我们需要知道 request 事件何时触发 12345678910111213141516171819202122232425262728293031function connectionListener(socket) { defaultTriggerAsyncIdScope( getOrSetAsyncId(socket), connectionListenerInternal, this, socket );}function connectionListenerInternal(server, socket) { httpSocketSetup(socket); if (socket.server === null) socket.server = server; if (server.timeout &amp;&amp; typeof socket.setTimeout === 'function') socket.setTimeout(server.timeout); // 处理超时情况 socket.on('timeout', socketOnTimeout); // 获取 parser 对象（见下方） var parser = parsers.alloc(); parser.reinitialize(HTTPParser.REQUEST); parser.socket = socket; socket.parser = parser; parser.incoming = null; var state = { outgoing: [], incoming: [], //... }; parser.onIncoming = parserOnIncoming.bind(undefined, server, socket, state);} 在 connectionListenerInternal 函数内部可以发现有一个 parser 对象，parser 对象是由一个叫做 FreeList 的数据结构实现，其主要目的是复用 parser 通过调用 parsers.alloc() 和 parsers.free(parser) 来获取释放 parser，下面就先来看看 FreeList 这个对象 FreeList在 Node.js 中为了避免频繁创建和销毁对象，有一个通用的 FreeList 机制，在 http 模块中，就利用到了 FreeList 机制，即用来动态管理 HTTPParser 对象 1234var parsers = new FreeList('parsers', 1000, function () { var parser = new HTTPParser(HTTPParser.REQUEST); //...} 具体实现如下 12345678910111213141516171819202122class FreeList { constructor(name, max, ctor) { this.name = name; // 管理的对象名称 this.ctor = ctor; // 管理对象的构造函数 this.max = max; // 存储对象的最大值 this.list = []; // 存储对象的数组 } alloc() { return this.list.length ? this.list.pop() : this.ctor.apply(this, arguments); } free(obj) { if (this.list.length &lt; this.max) { this.list.push(obj); return true; } return false; }} 在处理 http 请求的场景下，当新的请求到来时，我们通过调用 parsers.alloc() 方法来获取 HTTPParser 对象，从而解析 http 请求 当完成 http 解析任务后，我们可以通过调用 parsers.free() 方法来归还 HTTPParser 对象 parserOnIncoming既然，http 报文是由 parser 来解析的，那么就让我们来看看 parser 是如何创建的吧 1234567891011121314151617var parsers = new FreeList('parsers', 1000, function () { var parser = new HTTPParser(HTTPParser.REQUEST); parser._headers = []; parser._url = ''; parser._consumed = false; parser.socket = null; parser.incoming = null; parser.outgoing = null; parser[kOnHeaders] = parserOnHeaders; parser[kOnHeadersComplete] = parserOnHeadersComplete; parser[kOnBody] = parserOnBody; return parser;}); 在上面以 parser 开头的这些对象，都是定义在 _http_common.js 文件中的函数对象，让我们来简单的梳理一下 parserOnHeaders：当请求头跨多个 TCP 数据包或者过大无法再一个运行周期内处理完才会调用该方法 kOnHeadersComplete：请求头解析完成后，会调用该方法，方法内部会创建 IncomingMessage 对象，填充相关的属性，比如 url、httpVersion、method和 headers 等 parserOnBody：不断解析已接收的请求体数据 这里需要注意的是，请求报文的解析工作是由 C++ 来完成，内部通过 binding 来实现，具体可以参考 deps/http_parser 目录 1const { methods, HTTPParser } = process.binding('http_parser'); 在 connectionListenerInternal 函数中，在最后一行设置了 parser 对象的 onIncoming 属性为绑定后的 parserOnIncoming 函数 1234567891011121314151617181920212223242526272829303132333435363738394041function parserOnIncoming(server, socket, state, req, keepAlive) { // 缓冲 IncomingMessage 实例 state.incoming.push(req); var res = new server[kServerResponse](req); if (socket._httpMessage) { // 缓冲 ServerResponse 实例 state.outgoing.push(res); } else { res.assignSocket(socket); } // 判断请求头是否包含 expect 字段且 http 协议的版本为 1.1 if (req.headers.expect !== undefined &amp;&amp; (req.httpVersionMajor === 1 &amp;&amp; req.httpVersionMinor === 1)) { // continueExpression: /(?:^|\\W)100-continue(?:$|\\W)/i // Expect: 100-continue if (continueExpression.test(req.headers.expect)) { res._expect_continue = true; if (server.listenerCount('checkContinue') &gt; 0) { server.emit('checkContinue', req, res); } else { res.writeContinue(); server.emit('request', req, res); } } else if (server.listenerCount('checkExpectation') &gt; 0) { server.emit('checkExpectation', req, res); } else { // http 协议中的 417 Expectation Failed 状态码表示客户端错误 // 意味着服务器无法满足 Expect 请求消息头中的期望条件 res.writeHead(417); res.end(); } } else { server.emit('request', req, res); } return 0;} 通过观察上面的代码，我们终于发现了 request 事件的踪迹，在 parserOnIncoming 函数内，我们会基于 req 请求对象创建 ServerResponse 响应对象 在创建响应对象后，会判断请求头是否包含 expect 字段，然后针对不同的条件做出不同的处理 对于之前最早的示例来说，程序会直接走 else 分支，即触发 request 事件，并传递当前的请求对象和响应对象 最后我们来回顾一下整个流程： 调用 http.createServer() 方法创建 server 对象，该对象创建完后，我们调用 listen() 方法执行监听操作 当 server 接收到客户端的连接请求，在成功创建 socket 对象后，会触发 connection 事件 当 connection 事件触发后，会执行对应的 connectionListener 回调函数，在函数内部会利用 HTTPParser 对象，对请求报文进行解析 在完成请求头的解析后，会创建 IncomingMessage 对象，并填充相关的属性，比如 url、httpVersion、method 和 headers 等 在配置完 IncomingMessage 对象后，会调用 parserOnIncoming 函数，在该函数内会构建 ServerResponse 响应对象，如果请求头不包含 expect 字段，则 server 就会触发 request 事件，并传递当前的请求对象和响应对象 request 事件触发后，就会执行我们设定的 requestListener 函数 参考 http http 模块 http.ClientRequest nodejs 源码 http server http 请求响应过程","link":"/2019/10/02/Node/12/"},{"title":"Node.js 的模块机制","text":"为了让 Node.js 的文件可以相互调用，Node.js 提供了一个简单的模块系统 模块是 Node.js 应用程序的基本组成部分，文件和模块是一一对应的，换言之，一个 Node.js 文件就是一个模块，这个文件可能是 JavaScript 代码、JSON 或者编译过的 C/C++ 扩展 CommonJS 规范Node.js 遵循 CommonJS 规范，该规范的核心思想是允许模块通过 require 方法来同步加载所要依赖的其他模块，然后通过 exports 或 module.exports 来导出需要暴露的接口 CommonJS 规范是为了解决 JavaScript 的作用域问题而定义的模块形式，可以使每个模块它自身的命名空间中执行，下面是一个简单的示例 123456// a.jsmodule.exports = (a, b) =&gt; a + b;// b.jsconst add = require('./a');console.log(add(2, 3)); CommonJS 也有浏览器端的实现，其原理是现将所有模块都定义好并通过 id 索引，这样就可以方便的在浏览器环境中解析了，可以参考 require1k 和 tiny-browser-require 源码 经常与 CommonJS 规范一起出现的还有 AMD 规范和 CMD 规范，在这里就不详细展开，感兴趣的可以参考 JavaSript 模块规范 - AMD 规范与 CMD 规范介绍，总结的很棒 模块分类在 Node.js 中，模块主要可以分为以下几种类型 核心模块：包含在 Node.js 源码中，被编译进 Node.js 可执行二进制文件 JavaScript 模块，也叫 native 模块，比如常用的 http，fs 等等 C/C++ 模块，也叫 built-in 模块，一般我们不直接调用，而是在 native module 中调用，然后我们再 require native 模块，比如我们在 Node.js 中常用的 buffer，fs，os 等 native 模块，其底层都有调用 built-in 模块 如对于 native 模块 buffer，还是需要借助 builtin node_buffer.cc 中提供的功能来实现大容量内存申请和管理，目的是能够脱离 V8 内存大小使用限制 第三方模块：非 Node.js 源码自带的模块都可以统称第三方模块，比如 express，webpack 等等 JavaScript 模块，这是最常见的，我们开发的时候一般都写的是 JavaScript 模块 JSON 模块，就是一个 JSON 文件 C/C++ 扩展模块，使用 C/C++ 编写，编译之后后缀名为 .node 源码的目录结构如下 1234567891011├── benchmark // 一些 Node.js 性能测试代码├── deps // Node.js 依赖├── doc // 文档├── lib // Node.js 对外暴露的 js 模块源码├── src // Node.js 的 C/C++ 源码文件，内建模块├── test // 单元测试├── tools // 编译时用到的工具├── doc // api 文档├── vcbuild.bat // win 平台 makefile 文件├── node.gyp // node-gyp 构建编译任务的配置文件... 模块对象每个模块内部，都有一个 module 对象，代表当前模块，它有以下属性 module.id - 模块的识别符，通常是带有绝对路径的模块文件名 module.filename - 模块的文件名，带有绝对路径 module.loaded - 返回一个布尔值，表示模块是否已经完成加载 module.parent - 返回一个对象，表示调用该模块的模块 module.children - 返回一个数组，表示该模块要用到的其他模块 module.exports - 表示模块对外输出的值 模块加载机制简单来说，模块加载机制也就是 require 函数执行的主要流程 在 Node.js 中模块加载一般会经历三个步骤，路径分析、文件定位、编译执行，按照模块的分类，按照以下顺序进行优先加载： 系统缓存：模块被执行之后会会进行缓存，首先是先进行缓存加载，判断缓存中是否有值 系统模块：也就是原生模块，这个优先级仅次于缓存加载，部分核心模块已经被编译成二进制，省略了路径分析、文件定位，直接加载到了内存中，系统模块定义在 Node.js 源码的 lib 目录下 文件模块：优先加载以 .、..、/ 开头的，如果文件没有加上扩展名，会依次按照 .js、.json、.node 进行扩展名补足尝试，那么在尝试的过程中也是以同步阻塞模式来判断文件是否存在 从性能优化的角度来看待，.json、.node 最好还是加上文件的扩展名 目录做为模块：这种情况发生在文件模块加载过程中，也没有找到，但是发现是一个目录的情况，这个时候会将这个目录当作一个包来处理 Node.js 这块采用了 Commonjs 规范，先会在项目根目录查找 package.json 文件，取出文件中定义的 main 属性 (&quot;main&quot;: &quot;lib/hello.js&quot;) 描述的入口文件进行加载 如果也没加载到，则会抛出默认错误: Error: Cannot find module 'lib/hello.js' node_modules 目录加载：对于系统模块、路径文件模块都找不到，Node.js 会从当前模块的父目录进行查找，直到系统的根目录 主要内容就是以上这些，下面我们来看一些 Node.js Module 当中可能涉及到的一些问题，主要有下面这些 模块中的 module、exports、__dirname、__filename 和 require 来自何方？ module.exports 与 exports 有什么区别？ 模块之间循环依赖是否会陷入死循环？ require 函数支持导入哪几类文件？ require 函数执行的主要流程是什么？ Node.js 模块与前端模块的异同 Node.js 中的 VM 模块是做什么用的？ 模块中的 module、exports、dirname、filename 和 require 来自何方？新建一个 index.js 文件，输入以下内容 12345console.log(module);console.log(exports);console.log(__dirname);console.log(__filename);console.log(require); 执行完以上代码，控制台的输出如下，其中忽略了输出对象中的大部分属性 12345678910111213141516171819202122232425Module { ========================================================&gt; module id: '.', exports: {}, parent: null, filename: 'index.js', loaded: false, children: [], // 模块查找路径 paths: []}{} ==============================================================&gt; exports/Users/Desktop/test =============================================&gt; __dirname/Users/Desktop/test/index.js ====================================&gt; __filename{ [Function: require] ===========================================&gt; require resolve: { [Function: resolve] paths: [Function: paths] }, // Module对象 main: Module { ... }, extensions: { '.js': [Function], '.json': [Function], '.node': [Function] }, cache: { ... } } 通过控制台的输出值，我们可以清楚地看出每个变量的值，在执行代码之前，Node.js 会对要执行的代码进行封装，至于到底是如何封装的，可以见下方 require 函数支持导入哪几类文件？ 如下面所示 123(function(exports, require, module, __filename, __dirname) { // 模块的代码}); 这里我们就清楚了，模块中的 module、exports、__dirname、__filename 和 require 这些对象都是函数的输入参数，在调用包装后的函数时传入 module.exports 与 exports 的区别我们先来看一行代码 1console.log(module.exports === exports); // true 可以发现，输出为 true，再看下面这样 123exports.id = 1; // 方式一：可以正常导出exports = { id: 1 }; // 方式二：无法正常导出module.exports = { id: 1 }; // 方式三：可以正常导出 为什么方式二无法正常导出呢？ 这里可以参考上面的 module 和 exports 输出的对应值来理解 如果 module.exports === exports 执行的结果为 true，那么表示模块中的 exports 变量与 module.exports 属性是指向同一个对象 当使用方式二 exports = { id: 1 } 的方式会改变 exports 变量的指向，这时与 module.exports 属性指向不同的变量 而当我们导入某个模块时，是导入 module.exports 属性指向的对象 如果想要深入了解，可以参考之前整理过的一篇文章内容 module.exports 和 exports，分析的很详细 模块之间循环依赖是否会陷入死循环？我们先来看看什么是循环依赖，所谓循环依赖 当模块 a 执行时需要依赖模块 b 中定义的属性或方法，而在导入模块 b 中，发现模块 b 同时也依赖模块 a 中的属性或方法，即两个模块之间互相依赖，这种现象我们称之为循环依赖 我们来验证一下 123456789// a.jsexports.a = 1;exports.b = 2;require('./b');exports.c = 3;// b.jsconst a = require('./a');console.log(a); 当在控制台运行 a.js 之后可以发现程序正常运行，并不会出现死循环，但只会输出相应模块已加载的部分数据，如下 1{ a: 1, b: 2 } 所以我们可以得出结论 在启动 a.js 的时候，会加载 b.js，那么在 b.js 中又加载了 a.js，但是此时 a.js 模块还没有执行完，返回的是一个 a.js 模块的 exports 对象未完成的副本给到 b.js 模块（因此是不会陷入死循环的） 然后 b.js 完成加载之后将 exports 对象提供给了 a.js 模块 require 函数支持导入哪几类文件？在 require 函数对象中，有一个 extensions 属性，顾名思义表示它支持的扩展名，支持的文件类型主要有 .js、.json 和 .node，在上面输出的 require 函数对象中我们已经可以了解到了 12345678{ [Function: require] ===========================================&gt; require resolve: { [Function: resolve] paths: [Function: paths] }, // Module对象 main: Module { ... }, extensions: { '.js': [Function], '.json': [Function], '.node': [Function] }, cache: { ... } } 我们再来深入一下，其实模块内的 require 函数对象是通过 lib/internal/module.js 文件中的 makeRequireFunction 函数创建的 1234567891011121314151617function makeRequireFunction(mod) { const Module = mod.constructor; function require(path) { try { exports.requireDepth += 1; return mod.require(path); } finally { exports.requireDepth -= 1; } } // Enable support to add extra extension types. require.extensions = Module._extensions; require.cache = Module._cache; return require;} 可以发现，在导入模块时，最终还是通过调用 Module 对象的 require() 方法来实现模块导入 在上面代码中，我们可以发现这一行 require.extensions = Module._extensions，在 lib/module.js 文件当中我们可以发现以下的定义 123456789101112131415161718192021// Native extension for .jsModule._extensions['.js'] = function (module, filename) { var content = fs.readFileSync(filename, 'utf8'); module._compile(internalModule.stripBOM(content), filename);};// Native extension for .jsonModule._extensions['.json'] = function (module, filename) { var content = fs.readFileSync(filename, 'utf8'); try { module.exports = JSON.parse(internalModule.stripBOM(content)); } catch (err) { err.message = filename + ': ' + err.message; throw err; }};//Native extension for .nodeModule._extensions['.node'] = function (module, filename) { return process.dlopen(module, path.toNamespacedPath(filename));}; 这是 Node.js 针对处理的几种文件类型，这里我们主要看处理 .js 类型文件 12345// Native extension for .jsModule._extensions['.js'] = function (module, filename) { var content = fs.readFileSync(filename, 'utf8'); module._compile(internalModule.stripBOM(content), filename);}; 可以发现，首先我们会以同步的方式读取对应的文件内容，然后在使用 module._compile() 方法对文件的内容进行编译 123456789Module.prototype._compile = function (content, filename) { // ... // create wrapper function var wrapper = Module.wrap(content); // ...}; 在这里，我们主要关注 var wrapper = Module.wrap(content) 这一行，调用 Module 内部的封装函数对模块的原始内容进行封装 12345678Module.wrap = function (script) { return Module.wrapper[0] + script + Module.wrapper[1];};Module.wrapper = [ '(function (exports, require, module, __filename, __dirname) { ', '\\n});']; 看到这里我们就可以明白，原来模块中的原始内容是在这个阶段进行包装的，包装后的格式为 123(function (exports, require, module, __filename, __dirname) { // 模块原始内容}); 这也就解释了之前的模块中的 exports，require，module，__filename 和 __dirname 来自何方 require 函数执行的主要流程是什么？在之前的章节中我们已经了解到了 require 函数执行的主要流程，其实就是模块加载机制 在加载对应模块前，我们首先需要定位文件的路径，文件的定位是通过 Module 内部的 _resolveFilename() 方法来实现 简化版的相关的伪代码描述如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647从 Y 路径的模块 require(X)1. 如果 X 是一个核心模块， a. 返回核心模块 b. 结束2. 如果 X 是以 '/' 开头 a. 设 Y 为文件系统根目录3. 如果 X 是以 './' 或 '/' 或 '../' 开头 a. 加载文件(Y + X) b. 加载目录(Y + X)4. 加载Node模块(X, dirname(Y))5. 抛出 \"未找到\"加载文件(X)1. 如果 X 是一个文件，加载 X 作为 JavaScript 文本，结束2. 如果 X.js 是一个文件，加载 X.js 作为 JavaScript 文本，结束3. 如果 X.json 是一个文件，解析 X.json 成一个 JavaScript 对象，结束4. 如果 X.node 是一个文件，加载 X.node 作为二进制插件，结束加载索引(X)1. 如果 X/index.js 是一个文件，加载 X/index.js 作为 JavaScript 文本，结束3. 如果 X/index.json 是一个文件，解析 X/index.json 成一个 JavaScript 对象，结束4. 如果 X/index.node 是一个文件，加载 X/index.node 作为二进制插件，结束加载目录(X)1. 如果 X/package.json 是一个文件， a. 解析 X/package.json，查找 \"main\" 字段 b. let M = X + (json main 字段) c. 加载文件(M) d. 加载索引(M)2. 加载索引(X)加载Node模块(X, START)1. let DIRS=NODE_MODULES_PATHS(START)2. for each DIR in DIRS: a. 加载文件(DIR/X) b. 加载目录(DIR/X)NODE_MODULES_PATHS(START)1. let PARTS = path split(START)2. let I = count of PARTS - 13. let DIRS = []4. while I &gt;= 0, a. if PARTS[I] = \"node_modules\" CONTINUE b. DIR = path join(PARTS[0 .. I] + \"node_modules\") c. DIRS = DIRS + DIR d. let I = I - 15. return DIRS 下面就简单的看一下内部的 Module 对象的 require() 方法 123456789101112// Loads a module at the given file path. Returns that module's// `exports` property.Module.prototype.require = function (id) { if (typeof id !== 'string') { throw new errors.TypeError('ERR_INVALID_ARG_TYPE', 'id', 'string', id); } if (id === '') { throw new errors.Error('ERR_INVALID_ARG_VALUE', 'id', id, 'must be a non-empty string'); } return Module._load(id, this, /* isMain */ false);}; 通过源码可以发现，其本质上是调用了 Module._load() 方法 12345678910111213141516171819202122232425262728293031323334353637383940414243// Check the cache for the requested file.// 1. If a module already exists in the cache: return its exports object.// 2. If the module is native: call `NativeModule.require()` with the// filename and return the result.// 3. Otherwise, create a new module for the file and save it to the cache.// Then have it load the file contents before returning its exports// object.Module._load = function (request, parent, isMain) { // 解析文件的具体路径 var filename = Module._resolveFilename(request, parent, isMain); // 优先从缓存中获取 var cachedModule = Module._cache[filename]; if (cachedModule) { updateChildren(parent, cachedModule, true); // 导出模块的 exports 属性 return cachedModule.exports; } // 判断是否为 native module，如 fs、http 等 if (NativeModule.nonInternalExists(filename)) { debug('load native module %s', request); return NativeModule.require(filename); } // Don't call updateChildren(), Module constructor already does. // 创建新的模块对象 var module = new Module(filename, parent); if (isMain) { process.mainModule = module; module.id = '.'; } // 缓存新建的模块 Module._cache[filename] = module; // 尝试进行模块加载 tryModuleLoad(module, filename); return module.exports;}; 可以发现，与我们之前的模块加载机制是完全类似的，这里存在一个小问题 模块首次被加载后，会被缓存在 Module._cache 属性中，但有些时候，我们修改了已被缓存的模块，希望其它模块导入时，获取到更新后的内容的话该怎么处理呢？ 针对这种情况，我们可以使用以下方法清除指定缓存的模块，或清理所有已缓存的模块 1234567// 删除指定模块的缓存delete require.cache[require.resolve('/* 被缓存的模块名称 */')]// 删除所有模块的缓存Object.keys(require.cache).forEach(function (key) { delete require.cache[key];}); Node.js 模块与前端模块的异同通常有一些模块可以同时适用于前后端，但是在浏览器端通过 script 标签的载入 JavaScript 文件的方式与 Node.js 不同 Node.js 在载入到最终的执行中，进行了包装，使得每个文件中的变量天然的形成在一个闭包之中，不会污染全局变量 而浏览器端则通常是裸露的 JavaScript 代码片段，所以为了解决前后端一致性的问题，类库开发者需要将类库代码包装在一个闭包内，比如 underscore 的定义方式 1234567891011121314151617181920(function () { // Establish the root object, `window` in the browser, or `global` on the server. var root = this; var _ = function (obj) { return new wrapper(obj); }; if (typeof exports !== 'undefined') { if (typeof module !== 'undefined' &amp;&amp; module.exports) { exports = module.exports = _; } exports._ = _; } else if (typeof define === 'function' &amp;&amp; define.amd) { // Register as a named module with AMD. define('underscore', function () { return _; }); } else { root['_'] = _; }}).call(this); 首先，它通过 function 定义构建了一个闭包，将 this 作为上下文对象直接 call 调用，以避免内部变量污染到全局作用域 续而通过判断 exports 是否存在来决定将局部变量 _ 绑定给 exports，并且根据 define 变量是否存在，作为处理在实现了 AMD 规范环境 下的使用案例 仅只当处于浏览器的环境中的时候，this 指向的是全局对象（window 对象），才将 _ 变量赋在全局对象上，作为一个全局对象的方法导出，以供外部调用 所以在设计前后端通用的 JavaScript 类库时，都有着以下类似的判断： 12345if (typeof exports !== \"undefined\") { exports.EventProxy = EventProxy;} else { this.EventProxy = EventProxy;} 即，如果 exports 对象存在，则将局部变量挂载在 exports 对象上，如果不存在，则挂载在全局对象上 Node.js 中的 VM 模块是做什么用的？VM 模块提供了一系列 API 用于在 V8 虚拟机环境中编译和运行代码，JavaScript 代码可以被编译并立即运行，或编译、保存然后再运行 vm.runInThisContext(code[, options])vm.runInThisContext() 在当前的 global 对象的上下文中编译并执行 code，最后返回结果，运行中的代码无法获取本地作用域，但可以获取当前的 global 对象 12345678910111213const vm = require('vm');let localVar = 'initial value';const vmResult = vm.runInThisContext('localVar = \"vm\";');console.log('vmResult:', vmResult);console.log('localVar:', localVar);const evalResult = eval('localVar = \"eval\";');console.log('evalResult:', evalResult);console.log('localVar:', localVar);// vmResult: 'vm', localVar: 'initial value'// evalResult: 'eval', localVar: 'eval' 正因 vm.runInThisContext() 无法获取本地作用域，故 localVar 的值不变，相反 eval() 确实能获取本地作用域，所以 localVar 的值被改变了 参考 CommonJS JavaSript 模块规范 - AMD 规范与 CMD 规范介绍 结合源码分析 Node.js 模块加载与运行原理 modules node模块化之require学习 Node.js介绍 - 模块化 exports、module.exports 和 export、export default 到底是咋回事 NodeJs 的 VM 模块","link":"/2019/09/28/Node/11/"},{"title":"Buffer","text":"JavaScript 语言自身只有字符串数据类型，没有二进制数据类型 但在处理像 TCP 流或文件流时，必须使用到二进制数据，因此在 Node.js 中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区 但是在深入展开之前，我们先来了解一下 JavaScript 当中的 ArrayBuffer 本文部分内容截取自 Node.js 中的缓冲区（Buffer）究竟是什么？ ArrayBufferArrayBuffer 对象用来表示通用的、固定长度的原始二进制数据缓冲区，代表储存二进制数据的一段内存，它不能直接操作，而是要通过类型数组对象 或 DataView 对象来操作，它们会将缓冲区中的数据表示为特定的格式，并通过这些格式来读写缓冲区的内容 下面的例子创建了一个 8 字节的缓冲区，并使用一个 Int32Array 来引用它 12var buffer = new ArrayBuffer(8);var view = new Int32Array(buffer); TypedArray 视图ArrayBuffer 对象作为内存区域，可以存放多种类型的数据（其本身只是一个 0 和 1 存放在一行里面的一个集合），同一段内存，不同数据有不同的解读方式，这就叫做视图（view） ArrayBuffer 有两种视图，一种是 TypedArray 视图，另一种是 DataView 视图，前者的数组成员都是同一个数据类型，后者的数组成员可以是不同的数据类型 同一个 ArrayBuffer 对象之上，可以根据不同的数据类型建立多个视图 1234567891011// 创建一个 8 字节的 ArrayBufferconst b = new ArrayBuffer(8);// 创建一个指向 b 的 Int32 视图，开始于字节 0，直到缓冲区的末尾const v1 = new Int32Array(b);// 创建一个指向 b 的 Uint8 视图，开始于字节 2，直到缓冲区的末尾const v2 = new Uint8Array(b, 2);// 创建一个指向 b 的 Int16 视图，开始于字节 2，长度为 2const v3 = new Int16Array(b, 2, 2); 视图的构造函数可以接受三个参数 第一个参数（必需）：视图对应的底层 ArrayBuffer 对象 第二个参数（可选）：视图开始的字节序号，默认从 0 开始 第三个参数（可选）：视图包含的数据个数，默认直到本段内存区域结束 但是有一个需要注意的地方，byteOffset 必须与所要建立的数据类型一致，否则会报错 123const buffer = new ArrayBuffer(8);const i16 = new Int16Array(buffer, 1);// Uncaught RangeError: start offset of Int16Array should be a multiple of 2 上面代码中，新生成一个 8 个字节的 ArrayBuffer 对象，然后在这个对象的第一个字节，建立带符号的 16 位整数视图，结果报错 因为，带符号的 16 位整数需要两个字节，所以 byteOffset 参数必须能够被 2 整除 关于 ArrayBuffer 的内容就简单的介绍到这里，如果想了解更多可以参考 DataView 在 Node.js 当中的之所以设置 Buffer 这种方式，简单来说就是扮演了一个原生内存的角色，它模拟了像 C 语言才有的那种直接访问内存的方式 你可能想知道为什么我们不让程序直接访问内存，而是添加了这种抽象层，因为直接访问内存将导致一些安全漏洞 BufferNode.js 里面的 Buffer，是一个二进制数据容器，类似于整数数组，但 Buffer 的大小是固定的、且在 V8 堆外分配物理内存，Buffer 的大小在被创建时确定，且无法调整 比如我们使用 fs 模块来读取文件内容的时候，返回的就是一个 Buffer 123fs.readFile('filename', function (err, buf) { // &lt;Buffer 2f 2a 2a 0a 20 2a 20 53 75 ... &gt;}); Buffer 基本使用在 Node.js 的 v6 之前的版本中，Buffer 实例是通过 Buffer 构造函数创建的，但是这种方式存在两个问题: 参数复杂: 内存分配，还是内存分配和内容写入，需要根据参数来确定 安全隐患: 分配到的内存可能还存储着旧数据，这样就存在安全隐患 12345// 本来只想申请一块内存，但是里面却存在旧数据const buf = new Buffer(10) // &lt;Buffer 90 09 70 6b bf 7f 00 00 50 3a&gt;// 但是如果不小心操作，旧数据就会被读取出来buf.toString() // '�\\tpk�\\u0000\\u0000P:' 为了解决上述问题，使 Buffer 实例的创建更可靠、更不容易出错，各种 new Buffer() 构造函数已被废弃，并由 Buffer.from()、Buffer.alloc()、和 Buffer.allocUnsafe() 等方法替代 Buffer.from()返回一个新的 Buffer，其中包含给定内容的副本 123456const b1 = Buffer.from('10');const b2 = Buffer.from('10', 'utf8');const b3 = Buffer.from([10]);const b4 = Buffer.from(b3);console.log(b1, b2, b3, b4); // &lt;Buffer 31 30&gt; &lt;Buffer 31 30&gt; &lt;Buffer 0a&gt; &lt;Buffer 0a&gt; Buffer.alloc(size)返回一个指定大小的新建的的已初始化的 Buffer，此方法比 Buffer.allocUnsafe(size) 慢 但能确保新创建的 Buffer 实例永远不会包含可能敏感的旧数据，如果 size 不是数字，则将会抛出 TypeError 123const bAlloc1 = Buffer.alloc(10); // 创建一个大小为 10 个字节的缓冲区console.log(bAlloc1); // &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt; Buffer.allocUnsafe(size)创建一个大小为 size 字节的新的未初始化的 Buffer，由于 Buffer 是未初始化的，因此分配的内存片段可能包含敏感的旧数据 在 Buffer 内容可读情况下，则可能会泄露它的旧数据，这个是不安全的，使用时要谨慎 123const bAllocUnsafe1 = Buffer.allocUnsafe(10);console.log(bAllocUnsafe1); // &lt;Buffer 80 75 45 00 00 00 00 00 00 20&gt; Buffer 与字符编码Buffer 实例一般用于表示编码字符的序列，比如 UTF-8、 UCS2、 Base64 或十六进制编码的数据 通过使用显式的字符编码，就可以在 Buffer 实例与普通的 JavaScript 字符串之间进行相互转换 1234567const buf = Buffer.from('hello world', 'ascii');// 68656c6c6f20776f726c64console.log(buf.toString('hex'));// aGVsbG8gd29ybGQ=console.log(buf.toString('base64')); 目前所支持的字符编码如下所示 ascii - 仅支持 7 位 ASCII 数据，如果设置去掉高位的话，这种编码是非常快的 utf8 - 多字节编码的 Unicode 字符，许多网页和其他文档格式都使用 UTF-8 utf16le - 2 或 4 个字节，小字节序编码的 Unicode 字符，支持代理对（U+10000 至 U+10FFFF） ucs2 - utf16le 的别名 base64 - Base64 编码 latin1 - 一种把 Buffer 编码成一字节编码的字符串的方式 binary - latin1 的别名， hex - 将每个字节编码为两个十六进制字符 更多关于 ASCII，Unicode 和 UTF-8 相关内容可见 ASCII，Unicode 和 UTF-8 字符串与 Buffer 类型互转字符串转 Buffer如果不传递 encoding 默认按照 UTF-8 格式转换存储 1234const buf = Buffer.from('Node.js 技术栈', 'UTF-8');console.log(buf); // &lt;Buffer 4e 6f 64 65 2e 6a 73 20 e6 8a 80 e6 9c af e6 a0 88&gt;console.log(buf.length); // 17 Buffer 转换为字符串Buffer 转换为字符串也很简单，使用 toString([encoding], [start], [end]) 方法，默认编码仍为 UTF-8 如果不传递 start、end 可实现全部转换，传了 start、end 可实现部分转换（这里要注意了） 123456const buf = Buffer.from('Node.js 技术栈', 'UTF-8');console.log(buf); // &lt;Buffer 4e 6f 64 65 2e 6a 73 20 e6 8a 80 e6 9c af e6 a0 88&gt;console.log(buf.length); // 17console.log(buf.toString('UTF-8', 0, 9)); // Node.js � 运行查看，可以看到以上输出结果为 Node.js � 出现了乱码，为什么？ 为什么转换过程中会出现乱码首先在上面示例中使用的默认编码方式 UTF-8，问题就出在这里：一个中文在 UTF-8 下占用三个字节，Node.js 技术栈中的这个技字在 buf 中对应的字节为 8a 80 e6 而我们的设定的范围为 0～9 因此只输出了 8a，这个时候就会造成字符被截断出现乱码 下面我们稍微调整一下示例的截取范围 123456const buf = Buffer.from('Node.js 技术栈', 'UTF-8');console.log(buf); // &lt;Buffer 4e 6f 64 65 2e 6a 73 20 e6 8a 80 e6 9c af e6 a0 88&gt;console.log(buf.length); // 17console.log(buf.toString('UTF-8', 0, 11)); // Node.js 技 可以看到已经正常输出了，所以说平常在使用过程当中如果遇到需要截取中文的情况下应当小心 Buffer 与 TypedArrayBuffer 实例也是 Uint8Array 实例，但是与 ECMAScript 2015 中的 TypedArray 规范还是有些微妙的不同 例如，当 ArrayBuffer#slice() 创建一个切片的副本时，Buffer#slice() 的实现是在现有的 Buffer 上不经过拷贝直接进行创建，这也使得 Buffer#slice() 更高效 遵循以下注意事项，也可以从一个 Buffer 创建一个新的 TypedArray 实例 Buffer 对象的内存是拷贝到 TypedArray 的，而不是共享的 Buffer 对象的内存是被解析为一个明确元素的数组，而不是一个目标类型的字节数组 也就是说 new Uint32Array(Buffer.from([1, 2, 3, 4])) 会创建一个包含 [1, 2, 3, 4] 四个元素的 Uint32Array 而不是一个只包含一个元素 [0x1020304] 或 [0x4030201] 的 Uint32Array 也可以通过 TypeArray 对象的 .buffer 属性创建一个新建的且与 TypedArray 实例共享同一分配内存的 Buffer Buffer#slice() 和 Array#slice()Array#slice()Array 当中的 slice() 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象，且原始数组不会被修改 1234var arr = ['AAA', 'BBB', 'CCC', 'DDD', 'EEE'];console.log(arr.slice(2)); // ['CCC', 'DDD', 'EEE']console.log(animals); // ['AAA', 'BBB', 'CCC', 'DDD', 'EEE']; Buffer#slice()Buffer 当中的 slice() 方法返回一个指向相同原始内存的新建的 Buffer，但做了偏移且通过 start 和 end 索引进行裁剪 需要注意的是，修改这个新建的 Buffer 切片，也会同时修改原始的 Buffer 的内存，因为这两个对象所分配的内存是重叠的 1234567const buf = Buffer.from('hello world');const buf1 = buf.slice(0, 3);buf1[4] = 97;console.log(buf); // &lt;Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64&gt;console.log(buf1); // &lt;Buffer 68 65 6c&gt;console.log(buf.toString('utf8')); // hello world 通过观察 Array#slice() 示例和 Buffer#slice() 示例的输出结果，我们更加直观地了解它们之间的差异 Buffer 对象的 slice() 方法具体实现如下： 12345678Buffer.prototype.slice = function slice(start, end) { const srcLength = this.length; start = adjustOffset(start, srcLength); end = end !== undefined ? adjustOffset(end, srcLength) : srcLength; const newLength = end &gt; start ? end - start : 0; // 与原始的 Buffer 对象共用内存 return new FastBuffer(this.buffer, this.byteOffset + start, newLength);}; Buffer 内存机制由于 Buffer 需要处理的是大量的二进制数据，假如用一点就向系统去申请，则会造成频繁的向系统申请内存调用，所以 Buffer 所占用的内存不再由 V8 分配 而是在 Node.js 的 C++ 层面完成申请，在 JavaScript 中进行内存分配，因此这部分内存我们称之为堆外内存 Buffer 模块的内部结构如下 1234exports.Buffer = Buffer;exports.SlowBuffer = SlowBuffer;exports.INSPECT_MAX_BYTES = 50;exports.kMaxLength = binding.kMaxLength; 并且提供了四个接口: Buffer - 二进制数据容器类，Node.js 启动时默认加载 SlowBuffer - 同样也是二进制数据容器类，不过直接进行内存申请 INSPECT_MAX_BYTES - 限制 bufObject.inspect() 输出的长度 kMaxLength - 一次性内存分配的上限，大小为（2^31 - 1） 其中，由于 Buffer 经常使用，所以 Node.js 在启动的时候，就已经加载了 Buffer，而其他三个仍然需要使用对应的引用来进行使用（require('buffer').xxx） 关于 Buffer 的内存申请、填充、修改等涉及性能问题的操作，均通过 C++ 里面的 node_buffer.cc 来实现 内存分配的策略Node.js 中 Buffer 内存分配太过常见，从系统性能考虑出发，Buffer 采用了如下的管理策略 Node.js 采用了 slab 机制进行预先申请、事后分配，是一种动态的管理机制 使用 Buffer.alloc(size) 传入一个指定的 size 就会申请一块固定大小的内存区域，slab 具有如下三种状态： full - 完全分配状态 partial - 部分分配状态 empty - 没有被分配状态 8K 内存池在 Node.js 应用程序启动时，为了方便地、高效地使用 Buffer，会创建一个大小为 8K 的内存池，所以是以 8KB 为界限来区分是小对象还是大对象 1234567891011Buffer.poolSize = 8 * 1024; // 8Kvar poolSize, poolOffset, allocPool;// 创建内存池function createPool() { poolSize = Buffer.poolSize; allocPool = createUnsafeArrayBuffer(poolSize); poolOffset = 0;}createPool(); 在加载时直接调用了 createPool() 相当于直接初始化了一个 8KB 的内存空间，这样在第一次进行内存分配时也会变得更高效 另外在初始化的同时还初始化了一个新的变量 poolOffset = 0 这个变量会记录已经使用了多少字节 在 createPool() 函数中，通过调用 createUnsafeArrayBuffer() 函数来创建 poolSize（8KB）的 ArrayBuffer 对象，createUnsafeArrayBuffer() 函数的实现如下： 123456789function createUnsafeArrayBuffer(size) { zeroFill[0] = 0; try { // 创建指定 size 大小的 ArrayBuffer 对象，其内容被初始化为 0 return new ArrayBuffer(size); } finally { zeroFill[0] = 1; }} 此时，新构造的 slab 如下所示 现在让我们来尝试分配一个大小为 2048 的 Buffer 对象，代码如下所示： 1Buffer.alloc(2 * 1024) 现在让我们先看下当前的 slab 内存是怎么样的？如下所示： 那么这个分配过程是怎样的呢？让我们再看 buffer.js 另外一个核心的方法 allocate(size) 12345678910111213141516171819202122function allocate(size) { if (size &lt;= 0) { return new FastBuffer(); } // 当分配的空间小于 Buffer.poolSize 向右移位，这里得出来的结果为 4KB if (size &lt; (Buffer.poolSize &gt;&gt;&gt; 1)) { if (size &gt; (poolSize - poolOffset)) createPool(); var b = new FastBuffer(allocPool, poolOffset, size); // 已使用空间累加 poolOffset += size; // 8 字节内存对齐处理（关于字节对齐见最下方） alignPool(); return b; } else { // C++ 层面申请 return createUnsafeBuffer(size); }} Buffer 内存分配总结 在初次加载时就会初始化 1 个 8KB 的内存空间 根据申请的内存大小，Buffer 对象分为小对象和大对象 Buffer 小对象的情况，会继续判断这个 slab 空间是否足够 如果空间足够就去使用剩余空间同时更新 slab 分配状态，偏移量会增加 如果空间不足，slab 空间不足，就会去创建一个新的 slab 空间用来分配 Buffer 大对象情况，则会直接走 createUnsafeBuffer(size) 函数 不论是小对象的还是大对象，内存分配是在 C++ 层面完成，内存管理在 JavaScript 层面，最终还是可以被 V8 的垃圾回收标记所回收 Buffer.from() 剖析在我们使用 Buffer 的过程中，比如下面这个简单示例 123const buf = Buffer.from('hello world')console.log(buf) 运行以后可以发现，输出变成了 1&lt;Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64&gt; 为什么结果会变成一串数字，这就要从源码找起了，如下 123456789101112131415/** * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError * if value is a number. * Buffer.from(str[, encoding]) * Buffer.from(array) * Buffer.from(buffer) * Buffer.from(arrayBuffer[, byteOffset[, length]]) **/Buffer.from = function from(value, encodingOrOffset, length) { if (typeof value === \"string\") return fromString(value, encodingOrOffset); // 处理其它数据类型，省略异常处理等其它代码 if (isAnyArrayBuffer(value)) return fromArrayBuffer(value, encodingOrOffset, length); var b = fromObject(value);}; 可以看出 Buffer.from() 工厂函数，支持基于多种数据类型（string、array、buffer 等）创建 Buffer 对象 对于字符串类型的数据，内部调用 fromString(value, encodingOrOffset) 方法来创建 Buffer 对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class FastBuffer extends Uint8Array { constructor(arg1, arg2, arg3) { super(arg1, arg2, arg3); }}function fromString(string, encoding) { var length; if (typeof encoding !== \"string\" || encoding.length === 0) { if (string.length === 0) return new FastBuffer(); // 若未设置编码，则默认使用 utf8 编码 encoding = \"utf8\"; // 计算 string 的长度 length = byteLengthUtf8(string); } else { // 基于指定的 encoding 计算 string 的长度 length = byteLength(string, encoding, true); if (length === -1) throw new errors.TypeError(\"ERR_UNKNOWN_ENCODING\", encoding); if (string.length === 0) return new FastBuffer(); } // 当字符串所需字节数大于 4KB，则直接进行内存分配 if (length &gt;= Buffer.poolSize &gt;&gt;&gt; 1) // 创建 buffer 对象 return createFromString(string, encoding); // 当剩余的空间小于所需的字节长度，则先重新申请 8K 内存 if (length &gt; poolSize - poolOffset) // 上面提到过的 createPool() 方法 // allocPool = createUnsafeArrayBuffer(8K); // poolOffset = 0; createPool(); // 创建 FastBuffer 对象，并写入数据 var b = new FastBuffer(allocPool, poolOffset, length); const actual = b.write(string, encoding); if (actual !== length) { // byteLength() may overestimate. That's a rare case, though. b = new FastBuffer(allocPool, poolOffset, actual); } // 更新 pool 的偏移，并执行字节对齐（关于字节对齐可见下方，也就是所谓的 alignPool() 方法） poolOffset += actual; alignPool(); return b;} 简单的梳理如下，可以发现与上面的 Buffer 内存机制是相符的 当未设置编码的时候，默认使用 utf8 编码 当字符串所需字节数大于 4KB，则直接进行内存分配 当字符串所需字节数小于 4KB，但超过预分配的 8K 内存池的剩余空间，则重新申请 8K 的内存池 调用 new FastBuffer(allocPool, poolOffset, length) 创建 FastBuffer 对象，进行数据存储，数据成功保存后，会进行长度校验、更新 poolOffset 偏移量和字节对齐等操作 Buffer 应用场景下面是一些 Buffer 在实际业务中的应用场景 I/O 操作关于 I/O 可以是文件或网络 I/O，以下为通过流的方式将 input.txt 的信息读取出来之后写入到 output.txt 文件 123456const fs = require('fs');const inputStream = fs.createReadStream('input.txt'); // 创建可读流const outputStream = fs.createWriteStream('output.txt'); // 创建可写流inputStream.pipe(outputStream); // 管道读写 在 Stream 中我们是不需要手动去创建自己的缓冲区，在 Node.js 的流中将会自动创建 zlib.jszlib.js 为 Node.js 的核心库之一，其利用了缓冲区（Buffer）的功能来操作二进制数据流，提供了压缩或解压功能，见 zlib.js 加解密在一些加解密算法中会遇到使用 Buffer，例如 crypto.createCipheriv 的第二个参数 key 为 String 或 Buffer 类型 使用 Buffer.alloc() 初始化一个实例，然后使用 fill 方法进行填充 语法为 1buf.fill(value[, offset[, end]][, encoding]) value - 第一个参数为要填充的内容 offset - 偏移量，填充的起始位置 end - 结束填充 buf 的偏移量 encoding - 编码集 以下为使用 Cipher 对称加密的示例 1234567891011121314151617181920const crypto = require('crypto')const [key, iv, algorithm, encoding, cipherEncoding] = [ 'a123456789', '', 'aes-128-ecb', 'utf8', 'base64']const handleKey = key =&gt; { const bytes = Buffer.alloc(16) // 初始化一个 Buffer 实例，每一项都用 00 填充 console.log(bytes) // &lt;Buffer 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00&gt; bytes.fill(key, 0, 10) // 填充 console.log(bytes) // &lt;Buffer 61 31 32 33 34 35 36 37 38 39 00 00 00 00 00 00&gt; return bytes}let cipher = crypto.createCipheriv(algorithm, handleKey(key), iv)let crypted = cipher.update('Node.js 技术栈', encoding, cipherEncoding)crypted += cipher.final(cipherEncoding)console.log(crypted) // jE0ODwuKN6iaKFKqd3RF4xFZkOpasy8WfIDl8tRC5t0= 缓冲（Buffer）与缓存（Cache）的区别缓冲（Buffer）缓冲（Buffer）是用于处理二进制流数据，将数据缓冲起来，它是临时性的，对于流式数据，会采用缓冲区将数据临时存储起来，等缓冲到一定的大小之后在存入硬盘中 视频播放器就是一个经典的例子，有时你会看到一个缓冲的图标，这意味着此时这一组缓冲区并未填满，当数据到达填满缓冲区并且被处理之后，此时缓冲图标消失，你可以看到一些图像数据 缓存（Cache）缓存（Cache）我们可以看作是一个中间层，它可以是永久性的将热点数据进行缓存，使得访问速度更快 例如我们通过 Memory、Redis 等将数据从硬盘或其它第三方接口中请求过来进行缓存，目的就是将数据存于内存的缓存区中，这样对同一个资源进行访问，速度会更快，也是性能优化一个重要的点 更多区别可以参考 Cache 和 Buffer 都是缓存，主要区别是什么？ 字节对齐截取自 数据结构对齐 - 维基百科 所谓的字节对齐，就是各种类型的数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这个就是对齐 我们经常听说的对齐在 N 上，它的含义就是数据的存放起始地址 %N== 0，首先还是让我们来看一下，为什么要进行字节对齐吧 各个硬件平台对存储空间的处理上有很大的不同，一些平台对某些特定类型的数据只能从某些特定地址开始存取，比如有些架构的 CPU，诸如 SPARC 在访问一个没有进行对齐的变量的时候会发生错误，那么在这种架构上必须编程必须保证字节对齐，而有些平台对于没有进行对齐的数据进行存取时会产生效率的下降 让我们来以 x86 为例看一下如果在不进行对齐的情况下，会带来什么样子的效率低下问题，看下面的数据结构声明 123456struct A { char c; // 字符占一个字节 int i; // 整型占四个字节 }; struct A a; 假设变量 a 存放在内存中的起始地址为 0x00，那么其成员变量 c 的起始地址为 0x00，成员变量 i 的起始地址为0x01，变量 a 一共占用了 5 个字节 当 CPU 要对成员变量 c 进行访问时，只需要一个读周期即可 然而如果要对成员变量 i 进行访问，那么情况就变得有点复杂了，首先 CPU 用了一个读周期，从 0x00 处读取了 4 个字节（注意由于是 32 位架构） 然后将 0x01 - 0x03 的 3 个字节暂存，接着又花费了一个读周期读取了从 0x04 - 0x07 的 4 字节数据，将 0x04 这个字节与刚刚暂存的 3 个字节进行拼接从而读取到成员变量 i 的值 为了读取这个成员变量 i，CPU 花费了整整 2 个读周期，试想一下，如果数据成员 i 的起始地址被放在了 0x04 处，那么读取其所花费的周期就变成了 1，显然引入字节对齐可以避免读取效率的下降，但这同时也浪费了 3 个字节的空间（0x01 - 0x03） 了解完字节对齐的概念和使用字节对齐的原因，最后我们来看一下 Buffer.js 文件中的实现字节对齐的 alignPool() 函数： 1234567891011121314/** * 如果不按照平台要求对数据存放进行对齐，会带来存取效率上的损失 * 比如 32 位的 Intel 处理器通过总线访问内存数据每个总线周期从偶地址开始访问 32 位内存数据 * 内存数据以字节为单位存放，如果一个 32 位的数据没有存放在 4 字节整除的内存地址处 * 那么处理器就需要 2 个总线周期对其进行访问，显然访问效率下降很多 */function alignPool() { // Ensure aligned slices // 后四位：0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 if (poolOffset &amp; 0x7) { poolOffset |= 0x7; poolOffset++; }} 参考 Node.js 中的缓冲区（Buffer）究竟是什么？ buffer buffer.js 深入浅出 Node.js 数据结构对齐 - 维基百科 Cache 和 Buffer 都是缓存，主要区别是什么？ Do you want a better understanding of Buffer in Node.js A cartoon intro to ArrayBuffers and SharedArrayBuffers DataView ArrayBuffer Node.js Buffer 解读 Node 中的 Buffer Cache 和 Buffer 都是缓存，主要区别是什么？","link":"/2019/09/22/Node/10/"},{"title":"中间件","text":"在使用 koa.js 的过程当中，经常会接触到中间件这个概念，之前在学习 Redux 的过程当中，里面也有一个中间件（Middleware）的概念 所以就打算抽点时间，整理一下中间件的相关概念，应该会整理成一个系列文章，方向是比较偏向于 koa.js，但是本质上原理都是类似的 什么是中间件 中间件是介于应用系统和系统软件之间的一类软件，它使用系统软件所提供的基础服务（功能），衔接网络上应用系统的各个部分或不同的应用，能够达到资源共享、功能共享的目的 上面是 维基百科 当中对于中间件的解释 看上去比较抽象，其实简单的总结来说，所谓中间件，就是处在服务业务与用户应用中间的软件（架构），主要用来将具体业务和底层逻辑解耦的组件 在深入展开之前，我们先来看看中间件的洋葱模型 中间件的洋葱模型关于洋葱模型，也不说复杂了，直接通过几个例子来了解一下到底什么是中间件的洋葱模型，先以 express 为例 12345678910111213141516171819202122232425262728293031323334353637383940414243var express = require('express')var app = express()app.use(function middleware1(req, res, next) { console.log('A middleware1 开始') next() console.log('B middleware1 结束')})app.use(function middleware2(req, res, next) { console.log('C middleware2 开始') next() console.log('D middleware2 结束')})app.use(function middleware3(req, res, next) { console.log('E middleware3 开始') next() console.log('F middleware3 结束')})app.get('/', function handler(req, res) { res.send('ok') console.log('======= G =======')})if (module.parent) { module.exports = app} else { app.listen(8080)}// =============================================// 控制台输出结果为A middleware1 开始C middleware2 开始E middleware3 开始======= G =======F middleware3 结束D middleware2 结束B middleware1 结束 运行结果的示意图如下 123456789101112131415161718192021 -------------------------------------- | middleware1 | | ---------------------------- | | | middleware2 | | | | ------------------- | | | | | middleware3 | | | | | | | | | next next next ——————————— | | |请求 ——————————————————&gt; | handler | — 收尾工作-&gt; |响应 &lt;————————————————— | G | | | | | A | C | E ——————————— F | D | B | | | | | | | | | ------------------- | | | ---------------------------- | --------------------------------------顺序 A -&gt; C -&gt; E -&gt; G -&gt; F -&gt; D -&gt; B \\---------------/ \\----------/ ↓ ↓ 请求响应完毕 收尾工作 在 Redux 的里面也有一个中间件（Middleware）的概念，如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function middleware1(store) { return function (next) { return function (action) { console.log('A middleware1 开始'); next(action) console.log('B middleware1 结束'); }; };}function middleware2(store) { return function (next) { return function (action) { console.log('C middleware2 开始'); next(action) console.log('D middleware2 结束'); }; };}function middleware3(store) { return function (next) { return function (action) { console.log('E middleware3 开始'); next(action) console.log('F middleware3 结束'); }; };}function reducer(state, action) { if (action.type === 'MIDDLEWARE_TEST') { console.log('======= G ======='); } return {};}var store = Redux.createStore( reducer, Redux.applyMiddleware( middleware1, middleware2, middleware3 ));store.dispatch({ type: 'MIDDLEWARE_TEST' }); 运行结果的示意图如下 123456789101112131415161718192021 -------------------------------------- | middleware1 | | ---------------------------- | | | middleware2 | | | | ------------------- | | | | | middleware3 | | | | | | | | | next next next ——————————— | | |dispatch —————————————&gt; | reducer | — 收尾工作-&gt;|nextState &lt;————————————— | G | | | | | A | C | E ——————————— F | D | B | | | | | | | | | ------------------- | | | ---------------------------- | --------------------------------------顺序 A -&gt; C -&gt; E -&gt; G -&gt; F -&gt; D -&gt; B \\---------------/ \\----------/ ↓ ↓ 更新 state 完毕 收尾工作 当然，在 koa.js 当中也是一样的 123456789101112131415161718192021222324252627282930313233343536373839const Koa = require('koa');let app = new Koa();const middleware1 = async (ctx, next) =&gt; { console.log('A middleware1 开始'); await next(); console.log('B middleware1 结束') }const middleware2 = async (ctx, next) =&gt; { console.log('C middleware2 开始') await next(); console.log('D middleware2 结束')}const middleware3 = async (ctx, next) =&gt; { console.log('E middleware3 开始') await next(); console.log('F middleware3 结束')}app.use(middleware1);app.use(middleware2);app.use(middleware3);app.use(async(ctx, next) =&gt; { ctx.body = 'hello world' console.log('======= G =======')})app.listen(3000)// A middleware1 开始// C middleware2 开始// E middleware3 开始// ======= G =======// F middleware3 结束// D middleware2 结束// B middleware1 结束 可以发现，结果是一致的，至于为什么会出现以上的结果，这也就是本篇文章需要说到的地方 这个主要是 koa.js 的一个中间件引擎 koa-compose 模块来实现的，也就是 koa.js 实现洋葱模型的核心引擎 Koa.js 的切面koa.js 的切面是由中间件机制实现的，一个中间件一般有两个切面 遵循先进后出的切面执行顺序，类似入栈出栈的顺序，可以参考下图 中间件原理通过之前的洋葱模型可以看出，中间件的在 await next() 前后的操作，很像数据结构的一种场景，就是先进后出的栈，同时又有统一上下文管理操作数据 在 koa.js 当中最为人所知的便是基于洋葱模型的 http 中间件处理流程 koa.js 当中的洋葱模式可以拆解成以下几个元素 生命周期 中间件 中间件在生命周期中 前置操作 等待其他中间件操作 后置操作 所以综上所述，我们也可以总结出一下中间件的相关特性 有统一的 context 操作先进后出（栈数据结构） 有控制先进后出的机制的 next() 方法 有提前结束机制 这样子我们可以单纯用 promise 做个简单的实现如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950let context = { data: []};async function middleware1(ctx, next) { console.log('A middleware1 开始'); ctx.data.push(1); await next(); console.log('B middleware1 结束'); ctx.data.push(6);}async function middleware2(ctx, next) { console.log('C middleware2 开始'); ctx.data.push(2); await next(); console.log('D middleware2 结束'); ctx.data.push(5);}async function middleware3(ctx, next) { console.log('E middleware3 开始'); ctx.data.push(3); await next(); console.log('F middleware3 结束'); ctx.data.push(4);}Promise.resolve(middleware1(context, async () =&gt; { return Promise.resolve(middleware2(context, async () =&gt; { return Promise.resolve(middleware3(context, async () =&gt; { console.log('======= G =======') return Promise.resolve(); })); }));})) .then(() =&gt; { console.log('end'); console.log('context = ', context); });// A middleware1 开始// C middleware2 开始// E middleware3 开始// ======= G =======// F middleware3 结束// D middleware2 结束// B middleware1 结束// end// context = { data: [ 1, 2, 3, 4, 5, 6 ] } 我们可以简单的梳理一下上述示例的执行流程 生命周期就是 Promise.resolve 的嵌套 中间件就是 middleware1、middleware2 和 middleware3 中间件在生命周期中，就是 Promise.resolve(middleware) 嵌套中执行中间件 middleware1 前置操作是 A 等待嵌套的 middleware2 middleware2 前置操作是 C 等待嵌套的 middleware3 middleware3 前置操作是 E middleware3 前置操作是 F middleware2 后置操作是 D middleware1 后置操作是 B 实现通过上一节中的中间件原理，我们可以看出，单纯的使用 promise 嵌套是可以直接实现中间件流程的 虽然可以实现，但是 promise 嵌套会产生代码的可读性和可维护性的问题，也带来了中间件扩展问题 所以需要把 promise 嵌套实现的中间件方式进行高度抽象，达到可以自定义中间件的层数 在这种情况下，我们就可以采用 async/await 来进行实现，我们先来理清实现过程当中需要的步骤 中间件队列 处理中间件队列，并将上下文 context 传进去 中间件的流程控制器 next() 异常处理 根据上一节的中间的原理，我们可以抽象出 每一个中间件需要封装一个 promise 利用洋葱模型的先进后出操作，对应 promise.resolve() 的前后操作 1234567891011121314151617181920212223242526272829303132333435363738function compose(middleware) { if (!Array.isArray(middleware)) { throw new TypeError(`Middleware stack must be an array!`) } return function (ctx, next) { let index = -1; return dispatch(0) function dispatch(i) { if (i &lt; index) { return Promise.reject(new Error(`next() called multiple times.`)); } index = i; let fn = middleware[i]; if (i === middleware.length) { fn = next; } if (!fn) { return Promise.resolve() } try { return Promise.resolve(fn(ctx, _ =&gt; { return dispatch(i + 1) })); } catch (err) { return Promise.reject(err) } } }} 下面就让我们来简单是试用一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445let middleware = [];let context = { data: []}middleware.push(async (ctx, next) =&gt; { console.log('A middleware1 开始'); ctx.data.push(1) await next() console.log('B middleware1 结束'); ctx.data.push(6)})middleware.push(async (ctx, next) =&gt; { console.log('C middleware2 开始'); ctx.data.push(2) await next() console.log('D middleware2 结束'); ctx.data.push(5)})middleware.push(async (ctx, next) =&gt; { console.log('E middleware3 开始'); ctx.data.push(3) await next() console.log('F middleware3 结束'); ctx.data.push(4)})const fn = compose(middleware)fn(context) .then(_ =&gt; { console.log('end'); console.log('context = ', context); })// A middleware1 开始// C middleware2 开始// E middleware3 开始// F middleware3 结束// D middleware2 结束// B middleware1 结束// end// context = { data: [ 1, 2, 3, 4, 5, 6 ] }","link":"/2019/10/19/Node/15/"},{"title":"常用中间件的实现","text":"接上回 中间件 在前面一章，我们介绍了中间件的基本概念，以及洋葱模型，最后我们也手动实现了一个简单的 compose() 方法 这一章我们主要手动的来实现一个最基本的 koa.js 框架以及 koa.js 当中一些比较常用的中间件的简单实现，比如 koa-logger 和 koa-static 等 文中所有的示例源码均可见 koa2-example ctx在实现基本的框架之前，我们先来看看 koa.js 当中的 ctx 这个对象，一般我们使用的话是这么用的 123app.use(async (ctx, next) =&gt; { ctx.body = 'hello world';}); 上面示例当中的 ctx，其实就是 context，大多数人称之为上下文对象，这个对象下有四个主要的属性，它们分别是 ctx.req – 原生的 req 对象 ctx.res – 原生的 res 对象 ctx.request – koa.js 自己封装的 request 对象 ctx.response – koa.js 自己封装的 response 对象 其中 koa.js 自己封装的和原生的最大的区别在于：koa.js 自己封装的请求和响应对象的内容不仅囊括原生的还添加了一些额外的东西 除此之外，ctx 本身还代理了 ctx.request 和 ctx.response 身上的属性，比如下面的示例 12345// 如果是在原生当中，则是需要经过 url.parse(p, true).query 才能得到的 query 对象console.log(ctx.query);// 如果是在原生当中，则是需要经过 url.parse(p).pathname 才能得到的路径（url 去除 query 部分）console.log(ctx.path); 框架的实现我们先来简单的总结一下 koa.js 的一些基本特点 有一个可以注册使用中间件的 use() 方法 还有一个服务事件监听事件 listen() 方法，并且可以接收回调函数 我们先来使用最简单的回调方法来实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566const http = require('http')const Emitter = require('events')class WebServer extends Emitter { constructor() { super() this.middleware = [] this.context = Object.create(null) } // 服务事件监听 listen(...args) { const server = http.createServer(this.callback()) return server.listen(...args) } // 注册使用中间件 use(fn) { if (typeof fn === 'function') { this.middleware.push(fn) } } // 回调方法 callback() { let that = this; if (this.listeners('error').length === 0) { this.on('error', this.onerror) } const henadleRequest = (req, res) =&gt; { let context = that.createContext(req, res) this.middleware.forEach((cb, idx) =&gt; { try { cb(context) } catch (err) { that.onerror(err) } if (idx + 1 &gt;= this.middleware.length) { if (res &amp;&amp; typeof res.end === 'function') { res.end() } } }) } return henadleRequest } // 异常监听处理 onerror(err) { console.log(err) } // 创建通用上下文 createContext(req, res) { let content = Object.create(this.context) content.req = req; content.res = res; return content; }}module.exports = WebServer 然后来稍微的测试一下我们上面定义的服务 123456789101112131415161718const WebServer = require('./index')const app = new WebServer()app.use(ctx =&gt; { ctx.res.write('hello world 1 \\n')})app.use(ctx =&gt; { ctx.res.write('hello world 2 \\n')})app.use(ctx =&gt; { ctx.res.write('hello world 3 \\n')})app.listen(3000, _ =&gt; { console.log(`app is running at port 3000`)}) 发现是可以正常使用的，但是这里面有一个问题，就是我们在处理中间件队列的时候，底层使用的是回调嵌套去处理的 但是中间件越多，回调嵌套越深，代码的可读性和可扩展性就很差，所以我们就可以考虑将我们的 handleRequest 方法调整为 async/await 方式 所以在这种情况下，我们就可以使用我们之前已经定义过的 compose() 方法，如下 12345678const handleRequest = (req, res) =&gt; { let context = this.createContext(req, res); let middleware = this.middleware; // 执行中间件 compose(middleware)(context).catch(err =&gt; this.onerror(err))};return handleRequest; 下面是整合后的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970const http = require('http');const Emitter = require('events');const compose = require('./compose');// 通用上下文const context = { _body: null, get body() { return this._body; }, set body(val) { this._body = val; this.res.end(this._body); }};class SimpleKoa extends Emitter { constructor() { super(); this.middleware = []; this.context = Object.create(context); } // 服务事件监听 listen(...args) { const server = http.createServer(this.callback()); return server.listen(...args); } // 注册使用中间件 use(fn) { if (typeof fn === 'function') { this.middleware.push(fn); } } // 中间件总回调方法 callback() { if (this.listeners('error').length === 0) { this.on('error', this.onerror); } const handleRequest = (req, res) =&gt; { let context = this.createContext(req, res); let middleware = this.middleware; // 执行中间件 compose(middleware)(context).catch(err =&gt; this.onerror(err)) }; return handleRequest; } // 异常处理监听 onerror(err) { console.log(err); } // 创建通用上下文 createContext(req, res) { let context = Object.create(this.context); context.req = req; context.res = res; return context; }}module.exports = SimpleKoa; 测试一下 1234567891011const SimpleKoa = require('./index');const app = new SimpleKoa();app.use(async ctx =&gt; { ctx.body = '&lt;p&gt;SimpleKoa&lt;/p&gt;';});app.listen(3000, () =&gt; { console.log(`app is running at port 3000`);}); 发现是可以正常使用的，下面我们再来看看 koa.js 当中的一些比较常用的中间件的实现 koa-logger我们先来看一个比较简单的 koa-logger 的实现，我们这里只实现简单的拦截请求，打印请求的 url，以及操作响应并且打印出响应的 url 通过实现可以发现，这里就用到了我们之前提到过的洋葱模型 123456789101112131415const logger = async (ctx, next) =&gt; { let res = ctx.res; // 拦截操作请求 request console.log(`&lt;== 请求的方式和地址为 ${ctx.method} ${ctx.url}`); await next(); // 拦截操作响应 request res.on('finish', _ =&gt; { console.log(`==&gt; 响应的方式和地址为 ${ctx.method} ${ctx.url}`); })}module.exports = logger; 直接引入使用即可 1234567891011const Koa = require('koa')const logger = require('./log')const app = new Koa()app.use(logger)app.use(async (ctx, next) =&gt; { ctx.body = `hello world`})app.listen(3000) koa-send主要参考的是官方的 koajs/send，主要流程如下 拦截请求，判断该请求是否请求本地静态资源文件 操作响应，返回对应的静态文件文本内容或出错提示 简单的梳理一下，可以分为以下几个步骤 配置静态资源绝对目录地址 判断是否支持隐藏文件 获取文件或者目录信息 判断是否需要压缩 设置 http 头信息 静态文件读取 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697const fs = require('fs');const path = require('path');const { basename, extname} = path;const defaultOpts = { root: '', maxage: 0, immutable: false, extensions: false, hidden: false, brotli: false, gzip: false, setHeaders: () =&gt; { }};async function send(ctx, urlPath, opts = defaultOpts) { const { root, hidden, immutable, maxage, brotli, gzip, setHeaders } = opts; let filePath = urlPath; // 配置静态资源绝对目录地址 try { filePath = decodeURIComponent(filePath); if (/[\\.]{2,}/ig.test(filePath)) { ctx.throw(403, 'Forbidden'); } } catch (err) { ctx.throw(400, 'failed to decode'); } filePath = path.join(root, urlPath); const fileBasename = basename(filePath); // 判断是否支持隐藏文件 if (hidden !== true &amp;&amp; fileBasename.startsWith('.')) { ctx.throw(404, '404 Not Found'); return; } // 获取文件或者目录信息 let stats; try { stats = fs.statSync(filePath); if (stats.isDirectory()) { ctx.throw(404, '404 Not Found'); } } catch (err) { const notfound = ['ENOENT', 'ENAMETOOLONG', 'ENOTDIR'] if (notfound.includes(err.code)) { ctx.throw(404, '404 Not Found'); return; } err.status = 500 throw err } let encodingExt = ''; // 判断是否需要压缩 if (ctx.acceptsEncodings('br', 'identity') === 'br' &amp;&amp; brotli &amp;&amp; (fs.existsSync(filePath + '.br'))) { filePath = filePath + '.br'; ctx.set('Content-Encoding', 'br'); ctx.res.removeHeader('Content-Length'); encodingExt = '.br'; } else if (ctx.acceptsEncodings('gzip', 'identity') === 'gzip' &amp;&amp; gzip &amp;&amp; (fs.existsSync(filePath + '.gz'))) { filePath = filePath + '.gz'; ctx.set('Content-Encoding', 'gzip'); ctx.res.removeHeader('Content-Length'); encodingExt = '.gz'; } // 设置 http 头信息 if (typeof setHeaders === 'function') { setHeaders(ctx.res, filePath, stats); } ctx.set('Content-Length', stats.size); if (!ctx.response.get('Last-Modified')) { ctx.set('Last-Modified', stats.mtime.toUTCString()); } if (!ctx.response.get('Cache-Control')) { const directives = ['max-age=' + (maxage / 1000 | 0)]; if (immutable) { directives.push('immutable'); } ctx.set('Cache-Control', directives.join(',')); } const ctxType = encodingExt !== '' ? extname(basename(filePath, encodingExt)) : extname(filePath); ctx.type = ctxType; // 静态文件读取 ctx.body = fs.createReadStream(filePath);}module.exports = send; 使用如下 123456789const send = require('./send');const Koa = require('koa');const app = new Koa();app.use(async ctx =&gt; { await send(ctx, ctx.path, { root: `${__dirname}/public` });});app.listen(3000); koa-static之前我们简单的介绍了 koa-send 这个中间件，但是这个中间件平常使用的较少，因为 koa.js 官方对 koa-send 进行了二次封装，推出了我们所熟知的 koa-static 中间件，目标是用于做静态服务器或者项目静态资源管理 当然，还是主要依赖我们之前已经实现的 koa-send 这个中间件，因为需要它的静态文件读取过程，我们先来简单的梳理一下实现流程 配置静态资源绝对目录地址 判断是否支持等待其他请求 判断是否为 GET 和 HEAD 类型的请求 通过 koa-send 中间件读取和返回静态文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// static.jsconst { resolve } = require('path');const send = require('./send');function statics(opts = { root: '' }) { opts.root = resolve(opts.root); // 是否需要等待其他请求 if (opts.defer !== true) { // 如果需要等待其他请求 return async function statics(ctx, next) { let done = false; if (ctx.method === 'HEAD' || ctx.method === 'GET') { try { await send(ctx, ctx.path, opts); done = true; } catch (err) { if (err.status !== 404) { throw err; } } } if (!done) await next(); }; } else { // 如果不需要等待其他请求 return async function statics(ctx, next) { await next(); if (ctx.method !== 'HEAD' &amp;&amp; ctx.method !== 'GET') { return; } if (ctx.body != null || ctx.status !== 404) { return; } try { await send(ctx, ctx.path, opts); } catch (err) { if (err.status !== 404) { throw err; } } }; }}module.exports = statics; 使用如下 12345678910const path = require('path');const Koa = require('koa');const statics = require('./static');const app = new Koa();const root = path.join(__dirname, './public')app.use(statics({ root }))app.listen(3000) koa-view这一个中间件，在官方当中比较有代表性的是 koa-ejs 中间件，它实现了代理上下文（context），即把渲染的方法挂载在 koa 实例 app 的 app.context 属性中 所以这里我们就简单的实现一个模版渲染中间件来模仿 koa-ejs 的基本能力 老规矩，简单的梳理一下实现流程 初始化一个 koa 实例（let app = new Koa()） 将需要的属性或者方法 view 挂载在 app.context 上（app.context.view） 在 app.use() 中间件直接使用 ctx.view 方法或属性渲染模板 123456789101112131415161718192021// view.jsconst path = require('path');const fs = require('fs');function view(app, opts = {}) { const { baseDir = '' } = opts; // 将需要的属性或者方法挂载在 app.context 上 app.context.view = function (page = '', obj = {}) { let ctx = this; let filePath = path.join(baseDir, page); if (fs.existsSync(filePath)) { let tpl = fs.readFileSync(filePath, 'binary'); ctx.body = tpl; } else { ctx.throw(404); } };}module.exports = view; 然后我们来使用一下，目录结构如下 123456.├── view.js├── index.js└── views ├── hello.html └── index.html index.js 如下 12345678910111213141516171819202122232425const Koa = require('koa');const path = require('path');const view = require('./view');// 初始化一个 Koa 实例const app = new Koa()// 将需要的属性或者方法挂载在 app.context 上view(app, { baseDir: path.join(__dirname, 'views')})app.use(async ctx =&gt; { await ctx.view(`${ctx.path}.html`, { title: 'index page' })})app.use(async ctx =&gt; { await ctx.view(`${ctx.path}.html`, { title: 'index page' })})app.listen(3000) 直接运行，然后在浏览器当中访问对应的路由即可（/hello 和 /index） koa-jsonp下面来看一个跟我们之前实现的 koa-view 非常类似的一个示例，本质上原理是一致的 就是首先初始化一个 koa 实例，将需要的属性或者方法 jsonp 挂载在 app.context 上，当前请求响应要返回 jsonp 数据时候设置 ctx.body = ctx.jsonp(result) 123456789101112131415161718192021// jsonp.jsfunction jsonp(app, opts = {}) { let callback = opts.callback || 'callback'; app.context.jsonp = function (obj = {}) { let ctx = this; if (Object.prototype.toString.call(obj).toLowerCase() === '[object object]') { let jsonpStr = `;${callback}(${JSON.stringify(obj)})`; // 用 text/javascript 让请求支持跨域获取 ctx.type = 'text/javascript'; // 输出 jsonp 字符串 ctx.body = jsonpStr; } else { ctx.throw(500, 'result most be a json'); } };}module.exports = jsonp; 然后我们来测试一下 1234567891011121314const Koa = require('koa');const jsonp = require('./jsonp');const app = new Koa();jsonp(app, {})app.use(async ctx =&gt; { await ctx.jsonp({ data: 'this is jsonp test', success: true })})app.listen(3000) 可以发现，访问 3000 端口的时候可以看到我们返回的 callback koa-bodyparser本节主要参考的是官方 koajs/bodyparser 如果有使用过 bodyparser 这个中间件，就会了解到 bodyparser 中间件的主要作用就是： 拦截 POST 请求，然后等待解析表单信息，最后把表单信息代理到 ctx.request.body 上 这样一来，在后面的中间件当中都可以使用 ctx.request.body 来获取表单当中的数据，下面我们就来看看是如何实现的 我们先来看看如何来解析请求体当中的数据流 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475function readStream(req) { return new Promise((resolve, reject) =&gt; { try { streamEventListen(req, (data, err) =&gt; { if (data &amp;&amp; !isError(err)) { resolve(data); } else { reject(err); } }); } catch (err) { reject(err); } });}function isError(err) { return Object.prototype.toString.call(err).toLowerCase() === '[object error]';}function streamEventListen(req, callback) { let stream = req.req || req; let chunk = []; let complete = false; // attach listeners stream.on('aborted', onAborted); stream.on('close', cleanup); stream.on('data', onData); stream.on('end', onEnd); stream.on('error', onEnd); function onAborted() { if (complete) { return; } callback(null, new Error('request body parse aborted')); } function cleanup() { stream.removeListener('aborted', onAborted); stream.removeListener('data', onData); stream.removeListener('end', onEnd); stream.removeListener('error', onEnd); stream.removeListener('close', cleanup); } function onData(data) { if (complete) { return; } if (data) { chunk.push(data.toString()); } } function onEnd(err) { if (complete) { return; } if (isError(err)) { callback(null, err); return; } complete = true; let result = chunk.join(''); chunk = []; callback(result, null); }}module.exports = readStream; 然后再来实现我们的 bodyparser 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const readStream = require('./readStream');let strictJSONReg = /^[\\x20\\x09\\x0a\\x0d]*(\\[|\\{)/;let jsonTypes = [ 'application/json'];let formTypes = [ 'application/x-www-form-urlencoded'];let textTypes = [ 'text/plain'];function parseQueryStr(queryStr) { let queryData = {}; let queryStrList = queryStr.split('&amp;'); for (let [index, queryStr] of queryStrList.entries()) { let itemList = queryStr.split('='); queryData[itemList[0]] = decodeURIComponent(itemList[1]); } return queryData;}function bodyParser(opts = {}) { return async function (ctx, next) { // 拦截 POST 请求 if (!ctx.request.body &amp;&amp; ctx.method === 'POST') { // 解析请求体中的表单信息 let body = await readStream(ctx.request.req); let result = body; if (ctx.request.is(formTypes)) { result = parseQueryStr(body); } else if (ctx.request.is(jsonTypes)) { if (strictJSONReg.test(body)) { try { result = JSON.parse(body); } catch (err) { ctx.throw(500, err); } } } else if (ctx.request.is(textTypes)) { result = body; } // 将请求体中的信息挂载到上下文的 request 属性中 ctx.request.body = result; } await next(); };}module.exports = bodyParser; 下面我们建立个表单来测试一下，如下 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;index&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;form post demo&lt;/p&gt; &lt;form method=\"POST\" action=\"/post\"&gt; &lt;span&gt;data&lt;/span&gt; &lt;input name=\"userName\" type=\"text\"&gt; &lt;button type=\"submit\"&gt;submit&lt;/button&gt; &lt;/form&gt; &lt;script src=\"./index.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324const Koa = require('koa');const fs = require('fs');const path = require('path');const body = require('./bodyparser');const app = new Koa();app.use(body());app.use(async (ctx, next) =&gt; { if (ctx.url === '/') { // 当 GET 请求时候返回表单页面 let html = fs.readFileSync(path.join(__dirname, './index.html'), 'binary'); ctx.body = html; } else if (ctx.url === '/post' &amp;&amp; ctx.method === 'POST') { // 当 POST 请求的时候，解析 POST 表单里的数据，并显示出来 ctx.body = ctx.request.body; } else { ctx.body = '404'; } await next();});app.listen(3000) 可以发现，页面可以正常输出 koa-router最后我们来看一个不直接提供中间件，而是通过间接方式提供了中间件，最具代表性的莫过于 koa-router 了，我们先来看下实现步骤 初始化路由实例 注册路由请求信息缓存到实例中 请求类型 请求 path 对应的请求后操作 注册的路由操作就是子中间件 路由实例输出父中间件 返回一个父中间件 中间件里对每次请求进行遍历匹配缓存中注册的路由操作 匹配上请求类型，路径就执行对应路由子中间件 app.use() 路由实例返回的父中间件 实现如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const methods = [ 'GET', 'PUT', 'PATCH', 'POST', 'DELETE'];class Layer { constructor(path, methods, middleware, opts) { this.path = path; this.methods = methods; this.middleware = middleware; this.opts = opts; }}class Router { constructor(opts = {}) { this.stack = []; } register(path, methods, middleware, opts) { let route = new Layer(path, methods, middleware, opts); this.stack.push(route); return this; } routes() { let stock = this.stack; return async function (ctx, next) { let currentPath = ctx.path; let route; for (let i = 0; i &lt; stock.length; i++) { let item = stock[i]; if (currentPath === item.path &amp;&amp; item.methods.indexOf(ctx.method) &gt;= 0) { route = item.middleware; break; } } if (typeof route === 'function') { route(ctx, next); return; } await next(); }; }}methods.forEach(method =&gt; { Router.prototype[method.toLowerCase()] = Router.prototype[method] = function (path, middleware) { this.register(path, [method], middleware); };});module.exports = Router; 测试一下 1234567891011121314151617181920const Koa = require('koa')const Router = require('./router')const app = new Koa()// 初始化路由实例const router = new Router()// 注册路由请求信息缓存到实例中router.get('/index', async ctx =&gt; { ctx.body = 'index page'; });router.get('/post', async ctx =&gt; { ctx.body = 'post page'; });router.get('/list', async ctx =&gt; { ctx.body = 'list page'; });router.get('/item', async ctx =&gt; { ctx.body = 'item page'; });app.use(router.routes());app.use(async ctx =&gt; { ctx.body = '404';});app.listen(3000); 参考 koajs/send koajs/bodyparser Koa：核心探秘与入坑指北","link":"/2019/10/25/Node/16/"},{"title":"koa.js 源码解析","text":"接上回 中间件 和 常用中间件的实现 之前我们简单的介绍了一下中间件和洋葱模型的概念，然后我们手动实现了一个最基本的 koa.js 框架和一些比较常用的中间件 那么这一章我们就来深入的了解一下 koa.js 的源码 使用在分析源码之前，先直观看一下使用 koa.js 如何创建一个 server 12345678const Koa = require('koa');const app = new Koa();app.use(async ctx =&gt; { ctx.body = 'hello world';});app.listen(3000); 下面是一张来源于网络关于 koa.js 架构的示意图，我们可以对比着进行了解 入口文件一般我们都是从入口文件开始找起，如果你看了 koa.js 的源码，会发现 koa.js 源码其实很简单，一共就四个文件 123456// https://github.com/koajs/koa/tree/master/lib── lib ├── application.js ├── context.js ├── request.js └── response.js 其实这四个文件分别对应着 koa.js 当中的四个对象 12345── lib ├── application.js ==&gt; new Koa() || ctx.app ├── context.js ==&gt; ctx ├── request.js ==&gt; ctx.req || ctx.request └── response.js ==&gt; ctx.res || ctx.response 对比使用可以发现，其实总的来说就三个步骤 实例化一个对象（new Koa()） 注册一个或多个中间件（app.use(async ctx =&gt; { ... })） 调用 listen() 方法启动一个服务器 下面我们就按照步骤一个一个来了解 构造函数通过查看 package.json 的 main 字段中可以发现 application.js 是入口文件 下面是入口文件的部分源码，只罗列了一些比较核心的内容，详细见 lib/application.js 1234567891011121314151617181920212223242526// 依赖模块，我们主要看下面这几个const response = require('./response');const compose = require('koa-compose');const context = require('./context');const request = require('./request');const Emitter = require('events');const convert = require('koa-convert');// 可以发现 Application 类是继承于 EventEmitter 的// 所以我们在 koa 实例对象上可以使用 on，emit 等方法进行事件监听module.exports = class Application extends Emitter { constructor() { super(); // 因为继承于 EventEmitter，这里需要调用 super this.middleware = []; // 该数组存放所有通过 use 函数的引入的中间件函数 // 这两个见下方 this.proxy = false; // 代理设置 this.subdomainOffset = 2; // 下面这三个是我们重点需要关注的 // 分别通过 context.js、request.js、response.js 来创建对应的 context、request、response this.context = Object.create(context); this.request = Object.create(request); this.response = Object.create(response); }}; 相关内容都已经写在注释当中了，这里我们主要要提及两个属性 subdomainOffsetsubdomainOffset 属性会改变获取 subdomain 时返回数组的值，比如 test.page.example.com 域名 如果设置 subdomainOffset 为 2，那么返回的数组值为 ['page', 'test']，如果设置为 3，那么返回数组值为 ['test'] proxy顾名思义，指的是代理，属性值是 true 或者 false，它的作用在于是否获取真正的客户端 ip 地址 在我们实际运用当中，可能会使用很多的代理服务器，包括我们常见的正向代理与反向代理，虽然代理的用处很大，但是无法避免地我们有时需要知晓真正的客户端的请求 ip 而其实实际上，服务器并不知道真正的客户端请求 ip，即使你使用 socket.remoteAddrss 属性来查看，因为这个请求是代理服务器转发给服务器的 幸好代理服务器例如 nginx 提供了一个 http 头部来记录每次代理服务器的源 ip 地址，也就是 X-Forwarded-For 头部，形式如下 1X-Forwarded-For: client, proxy1, proxy2 如果一个请求跳转了很多代理服务器，那么 X-Forwarded-For 头部的 ip 地址就会越多，第一个就是原始的客户端请求 ip，第二个就是第一个代理服务器 ip，以此类推 当然，X-Forwarded-For 并不完全可信，因为中间的代理服务器可能会更改某些 ip（也有可能直接手动设定），所以 koa.js 中 proxy 属性的设置就是如果使用 true，那么就是使用 X-Forwarded-For 头部的第一个 ip 地址 如果使用 false，则使用 server 中的 socket.remoteAddress 属性值 除了 X-Forwarded-For 之外，proxy 还会影响 X-Forwarded-proto 的使用，和 X-Forwarded-For 一样，X-Forwarded-proto 记录最开始的请求连接使用的协议类型（http/https） 因为客户端与服务端之间可能会存在很多层代理服务器，而代理服务器与服务端之间可能只是使用 http 协议，并没有使用 https，所以 proxy 属性为 true 的话，koa.js 的 protocol 属性会去取 X-Forwarded-proto 头部的值 koa.js 中 protocol 属性会先使用 tlsSocket.encrypted 属性来判断是否是 https 协议，如果是则直接返回 https 关于此部分内容想了解更多的可以参考下面两个链接 科普文：如何伪造和获取用户真实 IP ？ egg.js 提供的 前置代理模式 接下来我们再来看注册中间件使用的 use() 方法 注册中间件在实例化一个对象以后，接下来使用 use() 方法来注册一个中间件，其实就是简单的 push 到自身的 mideware 这个数组中 12345678use(fn) { if (isGeneratorFunction(fn)) { // 兼容 koa v1 的 generator 写法 fn = convert(fn); } this.middleware.push(fn); return this;} 这其中有一个 convert() 的方法，简单来说就是将 koa v1 当中使用的 generator 函数转换成 koa v2 中的 async 函数 更准确的说是将 generator 函数转换成使用 co 包装成的 promise 对象，然后执行对应的代码 这里就不详细展开了，详细可以参考这篇博文 koa-convert 源码分析 启动服务最后调用 listen() 方法来启动服务 1234listen(...args) { const server = http.createServer(this.callback()); return server.listen(...args);} 使用了 Node.js 原生的 http.createServer() 来创建服务器，并把 this.callback() 作为参数传递进去 下面我们就来看一下这个核心的 callback() 函数 12345678910111213141516callback() { // 使用 koa-compose 来组合 middleware 的运行方式（可以参考之前我们手动实现的 compose 方法） const fn = compose(this.middleware); if (!this.listenerCount('error')) this.on('error', this.onerror); // 这里的 req, res 两个参数，代表原生的 request, response 对象 const handleRequest = (req, res) =&gt; { // 每次接受一个新的请求就是生成一次全新的 context const ctx = this.createContext(req, res); return this.handleRequest(ctx, fn); }; return handleRequest;} 这里主要涉及到三个方法 compose(this.middleware)洋葱模型实现的核心 123456789101112131415161718192021222324252627282930313233343536/** * Compose `middleware` returning a fully valid middleware comprised of all those which are passed. * * @param {Array} middleware * @return {Function} */function compose(middleware) { // 参数校验 if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!'); for (const fn of middleware) { if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!'); } /** * @param {Object} context * @return {Promise} */ return function (context, next) { // last called middleware # let index = -1; return dispatch(0); function dispatch(i) { if (i &lt;= index) return Promise.reject(new Error('next() called multiple times')); index = i; let fn = middleware[i]; if (i === middleware.length) fn = next; if (!fn) return Promise.resolve(); try { // 执行下一个中间件逻辑，并将 next 参数设置为 dispatch(i + 1) return Promise.resolve(fn(context, dispatch.bind(null, i + 1))); } catch (err) { return Promise.reject(err); } } };} 之前我们已经手动的实现了一个简化版本的了，这里就不详细展开了，可以参考之前的洋葱模型的实现章节 这里主要介绍其中两行代码 12if (i === middleware.length) fn = next;if (!fn) return Promise.resolve(); 在我们调用 fnMiddleware 是可以传入两个参数的，第二个可选参数表示最终的回调函数，比如 123fnMiddleware(ctx, () =&gt; { console.log(`done`, ctx);}); 当 i === middleware.length 成立时，实际上所有传入的 middleware 已经执行完 这个时候我们的 fn = next 表示 fn 被赋值给了这个传入的最终回调，接下来判断如果没有传入最终回调，那么整个中间件执行流程就到此结束 createContext(req, res)1234567891011121314createContext(req, res) { const context = Object.create(this.context); const request = context.request = Object.create(this.request); const response = context.response = Object.create(this.response); context.app = request.app = response.app = this; context.req = request.req = response.req = req; context.res = request.res = response.res = res; request.ctx = response.ctx = context; request.response = response; response.request = request; context.originalUrl = request.originalUrl = req.url; context.state = {}; return context;} 根据 req 和 res 封装中间件所需要的 ctx，简单来说就是将变量挂到 context 上面，然后最后返回，但是这里需要注意区分 request.req、response.req 指向的是 http 模块原生的 IncomingMessage 对象 而 request.response、response.request 指向的都是 koa.js 封装后的对象 即 ctx.req 和 ctx.res 是原生的 req 和 res 对象 而 ctx.request 和 ctx.response 则是 koa.js 自己封装的 request 和 response 对象 这里有一个小问题，这里明明只是将原生的 req 和 res 赋值给相应的属性，但是 ctx 上不是暴露出来很多属性吗？它们在哪里？ 这些东西我们就可以通过 request.js 和 response.js 的源码来了解了 通过源码可以发现，经过原型链的形式，我们 ctx.request 所能访问属性和方法绝大部分都在其对应的 request 这个简单的对象上面 1234567891011121314151617181920212223242526// https://github.com/koajs/koa/blob/master/lib/request.jsmodule.exports = { /** * Return request header. * * @return {Object} * @api public */ get header() { return this.req.headers; }, /** * Set request header. * * @api public */ set header(val) { this.req.headers = val; }, // ...} 所以当你操作 ctx.request.xx 的时候，其实访问的都是 resquest 这个对象上的属性的赋值器（setter）和取值器（getter） handleRequest(ctx, fnMiddleware)123456789// fnMiddleware 是经过 compose 包装后的函数handleRequest(ctx, fnMiddleware) { const res = ctx.res; res.statusCode = 404; const onerror = err =&gt; ctx.onerror(err); const handleResponse = () =&gt; respond(ctx); onFinished(res, onerror); return fnMiddleware(ctx).then(handleResponse).catch(onerror);} 这个函数简单来说只是负责执行中间件所有的函数, 并在中间件函数执行结束的时候调用 respond(ctx) 本质上，在执行 fnMiddleware(ctx) 的时候其实就会调用 compose() 方法当中的那个 dispatch(0)，然后开始不断递归，直到中间件流程执行结束，触发 handleResponse，也就是我们这里的 respond(ctx) 对请求的响应处理 respond对于 respond() 函数, 其核心就是根据不同类型的数据对 http 的响应头部与响应体 body 做对应的处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657function respond(ctx) { // allow bypassing koa // 用于设置自定义的 response 策略 if (false === ctx.respond) return; // writable 是原生的 response 对象的 writeable 属性，检查是否是可写流 if (!ctx.writable) return; const res = ctx.res; let body = ctx.body; const code = ctx.status; // ignore body // 如果响应的 statusCode 是属于 body 为空的类型，例如 204，205，304，将 body 置为 null if (statuses.empty[code]) { // strip headers ctx.body = null; return res.end(); } // 如果是 HEAD 方法 // 需要注意，HEAD 请求不返回 body if ('HEAD' == ctx.method) { // headersSent 属性 Node 原生的 response 对象上的，用于检查 http 响应头部是否已经被发送 // 如果头部未被发送，那么添加 length 头部 if (!res.headersSent &amp;&amp; isJSON(body)) { ctx.length = Buffer.byteLength(JSON.stringify(body)); } return res.end(); } // status body // 如果 body 值为空 if (null == body) { // body 值为 context 中的 message 属性或 code body = ctx.message || String(code); // 修改头部的 type 与 length 属性 if (!res.headersSent) { ctx.type = 'text'; ctx.length = Buffer.byteLength(body); } return res.end(body); } // responses if (Buffer.isBuffer(body)) return res.end(body); // 对 body 为 buffer 类型的进行处理 if ('string' == typeof body) return res.end(body); // 对 body 为字符串类型的进行处理 if (body instanceof Stream) return body.pipe(res); // 对 body 为流形式的进行处理，流式响应使用 pipe，更好的利用缓存 // body: json // 对 body 为 json 格式的数据进行处理，（转化为 json 字符串，添加 length 头部信息） body = JSON.stringify(body); if (!res.headersSent) { ctx.length = Buffer.byteLength(body); } res.end(body);} 可以发现，respond() 函数主要用于将中间件处理后的结果通过 res.end 返回给客户端 错误处理在 koa.js 中, 错误处理分为在 application.js 中的 onerror 处理函数与在 context.js 中的 onerror 处理函数 context 的 onerror 函数是绑定在中间函数数组生成的 promise 的 catch 中与 res 对象的 onFinished 函数的回调的（为了处理请求或响应中出现的 error 事件） application.js 中的 onerror 函数是绑定在 koa.js 实例对象上的, 它监听的是整个对象的 error 事件 这里，我们主要看 context 中的的 onerror() 函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162onerror(err) { // don't do anything if there is no error. // this allows you to pass `this.onerror` // to node-style callbacks. // 没有错误则忽略, 不执行下面的逻辑 if (null == err) return; // 将错误转化为 Error 实例 if (!(err instanceof Error)) err = new Error(util.format('non-error thrown: %j', err)); let headerSent = false; if (this.headerSent || !this.writable) { headerSent = err.headerSent = true; } // delegate // 触发 koa 实例对象的 error 事件, application 上的 onerror 函数会执行 this.app.emit('error', err, this); // nothing we can do here other // than delegate to the app-level // handler and log. // 如果响应头部已经发送（或者 socket 不可写）, 那么退出函数 if (headerSent) { return; } // 获取 http 原生 res 对象 const { res } = this; // first unset all headers // 根据文档 res.getHeaderNames 函数是 7.7.0 版本后添加的, 这里为了兼容做了一个判断 // 如果出错那么之前中间件或者其他地方设置的 HTTP 头部就无效了, 应该清空设置 if (typeof res.getHeaderNames === 'function') { res.getHeaderNames().forEach(name =&gt; res.removeHeader(name)); } else { res._headers = {}; // Node &lt; 7.7 } // then set those specified this.set(err.headers); // force text/plain // 出错后响应类型为 text/plain this.type = 'text'; // ENOENT support // 对 ENOENT 错误进行处理, ENOENT 的错误 message 是文件或者路径不存在, 所以状态码应该是 404 if ('ENOENT' == err.code) err.status = 404; // default to 500 // 默认设置状态码为 500 if ('number' != typeof err.status || !statuses[err.status]) err.status = 500; // respond const code = statuses[err.status]; const msg = err.expose ? err.message : code; // 设置响应状态码 this.status = err.status; // 设置响应 body 长度 this.length = Buffer.byteLength(msg); // 返回 message this.res.end(msg);} 在之前的 callback() 中的源码我们可以看到，app 会默认注册一个错误处理函数 1if (!this.listenerCount('error')) this.on('error', this.onerror); 但是我们每次 http 请求的错误其实是交给 ctx.onerror 处理的 1234const onerror = err =&gt; ctx.onerror(err);const handleResponse = () =&gt; respond(ctx);onFinished(res, onerror);return fnMiddleware(ctx).then(handleResponse).catch(onerror); onFinished 是确保一个流在关闭、完成和报错时都会执行相应的回调函数 ctx.onerror 这个函数在参数为空或者 null 的时候，直接返回，不会做任何操作，就是上面源码当中的 1234// don't do anything if there is no error.// this allows you to pass `this.onerror`// to node-style callbacks.if (null == err) return; 否则，则会触发 app 产生一个错误事件，如下 123// delegate// 触发 koa 实例对象的 error 事件, application 上的 onerror 函数会执行this.app.emit('error', err, this); 然后如果判断该请求处理依旧没有结束，也就是 app 注册的 onerror 事件没有结束该请求，则会尝试向客户端产生一个 500 的错误 1234567891011121314151617181920let headerSent = false;if (this.headerSent || !this.writable) { headerSent = err.headerSent = true;}// nothing we can do here other// than delegate to the app-level// handler and log.if (headerSent) { return;}// ...// default to 500if ('number' != typeof err.status || !statuses[err.status]) err.status = 500;// ...this.res.end(msg); 总结起来，我们可以在不同的抽象层次上处理错误，比如我们可以在顶层的中间件将所有中间件产生的错误捕获并处理了，这样错误就不会被上层捕获 我们也可以覆盖 ctx.onerror 的方式来捕获所有的异常，而且可以不触发 app 的 error 事件 最后我们也可以直接监听 app 的 error 事件的方式来处理错误 参考 koajs/koa context.js 十分钟带你看完 KOA 源码","link":"/2019/10/30/Node/17/"},{"title":"egg 实战（实现一个接口服务）","text":"之前我们已经了解过 koa.js 相关知识，今天我们来看看如何使用 egg.js 来实现一个接口服务 egg.js 是一个基于 koa.js 的框架，所以它应当属于框架之上的框架，它继承了 koa.js 的高性能优点，同时又加入了一些约束与开发规范，来规避 koa.js 框架本身的开发自由度太高的问题 koa.js 是一个比较基层的框架，它本身没有太多约束与规范，自由度非常高，每一个开发者实现自己的服务的时候，代码风格都可以能不太一样 而 egg.js 为了适应企业开发，加了一些开发时的规范与约束，从而解决 koa.js 这种自由度过高而导致不适合企业内使用的缺点，egg.js 便在这种背景下诞生 关于 egg.js 更多的特性，这里我们只做简单介绍，更多的可以参考官网 egg.js 需求需求比较简单，只需要实现一个接口服务即可 简单来说就是实现一个连接数据库，查询数据库里的数据并且提供一个 http 接口服务 下面我们来看看如何实现 实现首先安装 egg.js，根据官方文档提供的方法即可 12345$ npm init egg --type=simple$ npm i$ npm run dev 但是这里有一个需要注意的地方，如果想要使用 npm init egg 命令，npm 的版本需要 &gt;= 6.1.0 启动成功以后，我们先来建立一张表，用于我们的后续操作，使用的 SQL 如下 12345678910111213141516171819CREATE TABLE `Tab_User_Info` ( id INT(100) AUTO_INCREMENT PRIMARY KEY, name VARCHAR(50) NOT NULL COMMENT '姓名', uid VARCHAR(50) NOT NULL, sex tinyint(2) DEFAULT 1 COMMENT '1男2女', age tinyint(2) DEFAULT 1, description VARCHAR(50) DEFAULT NULL, `createdAt` datetime DEFAULT CURRENT_TIMESTAMP, `updatedAt` datetime DEFAULT CURRENT_TIMESTAMP) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT = 'test user';INSERT INTO Tab_User_Info (`name`, uid, sex, age, description) VALUES ( 'zhangsan', 'uid123', 1, 24, 'this is boy' ), ( 'lisi', 'uid124', 2, 24, 'this is girl' ), ( 'wangwu', 'uid125', 1, 26, 'this is test user' ), ( 'zhaoliu', 'uid126', 2, 44, 'this is test user5' ), ( 'test01', 'uid127', 2, 64, 'this is test user4' ), ( 'test02', 'uid128', 1, 14, 'this is test user2' ), ( 'test03', 'uid129', 2, 4, 'this is test user9' ); 完成后结果如下 123456789101112131415161718192021222324252627282930313233mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || test |+--------------------+2 rows in set (0.00 sec)mysql&gt; use test;Database changedmysql&gt; show tables;+----------------+| Tables_in_test |+----------------+| tab_user_info |+----------------+1 row in set (0.00 sec)mysql&gt; select * from tab_user_info;+----+----------+--------+------+------+--------------------+---------------------+---------------------+| id | name | uid | sex | age | description | createdAt | updatedAt |+----+----------+--------+------+------+--------------------+---------------------+---------------------+| 1 | zhangsan | uid123 | 1 | 24 | this is boy | 2019-11-12 17:51:38 | 2019-11-12 17:51:38 || 2 | lisi | uid124 | 2 | 24 | this is girl | 2019-11-12 17:51:38 | 2019-11-12 17:51:38 || 3 | wangwu | uid125 | 1 | 26 | this is test user | 2019-11-12 17:51:38 | 2019-11-12 17:51:38 || 4 | zhaoliu | uid126 | 2 | 44 | this is test user5 | 2019-11-12 17:51:38 | 2019-11-12 17:51:38 || 5 | test01 | uid127 | 2 | 64 | this is test user4 | 2019-11-12 17:51:38 | 2019-11-12 17:51:38 || 6 | test02 | uid128 | 1 | 14 | this is test user2 | 2019-11-12 17:51:38 | 2019-11-12 17:51:38 || 7 | test03 | uid129 | 2 | 4 | this is test user9 | 2019-11-12 17:51:38 | 2019-11-12 17:51:38 |+----+----------+--------+------+------+--------------------+---------------------+---------------------+7 rows in set (0.00 sec) 连接数据库首先安装 mysql 插件 egg-mysql 1$ npm install egg-mysql --save 接下来修改目录下的配置文件，开启 mysql 插件，更多的配置参数可以参考官方文档 egg-mysql 12345678910111213141516171819202122232425262728// app/config/plugin.jsmodule.exports = { mysql: { enable: true, package: 'egg-mysql', },};// app/config/config.default.jsconst mysql = { // 单数据库信息配置 client: { host: '127.0.0.1', port: '3306', user: 'root', password: '', database: 'test', }, // 是否加载到 app 上，默认开启 app: true, // 是否加载到 agent 上，默认关闭 agent: false,};return { mysql}; 路由然后再来实现路由 12345678// app/router.jsmodule.exports = app =&gt; { const { router, controller } = app; router.get('/', controller.home.index); router.get('/user/list', controller.user.list); router.get('/user/find', controller.user.find);}; 服务然后我们来添加两个服务，一个 searchAll() 方法和一个 find(id) 方法 123456789101112131415161718// app/service/user.js'use strict';const Service = require('egg').Service;class UserService extends Service { async searchAll() { const users = await this.app.mysql.select('tab_user_info'); return { users }; } async find(id) { const user = await this.app.mysql.get('tab_user_info', { id }); return { user }; }}module.exports = UserService; 控制器我们之前设定了两个服务，现在就建立一个对应的控制器来进行使用 1234567891011121314151617181920212223242526272829303132333435363738394041// app/controller/user.js'use strict';const Controller = require('egg').Controller;class UserController extends Controller { async list() { const { ctx } = this; try { const userList = await ctx.service.user.searchAll(); ctx.body = { success: true, data: userList, }; } catch (error) { ctx.body = { success: false, error, }; } } async find() { const { ctx } = this; try { if (!ctx.query.id) throw new Error('缺少参数'); const userList = await ctx.service.user.find(ctx.query.id); ctx.body = { success: true, data: userList, }; } catch (error) { ctx.body = { success: false, error, }; } }}module.exports = UserController; 验证下面我们就可以在浏览器当中访问 http://127.0.0.1:7001/user/list 来访问我们的接口 就可以发现已经将数据库当中所有的列表信息展示了出来，如果想针对单独的 id 进行查询，只需要访问 find 接口，然后传递参数即可，例如 http://127.0.0.1:7001/user/find?id=7 逻辑很简单，当路由匹配到我们对应访问的地址的时候（/user/list）就回去调用我们对应的控制器（controller.user.list） 然后在控制器当中又回去访问我们之前定义的服务来进行数据库的数据查询","link":"/2019/11/01/Node/18/"},{"title":"egg 问题汇总","text":"最近在深入学习 egg.js 相关知识，本篇文章主要用来记录一些当中遇到的坑或者知识点之类的 query &amp;&amp; queries在 url 中的 ? 后面的部分是一个 Query String，这一部分经常用于 GET 类型的请求中传递参数 例如 GET /search?name=zhangsan&amp;age=18 中 name=zhangsan&amp;age=18 就是用户传递过来的参数 egg.js 已经帮我们封装好了获取方式，所以我们可以直接通过 this.ctx.query 来拿到解析过后的这个参数体 12345678910111213'use strict';const Controller = require('egg').Controller;class NewsController extends Controller { async index() { const query = this.ctx.query; console.log(query.age); // 18 console.log(query); // { name: 'zhangsan', age: '18' } }}module.exports = NewsController; 不过这样的使用方式上有一点需要注意的地方 当 Query String 中的 key 重复时，this.ctx.query 只会取 key 第一次出现时的值，后面再出现的都会被忽略 比如 GET /search?name=zhangsan&amp;name=lisi 通过 this.ctx.query 拿到的值是 { name: 'zhangsan' } 但是有时候用户会传递相同的 key，例如 GET /search?name=zhangsan&amp;id=123&amp;id=456，针对此类情况，框架提供了 this.ctx.queries 对象 这个对象也解析了 Query String，但是它不会丢弃任何一个重复的数据，而是将他们都放到一个数组中 12345678910111213141516'use strict';const Controller = require('egg').Controller;class NewsController extends Controller { async index() { // GET /search?name=zhangsan&amp;id=123&amp;id=456 console.log(this.ctx.queries); // { // name: ['zhangsan'], // id: ['123', '456'], // } }}module.exports = NewsController; this.ctx.queries 上所有的 key 如果有值，也一定会是数组类型 helperhelper 函数用来提供一些实用的工具函数，它的作用在于我们可以将一些常用的动作抽离在 helper.js 里面成为一个独立的函数 下面来看一个比较常见的实例，序列化模版引擎当中的日期格式，我们先在 helper.js 当中定义我们格式化的方法 这里有个需要注意的地方，定义的文件名字需要是一致的，因为框架会把 app/extend/helper.js 中定义的对象与内置 helper 的 prototype 对象进行合并 在处理请求时会基于扩展后的 prototype 生成 helper 对象，这里使用的是 silly-datetime 这个日期库，使用其他的也是可行的 12345678910// app/extend/helper.js'use strict';const sd = require('silly-datetime');module.exports = { formatTime(time) { return sd.format(new Date(time * 1000), 'YYYY-MM-DD HH:mm'); },}; 然后在模版当中不需要引入之类的操作，直接使用即可（helper.formatTime()） 12345678&lt;!-- app/view/news.html --&gt;&lt;ul&gt; &lt;% for (var i = 0; i &lt; list.length; i++) {%&gt; &lt;li&gt; &lt;a href=\"/newscontent?aid=&lt;%= list[i].aid %&gt;\"&gt;&lt;%= list[i].title %&gt;&lt;/a&gt; --- &lt;span&gt;&lt;%= helper.formatTime(list[i].datetime) %&gt;&lt;/span&gt; &lt;/li&gt; &lt;% } %&gt;&lt;/ul&gt; 跨域请求设置可以使用 egg-cors 这个库，先配置 plugin.js 12345// config/plugin.jsexports.cors = { enable: true, package: 'egg-cors',}; 然后在配置 config.default.js 123456789101112131415// config/config.default.jsconfig.security = { csrf: { enable: false, ignoreJSON: true, }, // 配置白名单 domainWhiteList: ['http://www.baidu.com'],};config.cors = { // 允许所有跨域访问，如果注释掉则允许上面 白名单 访问 // origin: '*', allowMethods: 'GET, HEAD, PUT, POST, DELETE, PATCH',}; 不要使用全部允许跨域，可能会引起安全方面的问题，建议配置访问白名单（注释掉 origin 即可） 使用 koa 的中间件在框架里面可以非常容易的引入 koa 中间件生态，以 koa-compress 为例，在 koa 中使用时 1234567const koa = require('koa');const compress = require('koa-compress');const app = koa();const options = { threshold: 2048 };app.use(compress(options)); 在 egg.js 当中使用如下 12// app/middleware/compress.jsmodule.exports = require('koa-compress'); 一个需要注意的地方，koa-compress 暴露的接口（(options) =&gt; middleware）和框架对中间件要求一致 配置中间件 1234567// config/config.default.jsmodule.exports = { middleware: ['compress'], compress: { threshold: 2048, },} 表单内容的获取先来看如下代码 123456789// app/router.jsmodule.exports = app =&gt; { app.router.post('/form', app.controller.form.post);};// app/controller/form.jsexports.post = async ctx =&gt; { ctx.body = `body: ${JSON.stringify(ctx.request.body)}`;}; 这里如果直接发起 POST 请求是会报错的，错误提示为 missing csrf token 简单来说，因为框架中内置了安全插件 egg-security，提供了一些默认的安全实践，并且框架的安全插件是默认开启的 如果需要关闭其中一些安全防范，直接设置该项的 enable 属性为 false 即可 123exports.security = { csrf: false}; 路由重定向内部重定向 1234567891011// app/router.jsmodule.exports = app =&gt; { app.router.get('index', '/home/index', app.controller.home.index); // 访问根目录自动重定向到 /home/index app.router.redirect('/', '/home/index', 303);};// app/controller/home.jsexports.index = async ctx =&gt; { ctx.body = 'hello controller';}; 外部重定向 12345678910exports.index = async ctx =&gt; { const type = ctx.query.type; const q = ctx.query.q || 'nodejs'; if (type === 'bing') { ctx.redirect(`http://cn.bing.com/search?q=${q}`); } else { ctx.redirect(`https://www.google.co.kr/search?q=${q}`); }}; 自定义控制器基类12345678910111213141516171819202122// app/core/base_controller.jsconst { Controller } = require('egg');class BaseController extends Controller { get user() { return this.ctx.session.user; } success(data) { this.ctx.body = { success: true, data, }; } notFound(msg) { msg = msg || 'not found'; this.ctx.throw(404, msg); }}module.exports = BaseController; 此时在编写应用的 Controller 时，可以继承 BaseController，直接使用基类上的方法 1234567891011//app/controller/post.jsconst Controller = require('../core/base_controller');class PostController extends Controller { async list() { const posts = await this.service.listByUser(this.user); // 使用基类的方法 this.success(posts); }} 文件上传一般来说，浏览器上都是通过 Multipart/form-data 格式发送文件的，框架通过内置 Multipart 插件来支持获取用户上传的文件 首先需要在 config 文件中启用 file 模式 1234// config/config.default.jsexports.multipart = { mode: 'file',}; 然后就可以进行使用了，这里主要分为两种情况，上传单个文件和上传多个文件，我们先来看单文件情况 12345&lt;form method=\"POST\" action=\"/upload?_csrf={{ ctx.csrf | safe }}\" enctype=\"multipart/form-data\"&gt; title: &lt;input name=\"title\" /&gt; file: &lt;input name=\"file\" type=\"file\" /&gt; &lt;button type=\"submit\"&gt;Upload&lt;/button&gt;&lt;/form&gt; 12345678910111213141516171819202122232425// app/controller/upload.jsconst Controller = require('egg').Controller;const fs = require('mz/fs');module.exports = class extends Controller { async upload() { const { ctx } = this; const file = ctx.request.files[0]; const name = 'egg-multipart-test/' + path.basename(file.filename); let result; try { // 处理文件，比如上传到云端 result = await ctx.oss.put(name, file.filepath); } finally { // 需要删除临时文件 await fs.unlink(file.filepath); } ctx.body = { url: result.url, // 获取所有的字段值 requestBody: ctx.request.body, }; }}; 对于多个文件，我们借助 ctx.request.files 属性进行遍历，然后分别进行处理，html 还是一样的，不过添加了可接受多个值的文件上传字段 multiple 这里主要来看后端是如何处理的 123456789101112131415161718192021222324252627282930// app/controller/upload.jsconst Controller = require('egg').Controller;const fs = require('mz/fs');module.exports = class extends Controller { async upload() { const { ctx } = this; console.log(ctx.request.body); console.log('got %d files', ctx.request.files.length); for (const file of ctx.request.files) { console.log('field: ' + file.fieldname); console.log('filename: ' + file.filename); console.log('encoding: ' + file.encoding); console.log('mime: ' + file.mime); console.log('tmp filepath: ' + file.filepath); let result; try { // 处理文件，比如上传到云端 result = await ctx.oss.put('egg-multipart-test/' + file.filename, file.filepath); } finally { // 需要删除临时文件 await fs.unlink(file.filepath); } console.log(result); } }}; 但是这里有个需要注意的地方，为了保证文件上传的安全，框架限制了支持的的文件格式，框架默认支持白名单如下 12345678910111213141516171819202122232425const whitelist = [ // images '.jpg', '.jpeg', // image/jpeg '.png', // image/png, image/x-png '.gif', // image/gif '.bmp', // image/bmp '.wbmp', // image/vnd.wap.wbmp '.webp', '.tif', '.psd', // text '.svg', '.js', '.jsx', '.json', '.css', '.less', '.html', '.htm', '.xml', // tar '.zip', '.gz', '.tgz', '.gzip', // video '.mp3', '.mp4', '.avi',]; 但是我们可以通过在 config/config.default.js 中配置来新增支持的文件扩展名 1234567// 新增支持的文件扩展名module.exports = { multipart: { // 增加对 apk 扩展名的文件支持 fileExtensions: ['.apk'] },}; 或者重写整个白名单 123456// 覆盖整个白名单，只允许上传 '.png' 格式module.exports = { multipart: { whitelist: ['.png'], },}; 更多详细可以参考文档 egg-multipart 服务（service）注意事项，service 文件必须放在 app/service 目录，可以支持多级目录，访问的时候可以通过目录名级联访问 123app/service/biz/user.js ==&gt; ctx.service.biz.user // 多级目录，依据目录名级联访问app/service/sync_user.js ==&gt; ctx.service.syncUser // 下划线自动转换为自动驼峰app/service/HackerNews.js ==&gt; ctx.service.hackerNews // 大写自动转换为驼峰 一个 service 文件只能包含一个类，这个类需要通过 module.exports 的方式返回 service 需要通过 class 的方式定义，父类必须是 egg.service service 不是单例，是请求级别的对象，框架在每次请求中首次访问 ctx.service.xx 时延迟实例化，所以 service 中可以通过 this.ctx 获取到当前请求的上下文 下面是一个实际的使用例子 1234567891011121314151617181920212223242526272829303132333435363738394041424344// app/controller/user.jsconst Controller = require('egg').Controller;class UserController extends Controller { async info() { const userId = this.ctx.params.id; const userInfo = await this.ctx.service.user.find(userId); this.ctx.body = userInfo; }}module.exports = UserController;// app/service/user.jsconst Service = require('egg').Service;class UserService extends Service { // 默认不需要提供构造函数，如果需要在构造函数做一些处理，需要调用 super(ctx) 才能保证后面 this.ctx 的使用 // 调用之后就可以直接通过 this.ctx 获取 ctx 和通过 this.app 获取 app 了 // constructor(ctx) { // super(ctx); // } async find(uid) { // 假如 我们拿到用户 id 从数据库获取用户详细信息 const user = await this.ctx.db.query('select * from user where uid = ?', uid); // 假定这里还有一些复杂的计算，然后返回需要的信息。 const picture = await this.getPicture(uid); return { name: user.user_name, age: user.age, picture, }; } async getPicture(uid) { const result = await this.ctx.curl(`http://photoserver/uid=${uid}`, { dataType: 'json' }); return result.data; }}module.exports = UserService; 属性扩展一般来说属性的计算只需要进行一次，那么一定要实现缓存，否则在多次访问属性时会计算多次，这样会降低应用性能 推荐的方式是使用 Symbol + Getter 的模式 12345678910111213// app/extend/application.jsconst BAR = Symbol('Application#bar');module.exports = { get bar() { // this 就是 app 对象，在其中可以调用 app 上的其他方法，或访问属性 if (!this[BAR]) { // 实际情况肯定更复杂 this[BAR] = this.config.xx + this.config.yy; } return this[BAR]; },}; session 存储框架内置了 egg-session 插件，给我们提供了 ctx.session 来访问或者修改当前用户 session 1234567891011121314class HomeController extends Controller { async fetchPosts() { const ctx = this.ctx; // 获取 Session 上的内容 const userId = ctx.session.userId; const posts = await ctx.service.post.fetch(userId); // 修改 Session 的值 ctx.session.visited = ctx.session.visited ? (ctx.session.visited + 1) : 1; ctx.body = { success: true, posts, }; }} 但是有一个特别需要注意的地方，在设置 session 属性时需要避免以下几种情况，因为会造成字段丢失（koa-session） 不要以 _ 开头 不能为 isNew 123456// ❌ 错误的用法ctx.session._visited = 1; // ==&gt; 该字段会在下一次请求时丢失ctx.session.isNew = 'lisi'; // ==&gt; 为内部关键字, 不应该去更改// ✔️ 正确的用法ctx.session.visited = 1; // ==&gt; 此处没有问题 session 默认存放在 cookie 中，但是如果我们的 session 对象过于庞大，就会带来一些额外的问题 浏览器通常都有限制最大的 cookie 长度，当设置的 session 过大时，浏览器可能拒绝保存 cookie 在每次请求时都会带上，当 session 过大时，每次请求都要额外带上庞大的 cookie 信息 我们只需要设置 app.sessionStore 即可将 session 存储到指定的存储中 123456789101112131415// app.jsmodule.exports = app =&gt; { app.sessionStore = { // support promise / async async get(key) { // return value; }, async set(key, value, maxAge) { // set key to store }, async destroy(key) { // destroy key }, };}; sessionStore 的实现我们也可以封装到插件中，例如 egg-session-redis 就提供了将 session 存储到 redis 中的能力 在应用层我们只需要引入 egg-redis 和 egg-session-redis 插件即可 12345678910// plugin.jsexports.redis = { enable: true, package: 'egg-redis',};exports.sessionRedis = { enable: true, package: 'egg-session-redis',}; 但是需要注意的是，一旦选择了将 session 存入到外部存储中，就意味着系统将强依赖于这个外部存储，当它挂了的时候，就完全无法使用 session 相关的功能了 因此更推荐只将必要的信息存储在 session 中，保持 session 的精简并使用默认的 cookie 存储，用户级别的缓存不要存储在 session 中 egg-jwt本章节主要介绍使用 egg 验证 token 的过程，首先初始化一个项目，然后安装两个用于我们之后操作所使用的包 123456// 使用 ts 版本npm init egg --type=tsnpm install // 安装跨域包以及 token 的生成以及验证包npm install egg-cors egg-jwt --save 安装完成后首先来配置 config/plugin.ts 当中的两个验证包 1234567891011121314import { EggPlugin } from 'egg';const plugin: EggPlugin = { jwt: { enable: true, package: \"egg-jwt\" }, cors: { enable: true, package: 'egg-cors', }};export default plugin; 接下来是 config/config.default.ts 123456789101112131415161718config.jwt = { //自定义 token 的加密条件字符串 secret: 'abc'};config.security = { csrf: { enable: false, ignoreJSON: true }, // 允许访问接口的白名单 domainWhiteList: ['http://localhost:8080'],};config.cors = { origin: '*', allowMethods: 'GET, HEAD, PUT, POST, DELETE, PATCH'}; 最后一步操作，也是 TypeScript 独有的坑，需要在根目录下的 typings/index.d.ts 文件里声明一个 any 类型，否则会类型错误 1234567import 'egg';declare module 'egg' { interface Application { jwt: any; }} 下面就是具体操作流程，首先来定义路由 123456789101112131415// app/router.tsimport { Application } from 'egg';export default (app: Application) =&gt; { const { controller, router, jwt } = app; // 正常路由 router.post('/admin/login', controller.admin.login); /* * 这里的第二个对象不再是控制器，而是 jwt 验证对象，第三个地方才是控制器 * 只有在需要验证 token 的路由才需要第二个 是 jwt 否则第二个对象为控制器 **/ router.post('/admin', jwt, controller.admin.index);}; 接下来就是设定控制器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import { Controller } from 'egg';export default class AdminController extends Controller { // 验证登录并且生成 token public async login() { const { ctx, app } = this; // 获取用户端传递过来的参数 const data = ctx.request.body; // 进行验证 data 数据 登录是否成功 // ... // 成功过后进行一下操作 // 生成 token 的方式 const token = app.jwt.sign({ // 需要存储的 token 数据 username: data.username, // ... }, app.config.jwt.secret); // 生成的token = eyJhbGciOiJIUzI1... // 返回 token 到前端 ctx.body = token; }; // 访问 admin 数据时进行验证 token，并且解析 token 的数据 public async index() { const { ctx, app } = this; console.log(ctx.state.user); /* * 打印内容为：{ username : 'admin', iat: 1560346903 } * iat 为过期时间，可以单独写中间件验证，这里不做细究 * 除了 iat 之后，其余的为当时存储的数据 **/ ctx.body = { code: 0, msg: '验证成功' }; }} 最后前端在请求的时候需要在 headers 里面上添加上默认的验证字断 Authorization 就可以了 1234567891011121314axios({ method: 'post', url: 'http://127.0.0.1:7001/admin', data: { username: 'admin', lastName: '123456' }, headers: { // 切记 token 不要直接发送，要在前面加上 Bearer 字符串和一个空格 'Authorization': `Bearer ${token}` }}).then(res =&gt; { console.log(res.data)})","link":"/2019/11/06/Node/19/"},{"title":"ES6 中的 Symbol，Set 和 Map","text":"在平常的开发当中，我们会经常用到 ES6 相关语法，大致总结一下，ES6 更新的内容可以分为以下几点 表达式：声明、解构赋值 内置对象：字符串扩展、数值扩展、对象扩展、数组扩展、函数扩展、正则扩展、Symbol、Set、Map、Proxy、Reflect 语句与运算：Class、Module、Iterator 异步编程：Promise、Generator、Async 有一些是我们经常会遇到和用到的，比如 let，const，扩展运算，promise 等，之前也单独整理过一些，比如 Class，Iterator，Generator 和 Reflect 等 今天我们就来看看剩下的几个可能是平常用的不太多的 Symbol，Set 和 Map 主要参考的依然是阮一峰老师的 ECMAScript 6 入门 SymbolES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值，它是 JavaScript 语言的第七种数据类型 比如如下代码，变量 s 就是一个独一无二的值 123const s = Symbol();typeof s; // 'symbol' 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分 比如如下示例，如果不加参数，它们在控制台的输出都是 Symbol()，不利于区分 12345678let s1 = Symbol('foo');let s2 = Symbol('bar');s1 // Symbol(foo)s2 // Symbol(bar)s1.toString() // 'Symbol(foo)'s2.toString() // 'Symbol(bar)' 如果 Symbol 的参数是一个对象，就会调用该对象的 toString() 方法，将其转为字符串，然后才生成一个 Symbol 值 12345678910const obj = { value: 'abc', toString() { return 'def'; }};const sym = Symbol(obj);sym // Symbol(def) Symbol 函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的 Symbol 函数的返回值是不相等的 1234567891011// 没有参数的情况let s1 = Symbol();let s2 = Symbol();s1 === s2 // false// 有参数的情况let s1 = Symbol('foo');let s2 = Symbol('foo');s1 === s2 // false 另外需要注意的是，虽然 Symbol 值也可以转为布尔值，但是不能转为数值，并且不能与其他类型的值进行运算，会报错 123456let sym = Symbol();Boolean(sym) // true!sym // falseNumber(sym) // TypeError 作为属性名的 Symbol由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性 1234567891011121314151617181920let s = Symbol();// 第一种写法let a = { };a[s] = 'hello!';// 第二种写法let a = { [s]: 'hello!'};// 第三种写法let a = {};Object.defineProperty(a, s, { value: 'hello!' });// 以上写法都得到同样结果a[s] // 'hello!'// 但是这里需要注意，不能使用点运算符a.s // undefined 还有一点需要注意，Symbol 值作为属性名时，该属性还是公开属性，不是私有属性 属性名的遍历Symbol 作为属性名，遍历对象的时候，该属性不会出现在 for...in、for...of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 返回 但是可以使用 Object.getOwnPropertySymbols() 方法来获取指定对象的所有 Symbol 属性名，该方法返回一个数组 12345678910const obj = {};let a = Symbol('a');let b = Symbol('b');obj[a] = 'hello';obj[b] = 'world';const objectSymbols = Object.getOwnPropertySymbols(obj);objectSymbols // [Symbol(a), Symbol(b)] 另外也可以使用 Reflect.ownKeys() 方法来获取 1Reflect.ownKeys(obj) // [Symbol(a), Symbol(b)] 所以可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法 1234567891011121314151617181920212223242526let size = Symbol('size');class Collection { constructor() { this[size] = 0; } add(item) { this[this[size]] = item; this[size]++; } static sizeOf(instance) { return instance[size]; }}let x = new Collection();Collection.sizeOf(x) // 0x.add('foo');Collection.sizeOf(x) // 1Object.keys(x) // ['0']Object.getOwnPropertyNames(x) // ['0']Object.getOwnPropertySymbols(x) // [Symbol(size)] Symbol.for() &amp;&amp; Symbol.keyFor()Symbol.for() 接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值 如果有就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局 也就是说尽管是在函数内部运行的，但是生成的 Symbol 值是登记在全局环境的 1234let s1 = Symbol.for('foo');let s2 = Symbol.for('foo');s1 === s2 // true 注意与 Symbol('foo') 区分开来，Symbol('foo') 每次调用都会返回不同的 Symbol 值 而 Symbol.keyFor() 则是用于返回已登记的 Symbol 类型值的 key，但是需要注意，只能返回 Symbol.for() 的 key 12345let s1 = Symbol.for('foo');Symbol.keyFor(s1) // 'foo'let s2 = Symbol('foo');Symbol.keyFor(s2) // undefined SetES6 提供了新的数据结构 Set，它类似于数组，但是成员的值都是唯一的，没有重复的值 在平常开发当中，使用较多的就是用来进行去重，如下数组去重 1[...new Set(array)] 也可以用于字符串去重 1[...new Set('ababbc')].join('') // abc 但是除了去重之外，Set 还有许多其他的方法，因为 Set 本身是一个构造函数，可以用来生成 Set 数据结构 1234567const s = new Set();[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));for (let i of s) { console.log(i); // 2 3 5 4} Set 实例的属性和方法我们先来看看 Set 当中的操作方法，主要有以下这些 add() – 添加值，返回实例 delete() – 删除值，返回布尔值 has() – 检查值，返回布尔值 clear() – 清除所有成员 123456789101112131415let s = new Set();s.add(1).add(2).add(2);s.size // 2s.has(1) // trues.has(2) // trues.has(3) // falses.delete(2);s.has(2) // falses.clear()s.size // 0 除了操作方法之外，还有遍历方法 keys() – 返回以属性值为遍历器的对象 values() – 返回以属性值为遍历器的对象 entries() – 返回以属性值和属性值为遍历器的对象 forEach() – 使用回调函数遍历每个成员 keys 方法、values 方法、entries 方法返回的都是遍历器对象 由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以 keys 方法和 values 方法的行为完全一致 12345678910111213141516171819202122let set = new Set(['red', 'green', 'blue']);for (let item of set.keys()) { console.log(item);}// red// green// bluefor (let item of set.values()) { console.log(item);}// red// green// bluefor (let item of set.entries()) { console.log(item);}// ['red', 'red']// ['green', 'green']// ['blue', 'blue'] Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的 values 方法，所以可以省略 values 方法，直接用 for...of 循环遍历 Set 12345678let set = new Set(['red', 'green', 'blue']);for (let x of set) { console.log(x);}// red// green// blue Set 结构的实例与数组一样，也拥有 forEach 方法，用于对每个成员执行某种操作，没有返回值 12345678let set = new Set([1, 4, 9]);set.forEach((v, k) =&gt; { console.log(k + ' : ' + v)})// 1 : 1// 4 : 4// 9 : 9 而且，数组的 map 和 filter 方法也可以间接用于 Set 12345let set = new Set([1, 2, 3]);new Set([...set].map(x =&gt; x * 2)) // Set {2, 4, 6}let set = new Set([1, 2, 3, 4, 5]);new Set([...set].filter(x =&gt; (x % 2) == 0)) // Set {2, 4} 因此使用 Set 可以很容易地实现并集、交集和差集 1234567891011let a = new Set([1, 2, 3])let b = new Set([4, 3, 2])// 并集let union = new Set([...a, ...b]) // Set {1, 2, 3, 4}// 交集let intersect = new Set([...a].filter(x =&gt; b.has(x))) // set {2, 3}// 差集let difference = new Set([...a].filter(x =&gt; !b.has(x))) // Set {1} WeakSetWeakSet 结构与 Set 类似，也是不重复的值的集合，但是 WeakSet 的成员只能是对象，而不能是其他类型的值 WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用 也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中 并且 WeakSet 结构是不可遍历的 12345const a = [[1, 2], [3, 4]]const ws = new WeakSet(a) // WeakSet {[1, 2], [3, 4]}const b = [1, 2]const ws = new WeakSet(b) // Uncaught TypeError WeakSet 结构有以下三个方法 add() – 添加值，返回实例 delete() – 删除值，返回布尔值 has() – 检查值，返回布尔值 123456789101112const ws = new WeakSet()const obj = {}const foo = {}ws.add(window)ws.add(obj)ws.has(window) // truews.has(foo) // falsews.delete(window)ws.has(window) // false WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏 MapMap 数据结构类似于对象的数据结构，成员键可以是任何类型的值 也就是说，Object 结构提供了字符串与值的对应，而 Map 结构提供了值与值的对应，是一种更完善的 hash 结构实现 如果你需要键值对的数据结构，Map 比 Object 更合适 123456789const m = new Map();const o = { p: 'hello world' };m.set(o, 'test')m.get(o) // 'test'm.has(o) // truem.delete(o) // truem.has(o) // false Map 也可以接受一个数组作为参数，该数组的成员是一个个表示键值对的数组 1234567891011const map = new Map([ ['name', 'zhangsan'], ['name', 'lisi'], ['age', '18']]);map.size // 2map.has('name') // truemap.get('name') // 'lisi'map.has('age') // truemap.get('age') // '18' 可以发现，如果对同一个键多次赋值，后面的值将覆盖前面的值 有一个需要注意的地方，只有对同一个对象的引用，Map 结构才将其视为同一个键 1234567891011const m1 = new Map();m1.set(['a'], 555);m1.get(['a']) // undefinedconst m2 = new Map()const a = {}m2.set(a, 555)m2.get(a) // 555 Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键 与其他数据结构的互相转换关于 Map 数据结构的方法，和 Set 方法使用是类似的，这里就不详细展开了，我们来看看与其他数据结构的互相转换 Map 转为数组 Map 转为数组最方便的方法，就是使用扩展运算符（...） 12345const m = new Map() .set(true, 7) .set({foo: 3}, ['abc']);[...m] // [ [ true, 7 ], [ { foo: 3 }, [ 'abc' ] ] ] 数组转为 Map 将数组传入 Map 构造函数，就可以转为 Map 12345678new Map([ [true, 7], [{ foo: 3 }, ['abc']]])// Map {// true =&gt; 7,// Object { foo: 3 } =&gt; ['abc']// } Map 转为对象 如果所有 Map 的键都是字符串，它可以无损地转为对象，如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名 12345678910111213function strMapToObj(strMap) { let obj = Object.create(null); for (let [k, v] of strMap) { obj[k] = v; } return obj;}const m = new Map() .set('yes', true) .set('no', false);strMapToObj(m) // { yes: true, no: false } 对象转为 Map 123456789function objToStrMap(obj) { let strMap = new Map(); for (let k of Object.keys(obj)) { strMap.set(k, obj[k]); } return strMap;}objToStrMap({ yes: true, no: false }) // Map {'yes' =&gt; true, 'no' =&gt; false} Map 转为 JSON Map 转为 JSON 要区分两种情况，一种情况是 Map 的键名都是字符串，在这种情况下可以先将其转换为对象（使用之前的 strMapToObj() 方法），然后在转换为对象 JSON 123456function strMapToJson(strMap) { return JSON.stringify(strMapToObj(strMap));}let myMap = new Map().set('yes', true).set('no', false);strMapToJson(myMap) // '{ \"yes\": true, \"no\": false }' 另一种情况是 Map 的键名有非字符串，这时可以选择转为数组 JSON，这时可以选择转为数组 JSON 123456function mapToArrayJson(map) { return JSON.stringify([...map]);}let myMap = new Map().set(true, 7).set({ foo: 3 }, ['abc']).set('yes', true)mapToArrayJson(myMap) // '[[true, 7], [{ \"foo\": 3 }, [\"abc\"]], [\"yes\", true]]' JSON 转为 Map JSON 转为 Map，正常情况下，所有键名都是字符串，也是使用之前的 objToStrMap() 方法 12345function jsonToStrMap(jsonStr) { return objToStrMap(JSON.parse(jsonStr));}jsonToStrMap('{\"yes\": true, \"no\": false}') // Map {'yes' =&gt; true, 'no' =&gt; false} 但是有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组 12345function jsonToMap(jsonStr) { return new Map(JSON.parse(jsonStr));}jsonToMap('[[true, 7], [{\"foo\": 3}, [\"abc\"]]]') // Map { true =&gt; 7, Object { foo: 3 } =&gt; ['abc'] } WeakMapWeakMap 结构与 Map 结构类似，也是用于生成键值对的集合 1234567891011// WeakMap 可以使用 set 方法添加成员const wm1 = new WeakMap()const key = { foo: 1 }wm1.set(key, 2)wm1.get(key) // 2// WeakMap 也可以接受一个数组，作为构造函数的参数const k1 = [1, 2, 3]const k2 = [4, 5, 6]const wm2 = new WeakMap([[k1, 'foo'], [k2, 'bar']])wm2.get(k2) // 'bar' WeakMap 与 Map 的区别有两点 WeakMap 只接受对象作为键名（null 除外），不接受其他类型的值作为键名 WeakMap 的键名所指向的对象，不计入垃圾回收机制 同 WeakSet 一致，WeakMap 的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内 WeakMap 与 Map 在 API 上的区别主要是两个 一是没有遍历操作（即没有 keys()、values() 和 entries() 方法），也没有 size 属性，因为没有办法列出所有键名 二是无法清空，即不支持 clear() 方法 因此，WeakMap 只有四个方法可用 get()、set()、has()、delete() get() – 返回键值对 set() – 添加键值对，返回实例 delete() – 删除键值对，返回布尔值 has() – 检查键值对，返回布尔值 WeakMap 应用的典型场合就是 DOM 节点作为键名 123456789let myElement = document.getElementById('logo');let myWeakmap = new WeakMap();myWeakmap.set(myElement, { timesClicked: 0 });myElement.addEventListener('click', function () { let logoData = myWeakmap.get(myElement); logoData.timesClicked++;}, false); 另一个用处是部署私有属性 1234567891011121314151617181920212223const _counter = new WeakMap();const _action = new WeakMap();class Countdown { constructor(counter, action) { _counter.set(this, counter); _action.set(this, action); } dec() { let counter = _counter.get(this); if (counter &lt; 1) return; counter--; _counter.set(this, counter); if (counter === 0) { _action.get(this)(); } }}const c = new Countdown(2, () =&gt; console.log('DONE'));c.dec()c.dec() // DONE Countdown 类的两个内部属性 _counter 和 _action，是实例的弱引用，所以如果删除实例，它们也就随之消失，不会造成内存泄漏 结论 &amp;&amp; 区别 Set、Map、WeakSet、WeakMap、都是一种集合的数据结构 Set 和 WeakSet 是一种值-值的集合，且元素唯一不重复 Map 和 WeakMap 是一种键-值对的集合，Map 的键可以是任意类型，WeakMap 的键只能是对象类型 Set 添加值使用 add()，Map 添加值和返回键值对使用 set()/get() Set 和 Map 可遍历，WeakSet 和 WeakMap 不可遍历 WeakSet 和 WeakMap 键名所指向的对象，不计入垃圾回收机制","link":"/2019/11/07/JavaScript/60/"},{"title":"React && Redux","text":"最近打算从头开始梳理一下 React 和 Redux 的一些相关进阶知识点，也算是总结和复习一下，在这里记录一下 主要参考的是官方文档和一些网络资料，针对自己不太熟悉的地方，在这里做一下整理汇总 Redux、Flux 和 React-Redux之前已经整理过 Redux、Flux 和 React-Redux 相关知识点，如下 Flux Redux Redux 官方示例剖析 React-Redux Redux、Flux 和 React-Redux 三者之间的区别 Redux 源码初探 Code Spliting在 16.6 版本之前，code-spliting 通常是由第三方库来完成的，比如 react-loadble 在 16.6 版本中提供了 Suspense 和 lazy 这两个钩子, 因此在之后的版本中便可以使用其来实现 Code Spliting Code Spliting 在 React 中的使用方法是在 Suspense 组件中使用 &lt;LazyComponent&gt; 组件 12345678910111213141516import { BrowserRouter as Router, Route, Switch } from 'react-router-dom';import React, { Suspense, lazy } from 'react';const Home = lazy(() =&gt; import('./routes/Home'));const About = lazy(() =&gt; import('./routes/About'));const App = () =&gt; ( &lt;Router&gt; &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt; &lt;Switch&gt; &lt;Route exact path=\"/\" component={Home}/&gt; &lt;Route path=\"/about\" component={About}/&gt; &lt;/Switch&gt; &lt;/Suspense&gt; &lt;/Router&gt;); 事件处理函数如何绑定？可以使用 onClick={ this.handleClick } 用于绑定 如何确保处理函数在组件实例作用域内？第一种是在 constructor 中，通过 this.handleClick = this.handleClick.bind(this) 来绑定作用域 第二种可以使用箭头函数来声明处理函数 handleClick = () =&gt; { ... } 第三种就是在 render 中使用 bind 绑定，但是需要注意此方法会在每次组件渲染时创建一个新函数，而影响性能 1&lt;button onClick={ this.handleClick.bind(this) }&gt;Click Me&lt;/button&gt; 最后一种就是在 render 中使用箭头函数，但是同第三种一样，也会影响性能 1&lt;button onClick={ () =&gt; this.handleClick() }&gt;Click Me&lt;/button&gt; 如何传参？有两种方式，第一种就是使用箭头函数 1&lt;button onClick={ () =&gt; this.handleClick(id) } /&gt; 另外一种方式可以通过 data-* 来进行属性传参 1&lt;button data-id={ id } onClick={ this.handleClick } /&gt; 在 handleClick 中通过 e.target.dataset.id 拿取 data-id 的值 jsxjsx 本质上是 React.createElement(component, props, ...children) 方法提供的语法糖，比如以下代码 123&lt;MyButton color=\"blue\" size={2}&gt; Click Me&lt;/MyButton&gt; 会被编译为 12345React.createElement( MyButton, { color: 'blue', size: 2 }, 'Click Me') 在没有子元素的情况下，可以直接使用闭合标签 1&lt;MyButton className=\"warn\" /&gt; 这会被编译为： 12345React.createElement( MyButton, { className: 'warn' }, null) 在 jsx 类型中使用点语法在 jsx 中，你也可以使用点语法来引用一个 React 组件，当你在一个模块中导出许多 React 组件时，这会非常方便 例如，如果 MyComponents.DatePicker 是一个组件，你可以在 jsx 中直接使用 1234567891011import React from 'react';const MyComponents = { DatePicker: function DatePicker(props) { return &lt;div&gt;Imagine a {props.color} datepicker here.&lt;/div&gt;; }}function BlueDatePicker() { return &lt;MyComponents.DatePicker color=\"blue\" /&gt;;} 但是这里有个需要注意的地方，比如下面这个示例 123456import React from 'react'import { PhotoStory, VideoStory } from './stories'const components = { photo: PhotoStory, video: VideoStory} 如果我们以下面的方式引用，是错误的，因为 jsx 标签名不能是一个表达式 1234// 错误的使用方式render(props) { return &lt;components[props.storyType] story={ props.story } /&gt;} 为了解决这个问题，可以事先保存变量 1234render(props) { const Component = components[props.storyType] return &lt;Component story={ props.story } /&gt;} PortalsPortal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的解决方案（也就是其他框架当中的插槽的概念） 1ReactDOM.createPortal(child, container) 第一个参数（child）是任何可渲染的 React 子元素，例如一个元素，字符串或 fragment 第二个参数（container）是一个 DOM 元素 通常来讲，当你从组件的 render 方法返回一个元素时，该元素将被挂载到 DOM 节点中离其最近的父节点 12345678render() { // React 挂载了一个新的 div，并且把子元素渲染其中 return ( &lt;div&gt; {this.props.children} &lt;/div&gt; );} 然而，有时候将子元素插入到 DOM 节点中的不同位置也是有好处的 12345678render() { // React 并没有创建一个新的 div，它只是把子元素渲染到 domNode 中 // domNode 是一个可以在任何位置的有效 DOM 节点 return ReactDOM.createPortal( this.props.children, domNode );} 一个 portal 的典型用例是当父组件有 overflow: hidden 或 z-index 样式时，但你需要子组件能够在视觉上跳出其容器（例如对话框、悬浮卡以及提示框） RefsRefs 是使用 React.createRef() 创建的，并通过 ref 属性附加到 React 元素 在构造组件时，通常将 Refs 分配给实例属性，以便可以在整个组件中引用它们 123456789class MyComponent extends React.Component { constructor(props) { super(props); this.myRef = React.createRef(); } render() { return &lt;div ref={this.myRef} /&gt;; }} 当 ref 被传递给 render 中的元素时，对该节点的引用可以在 ref 的 current 属性中被访问 1const node = this.myRef.current; ref 的值根据节点的类型而有所不同，下面是一些需要注意的地方 在 v16 版本后，通过 createRef() 来生成 ref 并赋值给对应组件或 DOM 元素，之前是通过在元素上 el =&gt; this.refName = el 完成赋值 在 v16 版本后，通过 this.refName.current 来获取 refName 对应对应组件或 DOM 元素，之前是直接通过 this.refName 获取 当 ref 属性赋在 DOM 元素上时，this.refName.current 返回的就是 DOM 元素，当赋给 React 组件时，this.refName.current 返回的就是 React 组件 不能在函数式组件上使用 ref 属性，但可以在函数式组件内部的子组件中使用 ref 属性 为 DOM 元素添加 refReact 支持给任意组件添加特殊属性，而 ref 属性则接收一个回调函数 这个回调函数在组件加载或卸载时会立即执行，并且将底层的 DOM 元素作为参数传给回调函数 1234567891011121314151617181920212223242526272829303132class CustomTextInput extends React.Component { constructor(props) { super(props); // 创建一个 ref 来存储 textInput 的 DOM 元素 this.textInput = React.createRef(); this.focusTextInput = this.focusTextInput.bind(this); } focusTextInput() { // 直接使用原生 API 使 text 输入框获得焦点 // 我们通过 current 来访问 DOM 节点 this.textInput.current.focus(); } render() { // 告诉 React 我们想把 &lt;input&gt; ref 关联到 // 构造器里创建的 textInput 上 return ( &lt;div&gt; &lt;input type=\"text\" ref={this.textInput} /&gt; &lt;input type=\"button\" value=\"Focus the text input\" onClick={this.focusTextInput} /&gt; &lt;/div&gt; ); }} React 会在组件挂载时给 current 属性传入 DOM 元素，并在组件卸载时传入 null 值 ref 会在 componentDidMount 或 componentDidUpdate 生命周期钩子触发前更新 为 Class 组件添加 ref如果我们想包装上面的 CustomTextInput，来模拟它挂载之后立即被点击的操作 我们可以使用 ref 来获取这个自定义的 input 组件并手动调用它的 focusTextInput 方法 12345678910111213141516class AutoFocusTextInput extends React.Component { constructor(props) { super(props); this.textInput = React.createRef(); } componentDidMount() { this.textInput.current.focusTextInput(); } render() { return ( &lt;CustomTextInput ref={this.textInput} /&gt; ); }} 请注意，这仅在 CustomTextInput 声明为 Class 时才有效 123class CustomTextInput extends React.Component { // ...} 传递 refs当父组件需要拿到子组件的 ref 时，在 v16 版本后可以通过 React.forwardRef() 实现，之前则是父组件给子组件传递一个回调作为属性，子组件则获取这个回调，绑定到 ref 上 即通过父组件向子组件传递 ref 属性，在子组件中获取到父组件赋值的 ref 值后，对应的赋给相应元素实现 ref 的传递 1234567891011// 通过 this.ref.current 可以直接获取到 buttonconst FancyButton = React.forwardRef((props, ref) =&gt; ( &lt;div&gt; &lt;h3&gt;子组件&lt;/h3&gt; &lt;button ref={ref}&gt;{props.children}&lt;/button&gt; &lt;/div&gt;));const ref = React.createRef();&lt;FancyButton ref={ref}&gt;按钮&lt;/FancyButton&gt; 比如下面这个在类组件中传递 ref 的示例 123456789101112131415161718// 父组件this.childRef = React.createRef();&lt;Child ref={this.childRef} /&gt;// 子组件class Child extends React.Component { render() { const { forwardedRef, ...rest } = this.props; return ( &lt;div&gt; &lt;h3&gt;这是子组件的另一个按钮&lt;/h3&gt; &lt;button ref={forwardedRef}&gt;另一个按钮&lt;/button&gt; &lt;/div&gt; ) }}export default React.forwardRef((props, ref) =&gt; (&lt;Child forwardedRef={ref} /&gt;)); 通过 React.forwardRef() 包裹组件用于传递父组件赋值的 ref 在类组件中，通过属性 forwardedRef 来获取父组件赋值的 ref，并赋给对应的元素或组件实例 生命周期主要分为挂载，更新，卸载三个阶段，可以参考生命周期图谱作为速查表，如下 挂载当组件实例被创建并插入 DOM 中时，其生命周期调用顺序如下 constructor() static getDerivedStateFromProps() render() componentDidMount() 需要注意的是：UNSAFE_componentWillMount() 这个方法即将被移除 更新当组件的 props 或 state 发生变化时会触发更新，组件更新的生命周期调用顺序如下 static getDerivedStateFromProps() shouldComponentUpdate() render() getSnapshotBeforeUpdate() componentDidUpdate() 需要注意的是：UNSAFE_componentWillUpdate() 和 UNSAFE_componentWillReceiveProps() 这两个方法即将被移除 卸载当组件从 DOM 中移除时会调用如下方法 componentWillUnmount() 使用 PropTypes 进行类型检查 自 React v15.5 起，React.PropTypes 已移入另一个包中，请使用 prop-types 库代替 React 有一些内置的类型检查功能，要检查组件的属性，需要配置特殊的 propTypes 属性 12345678910111213import PropTypes from 'prop-types'class Greeting extends React.Component { render() { return ( &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt; ) }}Greeting.propTypes = { name: PropTypes.string} PropTypes 包含一整套验证器，可用于确保你接收的数据是有效的 在上面示例当中，我们使用了 PropTypes.string，当你给属性传递了无效值时，JavsScript 控制台将会打印警告 出于性能原因，propTypes 只在开发模式下进行检查 FragmentsReact 中经常会有一个组件返回多个元素的场景，但是又有只能有一个根组件的限定 通常的做法则是使用 &lt;div&gt; 进行包裹，但是这样子会在 DOM 中增加额外的节点 那么 Fragment 就是为了解决这一问题的方案 123456789101112import { Component, Fragment } from 'react';class Columns extends Component { render() { return ( &lt;Fragment&gt; &lt;p&gt;Hello&lt;/p&gt; &lt;p&gt;World&lt;/p&gt; &lt;/Fragment&gt; ); }} 之所以需要有这种特性，是因为通常情况下 &lt;div&gt; 包裹不会有什么问题，但对于 table 渲染而言 1234567891011121314151617181920class Table extends React.Component { render() { return ( &lt;table&gt; &lt;tr&gt;&lt;Columns /&gt;&lt;/tr&gt; &lt;/table&gt; ) }}class Columns extends React.Component { render() { return ( &lt;div&gt; &lt;td&gt;Hello&lt;/td&gt; &lt;td&gt;World&lt;/td&gt; &lt;/div&gt; ) }} 这种情况下，最终渲染会得到 12345678&lt;table&gt; &lt;tr&gt; &lt;div&gt; &lt;td&gt;Hello&lt;/td&gt; &lt;td&gt;World&lt;/td&gt; &lt;/div&gt; &lt;/tr&gt;&lt;/table&gt; 最终的 HTML 元素则是无效的，Fragment 还可以使用一种更简短的语法来声明 也可以理解为简写方式 12345678910class Columns extends React.Component { render() { return ( &lt;&gt; &lt;td&gt;Hello&lt;/td&gt; &lt;td&gt;World&lt;/td&gt; &lt;/&gt; ); }} 事实上，&lt;&gt;&lt;/&gt; 是 &lt;React.Fragment&gt; 的语法糖，我们也可以这么写 12345678910class Columns extends React.Component { render() { return ( &lt;React.Fragment&gt; &lt;td&gt;Hello&lt;/td&gt; &lt;td&gt;World&lt;/td&gt; &lt;/React.Fragment&gt; ) }} 应该注意的是，&lt;&gt;&lt;/&gt; 不能接受任何 key 或者属性 比如在循环当中需要使用 key，请用 &lt;React.Fragment&gt;，它可以接受且目前也只能接收 key 这一属性 高阶组件关于高阶组件的用法有许多，这里只做简单介绍，详细内容可能会另起篇章来进行介绍 高阶组件（HOC-Higher-Order-Components）是 React 中用于重用组件逻辑的高级技术 高阶组件是一个函数，能够接受一个组件并返回一个新的组件，简单来说就是高阶组件将一个组价转化（包装）成另外一个组件 在第三方组件库中，HOC 非常常见，如例如 Redux 的 connect 和 createFragmentContainer 需要注意，高级组件是纯函数，没有副作用 123456789101112131415161718192021// 创建一个高阶组件，使每个组件在更新时，打印其新旧 props 的值export default function logProps(WrappedComponent) { return class extends React.Component { componentDidUpdate(prevProps) { console.log('old props', preProps); console.log('new props', this.props) } render() { return &lt;WrappedComponent {...this.props} /&gt; } }}// 使用import logProps from './hocWrapper';class More extends React.Component { // ...}export default logProps(More) 如上，每当传入 More 组件的 props 发生变化时，都会打印其 prop 修改状况 下面是一些在使用过程中需要注意的地方 不要改变原始组件原型，推荐用容器组件组合包裹组件且不修改包裹组件 不要在 render() 函数中使用高阶组件，因为每次调用 render() 函数都会创建一个新的高阶组件，这将导致子树每次渲染都会进行卸载，和重新挂载的操作 Refs 不会被传递，若向一个高阶组件赋值 ref，那么通过这个 ref 拿到的是最外层的窗口组件（可以使用 React.forwardRef 来解决这个问题） 高阶组件的静态方法需要手动从原组件进行复制，即 HOCComponet.staticMethod = WrappedComponent.staticMethod 阻止组件渲染有时候我们希望是整个组件都不渲染，而不仅仅是局部不渲染 那么这种情况下，我们就可以在 render() 函数里返回一个 null，来实现我们想要的效果 如下示例 12345678910111213141516// 定义如下function LogBtn(props) { const isLogined = props.isLogined; const isShow = props.isShow; if (isShow) { return ( &lt;div&gt;You can &lt;button&gt;{isLogined ? '退出' : '登陆'}&lt;/button&gt; &lt;/div&gt; ) } return null;}// 使用如下&lt;LogBtn isLogined={false} /&gt; 但是有一个需要注意的地方，当组件里返回 null 不会影响组件生命周期的触发 即 componentWillUpdate 和 componentDidUpdate 仍然会被调用 React 中的表单在 React 中的表单和普通的 HTML 的表单略有不同，主要分为受控组件和非受控组件 受控组件在 HTML 中 &lt;input&gt;、&lt;textarea&gt;、&lt;select&gt; 这类表单元素会维持自身状态，并根据用户输入进行更新 不过在 React 中，可变的状态通常保存在组件的 this.state 中，且只能用 setState() 方法进行更新 1234567891011121314151617181920212223242526272829import React, { Component } from 'react'export default class NameForm extends Component { constructor(props) { super(props); this.state = { value: '' } this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); } handleChange(e) { this.setState({ value: e.target.value }); } handleSubmit(e) { alert('Your name is ' + this.state.value); e.preventDefault(); } render() { return ( &lt;form onSubmit={this.handleSubmit}&gt; Name: &lt;input type=\"text\" value={this.state.value} onChange={this.handleChange} /&gt; &lt;input type=\"submit\" value=\"Submit\" /&gt; &lt;/form&gt; ) }} 针对 textarea 标签，和 HTML 中不同的是，React 中的 textarea 并不需要写成 &lt;textarea&gt;&lt;/textarea&gt; 的形式，而是写成 &lt;textarea value=&quot;...&quot; /&gt; 的形式便可 而对于 HTML 中的 select 标签，通常做法是 12345&lt;select&gt; &lt;option value=\"A\"&gt;A&lt;/option&gt; &lt;option value=\"B\" selected&gt;B&lt;/option&gt; &lt;option value=\"C\"&gt;C&lt;/option&gt;&lt;/select&gt; 但是 React 中，不需要在需要选中的 option 处加入 selected，而只需要传入一个 value，就会自动根据 value 来选中相应的选项 12345&lt;select value=\"A\"&gt; &lt;option value=\"A\"&gt;A&lt;/option&gt; &lt;option value=\"B\"&gt;B&lt;/option&gt; &lt;option value=\"C\"&gt;C&lt;/option&gt;&lt;/select&gt; 如上所述，A 所在的这个 option 就会被选中 但是我们之前都是处理的单个表单元素，但是通常情况下，一个表单往往会有多个输入，如果我们为每一个输入添加处理事件，那么将会非常繁琐 好的一个解决办法是，使用 name，然后根据 event.target.name 来选择做什么 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import React, { Component } from 'react'export default class Form extends Component { constructor(props) { super(props); this.state = { name: '', gender: '男', attend: false, profile: '' }; this.handleInputChange = this.handleInputChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); } handleInputChange(e) { const target = e.target; const value = target.type === 'checkbox' ? target.checked : target.value; const name = target.name; this.setState({ [name]: value }); } handleSubmit(e) { this.setState({ profile: `姓名：${this.state.name}，${this.state.gender}，${this.state.attend ? '参加' : '不参加'} 活动` }); e.preventDefault(); } render() { return ( &lt;form&gt; &lt;p&gt;姓名：&lt;input name=\"name\" value={this.state.name} onChange={this.handleInputChange} /&gt;&lt;/p&gt; &lt;p&gt;性别： &lt;select name=\"gender\" value={this.state.gender} onChange={this.handleInputChange}&gt; &lt;option value=\"男\"&gt;男&lt;/option&gt; &lt;option value=\"女\"&gt;女&lt;/option&gt; &lt;/select&gt; &lt;/p&gt; &lt;p&gt;是否参加：&lt;input name=\"attend\" type=\"checkbox\" onChange={this.handleInputChange} checked={this.state.attend} /&gt;&lt;/p&gt; &lt;input type=\"submit\" value=\"Submit\" onClick={this.handleSubmit} /&gt; &lt;p&gt;您的报名信息：{this.state.profile}&lt;/p&gt; &lt;/form&gt; ) }} 非受控组件大多数情况下，使用受控组件实现表单是首选，在受控组件中，表单数据是交由 React 组件处理的 如果想要让表单数据由 DOM 处理（即数据不保存在 React 的状态里，而是保存在 DOM 中） 那么可以使用非受控组件，使用非受控组件便可以无需为每个状态更新编写事件处理程序，使用 ref 即可实现 123456789101112131415161718192021import React, { Component } from 'react'export default class NameForm extends Component { constrcutor(props) { super(props) } handleSubmit(event) { console.log(this.input.value) event.preventDefault() } render() { return ( &lt;form onSubmit={this.handleSubmit}&gt; &lt;label&gt; Name: &lt;input type=\"text\" ref={input =&gt; this.input = input} /&gt; &lt;/label&gt; &lt;input type=\"submit\" value=\"submit\" /&gt; &lt;/form&gt; ) }} 对于非受控组件，如果要指定默认值，那么可以使用 defaultValue 1&lt;input type=\"text\" defaultValue=\"Hello\" ref={input =&gt; this.input = input} /&gt; 相应的，type=&quot;checkbox&quot; 和 type=&quot;radio&quot;，则使用 defaultChecked 但是这里有个需要注意的地方，那就是 file Input 在 React 中 file Input 永远是一个不受控制的组件，因为它的值只能由用户设置，而不是以编程方式设置 通过给 file input 添加 ref 属性来获取到 file input 对应的 files 文件 1234567891011121314151617181920212223class Form extends React.Component { constructor() { super(); this.textInput = React.createRef(); this.fileInput = React.createRef(); this.submitForm = this.submitForm.bind(this); } submitForm(e) { e.preventDefault(); const userName = this.textInput.current.value; const fileName = this.fileInput.current.files[0].name console.log(userName, fileName) } render() { return ( &lt;div&gt; &lt;input defaultValue=\"123\" name=\"username\" type=\"text\" ref={this.textInput} /&gt; &lt;input name=\"file\" type=\"file\" ref={this.fileInput} /&gt; &lt;button onClick={this.submitForm}&gt;点我&lt;/button&gt; &lt;/div&gt; ) }}","link":"/2019/11/25/React/15/"},{"title":"Hook","text":"主要参考的是官方文档和一些网络资料，在这里做一下整理汇总，便于理解 Hook如果说为什么要使用 Hook，那么我们可以先来看看 Hook 主要解决的问题，主要有下面三个 在组件之间复用状态逻辑很难，Hook 使你在无需修改组件结构的情况下复用状态逻辑 复杂组件变得难以理解，Hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据） 难以理解的 Class，Hook 使你在非 Class 的情况下可以使用更多的 React 特性 什么是 Hook?Hook 是一些可以让你在函数组件里钩入 React state 及生命周期等特性的函数 但是需要注意的是，Hook 不能在 Class 组件中使用 React 内置了一些像 useState 这样的 Hook，你也可以创建你自己的 Hook 来复用不同组件之间的状态逻辑 示例下面是一个简单的例子 12345678910111213141516171819202122232425import React, { Component, useState } from 'react'export default class App extends Component { render() { return ( &lt;div&gt; &lt;Example /&gt; &lt;/div&gt; ) }}function Example() { // 声明一个叫 count 的 state 变量 const [count, setCount] = useState(0) return ( &lt;div&gt; &lt;p&gt;You clicked {count} times&lt;/p&gt; &lt;button onClick={_ =&gt; setCount(count + 1)}&gt; Click Me &lt;/button&gt; &lt;/div&gt; )} 在上面示例当中，useState 就是一个 Hook，通过在函数组件里调用它来给组件添加一些内部 state，React 会在重复渲染时保留这个 state useState 会返回一对值：当前状态和一个让你更新它的函数，你可以在事件处理函数中或其他一些地方调用这个函数 它类似 Class 组件的 this.setState，但是它不会把新的 state 和旧的 state 进行合并 useState 唯一的参数就是初始 state，值得注意的是，不同于 this.state，这里的 state 不一定要是一个对象，这个初始 state 参数只有在第一次渲染时会被用到 声明多个 state 变量可以在一个组件中多次使用 State Hook 123const [age, setAge] = useState(42);const [fruit, setFruit] = useState('banana');const [todos, setTodos] = useState([{ text: 'Learn Hooks' }]); Effect HookuseEffect 就是一个 Effect Hook，给函数组件增加了操作副作用的能力 它跟 Class 组件中的 componentDidMount、componentDidUpdate 和 componentWillUnmount 具有相同的用途，只不过被合并成了一个 API 比如在之前示例当中添加一个对应标题显示 1234567891011121314151617181920212223function Example() { // 声明一个叫 count 的 state 变量 const [count, setCount] = useState(0) // 相当于 componentDidMount 和 componentDidUpdate useEffect(_ =&gt; { document.title = `clicked ${count} times` // 还可以通过返回一个函数来指定如何清除相应的副作用 return _ =&gt; { // ... } }) return ( &lt;div&gt; &lt;p&gt;You clicked {count} times&lt;/p&gt; &lt;button onClick={_ =&gt; setCount(count + 1)}&gt; Click Me &lt;/button&gt; &lt;/div&gt; )} 当你调用 useEffect 时，就是在告诉 React 在完成对 DOM 的更改后运行你的副作用函数 由于副作用函数是在组件内声明的，所以它们可以访问到组件的 props 和 state 默认情况下，React 会在每次渲染后调用副作用函数（包括第一次渲染的时候） 跟 useState 一样，你可以在组件中多次使用 useEffect 1234567useEffect(_ =&gt; { document.title = `clicked ${count} times`;});useEffect(_ =&gt; { console.log(`clicked ${count} times`)}); 通过使用 Hook，你可以把组件内相关的副作用组织在一起（例如创建订阅及取消订阅），而不要把它们拆分到不同的生命周期函数里 Hook 使用规则Hook 就是 JavaScript 函数，但是使用它们会有两个额外的规则 只能在函数最外层调用 Hook，不要在循环、条件判断或者子函数中调用 只能在 React 的函数组件中（包括自定义的 Hook）当中调用 Hook，不要在其他 JavaScript 函数中调用 与 Class 的区别我们先来看一个与之前示例相同的一个等价的 Class 写法 12345678910111213141516171819class Example extends React.Component { constructor(props) { super(props); this.state = { count: 0 }; } render() { return ( &lt;div&gt; &lt;p&gt;clicked {this.state.count} times&lt;/p&gt; &lt;button onClick={_ =&gt; this.setState({ count: this.state.count + 1 })}&gt; Click Me &lt;/button&gt; &lt;/div&gt; ); }} 然后我们可以对比两者来看看他们之间的区别 声明 State 的区别在 Class 中，我们通过在构造函数中设置 this.state 为 { count: 0 } 来进行初始化 123456constructor(props) { super(props); this.state = { count: 0 };} 而在 Hook 当中，我们没有 this，所以不能分配或读取 this.state 所以我们直接在组件当中调用 useState 的 Hook 12// 声明一个叫 count 的 state 变量const [count, setCount] = useState(0) 这里主要涉及到三个问题 调用 useState 方法的时候做了什么?它定义了一个 state 变量，一般来说，在函数退出后变量就就会消失（销毁），而 state 中的变量会被 React 保留 useState 需要哪些参数？useState() 方法里面唯一的参数就是初始 state 如果我们想要在 state 中存储两个不同的变量，只需调用 useState() 两次即可 useState 方法的返回值是什么？会返回当前的 state 以及更新 state 的函数，但是需要成对的来获取它们 所以针对上面的示例，我们可以知道 12// 在 state 中声明一个初始值为 0 的 count 变量，以及一个用来更新它的函数 setCountconst [count, setCount] = useState(0) 我们声明了一个叫 count 的 state 变量，然后把它设置为 0 React 会在重复渲染的时候记住它当前的值，并且提供最新的值给我们的函数 我们可以通过调用 setCount 来更新当前的 count 读取 State 的区别在 Class 当中显示当前的 count，我们使用 this.state.count 1&lt;p&gt;clicked {this.state.count} times&lt;/p&gt; 而在函数（Hook）中，我们可以直接使用 count 1&lt;p&gt;clicked {count} times&lt;/p&gt; 更新 State 的区别在 Class 当中，我们需要调用 this.setState() 来更新 count 的值 123&lt;button onClick={_ =&gt; this.setState({ count: this.state.count + 1 })}&gt; Click Me&lt;/button&gt; 在函数中，我们已经有了 setCount 和 count 变量，所以不需要 this 123&lt;button onClick={_ =&gt; setCount(count + 1)}&gt; Click Me&lt;/button&gt; 无需清除的 effect有时候，我们只想在 React 更新 DOM 之后运行一些额外的代码 我们先来看看在 Class 当中的使用 123456789101112131415class Example extends React.Component { // ... componentDidMount() { document.title = `You clicked ${this.state.count} times`; } componentDidUpdate() { document.title = `You clicked ${this.state.count} times`; } // ...} 在很多情况下，我们希望组件在加载和更新时执行同样的操作，但 React 的 Class 组件没有提供这样的方法 如上示例，我们需要在两个生命周期函数当中编写重复的代码（即便提取成方法也还是需要调用两次） 在开头的示例当中，我们已经使用了 useEffect 来执行相同的操作 1234// 相当于 componentDidMount 和 componentDidUpdateuseEffect(_ =&gt; { document.title = `clicked ${count} times`}) 同样的也会涉及到三个问题 useEffect 做了什么？通过使用这个 Hook，你可以告诉 React 组件需要在渲染后执行哪些操作 为什么在组件内部调用 useEffect？将 useEffect 放在组件内部让我们可以在 effect 中直接访问 count 变量（或其他 props） Hook 使用了 JavaScript 的闭包机制，所以我们不需要特殊的 API 来读取它（它已经保存在函数作用域中） useEffect 会在每次渲染后都执行吗？默认情况下，它在第一次渲染之后和每次更新之后都会执行（但是可以进行控制） 需要清除的 effect但是在实际当中，还有一些副作用是需要清除的，例如订阅外部数据源 我们来比较一下如何用 Class 和 Hook 来实现 使用 Class 的示例在 Class 中，你通常会在 componentDidMount 中设置订阅，并在 componentWillUnmount 中清除它 12345678910111213141516171819202122232425262728293031323334class FriendStatus extends React.Component { constructor(props) { super(props); this.state = { isOnline: null }; this.handleStatusChange = this.handleStatusChange.bind(this); } componentDidMount() { ChatAPI.subscribeToFriendStatus( this.props.friend.id, this.handleStatusChange ); } componentWillUnmount() { ChatAPI.unsubscribeFromFriendStatus( this.props.friend.id, this.handleStatusChange ); } handleStatusChange(status) { this.setState({ isOnline: status.isOnline }); } render() { if (this.state.isOnline === null) { return 'Loading...'; } return this.state.isOnline ? 'Online' : 'Offline'; }} 有一点需要注意，以上示例还需要 componentDidUpdate 方法才能保证完全正确，后续会进行介绍 使用 Hook 的示例之前我们已经介绍过了，useEffect 接收第二个参数，用来执行清理操作 1234567891011121314151617181920212223import React, { useState, useEffect } from 'react';function FriendStatus(props) { const [isOnline, setIsOnline] = useState(null); useEffect(() =&gt; { function handleStatusChange(status) { setIsOnline(status.isOnline); } ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); // 命名为 cleanup 是为了表明此函数的目的 // 但其实也可以返回一个箭头函数或者给起一个别的名字 return function cleanup() { ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); }; }); if (isOnline === null) { return 'Loading...'; } return isOnline ? 'Online' : 'Offline';} 这里也有两个问题 为什么要在 effect 当中返回一个函数这是 effect 可选的清除机制，每个 effect 都可以返回一个清除函数（如此便可以将添加和移除订阅的逻辑放在一起） React 何时清除 effect？React 会在组件卸载的时候执行清除操作 通过跳过 Effect 进行性能优化在某些情况下，每次渲染后都执行清理或者执行 effect 可能会导致性能问题 在 Class 组件中，我们可以通过在 componentDidUpdate 中添加对 prevProps 或 prevState 的比较逻辑解决 12345componentDidUpdate(prevProps, prevState) { if (prevState.count !== this.state.count) { document.title = `clicked ${this.state.count} times`; }} 在 useEffect 当中也可以进行相关处理，只要传递数组作为 useEffect 的第二个可选参数即可 123useEffect(() =&gt; { document.title = `clicked ${count} times`;}, [count]) 在上面示例当中，我们传入 [count] 作为第二个参数，如果 count 的值在重新渲染的时候没有发生变化 React 会跳过这个 effect，这就实现了性能的优化 对于有清除操作的 effect 同样适用，比如之前的示例 123456789101112useEffect(() =&gt; { function handleStatusChange(status) { setIsOnline(status.isOnline); } ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); return () =&gt; { ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); };// 仅在 props.friend.id 发生变化时，重新订阅}, [props.friend.id]); 不过有一个需要注意的地方 如果你要使用此优化方式，请确保数组中包含了所有外部作用域中会随时间变化并且在 effect 中会使用的变量，否则你的代码会引用到先前渲染中的旧变量 即数组最好包含所有在 effect 当中使用的可能变化的变量 如果想执行只运行一次的 effect（仅在组件挂载和卸载时执行），可以传递一个空数组（[]）作为第二个参数 这就告诉 React 你的 effect 不依赖于 props 或 state 中的任何值，所以它永远都不需要重复执行 useState 函数式更新如下示例 1const [state, setState] = useState(initialState) 上述示例会返回一个 state，以及更新 state 的函数，这里主要介绍函数式更新 如果新的 state 需要通过使用先前的 state 计算得出，那么可以将函数传递给 setState 该函数将接收先前的 state，并返回一个更新后的值 1234567891011function Counter({ initialCount }) { const [count, setCount] = useState(initialCount); return ( &lt;&gt; Count: {count} &lt;button onClick={() =&gt; setCount(initialCount)}&gt;Reset&lt;/button&gt; &lt;button onClick={() =&gt; setCount(prevCount =&gt; prevCount - 1)}&gt;-&lt;/button&gt; &lt;button onClick={() =&gt; setCount(prevCount =&gt; prevCount + 1)}&gt;+&lt;/button&gt; &lt;/&gt; );} - 和 + 按钮采用函数式形式，因为被更新的 state 需要基于之前的 state 但是 Reset 按钮则采用普通形式，因为它总是把 count 设置回初始值 不过需要注意的是 与 Class 组件中的 setState 方法不同，useState 不会自动合并更新对象 你可以用函数式的 setState 结合展开运算符来达到合并更新对象的效果 1234setState(prevState =&gt; { // 也可以使用 Object.assign return { ...prevState, ...updatedValues }}) useContext如下示例 1const value = useContext(MyContext); 接收一个 context 对象（React.createContext 的返回值）并返回该 context 的当前值 当前的 context 值由上层组件中距离当前组件最近的 &lt;MyContext.Provider&gt; 的 value prop 决定 当组件上层最近的 &lt;MyContext.Provider&gt; 更新时，该 Hook 会触发重渲染，并使用最新传递给 MyContext provider 的 context value 值 比如如下代码 1234567891011121314151617181920212223242526272829303132333435363738const themes = { light: { foreground: \"#000000\", background: \"#eeeeee\" }, dark: { foreground: \"#ffffff\", background: \"#222222\" }};const ThemeContext = React.createContext(themes.light);function App() { return ( &lt;ThemeContext.Provider value={themes.dark}&gt; &lt;Toolbar /&gt; &lt;/ThemeContext.Provider&gt; );}function Toolbar(props) { return ( &lt;div&gt; &lt;ThemedButton /&gt; &lt;/div&gt; );}function ThemedButton() { const theme = useContext(ThemeContext); return ( &lt;button style={{ background: theme.background, color: theme.foreground }}&gt; I am styled by theme context! &lt;/button&gt; );} useReducer如下示例 1const [state, dispatch] = useReducer(reducer, initialArg, init); useState 的替代方案（用 dispatch 来替代 useState） 它接收一个形如 (state, action) =&gt; newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法 在某些场景下，useReducer 会比 useState 更适用，因为可以向子组件传递 dispatch 而不是回调函数 下面是一个用 reducer 重写的计数器示例 123456789101112131415161718192021222324// 将初始 state 作为第二个参数传入 useReducer，用以指定初始 stateconst initialState = { count: 0 };function reducer(state, action) { switch (action.type) { case 'increment': return { count: state.count + 1 }; case 'decrement': return { count: state.count - 1 }; default: return state; }}function Counter() { const [state, dispatch] = useReducer(reducer, initialState); return ( &lt;&gt; Count: {state.count} &lt;button onClick={_ =&gt; dispatch({ type: 'decrement' })}&gt; - &lt;/button&gt; &lt;button onClick={_ =&gt; dispatch({ type: 'increment' })}&gt; + &lt;/button&gt; &lt;/&gt; );} 惰性初始化针对上面的示例，可以选择惰性地创建初始 state，为此只需要将 init 函数作为 useReducer 的第三个参数传入 这样初始 state 将被设置为 init(initialArg) 这么做可以将用于计算 state 的逻辑提取到 reducer 外部，这也为将来对重置 state 的 action 做处理提供了便利 1234567891011121314151617181920212223242526272829function init(initialCount) { // 一系列复杂操作 return { count: initialCount };}function reducer(state, action) { switch (action.type) { case 'increment': return { count: state.count + 1 }; case 'decrement': return { count: state.count - 1 }; case 'reset': return init(action.payload); default: return state; }}function Counter({ initialCount }) { const [state, dispatch] = useReducer(reducer, initialCount, init); return ( &lt;&gt; Count: {state.count} &lt;button onClick={_ =&gt; dispatch({ type: 'reset', payload: initialCount })}&gt; Reset &lt;/button&gt; &lt;button onClick={_ =&gt; dispatch({ type: 'decrement' })}&gt; - &lt;/button&gt; &lt;button onClick={_ =&gt; dispatch({ type: 'increment' })}&gt; + &lt;/button&gt; &lt;/&gt; );}","link":"/2019/11/23/React/14/"},{"title":"数据结构与算法","text":"最近在学习数据结构与算法的相关知识，在这里整理一下相关笔记，方便以后进行复习 数据结构数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的科学 简单总结 程序设计 = 数据结构 + 算法 数据元素相互之间存在的一种或多种特定关系的集合 传统上数据结构分为逻辑结构和物理结构 逻辑结构（主要），指数据对象中数据元素之间的相互关系 物理结构（次之），数据的逻辑结构在计算机中的存储形式 逻辑结构 集合结构，集合结构中的数据元素除了同属于一个集合外，没有其他任何关系 线性结构，线性结构中的元素之间是一对一的关系 树形结构，树形结构中的数据元素之间存在一种一对多的层次关系 图形结构，图形结构的数据元素是多对多的关系 物理结构物理结构实际上研究的就是如何把数据元素存储到计算机的存储器当中 存储器主要是针对内存而言，像硬盘，软盘等外部存储器的数据组织通常用文件结构来描述 顺序存储和链式存储 顺序存储结构是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一直的（数组） 链式存储结构是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的（叫号） 针对链式存储结构，其数据元素存储关系并不能反应其逻辑关系，所以需要用一个指针存放数据元素的地址 这样就可以通过地址来找到相关联数据元素的位置 算法算法并不是唯一的，同一个问题可以有多种解决问题的算法 以下是两种方式计算一到一百累加的结果 123456789let result = 0for (let i = 1; i &lt;= 100; i++) { result += i}// VSlet m = 1, n = 100let result = (m + n) * (n / 2) 算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作 算法具备五个基本特征，输入，输出，有穷性，确定性和可行性 输入 – 具有零个或多个输入 输出 – 至少有一个或多个输出 有穷性 – 在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成 确定性 – 每一个步骤都有明确的含义，在一定条件下，只有一条执行路径，相同的输入只能有唯一的输出结果，每个步骤都应该被精确定义而无歧义 可行性 – 每一步都是可行的，即都能够通过执行有限次数完成 设计 正确性，指算法至少应该具有输入、输出和加工处理无歧义性，能正确反映问题的需求，能够得到问题的正确答案 可读性，目的是为了便于阅读、理解和交流 时间效率高和存储量低 算法效率的度量方法事前分析估算方法，即在计算机程序编写前，依据统计方法对算法进行估算 时间复杂度在进行算法分析时，语句总的执行次数 T(n) 是关系问题规模 n 的函数，进而分析 T(n) 随 n 的变化情况并确定 T(n) 的数量级，也就是算法的时间量度，记作 T(n) = O(f(n)) 它表示随问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度 其中 f(n) 是问题规模 n 的某个函数 推导大 O 阶 用常数 1 取代运行时间中的所有加法常数（例如 (1 + n) * n /2 记作 O(1)） 在修改后的运行次数函数中，只保留最高阶项（例如单层 for 循环，记作 O(n)） 如果最高阶项存在且不是 1，则去除与这个项相乘的常数（例如双重 for 循环，记作 O(n^2)，三重则是 O(n^3)） 对于下列函数 12345for (let i = 0; i &lt; n; i++) { for (let j = i; j &lt; n; j++) { // ... }} 也是一致的，复杂度为 O(n^2)，但是还有一种比较特殊的，先来看下面这个示例 1234let i = 1, n = 100;while (i &lt; n) { i = i * 2} 由于每次 i * 2 之后，就距离 n 更进一步，假设有 x 个 2 相乘后大于或等于 n，则会退出循环 所以由 2^x = n 可以得到 x = log(2)n，所以上述循环的时间复杂度为 O(logn) 函数调用的时间复杂度先看下面这个示例 1234567for (let i = 0; i &lt; 100; i++) { log(i)}function log(n) { console.log(n)} 在这种情况下，时间复杂度为 O(n)，稍微调整一下 123456789for (let i = 0; i &lt; 100; i++) { log()}function log() { for (let i = 0; i &lt; 100; i++) { console.log(i) }} 这样一来跟之前的示例是一样的，复杂度为 O(n^2) 常见的时间复杂度可以参考下表 示例 时间复杂度 简称 123456789 O(1) 常数阶 3n + 4 0(n) 线性阶 3n^2 + 4n + 5 0(n^2) 平方阶 3log(2)n + 4 0(1ogn) 对数阶 2n + 3nlog(2)n + 14 0(nlogn) nlogn 阶 n^3 + 2n^2 + 4n + 6 0(n^3) 立方阶 2^n 0(2^n) 指数阶 耗费时间从小到大依次是 1O(1) &lt; O(logn) &lt; (n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n) 时间曲线如下所示 算法一般要求尽量的简洁实用，但是对于 O(n^3) 之后的复杂度，由于 n 值的增大都会使得结果大的难以想象，所以一般不会去讨论它们 谁用谁傻逼 最坏情况与平均情况比如我们查找一个有 n 个随机数字数组中的某个数字，最好的情况是第一个数字就是，那么复杂度就为 O(1) 但是也有可能这个数字在最后一个位置，那么复杂度就为 O(n) 了 平均运行时间是期望的运行时间 最坏运行时间是一种保证，在应用中是一种最重要的需求，通常除非特别指定，我们提到的运行时间都是最坏的运行时间 空间复杂度空间复杂度通过计算算法所需的存储空间实现，算法的空间复杂度的计算公式为 1S(n) = O(f(n)) 其中 n 为问题的规模，f(n) 为语句关于 n 所占存储空间的函数 时间复杂度来指运行时间的需求 空间复杂度来指运行空间的需求 空间复杂度涉及到的较少，除非明确指明，否则我们在平常一般所讨论到的复杂度都是指时间复杂度","link":"/2019/12/01/Essay/05/"}],"tags":[{"name":"Angular","slug":"Angular","link":"/tags/Angular/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"HTTP","slug":"HTTP","link":"/tags/HTTP/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"jQuery","slug":"jQuery","link":"/tags/jQuery/"},{"name":"Essay","slug":"Essay","link":"/tags/Essay/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"http","slug":"http","link":"/tags/http/"},{"name":"Http","slug":"Http","link":"/tags/Http/"}],"categories":[{"name":"Angular","slug":"Angular","link":"/categories/Angular/"},{"name":"CSS","slug":"CSS","link":"/categories/CSS/"},{"name":"HTTP","slug":"HTTP","link":"/categories/HTTP/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"Node.js","slug":"Node-js","link":"/categories/Node-js/"},{"name":"React","slug":"React","link":"/categories/React/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"},{"name":"jQuery","slug":"jQuery","link":"/categories/jQuery/"},{"name":"Essay","slug":"Essay","link":"/categories/Essay/"},{"name":"MySQL","slug":"MySQL","link":"/categories/MySQL/"},{"name":"http","slug":"http","link":"/categories/http/"},{"name":"Http","slug":"Http","link":"/categories/Http/"}]}